<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.6">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.11/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Older resamplers}
-->
<p>The goal of this vignette is to explain the older resamplers:
<code>ResamplingVariableSizeTrainCV</code> and <code>ResamplingSameOtherCV</code>, which
output some data which are useful for visualizing the train/test
splits. If you do not want to visualize the train/test splits, then it
is recommended to instead use the newer resampler,
<code>ResamplingSameOtherSizesCV</code> (see other vignette).</p>
<h1 id="chp:same-other-all-resampler">Same/Other/All resampler</h1>
<p>The goal of thie section is to explain how to quantify the extent to
which it is possible to train on one data subset, and predict on
another data subset. This kind of problem occurs frequently in many
different problem domains:</p>
<ul>
<li>geography: can we train on one region (say Europe) and accurately
predict on another? (North America)</li>
<li>time series: can we train on one time period (2000) and accurately
predict on another? (2001)</li>
<li>personalization: can we train on one person (Alice) and accurately
predict on another? (Bob)</li>
</ul>
<p>The ideas are similar to my previous blog posts about how to do this
in
<a href="https://tdhock.github.io/blog/2022/generalization-to-new-subsets/">python</a>
and <a href="https://tdhock.github.io/blog/2023/R-gen-new-subsets/">R</a>. Below
we explain how to use <code>mlr3resampling</code> for this purpose, in simulated
regression and classification problems. To use this method in
real data, the important sections to read below are named “Benchmark:
computing test error,” which show how to create these cross-validation
experiments using mlr3 code.</p>
<h2 id="sec:simulated-regression-problems_1">Simulated regression problems</h2>
<p>We begin by generating some data which can be used with regression algorithms.
Assume there is a data set with some rows from one person, some rows
from another,</p>
<pre><code class="language-r">N &lt;- 300
library(data.table)
set.seed(1)
abs.x &lt;- 2
reg.dt &lt;- data.table(
  x=runif(N, -abs.x, abs.x),
  person=rep(1:2, each=0.5*N))
reg.pattern.list &lt;- list(
  easy=function(x, person)x^2,
  impossible=function(x, person)(x^2+person*3)*(-1)^person)
reg.task.list &lt;- list()
for(task_id in names(reg.pattern.list)){
  f &lt;- reg.pattern.list[[task_id]]
  yname &lt;- paste0(&quot;y_&quot;,task_id)
  reg.dt[, (yname) := f(x,person)+rnorm(N)][]
  task.dt &lt;- reg.dt[, c(&quot;x&quot;,&quot;person&quot;,yname), with=FALSE]
  reg.task &lt;- mlr3::TaskRegr$new(
    task_id, task.dt, target=yname)
  reg.task$col_roles$subset &lt;- &quot;person&quot;
  reg.task$col_roles$stratum &lt;- &quot;person&quot;
  reg.task$col_roles$feature &lt;- &quot;x&quot;
  reg.task.list[[task_id]] &lt;- reg.task
}
reg.dt
#&gt;               x person      y_easy y_impossible
#&gt;           &lt;num&gt;  &lt;int&gt;       &lt;num&gt;        &lt;num&gt;
#&gt;   1: -0.9379653      1  1.32996609    -2.918082
#&gt;   2: -0.5115044      1  0.24307692    -3.866062
#&gt;   3:  0.2914135      1 -0.23314657    -3.837799
#&gt;   4:  1.6328312      1  1.73677545    -7.221749
#&gt;   5: -1.1932723      1 -0.06356159    -5.877792
#&gt;  ---                                           
#&gt; 296:  0.7257701      2 -2.48130642     5.180948
#&gt; 297: -1.6033236      2  1.20453459     9.604312
#&gt; 298: -1.5243898      2  1.89966190     7.511988
#&gt; 299: -1.7982414      2  3.47047566    11.035397
#&gt; 300:  1.7170157      2  0.60541972    10.719685
</code></pre>
<p>The table above shows some simulated data for two regression problems:</p>
<ul>
<li>easy problem has the same pattern for each person, so it is possible/easy to train on one person, and accurately predict on another.</li>
<li>impossible problem has a different pattern for each person, so it is impossible to train on one person, and accurately predict on another.</li>
<li>when adapting the code above to real data, the important part is the
<code>mlr3::TaskRegr</code> line which tells mlr3 what data set to use, what is
the target column, and what is the subset/stratum column.</li>
</ul>
<h3 id="sec:static-visualization-of-simulated-data_1">Static visualization of simulated data</h3>
<p>First we reshape the data using the code below,</p>
<pre><code class="language-r">(reg.tall &lt;- nc::capture_melt_single(
  reg.dt,
  task_id=&quot;easy|impossible&quot;,
  value.name=&quot;y&quot;))
#&gt;               x person    task_id           y
#&gt;           &lt;num&gt;  &lt;int&gt;     &lt;char&gt;       &lt;num&gt;
#&gt;   1: -0.9379653      1       easy  1.32996609
#&gt;   2: -0.5115044      1       easy  0.24307692
#&gt;   3:  0.2914135      1       easy -0.23314657
#&gt;   4:  1.6328312      1       easy  1.73677545
#&gt;   5: -1.1932723      1       easy -0.06356159
#&gt;  ---                                         
#&gt; 596:  0.7257701      2 impossible  5.18094849
#&gt; 597: -1.6033236      2 impossible  9.60431191
#&gt; 598: -1.5243898      2 impossible  7.51198770
#&gt; 599: -1.7982414      2 impossible 11.03539747
#&gt; 600:  1.7170157      2 impossible 10.71968480
</code></pre>
<p>The table above is a more convenient form for the visualization which we create using the code below,</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x, y),
      data=reg.tall)+
    facet_grid(
      task_id ~ person,
      labeller=label_both,
      space=&quot;free&quot;,
      scales=&quot;free&quot;)+
    scale_y_continuous(
      breaks=seq(-100, 100, by=2))
}
#&gt; Le chargement a nécessité le package : animint2
#&gt; Registered S3 methods overwritten by 'animint2':
#&gt;   method                   from   
#&gt;   [.uneval                 ggplot2
#&gt;   drawDetails.zeroGrob     ggplot2
#&gt;   grid.draw.absoluteGrob   ggplot2
#&gt;   grobHeight.absoluteGrob  ggplot2
#&gt;   grobHeight.zeroGrob      ggplot2
#&gt;   grobWidth.absoluteGrob   ggplot2
#&gt;   grobWidth.zeroGrob       ggplot2
#&gt;   grobX.absoluteGrob       ggplot2
#&gt;   grobY.absoluteGrob       ggplot2
#&gt;   heightDetails.titleGrob  ggplot2
#&gt;   heightDetails.zeroGrob   ggplot2
#&gt;   makeContext.dotstackGrob ggplot2
#&gt;   print.element            ggplot2
#&gt;   print.ggplot2_bins       ggplot2
#&gt;   print.rel                ggplot2
#&gt;   print.theme              ggplot2
#&gt;   print.uneval             ggplot2
#&gt;   widthDetails.titleGrob   ggplot2
#&gt;   widthDetails.zeroGrob    ggplot2
#&gt; 
#&gt; Attachement du package : 'animint2'
#&gt; Les objets suivants sont masqués depuis 'package:ggplot2':
#&gt; 
#&gt;     %+%, %+replace%, Coord, CoordCartesian, CoordFixed, CoordFlip,
#&gt;     CoordMap, CoordPolar, CoordQuickmap, CoordTrans, Geom, GeomAbline,
#&gt;     GeomAnnotationMap, GeomArea, GeomBar, GeomBlank, GeomContour,
#&gt;     GeomCrossbar, GeomCurve, GeomCustomAnn, GeomDensity, GeomDensity2d,
#&gt;     GeomDotplot, GeomErrorbar, GeomErrorbarh, GeomHex, GeomHline,
#&gt;     GeomLabel, GeomLine, GeomLinerange, GeomLogticks, GeomMap,
#&gt;     GeomPath, GeomPoint, GeomPointrange, GeomPolygon, GeomRaster,
#&gt;     GeomRasterAnn, GeomRect, GeomRibbon, GeomRug, GeomSegment,
#&gt;     GeomSmooth, GeomSpoke, GeomStep, GeomText, GeomTile, GeomViolin,
#&gt;     GeomVline, Position, PositionDodge, PositionFill, PositionIdentity,
#&gt;     PositionJitter, PositionJitterdodge, PositionNudge, PositionStack,
#&gt;     Scale, ScaleContinuous, ScaleContinuousDate,
#&gt;     ScaleContinuousDatetime, ScaleContinuousIdentity,
#&gt;     ScaleContinuousPosition, ScaleDiscrete, ScaleDiscreteIdentity,
#&gt;     ScaleDiscretePosition, Stat, StatBin, StatBin2d, StatBindot,
#&gt;     StatBinhex, StatContour, StatCount, StatDensity, StatDensity2d,
#&gt;     StatEcdf, StatEllipse, StatFunction, StatIdentity, StatQq,
#&gt;     StatSmooth, StatSum, StatSummary, StatSummary2d, StatSummaryBin,
#&gt;     StatSummaryHex, StatUnique, StatYdensity, aes, aes_, aes_all,
#&gt;     aes_auto, aes_q, aes_string, annotate, annotation_custom,
#&gt;     annotation_logticks, annotation_map, annotation_raster,
#&gt;     as_labeller, autoplot, benchplot, borders, calc_element,
#&gt;     continuous_scale, coord_cartesian, coord_equal, coord_fixed,
#&gt;     coord_flip, coord_map, coord_munch, coord_polar, coord_quickmap,
#&gt;     coord_trans, cut_interval, cut_number, cut_width, discrete_scale,
#&gt;     draw_key_abline, draw_key_blank, draw_key_crossbar,
#&gt;     draw_key_dotplot, draw_key_label, draw_key_path, draw_key_point,
#&gt;     draw_key_pointrange, draw_key_polygon, draw_key_rect,
#&gt;     draw_key_smooth, draw_key_text, draw_key_vline, draw_key_vpath,
#&gt;     economics, economics_long, element_blank, element_grob,
#&gt;     element_line, element_rect, element_text, expand_limits,
#&gt;     facet_grid, facet_null, facet_wrap, fortify, geom_abline,
#&gt;     geom_area, geom_bar, geom_bin2d, geom_blank, geom_contour,
#&gt;     geom_count, geom_crossbar, geom_curve, geom_density,
#&gt;     geom_density2d, geom_density_2d, geom_dotplot, geom_errorbar,
#&gt;     geom_errorbarh, geom_freqpoly, geom_hex, geom_histogram,
#&gt;     geom_hline, geom_jitter, geom_label, geom_line, geom_linerange,
#&gt;     geom_map, geom_path, geom_point, geom_pointrange, geom_polygon,
#&gt;     geom_qq, geom_raster, geom_rect, geom_ribbon, geom_rug,
#&gt;     geom_segment, geom_smooth, geom_spoke, geom_step, geom_text,
#&gt;     geom_tile, geom_violin, geom_vline, gg_dep, ggplot, ggplotGrob,
#&gt;     ggplot_build, ggplot_gtable, ggsave, ggtitle, guide_colorbar,
#&gt;     guide_colourbar, guide_legend, guides, is.Coord, is.facet,
#&gt;     is.ggplot, is.theme, label_both, label_bquote, label_context,
#&gt;     label_parsed, label_value, label_wrap_gen, labeller, labs,
#&gt;     last_plot, layer, layer_data, layer_grob, layer_scales, lims,
#&gt;     map_data, margin, mean_cl_boot, mean_cl_normal, mean_sdl, mean_se,
#&gt;     median_hilow, position_dodge, position_fill, position_identity,
#&gt;     position_jitter, position_jitterdodge, position_nudge,
#&gt;     position_stack, presidential, qplot, quickplot, rel,
#&gt;     remove_missing, resolution, scale_alpha, scale_alpha_continuous,
#&gt;     scale_alpha_discrete, scale_alpha_identity, scale_alpha_manual,
#&gt;     scale_color_brewer, scale_color_continuous, scale_color_discrete,
#&gt;     scale_color_distiller, scale_color_gradient, scale_color_gradient2,
#&gt;     scale_color_gradientn, scale_color_grey, scale_color_hue,
#&gt;     scale_color_identity, scale_color_manual, scale_colour_brewer,
#&gt;     scale_colour_continuous, scale_colour_date, scale_colour_datetime,
#&gt;     scale_colour_discrete, scale_colour_distiller,
#&gt;     scale_colour_gradient, scale_colour_gradient2,
#&gt;     scale_colour_gradientn, scale_colour_grey, scale_colour_hue,
#&gt;     scale_colour_identity, scale_colour_manual, scale_fill_brewer,
#&gt;     scale_fill_continuous, scale_fill_date, scale_fill_datetime,
#&gt;     scale_fill_discrete, scale_fill_distiller, scale_fill_gradient,
#&gt;     scale_fill_gradient2, scale_fill_gradientn, scale_fill_grey,
#&gt;     scale_fill_hue, scale_fill_identity, scale_fill_manual,
#&gt;     scale_linetype, scale_linetype_continuous, scale_linetype_discrete,
#&gt;     scale_linetype_identity, scale_linetype_manual, scale_radius,
#&gt;     scale_shape, scale_shape_continuous, scale_shape_discrete,
#&gt;     scale_shape_identity, scale_shape_manual, scale_size,
#&gt;     scale_size_area, scale_size_continuous, scale_size_date,
#&gt;     scale_size_datetime, scale_size_discrete, scale_size_identity,
#&gt;     scale_size_manual, scale_x_continuous, scale_x_date,
#&gt;     scale_x_datetime, scale_x_discrete, scale_x_log10, scale_x_reverse,
#&gt;     scale_x_sqrt, scale_y_continuous, scale_y_date, scale_y_datetime,
#&gt;     scale_y_discrete, scale_y_log10, scale_y_reverse, scale_y_sqrt,
#&gt;     should_stop, stat_bin, stat_bin2d, stat_bin_2d, stat_bin_hex,
#&gt;     stat_binhex, stat_contour, stat_count, stat_density,
#&gt;     stat_density2d, stat_density_2d, stat_ecdf, stat_ellipse,
#&gt;     stat_function, stat_identity, stat_qq, stat_smooth, stat_spoke,
#&gt;     stat_sum, stat_summary, stat_summary2d, stat_summary_2d,
#&gt;     stat_summary_bin, stat_summary_hex, stat_unique, stat_ydensity,
#&gt;     theme, theme_bw, theme_classic, theme_dark, theme_get, theme_gray,
#&gt;     theme_grey, theme_light, theme_linedraw, theme_minimal,
#&gt;     theme_replace, theme_set, theme_update, theme_void,
#&gt;     transform_position, update_geom_defaults, update_labels,
#&gt;     update_stat_defaults, waiver, xlab, xlim, ylab, ylim, zeroGrob
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAMAAAD/kMAYAAAAFVBMVEUAAAAaGhozMzNNTU3Z2dnr6+v////Mrj8CAAAACXBIWXMAAAsSAAALEgHS3X78AAAaa0lEQVR4nO2diYKsKg6GqVut7//IM6cUyPKjbOKWzNzTJUYIfIREyrbdbHIrcWcbYFImBuxmYsBuJgbsZpIB7O+2cmP7DdjNxIDdTAzYzcSA3UwM2Aj5fD69qroPsG5d/hsO7NPR+osA+03B9R92EPrab47+9Qa2a/znrx+xqwD7/W/5f/xn+RlU+klnYPvGP8/DfhPy35z8xAn5uQ2wfeMfCcx/+lu6fi9g/hM0vqPtlwH25CWxv+nnA6NRmh7EBOvCwPaMX9bLPnIVYB3rypDeHjZQDFi7vBHYYLmx/QbsZmLAbiYG7GbSAmxaxP9kAgubVXu1Few/oe1G1SRDA3ZQ242qBmx0242qLwDmnJOFBmxQR2oqcI4QM2BjO2LAOgGjq85yYMAOUu0CjI3JcnAdYBbDksCWkbkcMFB4G2Bs6WoGFuTHaP3X/zDpIGAsu8WwVabLxTBUGOy/uIexWNM1S6TADuyIAesCzDnF64LAqOPfBVjnGBYrFbQO60hDBSwXAsCOn22XyRIRr9sBG7CeXwtYqkl+yoA1q3aKYakmBcyxwLhd2zHs4cC+DJivEISBM4HFttef/+5p1nMK2LNj2JcDi+OhJuklgMWNGG8LANa37eNUa4B9uYeRG2a9qpwYwwqBXXRJlGYdDaxvR+piWBYwaj0KyicBo2bVAvsuMey//9bjX53rhzTlM2XfvvXOZNEJHbqAOGlMDbB/8u+DB7+RJXaeebkVkAweqi4dicfhVtIFqW67VTXaTgyKqj2zRGHHxt1ZTUcKKlhmpSihqglg0wWARdvpFIoYjwOGun0WsIhjvQIBix/OjGESGJlDEtgnH1jo8IZ11wNGFhcBLCJyx303VAksrowE2GeVhwBTMSwLWDQ3+l1P46tiGO1Aw5KYBkaCxXkxLGFWGhiJXGy8ut5EZqkuTW5MQb8cfvoAC528wn2Yku0YRmK8vq/sYHyO6trmPKH5TpdE+rKWRwDjQUmq7gML0b6f8WXAQERhwMjvvD8BWLADDzoCRpZN6mI7mzd9+kmnVxYw9nvuLcDkDU9jR6orKANGlQgwQew4YKSVEMN2PaxT0tG1I/UV1ANbj2P5WGChUPPiHkag3RUY62FRDEulFycCAw7WHsOuJb8u1l+rPrXWWde+/xxalhZ0zhL7zryiClJugq4P9kulpZJjjM9TXUjx76wcUQ05x1+fpOOwjiRK4/g+C5jOWXkMu2vS4bu3flaqMhCkgZEJfRlg7nhgfl7QuD2xtKupz5vAgKrwuri4KGBkCTpqthWtGY5LVCW3YR02f2MLMyngC3JLn9PAcE7FGyRdTwLLbJvHlTzji1QJKxTD2HufhwNr8bvVm0HNARi/J17O7QFjA8VKZU15Zhar8oEjqh7XX5cssQoYLIUQ0yMR6qBjOgliW8BYg45KbCYeHg0stKwdvyaGfb/Jb5yd3DUN7crWhXUZZcnuEWAUnN7qCJ8AMDVcithBwPBsVQ1NBNinDNh3/xEBOd6RIzC5BzDPYhvYflqvaGFgHWPYdu97AZvZU1MJK2JLy0ESwuYcy+i0XJNVn5VqGpjmJSJbjkH9gLEma4HNmR4W29oBluhHbqeZKuypur4EWNiHJXezO8YXAHNwVPBQ1QP7sgdJkaydpUdHPWhKG/IF9U0JWrGIn2w1mreHjcAX1AD7rj83pxN363Vmdt/pALORLmVqnhbGMFIibo4qjE97GLYBV1CRJXpeSWDO36szo7AR7PqqkdgAppssWxJpEQbm4AqMO5qMYeooNMFPVgOTj2qjPs+yAIzeely124AGjdTSBRgtmeLdA28a5KKJqZmB0V+JauXAPn12OmKr0g7QDTIQoKPbwLZUS4FJ5xBXhUO911UELIERApvhJXSng4ayrsDIjAEY+wGLA+fPzyG909dTYIgBLWHAaH+mJmD+QO8TTWcA402Gf9mtjAKWF8O078RRJ8XaVUitG8D0OOmhjQqhDXjFRq18GlCLaSGviALr+Ki2U8CkiH6VZYkRTfhvZhODjmQXYMoiWvMMlBPXS6YQ2HbnpyO+wMwDRqzX4Q7a7EimhuuuAwacA4636tJSCNrZA850LgIsNB3GEbDz15PukZGYQLWbwDJWxN0s0beSHC+ZRs5Ot4QadvIm1Bs8iyLYeVJ6VNKhp22IYZIYVWY4dKUhhsmh03dDesyIrVXAQi9oqzOaGpCXDnUpVxzsYVuWzOEk6WT4REvlKKyHah6A4drqdAOwtRkFDHUX396l7wqybG8HlpafJZsnXVTxn3Shi7uC4SCx89ZiragscSTNpK3uGrBqC1NrLD/GwxIL0kS+e48eA1/MIiYyj4Nw9mbN0t2dDnYpaTyVluemuC7cGOou6ut5oT86cElMUiQGBgDwZlgGdzJoiFimBXXA4g/Rl6y2g4bISMkUlJfjuXHE1lRsJxXYnO522EFgp2aaYco60sOzU1oPTBpIHR9UQOclznsJMFlHLGFDwLPEHr8fRpouBMbKXUi/pon1PGTRcnjQwHUAhhND1SdQARtyBYz4Law3FPBmLwBsiWGi48tn+QQFLZWq0PF6AJOWlwETkZl2J1aWIkaqZ8T9ivjX4xf6toGlUnAIjKqSQw5sPTgYmJPZvDqpK3BxqPngi/4kgOGwzpOO+LVzPbDtGDZNcOeN7oKL/qSBsRPHAltrFlY5OusT/eRG1QBTYb37WwRwn0mp5qVKVGfjbJ3UQ+cLMESsM7B1C43iQ8bTLoAsnnTZ8TCVNoCXevcq+f2wjQdJQZPUmGRkE4eiC/Fg5iqLXuZuAymsA0aOBDfYJ5ni4i7NqIqcvcSCpOOb93Iw0V80EmpBYCBS1QpeBwMTq1/wrLhOquuDaezkLDV2zUSl5D4sF1jGg6Q5wOSwU+1tYNIN6UjudLoImMChZlvUEObiOTfLRHHXTFQqM45jgPklOw3M8SQ4wQunT/CR3HZgctSTia92tASwWNbuYQVvEViBbT5Iyn/N24vUEMKv267btW6i7gu0GtmiHvzUHXb8N80bHqqtiGE5HkbnF/EhHc3jzYrwLOGM6xm1K/JT1bN5Z+ouHdmeysjDdDMkqMqOyZI+L7iryhL3k44cYHGjQt/syLu7WCrHYjoMmI5h4VjOKzbdNC8PDC3dlcCK3iKQkdYzgz0LpUooir66FDA9GIfFMF1K1oGQlUsz4Y2JB5bb1n4MK0k6gmzVjoZQlTIPi33OAJbbvUThEcAclHhS1erCIp9twESBDXhPhxpr73bhBAIWJu6UWP1mUtmOBW3A2LySqpyT9jK8vFQBY1u/Q4GRgZAbNYkbOVTDrPV2zKoCRqoPH3lZkJn2xOv1A8beIXABYLwCdhGsYQww1LS2jS4P8aynCK6tXhI7vS9xu0nEi6fqzicoEpiT0UO2dRownQ6rRRoBa45hAzxM3YfFQrqCiO55XuQHrFWcGQjM8SOYX1w9S9y3LvSUAQtulFhAEmtqrgWdYtjEPF4C4+t5+PlYYK7jip8obPcwf8TS1vBpRtecD6xNFiz80KX/1Lo/dbRZSeFmxaMtm3BXmuQqMYyUxDAg1z8YwU72sM0KyIIJLd8xE5WeCMz3AUZo9ZxsOFPXFi+sAQZj2F4FYaFPmH4rYHGSqqG4JLCafjomPWq9AjDZmSSwxLpyYWDTK4CFJFj38cQsEVuU3U8RALPMRKVXiGFw9nWc5bqwFpi2tCZWs1ruBCwUotXiNsCyjX8QsHEV9Afmi9iJiwEre5B0t/RGwEAMW0efo9wxc3AMy3gj6WOB6cIaYLlmotI6YAXPJTZZ172C/sDg9z7XAjabh4HCghhWUKsuLQX2i1/7byQdI+4yf4F+nFQlHevPY6fT/i5U3NsqbSvYf4J3N6pWxrDjgeG9HANWA2znjaR9rHswsKZwV5d0XMPDMr/iAIWnAmtLKC8LrOBP6BiwSwA7pAID1rEjIyq4ArCHxrAHA2tSNWCj225UbQFmciUxYDcTA3YzMWA3EwN2MzFgNxNL6w9qu1HV7sNGt92oasBGt92oasBGt92oasBGt92oasBGt92oasBGt92oasBGt92oasBGt92oasBGt92oasB+wp/4OR2YfgDJ/1KqAfuJeKbubGDRHPJzfddMC7DnyDIel5Fgjv5w5otVKlTf5mH8gy2Jl49hjhKzGHZO2yWqjrm+ATNgR3fklcB4qQEb3XaRqs6FDNjothtVDdjothtVa4C9+MUq56uWAlte0mHATlMtBPb92otVBqmGfCN8qPUwAzZCVW9PtQK7wItVHinpfd+fmIf95Dp7iX6bt6OHPTDpEF9AXQGY+MMtQbUK2OPS+rBnt/y8BDBeElRLgVEZ2pGubWFg7grA2J9pITZNBkzEsKsAI4WLNW0x7KHAJgaMpyCd2y5QdUFiqQFbheZkDhIzYOWqBwJbxF0K2ORXRANGgVE6FwPmbSKlBozhobwktbOA8VIDxv0pZonKz+4P7Bmy3Knmlw8Sl/gDgOZh5MXzXitm+GKHUce2o8zkWy9E1YAtQvGwezJ6LchGms1M5DcGjBVKYDw3zALmat83zAVnpAZMFApgDgLTT9xrLzwMGH1am1VgwKYkMP0cJ3OwY4GlKjBgk95BVOR0hb2ApWJYsgID9k8Sd1wbwHrFsG1VPo+qgT3vC8zUpSKGdWm7QJWv1NXA7A++jVI1YO8E9qIlcb+0IMuri2Ed7sNWD3vDc4kO7ybG4nVEs69sN6EO2OOeS8SXJrJEef+sXQz+LfHT0vpnA3Pr1ys0fohbrp7Ahtw4PzmGLSuco+IHNQ1s/USaaQWW9rsaYF4yRian9HrAkMCFMn6UqyfzzQ2DMLANvzNgXPaBEb/bAeZ46axaIj+AFdh4AyYkyUvdHJFTFcBErcgIaLwBk8I40KwCAAMbxmszbcBmSMyAYSVOTDzaPjFiG227nRi2WYEzYLxwe0kUSZ7/ODOlLQfJMnMDmDNgojAN7DdQMCtXwCraprVSYKI1zMuAISWdS6AKM4C59bEQWsgxRBeVDg1xGbBtYPEoXhvOYKK0GQGeFAKLVMhM1TrZg6RK/IDFA3AqlHMFUA07i7W5XrLGVczDtKQ8LE7+UJ5cvKCHIX+chRq5TGrbklgNLPGYDk0oHYhhqCWV4IRW1GQwYIXA0AYE4xdOz/RkyiBHBBlgwKZMYHGgxZKmBzfwCgulizdXQhvdhzmHfkHXgMnCHWC+NIJYShEvEtKiv0Bg6FrkX5PwW26WAdu4lM/0NmACjWNS0CMDtnGpBKZmvj8l10QdwwSZeDgC2JO/ceaXUv/RGKeAhIy6gxuE3JXowRBgL3su0aV260OhHPVZXAt5OX1A96sSZlUA+75mScSlAJjID8Sa6TYcDO+FdQb2niURlwJgEzk3IRzJVZDejofMpA2YE3tbb33BpcOPj7LhiWi4Jisl52dawC9NSJ6HsVqe/Vxi8lLpN6sqcxe9hbjvYeC+u3lJXOYIIfbGJdHFcSVBiu8Ioz1fh2MYaYsD2+lR1pIovPKdMWwdTk5jIougPw0ydcCQtEWB7faoJq33kjEyOaX3AEaI8A1CteRpXktZuq144X6PDFjepS4JbJKRCwGrMxOVGrCkFht25Uda1Z8wYB0rKACmwg4CBtFgXgasQbUcGP66sciZQqFeU7OuN2DblyoYMQ3kRQDZppn8EgOWo5oDDH9/yAUENXhpuF6nLQYsRzULWBSX3H7gwLbTjhlshIwF9hb5jXDGyeWjR5JW3qhtX8zD9i9dXSJRIXMwnPuHWsEJWxJzVHsCE3pJXiGG5ZuJSg1YxqUghvmRV4XLqtfHTFRqwKoqDE6kVQM1mYt0B/YxYNkVbgCbyNrIdHsC+6xiwDIrPBuYLYmlFcIYRk7uAtusYB/Y52PAOra9H8O2XXR/SfwXwApi2Bu/ce7bz2ZgC7NMYK98ROBSwP5iymFP/g4B1hjDSAQzYGOA1arGe7BPLrAXvZH0glIRw77+We3xM888zLLETm3zXd3jgf0/48hPOgyYKhQb9MfHMNvpaKvQgBmwRCm5DbPN34a2B8ewJYqZh41ou1HV4/qz78MGtd2oajHsmLbBUx39gH0MWO+20XM4Bqxe9aXATJKyPDt1hJiHHdO2xbCubR0P7DBVyxJHt92oasBGt92oukL62E7HqLYbVVdeNJQZMAPWqyMGzHbrh7fdqFqTdLzz1UX3BWZ/Kf1M1YoY9tLX710KWOl9mHnYaapVwL72IOlpUpV0rD/HzzzzMHur9vC2G1VrgNmj2ieq1iUd5mGnqRqw0W03qi6MPkW/0GfATlQlnmXAhrTdqGoeNrrtRlXzsNFtN6oasNFtN6rakji67UbVlrTe5AS59H1Y++sgE4XB/nt6GHtA4ELAOrxwNVF4c2BXfQjHgIFSn3T8Fb1FwICdphpy+viA/WWAWQwDpYGXPfk7qO1G1SvHsAMqeCcwey7xRNWapMNev3eiakXSYc8lnqnqeZW9L9GAnaZKeBU++WvPJZ4iHljB+xLNw85UDbdhlnQMartR9U/LPjBL689TrUg6gozviAGr+0MDBuw81Yqkw4CdqVqTdBiwE1Vrkg4DdqKqARvddqOqARvddqPqLYGJb6JfCOxGL1YBfyf5jcDCPyXAzpDw5yXPNuQs8R52xaemUCn6S+Qv9LCLPjUFSgGvdwK7TdLR5WW6BmxQRyytt+cSh7fdqBqyxLvs1tuSeDowgCBZgc44ytp6DLDPX8GvG/X9xhkhSFUAUsSith4DjNw2D3/BpQErUq3IEjs/NQUZbAKrb+udwObOL7hkFMKnZAxraut9wH7xq/MLLsneoP/44s3CHanxsN4vuCQe5ogkK5DnzMO2gVW84NIPcUKVrYgJYEvBTHRyupcofBmw4hdchvHdVXUugWw9ntFpqhk/GzAlOU3+BrAWmBMnxHl+Sn42YDXAlgEkwFJZuS/36jKDh8AWBQPWHViMYWClw99xqXtkAYfMAwPWH5j/LIElV0D06MavWuB1FsM6AoMJYNRKAsNFYk31CpYldgQWhYYdVrYFTF4+s2K3kcoYsC7AwMq3LnPSc/wx+UninWoLrJ4bZhmwnCZBDPPl6fAVPm0DA/UasFZgE8gS/4lksKKhB+unNYYZsEpgNeLirq7/6D2KlIsDl6qC6rxku3iwh5HPwSnkMuc9zMU7r5C8o2pRbNwxK9j/Lg9rsy4CkysaiVZRjy2UTAzYUcBAbuFV2allfUsBi6o0HdGh0YC1AhOjGkZZqjoi6/HEFkqaQLr13s6ADQIGljnBixRPEJizLPFAYIDYLBTwEue90YANjWGI2MwPMbG1QMawtQJE2IARqXxqCmPwRXQh5ATiieBhxM3EBmPOSLwNWO2Tv5ICJ0aB6S+5ODAGFu6fGDDqX5vAHEzaJs2LfyXJ83MEbJLA/JIIgEEDDBiqnTmKOqGOhGq4FrCdYgxzVMCDB9CA6Y3Aliemth4kjeOITgi1WW4NwotxZTNRBVeAi54gFR6285hbpodFX5rXI34HlgqCoMJZOxS24I0etjLzHUa1u40YJg4DGiclVav6+nOCwFJrogFrsA4Dm/C+PFPAp1Rp2oDXAQsdLmnSkU0NX+DIt8h82GelyBX8Gsq3FDNHwoAxwSEIuQeLXNwrZnGlYCJXUP4wwd5IGDAqv5HbAuZALNuymVCZZZkGplRBrQaMyh4wCSgPmCglrES1BqwKGMjmPEZ5dka8ZAxTpWQNnWOzkwHLBEYHnROjRzMpgOlFS/fEimvAtoCtBMiYoQ1CvgWovaZ/9xKFBoyQmKYkMJ0hFHbEgPV6LnFJNJZ/12NywpeLT0UtZFjQtb6rStcYptO5yCt+LUlvlgpnXno+ykzGdjp2gC2i1jkODGfwRwBzsCUDttVk9Lk4eK0dyQXmDFgxsHXEWC5yILCJAmJ+zcAZMFo7HRoKLJ7oA0z6TgCW2GjUO5QG7J+woVmBiZWpCzC12mFg8wSQGbBpCltLfmici483jQYWTZk4MO7i7wbmx4MNzyBgLn7XKR165t/esFpfBky8kXQLmB/GTh2RMcy3NbHjSXxZasDmHGB8Y/GYLDEFTDj2y2OYepsbjmFByJp0CDDH2wrlG9e/DFjqJc10+dPABMaqjqhSCYwWb1z/ImArrdSftl8GEBWiE+2SqvaQxi4hlUti6kHSxOJHIlvTzNOlyVp5aQht67l5tf/5HrYQk0tiGIlktDoK2K6qi18jkOTnZcBEDCNpIIph5MR4YASVey0wL2s9dCR8wUEdMWBHAEtkbj06UgtMboMYMPXl4VWA0a39aNa7gcnnCk8ERi3ZUn05MFnxaTGMuTotlaoGbFBHaoChQgM2qCMG7FnAYAwzYLcRh39h/d7yLA9jpfJ24717ibcCJm8Ql3MGbExHDNiTgeEtmOWcAZMiokenjpRWYDEsF5iK93060mskDJgUA3aUag2wjL+UfkFg9BvUdwHL+kvp14hh3KC3fh/W+U/bjwX2yiwxY0k0YEeplgLbf8HlVWUFdrYZrVK3JCafSzx45jVW8N4YdhtgMvd5ZZZ4oxim7i7eCczL+I4YMAN2WNsHqT4bmMWwuwFLFBqwQR0xYAZseNuNqgZsdNuNqgZsdNuNqgZsdNuNqi3ATE4Q87DRbTeqGrDRbTeqdlgSC74Xu5xqyXd6lzOeiwHr2MwIVUs6biYG7GaSD8x/n9lTjqgTVXtIO6OM55IN7EteyJejnKlX0OdsVWVqke2HGF+k2Q1YflcyFUvqzK4UVHtIO0cMSEa1JTGs+4QqGsgSJ9G6/T2sbBbkN9/Fw5anFLNaDQ805ujOBwGjphbYfpzxRZOtz5LYNsHTagfFgdpL85WPArajWhTDejVK9A5KOiqvLNI+LOnYlHxg34I0Nj8YHwJMmlpk+yHGF2ju2Go3zjcTA3YzMWA3EwN2MzFgNxMDdjMxYDeTBwNzj+zdA7sUxD2xdw/sUpQndu6JffJy/3cJAHlin7zYkngvsaTD5AJiwG4mBuxmYsBuJgbsZmLAbiYG7GZiwG4m/wNWmP0C0LsBIwAAAABJRU5ErkJggg==" alt="plot of chunk unnamed-chunk-3" /></p>
<p>In the simulated data above, we can see that</p>
<ul>
<li>for the easy pattern, it is the same for both people, so it should
be possible/easy to train on one person, and accurately predict on
another.</li>
<li>for the impossible pattern, it is different for each person, so it
should not be possible to train on one person, and accurately
predict on another.</li>
</ul>
<h3 id="sec:benchmark-computing-test-error_1">Benchmark: computing test error</h3>
<p>In the code below, we define a K-fold cross-validation experiment.</p>
<pre><code class="language-r">(reg_same_other &lt;- mlr3resampling::ResamplingSameOtherCV$new())
#&gt; &lt;ResamplingSameOtherCV&gt; : Same versus Other Cross-Validation
#&gt; * Iterations:
#&gt; * Instantiated: FALSE
#&gt; * Parameters:
#&gt; List of 1
#&gt;  $ folds: int 3
</code></pre>
<p>In the code below, we define two learners to compare,</p>
<pre><code class="language-r">(reg.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerRegrRpart$new(),
  mlr3::LearnerRegrFeatureless$new()))
#&gt; [[1]]
#&gt; &lt;LearnerRegrRpart:regr.rpart&gt;: Regression Tree
#&gt; * Model: -
#&gt; * Parameters: xval=0
#&gt; * Packages: mlr3, rpart
#&gt; * Predict Types:  [response]
#&gt; * Feature Types: logical, integer, numeric, factor, ordered
#&gt; * Properties: importance, missings, selected_features, weights
#&gt; 
#&gt; [[2]]
#&gt; &lt;LearnerRegrFeatureless:regr.featureless&gt;: Featureless Regression Learner
#&gt; * Model: -
#&gt; * Parameters: robust=FALSE
#&gt; * Packages: mlr3, stats
#&gt; * Predict Types:  [response], se, quantiles
#&gt; * Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt;   POSIXct, Date
#&gt; * Properties: featureless, importance, missings, selected_features
</code></pre>
<p>In the code below, we define the benchmark grid, which is all
combinations of tasks (easy and impossible), learners (rpart and
featureless), and the one resampling method.</p>
<pre><code class="language-r">(reg.bench.grid &lt;- mlr3::benchmark_grid(
  reg.task.list,
  reg.learner.list,
  reg_same_other))
#&gt;          task          learner    resampling
#&gt;        &lt;char&gt;           &lt;char&gt;        &lt;char&gt;
#&gt; 1:       easy       regr.rpart same_other_cv
#&gt; 2:       easy regr.featureless same_other_cv
#&gt; 3: impossible       regr.rpart same_other_cv
#&gt; 4: impossible regr.featureless same_other_cv
</code></pre>
<p>In the code below, we execute the benchmark experiment (in parallel
using the multisession future plan).</p>
<pre><code class="language-r">if(FALSE){#for CRAN.
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
#&gt; Le chargement a nécessité le package : lgr
#&gt; 
#&gt; Attachement du package : 'lgr'
#&gt; L'objet suivant est masqué depuis 'package:ggplot2':
#&gt; 
#&gt;     Layout
(reg.bench.result &lt;- mlr3::benchmark(
  reg.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 72 rows with 4 resampling runs
#&gt;  nr    task_id       learner_id resampling_id iters warnings errors
#&gt;   1       easy       regr.rpart same_other_cv    18        0      0
#&gt;   2       easy regr.featureless same_other_cv    18        0      0
#&gt;   3 impossible       regr.rpart same_other_cv    18        0      0
#&gt;   4 impossible regr.featureless same_other_cv    18        0      0
</code></pre>
<p>The code below computes the test error for each split,</p>
<pre><code class="language-r">reg.bench.score &lt;- mlr3resampling::score(reg.bench.result)
reg.bench.score[1]
#&gt;    train.subsets test.fold test.subset person iteration                  test
#&gt;           &lt;char&gt;     &lt;int&gt;       &lt;int&gt;  &lt;int&gt;     &lt;int&gt;                &lt;list&gt;
#&gt; 1:           all         1           1      1         1  1, 3, 5, 6,12,13,...
#&gt;                    train                                uhash    nr
#&gt;                   &lt;list&gt;                               &lt;char&gt; &lt;int&gt;
#&gt; 1:  4, 7, 9,10,18,20,... b9604ff4-8908-4722-a403-be146addc161     1
#&gt;               task task_id                       learner learner_id
#&gt;             &lt;list&gt;  &lt;char&gt;                        &lt;list&gt;     &lt;char&gt;
#&gt; 1: &lt;TaskRegr:easy&gt;    easy &lt;LearnerRegrRpart:regr.rpart&gt; regr.rpart
#&gt;                 resampling resampling_id  prediction_test regr.mse algorithm
#&gt;                     &lt;list&gt;        &lt;char&gt;           &lt;list&gt;    &lt;num&gt;    &lt;char&gt;
#&gt; 1: &lt;ResamplingSameOtherCV&gt; same_other_cv &lt;PredictionRegr&gt; 1.638015     rpart
</code></pre>
<p>The code below visualizes the resulting test accuracy numbers.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    scale_x_log10()+
    geom_point(aes(
      regr.mse, train.subsets, color=algorithm),
      shape=1,
      data=reg.bench.score)+
    facet_grid(
      task_id ~ person,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-9" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>for the easy task, training on same is just as good as all or other
subsets. rpart has much lower test error than featureless, in all
three train subsets.</li>
<li>for the impossible task, the least test error is using rpart with same train subsets; featureless with same train subsets is next best; training on all is substantially worse (for both featureless and rpart); training on other is even worse (patterns in the two people are completely different).</li>
<li>in a real data task, training on other will most likely not be quite as bad as in the impossible task above, but also not as good as in the easy task.</li>
</ul>
<h3 id="sec:interactive-visualization-of-data-test-error-and-splits_1">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">inst &lt;- reg.bench.score$resampling[[1]]$instance
rect.expand &lt;- 0.3
grid.dt &lt;- data.table(x=seq(-abs.x, abs.x, l=101), y=0)
grid.task &lt;- mlr3::TaskRegr$new(&quot;grid&quot;, grid.dt, target=&quot;y&quot;)
pred.dt.list &lt;- list()
point.dt.list &lt;- list()
for(score.i in 1:nrow(reg.bench.score)){
  reg.bench.row &lt;- reg.bench.score[score.i]
  task.dt &lt;- data.table(
    reg.bench.row$task[[1]]$data(),
    reg.bench.row$resampling[[1]]$instance$id.dt)
  names(task.dt)[1] &lt;- &quot;y&quot;
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=reg.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ]
  point.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(task_id, iteration)],
    i.points)
  i.learner &lt;- reg.bench.row$learner[[1]]
  pred.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(
      task_id, iteration, algorithm
    )],
    as.data.table(
      i.learner$predict(grid.task)
    )[, .(x=grid.dt$x, y=response)]
  )
}
(pred.dt &lt;- rbindlist(pred.dt.list))
#&gt;          task_id iteration   algorithm     x        y
#&gt;           &lt;char&gt;     &lt;int&gt;      &lt;char&gt; &lt;num&gt;    &lt;num&gt;
#&gt;    1:       easy         1       rpart -2.00 3.557968
#&gt;    2:       easy         1       rpart -1.96 3.557968
#&gt;    3:       easy         1       rpart -1.92 3.557968
#&gt;    4:       easy         1       rpart -1.88 3.557968
#&gt;    5:       easy         1       rpart -1.84 3.557968
#&gt;   ---                                                
#&gt; 7268: impossible        18 featureless  1.84 7.204232
#&gt; 7269: impossible        18 featureless  1.88 7.204232
#&gt; 7270: impossible        18 featureless  1.92 7.204232
#&gt; 7271: impossible        18 featureless  1.96 7.204232
#&gt; 7272: impossible        18 featureless  2.00 7.204232
(point.dt &lt;- rbindlist(point.dt.list))
#&gt;           task_id iteration set.name row_id           y          x  fold person
#&gt;            &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;       &lt;num&gt;      &lt;num&gt; &lt;int&gt;  &lt;int&gt;
#&gt;     1:       easy         1     test      1  1.32996609 -0.9379653     1      1
#&gt;     2:       easy         1    train      2  0.24307692 -0.5115044     3      1
#&gt;     3:       easy         1     test      3 -0.23314657  0.2914135     1      1
#&gt;     4:       easy         1    train      4  1.73677545  1.6328312     2      1
#&gt;     5:       easy         1     test      5 -0.06356159 -1.1932723     1      1
#&gt;    ---                                                                         
#&gt; 21596: impossible        18    train    296  5.18094849  0.7257701     1      2
#&gt; 21597: impossible        18    train    297  9.60431191 -1.6033236     1      2
#&gt; 21598: impossible        18     test    298  7.51198770 -1.5243898     3      2
#&gt; 21599: impossible        18    train    299 11.03539747 -1.7982414     1      2
#&gt; 21600: impossible        18     test    300 10.71968480  1.7170157     3      2
#&gt;        subset display_row
#&gt;         &lt;int&gt;       &lt;int&gt;
#&gt;     1:      1           1
#&gt;     2:      1         101
#&gt;     3:      1           2
#&gt;     4:      1          51
#&gt;     5:      1           3
#&gt;    ---                   
#&gt; 21596:      2         198
#&gt; 21597:      2         199
#&gt; 21598:      2         299
#&gt; 21599:      2         200
#&gt; 21600:      2         300
set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
make_person_subset &lt;- function(DT){
  DT[, &quot;person/subset&quot; := person]
}
make_person_subset(point.dt)
make_person_subset(reg.bench.score)

if(require(animint2)){
  viz &lt;- animint(
    title=&quot;SOAK algorithm: train/predict on subsets, regression&quot;,
    video=&quot;https://vimeo.com/1053413000&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      geom_point(aes(
        x, y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        help=&quot;One dot for each train/test/unused data point.&quot;,
        shape=21,
        data=point.dt)+
      scale_color_manual(values=algo.colors)+
      geom_line(aes(
        x, y, color=algorithm,
        group=paste(algorithm, iteration)),
        help=&quot;One line for each learned prediction function.&quot;,
        showSelected=&quot;iteration&quot;,
        data=pred.dt)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;)+
      scale_x_continuous(
        &quot;x = input/feature in regression&quot;)+
      scale_y_continuous(
        &quot;y = output to predict in regression&quot;,
        breaks=seq(-100, 100, by=2)),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400, width=350)+
      guides(fill=&quot;none&quot;)+
      scale_y_log10(
        &quot;Mean squared error on test set&quot;)+
      scale_fill_manual(values=algo.colors)+
      scale_x_discrete(
        &quot;People/subsets in train set&quot;)+
      geom_point(aes(
        train.subsets, regr.mse, fill=algorithm),
        help=&quot;One dot per test set and learning algorithm.&quot;,
        shape=1,
        size=5,
        stroke=2,
        color=&quot;black&quot;,
        color_off=NA,
        showSelected=&quot;algorithm&quot;,
        clickSelects=&quot;iteration&quot;,
        data=reg.bench.score)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        scales=&quot;free&quot;),
    diagram=ggplot()+
      ggtitle(&quot;Select train/test split&quot;)+
      theme_bw()+
      theme_animint(height=400, width=300)+
      facet_grid(
        . ~ train.subsets,
        scales=&quot;free&quot;,
        space=&quot;free&quot;)+
      scale_size_manual(values=c(subset=3, fold=1))+
      scale_color_manual(values=c(subset=&quot;orange&quot;, fold=&quot;grey50&quot;))+
      geom_rect(aes(
        xmin=-Inf, xmax=Inf,
        color=rows,
        size=rows,
        ymin=display_row, ymax=display_end),
        help=&quot;One rect per chunk of data with common fold (grey) and subset (gold).&quot;,
        fill=NA,
        data=inst$viz.rect.dt)+
      scale_fill_manual(values=set.colors)+
      geom_text(aes(
        x=ifelse(rows==&quot;subset&quot;, Inf, -Inf),
        y=(display_row+display_end)/2,
        hjust=ifelse(rows==&quot;subset&quot;, 1, 0),
        label=paste0(rows, &quot;=&quot;, ifelse(rows==&quot;subset&quot;, subset, fold))),
        help=&quot;Text labels indicate chunks of data with common fold (grey) and subset (gold).&quot;,
        showSelected=&quot;rows&quot;,
        data=data.table(train.name=&quot;same&quot;, inst$viz.rect.dt))+
      geom_rect(aes(
        xmin=iteration-rect.expand, ymin=display_row,
        xmax=iteration+rect.expand, ymax=display_end,
        fill=set.name),
        help=&quot;One rect per chunk of data assigned to train/test set in cross-validation.&quot;,
        alpha=0.5,
        alpha_off=0.5,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=inst$viz.set.dt)+
      scale_x_continuous(
        &quot;Split number&quot;,
        breaks=c(1,6, 7,12, 13,18))+
      scale_y_continuous(
        &quot;Row number&quot;),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Older_resamplers.Rmd&quot;)
  viz
}
</code></pre>
<script>
// Copyright (c) 2013, Michael Bostock
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.

// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.

// * The name Michael Bostock may not be used to endorse or promote products
//   derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d3 = function() {
  var π = Math.PI, ε = 1e-6, d3 = {
    version: "3.0.6"
  }, d3_radians = π / 180, d3_degrees = 180 / π, d3_document = document, d3_window = window;
  function d3_target(d) {
    return d.target;
  }
  function d3_source(d) {
    return d.source;
  }
  var d3_format_decimalPoint = ".", d3_format_thousandsSeparator = ",", d3_format_grouping = [ 3, 3 ];
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  try {
    d3_document.createElement("div").style.setProperty("opacity", 0, "");
  } catch (error) {
    var d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + "", priority);
    };
  }
  function d3_class(ctor, properties) {
    try {
      for (var key in properties) {
        Object.defineProperty(ctor.prototype, key, {
          value: properties[key],
          enumerable: false
        });
      }
    } catch (e) {
      ctor.prototype = properties;
    }
  }
  var d3_array = d3_arraySlice;
  function d3_arrayCopy(pseudoarray) {
    var i = -1, n = pseudoarray.length, array = [];
    while (++i < n) array.push(pseudoarray[i]);
    return array;
  }
  function d3_arraySlice(pseudoarray) {
    return Array.prototype.slice.call(pseudoarray);
  }
  try {
    d3_array(d3_document.documentElement.childNodes)[0].nodeType;
  } catch (e) {
    d3_array = d3_arrayCopy;
  }
  var d3_arraySubclass = [].__proto__ ? function(array, prototype) {
    array.__proto__ = prototype;
  } : function(array, prototype) {
    for (var property in prototype) array[property] = prototype[property];
  };
  d3.map = function(object) {
    var map = new d3_Map();
    for (var key in object) map.set(key, object[key]);
    return map;
  };
  function d3_Map() {}
  d3_class(d3_Map, {
    has: function(key) {
      return d3_map_prefix + key in this;
    },
    get: function(key) {
      return this[d3_map_prefix + key];
    },
    set: function(key, value) {
      return this[d3_map_prefix + key] = value;
    },
    remove: function(key) {
      key = d3_map_prefix + key;
      return key in this && delete this[key];
    },
    keys: function() {
      var keys = [];
      this.forEach(function(key) {
        keys.push(key);
      });
      return keys;
    },
    values: function() {
      var values = [];
      this.forEach(function(key, value) {
        values.push(value);
      });
      return values;
    },
    entries: function() {
      var entries = [];
      this.forEach(function(key, value) {
        entries.push({
          key: key,
          value: value
        });
      });
      return entries;
    },
    forEach: function(f) {
      for (var key in this) {
        if (key.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, key.substring(1), this[key]);
        }
      }
    }
  });
  var d3_map_prefix = "\0", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
  function d3_identity(d) {
    return d;
  }
  function d3_true() {
    return true;
  }
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return arguments.length ? target : value;
    };
  }
  d3.ascending = function(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  };
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.mean = function(array, f) {
    var n = array.length, a, m = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
    } else {
      while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
    }
    return j ? m : undefined;
  };
  d3.median = function(array, f) {
    if (arguments.length > 1) array = array.map(f);
    array = array.filter(d3_number);
    return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s / m;
      };
    }
  };
  function d3_number(x) {
    return x != null && !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (!isNaN(a = +array[i])) s += a;
    } else {
      while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.shuffle = function(array) {
    var m = array.length, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m], array[m] = array[i], array[i] = t;
    }
    return array;
  };
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.bisector = function(f) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (f.call(a, a[mid], mid) < x) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (x < f.call(a, a[mid], mid)) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  };
  var d3_bisector = d3.bisector(function(d) {
    return d;
  });
  d3.bisectLeft = d3_bisector.left;
  d3.bisect = d3.bisectRight = d3_bisector.right;
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, valuesByKey = new d3_Map(), values, o = {};
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      valuesByKey.forEach(function(keyValue, values) {
        o[keyValue] = map(values, depth);
      });
      return o;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var a = [], sortKey = sortKeys[depth++], key;
      for (key in map) {
        a.push({
          key: key,
          values: entries(map[key], depth)
        });
      }
      if (sortKey) a.sort(function(a, b) {
        return sortKey(a.key, b.key);
      });
      return a;
    }
    nest.map = function(array) {
      return map(array, 0);
    };
    nest.entries = function(array) {
      return entries(map(array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.permute = function(array, indexes) {
    var permutes = [], i = -1, n = indexes.length;
    while (++i < n) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.merge = function(arrays) {
    return Array.prototype.concat.apply([], arrays);
  };
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(Math.abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  d3.xhr = function(url, mimeType, callback) {
    var xhr = {}, dispatch = d3.dispatch("progress", "load", "error"), headers = {}, response = d3_identity, request = new (d3_window.XDomainRequest && /^(http(s)?:)?\/\//.test(url) ? XDomainRequest : XMLHttpRequest)();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var s = request.status;
      !s && request.responseText || s >= 200 && s < 300 || s === 304 ? dispatch.load.call(xhr, response.call(xhr, request)) : dispatch.error.call(xhr, request);
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
    mimeType = null;
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  };
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  d3.text = function() {
    return d3.xhr.apply(d3, arguments).response(d3_text);
  };
  function d3_text(request) {
    return request.responseText;
  }
  d3.json = function(url, callback) {
    return d3.xhr(url, "application/json", callback).response(d3_json);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3.xhr(url, "text/html", callback).response(d3_html);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = function() {
    return d3.xhr.apply(d3, arguments).response(d3_xml);
  };
  function d3_xml(request) {
    return request.responseXML;
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.substring(0, i);
        name = name.substring(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i > 0) {
      name = type.substring(i + 1);
      type = type.substring(0, i);
    }
    return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.format = function(specifier) {
    var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "", basePrefix = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, suffix = "", integer = false;
    if (precision) precision = +precision.substring(1);
    if (zfill || fill === "0" && align === "=") {
      zfill = fill = "0";
      align = "=";
      if (comma) width -= Math.floor((width - 1) / 4);
    }
    switch (type) {
     case "n":
      comma = true;
      type = "g";
      break;

     case "%":
      scale = 100;
      suffix = "%";
      type = "f";
      break;

     case "p":
      scale = 100;
      suffix = "%";
      type = "r";
      break;

     case "b":
     case "o":
     case "x":
     case "X":
      if (basePrefix) basePrefix = "0" + type.toLowerCase();

     case "c":
     case "d":
      integer = true;
      precision = 0;
      break;

     case "s":
      scale = -1;
      type = "r";
      break;
    }
    if (basePrefix === "#") basePrefix = "";
    if (type == "r" && !precision) type = "g";
    type = d3_format_types.get(type) || d3_format_typeDefault;
    var zcomma = zfill && comma;
    return function(value) {
      if (integer && value % 1) return "";
      var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
      if (scale < 0) {
        var prefix = d3.formatPrefix(value, precision);
        value = prefix.scale(value);
        suffix = prefix.symbol;
      } else {
        value *= scale;
      }
      value = type(value, precision);
      if (!zfill && comma) value = d3_format_group(value);
      var length = basePrefix.length + value.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
      if (zcomma) value = d3_format_group(padding + value);
      if (d3_format_decimalPoint) value.replace(".", d3_format_decimalPoint);
      negative += basePrefix;
      return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix;
    };
  };
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?([0-9]+)?(,)?(\.[0-9]+)?([a-zA-Z%])?/;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_format_group = d3_identity;
  if (d3_format_grouping) {
    var d3_format_groupingLength = d3_format_grouping.length;
    d3_format_group = function(value) {
      var i = value.lastIndexOf("."), f = i >= 0 ? "." + value.substring(i + 1) : (i = value.length, 
      ""), t = [], j = 0, g = d3_format_grouping[0];
      while (i > 0 && g > 0) {
        t.push(value.substring(i -= g, i + g));
        g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];
      }
      return t.reverse().join(d3_format_thousandsSeparator || "") + f;
    };
  }
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, Math.abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * π / 2);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / (2 * π) * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * π / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.event = null;
  function d3_eventCancel() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      g.setAttribute("transform", string);
      var t = g.transform.baseVal.consolidate();
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolate = function(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  };
  d3.interpolateNumber = function(a, b) {
    b -= a;
    return function(t) {
      return a + b * t;
    };
  };
  d3.interpolateRound = function(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  };
  d3.interpolateString = function(a, b) {
    var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;
    d3_interpolate_number.lastIndex = 0;
    for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
      if (m.index) s.push(b.substring(s0, s1 = m.index));
      q.push({
        i: s.length,
        x: m[0]
      });
      s.push(null);
      s0 = d3_interpolate_number.lastIndex;
    }
    if (s0 < b.length) s.push(b.substring(s0));
    for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
      o = q[i];
      if (o.x == m[0]) {
        if (o.i) {
          if (s[o.i + 1] == null) {
            s[o.i - 1] += o.x;
            s.splice(o.i, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          } else {
            s[o.i - 1] += o.x + s[o.i + 1];
            s.splice(o.i, 2);
            for (j = i + 1; j < n; ++j) q[j].i -= 2;
          }
        } else {
          if (s[o.i + 1] == null) {
            s[o.i] = o.x;
          } else {
            s[o.i] = o.x + s[o.i + 1];
            s.splice(o.i + 1, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          }
        }
        q.splice(i, 1);
        n--;
        i--;
      } else {
        o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
      }
    }
    while (i < n) {
      o = q.pop();
      if (s[o.i + 1] == null) {
        s[o.i] = o.x;
      } else {
        s[o.i] = o.x + s[o.i + 1];
        s.splice(o.i + 1, 1);
      }
      n--;
    }
    if (s.length === 1) {
      return s[0] == null ? q[0].x : function() {
        return b;
      };
    }
    return function(t) {
      for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateTransform = function(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3.interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3.interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3.interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3.interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3.interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3.interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateRgb = function(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  };
  d3.interpolateHsl = function(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var h0 = a.h, s0 = a.s, l0 = a.l, h1 = b.h - h0, s1 = b.s - s0, l1 = b.l - l0;
    if (h1 > 180) h1 -= 360; else if (h1 < -180) h1 += 360;
    return function(t) {
      return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t) + "";
    };
  };
  d3.interpolateLab = function(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  };
  d3.interpolateHcl = function(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  };
  d3.interpolateArray = function(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  };
  d3.interpolateObject = function(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolateByName(k)(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  };
  var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  function d3_interpolateByName(name) {
    return name == "transform" ? d3.interpolateTransform : d3.interpolate;
  }
  d3.interpolators = [ d3.interpolateObject, function(a, b) {
    return b instanceof Array && d3.interpolateArray(a, b);
  }, function(a, b) {
    return (typeof a === "string" || typeof b === "string") && d3.interpolateString(a + "", b + "");
  }, function(a, b) {
    return (typeof b === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) : b instanceof d3_Color) && d3.interpolateRgb(a, b);
  }, function(a, b) {
    return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b);
  } ];
  function d3_uninterpolateNumber(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return (x - a) * b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) * b));
    };
  }
  function d3_Color() {}
  d3_Color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.rgb = function(r, g, b) {
    return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);
  };
  function d3_rgb(r, g, b) {
    return new d3_Rgb(r, g, b);
  }
  function d3_Rgb(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return d3_rgb(Math.min(255, Math.floor(r / k)), Math.min(255, Math.floor(g / k)), Math.min(255, Math.floor(b / k)));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_rgb(Math.floor(k * this.r), Math.floor(k * this.g), Math.floor(k * this.b));
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, name;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);
    if (format != null && format.charAt(0) === "#") {
      if (format.length === 4) {
        r = format.charAt(1);
        r += r;
        g = format.charAt(2);
        g += g;
        b = format.charAt(3);
        b += b;
      } else if (format.length === 7) {
        r = format.substring(1, 3);
        g = format.substring(3, 5);
        b = format.substring(5, 7);
      }
      r = parseInt(r, 16);
      g = parseInt(g, 16);
      b = parseInt(b, 16);
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      s = h = 0;
    }
    return d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));
  });
  d3.hsl = function(h, s, l) {
    return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);
  };
  function d3_hsl(h, s, l) {
    return new d3_Hsl(h, s, l);
  }
  function d3_Hsl(h, s, l) {
    this.h = h;
    this.s = s;
    this.l = l;
  }
  var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = h % 360;
    if (h < 0) h += 360;
    s = s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = function(h, c, l) {
    return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);
  };
  function d3_hcl(h, c, l) {
    return new d3_Hcl(h, c, l);
  }
  function d3_Hcl(h, c, l) {
    this.h = h;
    this.c = c;
    this.l = l;
  }
  var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();
  d3_hclPrototype.brighter = function(k) {
    return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = function(l, a, b) {
    return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);
  };
  function d3_lab(l, a, b) {
    return new d3_Lab(l, a, b);
  }
  function d3_Lab(l, a, b) {
    this.l = l;
    this.a = a;
    this.b = b;
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_Lab.prototype = new d3_Color();
  d3_labPrototype.brighter = function(k) {
    return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return d3_hcl(Math.atan2(b, a) / π * 180, Math.sqrt(a * a + b * b), l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  function d3_selection(groups) {
    d3_arraySubclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectRoot = d3_document.documentElement, d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector, d3_selectMatches = function(n, s) {
    return d3_selectMatcher.call(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = function(s, n) {
      return Sizzle.uniqueSort(Sizzle(s, n));
    };
    d3_selectMatches = Sizzle.matchesSelector;
  }
  var d3_selectionPrototype = [];
  d3.selection = function() {
    return d3_selectionRoot;
  };
  d3.selection.prototype = d3_selectionPrototype;
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return function() {
      return d3_selectAll(selector, this);
    };
  }
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = name.trim().split(/^|\s+/g)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.className;
          if (value.baseVal != null) value = value.baseVal;
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classed(name, value) {
    name = name.trim().split(/\s+/).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.className, cb = c.baseVal != null, cv = cb ? c.baseVal : c;
      if (value) {
        re.lastIndex = 0;
        if (!re.test(cv)) {
          cv = d3_collapse(cv + " " + name);
          if (cb) c.baseVal = cv; else node.className = cv;
        }
      } else if (cv) {
        cv = d3_collapse(cv.replace(re, " "));
        if (cb) c.baseVal = cv; else node.className = cv;
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3.ns.qualify(name);
    function append() {
      return this.appendChild(d3_document.createElementNS(this.namespaceURI, name));
    }
    function appendNS() {
      return this.appendChild(d3_document.createElementNS(name.space, name.local));
    }
    return this.select(name.local ? appendNS : append);
  };
  d3_selectionPrototype.insert = function(name, before) {
    name = d3.ns.qualify(name);
    function insert() {
      return this.insertBefore(d3_document.createElementNS(this.namespaceURI, name), d3_select(before, this));
    }
    function insertNS() {
      return this.insertBefore(d3_document.createElementNS(name.space, name.local), d3_select(before, this));
    }
    return this.select(name.local ? insertNS : insert);
  };
  d3_selectionPrototype.remove = function() {
    return this.each(function() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    });
  };
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;
        for (i = -1; ++i < n; ) {
          keyValue = key.call(node = group[i], node.__data__, i);
          if (nodeByKeyValue.has(keyValue)) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues.push(keyValue);
        }
        for (i = -1; ++i < m; ) {
          keyValue = key.call(groupData, nodeData = groupData[i], i);
          if (node = nodeByKeyValue.get(keyValue)) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          } else if (!dataByKeyValue.has(keyValue)) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
          dataByKeyValue.set(keyValue, nodeData);
          nodeByKeyValue.remove(keyValue);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValues[i])) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3.ascending;
    return function(a, b) {
      return !a - !b || comparator(a.__data__, b.__data__);
    };
  }
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf(".");
    if (i > 0) type = type.substring(0, i);
    function onRemove() {
      var wrapper = this[name];
      if (wrapper) {
        this.removeEventListener(type, wrapper, wrapper.$);
        delete this[name];
      }
    }
    function onAdd() {
      var node = this, args = d3_array(arguments);
      onRemove.call(this);
      this.addEventListener(type, this[name] = wrapper, wrapper.$ = capture);
      wrapper._ = listener;
      function wrapper(e) {
        var o = d3.event;
        d3.event = e;
        args[0] = node.__data__;
        try {
          listener.apply(node, args);
        } finally {
          d3.event = o;
        }
      }
    }
    return listener ? onAdd : onRemove;
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.transition = function() {
    var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = Object.create(d3_transitionInherit);
    transition.time = Date.now();
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id);
  };
  var d3_selectionRoot = d3_selection([ [ d3_document ] ]);
  d3_selectionRoot[0].parentNode = d3_selectRoot;
  d3.select = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.select(selector) : d3_selection([ [ selector ] ]);
  };
  d3.selectAll = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.selectAll(selector) : d3_selection([ d3_array(selector) ]);
  };
  function d3_selection_enter(selection) {
    d3_arraySubclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_transition(groups, id) {
    d3_arraySubclass(groups, d3_transitionPrototype);
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit = {
    ease: d3_ease_cubicInOut,
    delay: 0,
    duration: 250
  };
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3.transition = function(selection) {
    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
  };
  d3.transition.prototype = d3_transitionPrototype;
  function d3_transitionNode(node, i, id, inherit) {
    var lock = node.__transition__ || (node.__transition__ = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        event: d3.dispatch("start", "end"),
        time: time,
        ease: inherit.ease,
        delay: inherit.delay,
        duration: inherit.duration
      };
      ++lock.count;
      d3.timer(function(elapsed) {
        var d = node.__data__, ease = transition.ease, event = transition.event, delay = transition.delay, duration = transition.duration, tweened = [];
        return delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time), 1;
        function start(elapsed) {
          if (lock.active > id) return stop();
          lock.active = id;
          event.start.call(node, d, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, d, i)) {
              tweened.push(value);
            }
          });
          if (!tick(elapsed)) d3.timer(tick, 0, time);
          return 1;
        }
        function tick(elapsed) {
          if (lock.active !== id) return stop();
          var t = (elapsed - delay) / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            stop();
            event.end.call(node, d, i);
            return 1;
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node.__transition__;
          return 1;
        }
      }, 0, time);
      return transition;
    }
  }
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnode, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, id, node.__transition__[id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node.__transition__[id];
          subnodes = selector.call(node, node.__data__, i);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            d3_transitionNode(subnode = subnodes[k], k, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.id, this.time).ease(this.ease());
  };
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = d3_interpolateByName(nameNS), name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    return d3_transition_tween(this, "attr." + nameNS, value, function(b) {
      function attrString() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      }
      function attrStringNS() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      }
      return b == null ? name.local ? attrNullNS : attrNull : (b += "", name.local ? attrStringNS : attrString);
    });
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    var interpolate = d3_interpolateByName(name);
    function styleNull() {
      this.style.removeProperty(name);
    }
    return d3_transition_tween(this, "style." + name, value, function(b) {
      function styleString() {
        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      }
      return b == null ? styleNull : (b += "", styleString);
    });
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    return this.tween("style." + name, function(d, i) {
      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    });
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    return this.each("end.transition", function() {
      var p;
      if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id;
    if (arguments.length < 1) return this.node().__transition__[id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node.__transition__[id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].delay = value.call(node, node.__data__, i, j) | 0;
    } : (value |= 0, function(node) {
      node.__transition__[id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j) | 0);
    } : (value = Math.max(1, value | 0), function(node) {
      node.__transition__[id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      d3_transitionInheritId = id;
      d3_selection_each(this, function(node, i, j) {
        d3_transitionInherit = node.__transition__[id];
        type.call(node, node.__data__, i, j);
      });
      d3_transitionInherit = inherit;
      d3_transitionInheritId = inheritId;
    } else {
      d3_selection_each(this, function(node) {
        node.__transition__[id].event.on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = Object.create(node.__transition__[id0]);
          transition.delay += transition.duration;
          d3_transitionNode(node, i, id1, transition);
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id1);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id;
    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node.__transition__[id].tween.remove(name);
    } : function(node) {
      node.__transition__[id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node.__transition__[id].tween.set(name, value);
    }));
  }
  var d3_timer_id = 0, d3_timer_byId = {}, d3_timer_queue = null, d3_timer_interval, d3_timer_timeout;
  d3.timer = function(callback, delay, then) {
    if (arguments.length < 3) {
      if (arguments.length < 2) delay = 0; else if (!isFinite(delay)) return;
      then = Date.now();
    }
    var timer = d3_timer_byId[callback.id];
    if (timer && timer.callback === callback) {
      timer.then = then;
      timer.delay = delay;
    } else d3_timer_byId[callback.id = ++d3_timer_id] = d3_timer_queue = {
      callback: callback,
      then: then,
      delay: delay,
      next: d3_timer_queue
    };
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    var delay = d3_timer_flush() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (!t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    d3_timer_flush();
  };
  function d3_timer_flush() {
    var t0 = null, t1 = d3_timer_queue, then = Infinity;
    while (t1) {
      if (t1.flush) {
        delete d3_timer_byId[t1.callback.id];
        t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
      } else {
        then = Math.min(then, t1.then + t1.delay);
        t1 = (t0 = t1).next;
      }
    }
    return then;
  }
  var d3_timer_frame = d3_window.requestAnimationFrame || d3_window.webkitRequestAnimationFrame || d3_window.mozRequestAnimationFrame || d3_window.oRequestAnimationFrame || d3_window.msRequestAnimationFrame || function(callback) {
    setTimeout(callback, 17);
  };
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
        svg = d3.select(d3_document.body).append("svg").style("position", "absolute").style("top", 0).style("left", 0);
        var ctm = svg[0][0].getScreenCTM();
        d3_mouse_bug44083 = !(ctm.f || ctm.e);
        svg.remove();
      }
      if (d3_mouse_bug44083) {
        point.x = e.pageX;
        point.y = e.pageY;
      } else {
        point.x = e.clientX;
        point.y = e.clientY;
      }
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  function d3_noop() {}
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    if (nice = nice(x1 - x0)) {
      domain[i0] = nice.floor(x0);
      domain[i1] = nice.ceil(x1);
    }
    return domain;
  }
  function d3_scale_niceDefault() {
    return Math;
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3.interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3.interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3.interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    scale.nice = function() {
      d3_scale_nice(domain, d3_scale_linearNice);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(dx) {
    dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
    return dx && {
      floor: function(x) {
        return Math.floor(x / dx) * dx;
      },
      ceil: function(x) {
        return Math.ceil(x / dx) * dx;
      }
    };
  }
  function d3_scale_linearTickRange(domain, m) {
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m) {
    return d3.format(",." + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + "f");
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear(), d3_scale_logp);
  };
  function d3_scale_log(linear, log) {
    var pow = log.pow;
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(pow);
      log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;
      pow = log.pow;
      linear.domain(x.map(log));
      return scale;
    };
    scale.nice = function() {
      linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(linear.domain()), ticks = [];
      if (extent.every(isFinite)) {
        var i = Math.floor(extent[0]), j = Math.ceil(extent[1]), u = pow(extent[0]), v = pow(extent[1]);
        if (log === d3_scale_logn) {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);
        } else {
          for (;i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (arguments.length < 2) format = d3_scale_logFormat;
      if (!arguments.length) return format;
      var k = Math.max(.1, n / scale.ticks().length), f = log === d3_scale_logn ? (e = -1e-12, 
      Math.floor) : (e = 1e-12, Math.ceil), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), log);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e");
  function d3_scale_logp(x) {
    return Math.log(x < 0 ? 0 : x) / Math.LN10;
  }
  function d3_scale_logn(x) {
    return -Math.log(x > 0 ? 0 : -x) / Math.LN10;
  }
  d3_scale_logp.pow = function(x) {
    return Math.pow(10, x);
  };
  d3_scale_logn.pow = function(x) {
    return -Math.pow(10, -x);
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1);
  };
  function d3_scale_pow(linear, exponent) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(powb);
      linear.domain(x.map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(scale.domain(), m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(scale.domain(), m);
    };
    scale.nice = function() {
      return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      var domain = scale.domain();
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      return scale.domain(domain);
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
      range = steps(start + Math.round(error / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf" ];
  var d3_category20 = [ "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5" ];
  var d3_category20b = [ "#393b79", "#5254a3", "#6b6ecf", "#9c9ede", "#637939", "#8ca252", "#b5cf6b", "#cedb9c", "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94", "#843c39", "#ad494a", "#d6616b", "#e7969c", "#7b4173", "#a55194", "#ce6dbd", "#de9ed6" ];
  var d3_category20c = [ "#3182bd", "#6baed6", "#9ecae1", "#c6dbef", "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2", "#31a354", "#74c476", "#a1d99b", "#c7e9c0", "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb", "#636363", "#969696", "#bdbdbd", "#d9d9d9" ];
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (isNaN(x = +x)) return NaN;
      return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.filter(function(d) {
        return !isNaN(d);
      }).sort(d3.ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function arc() {
      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, 
      a0 = a1, a1 = da), a1 - a0), df = da < π ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
      return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcOffset = -π / 2, d3_svg_arcMax = 2 * π - 1e-6;
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_line(projection) {
    var x = d3_svg_lineX, y = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  function d3_svg_lineX(d) {
    return d[0];
  }
  function d3_svg_lineY(d) {
    return d[1];
  }
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0 ];
    d3_svg_lineBasisBezier(path, px, py);
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    i = -1;
    while (++i < 2) {
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (Math.abs(d) < 1e-6) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] + d3_svg_arcOffset;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_svg_lineX, x1 = d3_svg_lineX, y0 = 0, y1 = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, tickMajorSize = 6, tickMinorSize = 6, tickEndSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_, tickSubdivide = 0;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain() : tickValues, tickFormat = tickFormat_ == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String : tickFormat_;
        var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide), subtick = g.selectAll(".tick.minor").data(subticks, String), subtickEnter = subtick.enter().insert("line", ".tick").attr("class", "tick minor").style("opacity", 1e-6), subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(), subtickUpdate = d3.transition(subtick).style("opacity", 1);
        var tick = g.selectAll(".tick.major").data(ticks, String), tickEnter = tick.enter().insert("g", "path").attr("class", "tick major").style("opacity", 1e-6), tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(), tickUpdate = d3.transition(tick).style("opacity", 1), tickTransform;
        var range = d3_scaleRange(scale), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        var scale1 = scale.copy(), scale0 = this.__chart__ || scale1;
        this.__chart__ = scale1;
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text");
        switch (orient) {
         case "bottom":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize);
            lineEnter.attr("y2", tickMajorSize);
            textEnter.attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", 0).attr("y2", tickMajorSize);
            textUpdate.attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            text.attr("dy", ".71em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
            break;
          }

         case "top":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", -tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize);
            lineEnter.attr("y2", -tickMajorSize);
            textEnter.attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", 0).attr("y2", -tickMajorSize);
            textUpdate.attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            text.attr("dy", "0em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
            break;
          }

         case "left":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", -tickMinorSize);
            subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", -tickMajorSize);
            textEnter.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", -tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "end");
            pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
            break;
          }

         case "right":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", tickMinorSize);
            subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", tickMajorSize);
            textEnter.attr("x", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "start");
            pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize);
            break;
          }
        }
        if (scale.ticks) {
          tickEnter.call(tickTransform, scale0);
          tickUpdate.call(tickTransform, scale1);
          tickExit.call(tickTransform, scale1);
          subtickEnter.call(tickTransform, scale0);
          subtickUpdate.call(tickTransform, scale1);
          subtickExit.call(tickTransform, scale1);
        } else {
          var dx = scale1.rangeBand() / 2, x = function(d) {
            return scale1(d) + dx;
          };
          tickEnter.call(tickTransform, x);
          tickUpdate.call(tickTransform, x);
        }
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x, y) {
      if (!arguments.length) return tickMajorSize;
      var n = arguments.length - 1;
      tickMajorSize = +x;
      tickMinorSize = n > 1 ? +y : tickMajorSize;
      tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function(x) {
      if (!arguments.length) return tickSubdivide;
      tickSubdivide = +x;
      return axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x) {
    selection.attr("transform", function(d) {
      return "translate(" + x(d) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y) {
    selection.attr("transform", function(d) {
      return "translate(0," + y(d) + ")";
    });
  }
  function d3_svg_axisSubdivide(scale, ticks, m) {
    subticks = [];
    if (m && ticks.length > 1) {
      var extent = d3_scaleExtent(scale.domain()), subticks, i = -1, n = ticks.length, d = (ticks[1] - ticks[0]) / ++m, j, v;
      while (++i < n) {
        for (j = m; --j > 0; ) {
          if ((v = +ticks[i] - j * d) >= extent[0]) {
            subticks.push(v);
          }
        }
      }
      for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1]; ) {
        subticks.push(v);
      }
    }
    return subticks;
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, resizes = d3_svg_brushResizes[0], extent = [ [ 0, 0 ], [ 0, 0 ] ], extentDomain;
    function brush(g) {
      g.each(function() {
        var g = d3.select(this), bg = g.selectAll(".background").data([ 0 ]), fg = g.selectAll(".extent").data([ 0 ]), tz = g.selectAll(".resize").data(resizes, String), e;
        g.style("pointer-events", "all").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        bg.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        fg.enter().append("rect").attr("class", "extent").style("cursor", "move");
        tz.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        tz.style("display", brush.empty() ? "none" : null);
        tz.exit().remove();
        if (x) {
          e = d3_scaleRange(x);
          bg.attr("x", e[0]).attr("width", e[1] - e[0]);
          redrawX(g);
        }
        if (y) {
          e = d3_scaleRange(y);
          bg.attr("y", e[0]).attr("height", e[1] - e[0]);
          redrawY(g);
        }
        redraw(g);
      });
    }
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", extent[0][0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", extent[0][1]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), center, origin = mouse(), offset;
      var w = d3.select(d3_window).on("mousemove.brush", brushmove).on("mouseup.brush", brushend).on("touchmove.brush", brushmove).on("touchend.brush", brushend).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (dragging) {
        origin[0] = extent[0][0] - origin[0];
        origin[1] = extent[0][1] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1] ];
        origin[0] = extent[ex][0];
        origin[1] = extent[ey][1];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      d3_eventCancel();
      function mouse() {
        var touches = d3.event.changedTouches;
        return touches ? d3.touches(target, touches)[0] : d3.mouse(target);
      }
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= extent[1][0];
            origin[1] -= extent[1][1];
            dragging = 2;
          }
          d3_eventCancel();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += extent[1][0];
          origin[1] += extent[1][1];
          dragging = 0;
          d3_eventCancel();
        }
      }
      function brushmove() {
        var point = mouse(), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2 ];
            origin[0] = extent[+(point[0] < center[0])][0];
            origin[1] = extent[+(point[1] < center[1])][1];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], size = extent[1][i] - extent[0][i], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = Math.max(r0, Math.min(r1, point[i]));
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0][i] !== min || extent[1][i] !== max) {
          extentDomain = null;
          extent[0][i] = min;
          extent[1][i] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        event_({
          type: "brushend"
        });
        d3_eventCancel();
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        z = extentDomain || extent;
        if (x) {
          x0 = z[0][0], x1 = z[1][0];
          if (!extentDomain) {
            x0 = extent[0][0], x1 = extent[1][0];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          y0 = z[0][1], y1 = z[1][1];
          if (!extentDomain) {
            y0 = extent[0][1], y1 = extent[1][1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      extentDomain = [ [ 0, 0 ], [ 0, 0 ] ];
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        extentDomain[0][0] = x0, extentDomain[1][0] = x1;
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        extentDomain[0][1] = y0, extentDomain[1][1] = y1;
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;
      }
      return brush;
    };
    brush.clear = function() {
      extentDomain = null;
      extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;
      return brush;
    };
    brush.empty = function() {
      return x && extent[0][0] === extent[1][0] || y && extent[0][1] === extent[1][1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  d3.behavior = {};
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null;
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", mousedown);
    }
    function mousedown() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, touchId = d3.event.touches ? d3.event.changedTouches[0].identifier : null, offset, origin_ = point(), moved = 0;
      var w = d3.select(d3_window).on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", dragmove).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", dragend, true);
      if (origin) {
        offset = origin.apply(target, arguments);
        offset = [ offset.x - origin_[0], offset.y - origin_[1] ];
      } else {
        offset = [ 0, 0 ];
      }
      if (touchId == null) d3_eventCancel();
      event_({
        type: "dragstart"
      });
      function point() {
        var p = target.parentNode;
        return touchId != null ? d3.touches(p).filter(function(p) {
          return p.identifier === touchId;
        })[0] : d3.mouse(p);
      }
      function dragmove() {
        if (!target.parentNode) return dragend();
        var p = point(), dx = p[0] - origin_[0], dy = p[1] - origin_[1];
        moved |= dx | dy;
        origin_ = p;
        d3_eventCancel();
        event_({
          type: "drag",
          x: p[0] + offset[0],
          y: p[1] + offset[1],
          dx: dx,
          dy: dy
        });
      }
      function dragend() {
        event_({
          type: "dragend"
        });
        if (moved) {
          d3_eventCancel();
          if (d3.event.target === eventTarget) w.on("click.drag", click, true);
        }
        w.on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", null).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", null);
      }
      function click() {
        d3_eventCancel();
        w.on("click.drag", null);
      }
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  d3.behavior.zoom = function() {
    var translate = [ 0, 0 ], translate0, scale = 1, scale0, scaleExtent = d3_behavior_zoomInfinity, event = d3_eventDispatch(zoom, "zoom"), x0, x1, y0, y1, touchtime;
    function zoom() {
      this.on("mousedown.zoom", mousedown).on("mousemove.zoom", mousemove).on(d3_behavior_zoomWheel + ".zoom", mousewheel).on("dblclick.zoom", dblclick).on("touchstart.zoom", touchstart).on("touchmove.zoom", touchmove).on("touchend.zoom", touchstart);
    }
    zoom.translate = function(x) {
      if (!arguments.length) return translate;
      translate = x.map(Number);
      rescale();
      return zoom;
    };
    zoom.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(x) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      translate = [ 0, 0 ];
      scale = 1;
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      translate = [ 0, 0 ];
      scale = 1;
      return zoom;
    };
    function location(p) {
      return [ (p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale ];
    }
    function point(l) {
      return [ l[0] * scale + translate[0], l[1] * scale + translate[1] ];
    }
    function scaleTo(s) {
      scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      translate[0] += p[0] - l[0];
      translate[1] += p[1] - l[1];
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - translate[0]) / scale;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - translate[1]) / scale;
      }).map(y0.invert));
    }
    function dispatch(event) {
      rescale();
      d3.event.preventDefault();
      event({
        type: "zoom",
        scale: scale,
        translate: translate
      });
    }
    function mousedown() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, moved = 0, w = d3.select(d3_window).on("mousemove.zoom", mousemove).on("mouseup.zoom", mouseup), l = location(d3.mouse(target));
      d3_window.focus();
      d3_eventCancel();
      function mousemove() {
        moved = 1;
        translateTo(d3.mouse(target), l);
        dispatch(event_);
      }
      function mouseup() {
        if (moved) d3_eventCancel();
        w.on("mousemove.zoom", null).on("mouseup.zoom", null);
        if (moved && d3.event.target === eventTarget) w.on("click.zoom", click, true);
      }
      function click() {
        d3_eventCancel();
        w.on("click.zoom", null);
      }
    }
    function mousewheel() {
      if (!translate0) translate0 = location(d3.mouse(this));
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);
      translateTo(d3.mouse(this), translate0);
      dispatch(event.of(this, arguments));
    }
    function mousemove() {
      translate0 = null;
    }
    function dblclick() {
      var p = d3.mouse(this), l = location(p), k = Math.log(scale) / Math.LN2;
      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
      translateTo(p, l);
      dispatch(event.of(this, arguments));
    }
    function touchstart() {
      var touches = d3.touches(this), now = Date.now();
      scale0 = scale;
      translate0 = {};
      touches.forEach(function(t) {
        translate0[t.identifier] = location(t);
      });
      d3_eventCancel();
      if (touches.length === 1) {
        if (now - touchtime < 500) {
          var p = touches[0], l = location(touches[0]);
          scaleTo(scale * 2);
          translateTo(p, l);
          dispatch(event.of(this, arguments));
        }
        touchtime = now;
      }
    }
    function touchmove() {
      var touches = d3.touches(this), p0 = touches[0], l0 = translate0[p0.identifier];
      if (p1 = touches[1]) {
        var p1, l1 = translate0[p1.identifier];
        p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
        l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
        scaleTo(d3.event.scale * scale0);
      }
      translateTo(p0, l0);
      touchtime = null;
      dispatch(event.of(this, arguments));
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ];
  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in document ? (d3_behavior_zoomDelta = function() {
    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
  }, "wheel") : "onmousewheel" in document ? (d3_behavior_zoomDelta = function() {
    return d3.event.wheelDelta;
  }, "mousewheel") : (d3_behavior_zoomDelta = function() {
    return -d3.event.detail;
  }, "MozMousePixelScroll");
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (2 * π - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, gravity = .1, theta = .8, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dn = 1 / Math.sqrt(dx * dx + dy * dy);
          if ((x2 - x1) * dn < theta) {
            var k = quad.charge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
            return true;
          }
          if (quad.point && isFinite(dn)) {
            var k = quad.pointCharge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return theta;
      theta = +x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, j, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        var neighbors = neighbor(i), j = -1, m = neighbors.length, x;
        while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;
        return Math.random() * size;
      }
      function neighbor() {
        if (!neighbors) {
          neighbors = [];
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        return neighbors[i];
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1;
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = 2 * π;
    function pie(data) {
      var values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      });
      var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
      var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - startAngle) / d3.sum(values);
      var index = d3.range(data.length);
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      var arcs = [];
      index.forEach(function(i) {
        var d;
        arcs[i] = {
          data: data[i],
          value: d = values[i],
          startAngle: a,
          endAngle: a += d * k
        };
      });
      return arcs;
    }
    pie.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return pie;
    };
    pie.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return pie;
    };
    pie.startAngle = function(x) {
      if (!arguments.length) return startAngle;
      startAngle = x;
      return pie;
    };
    pie.endAngle = function(x) {
      if (!arguments.length) return endAngle;
      endAngle = x;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var n = series.length, m = series[0].length, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function recurse(node, depth, nodes) {
      var childs = children.call(hierarchy, node, depth);
      node.depth = depth;
      nodes.push(node);
      if (childs && (n = childs.length)) {
        var i = -1, n, c = node.children = [], v = 0, j = depth + 1, d;
        while (++i < n) {
          d = recurse(childs[i], j, nodes);
          d.parent = node;
          c.push(d);
          v += d.value;
        }
        if (sort) c.sort(sort);
        if (value) node.value = v;
      } else if (value) {
        node.value = +value.call(hierarchy, node, depth) || 0;
      }
      return node;
    }
    function revalue(node, depth) {
      var children = node.children, v = 0;
      if (children && (n = children.length)) {
        var i = -1, n, j = depth + 1;
        while (++i < n) v += revalue(children[i], j);
      } else if (value) {
        v = +value.call(hierarchy, node, depth) || 0;
      }
      if (value) node.value = v;
      return v;
    }
    function hierarchy(d) {
      var nodes = [];
      recurse(d, 0, nodes);
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      revalue(root, 0);
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ];
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      root.x = 0;
      root.y = 0;
      d3_layout_treeVisitAfter(root, function(d) {
        d.r = Math.sqrt(d.value);
      });
      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
      var w = size[0], h = size[1], k = Math.max(2 * root.r / w, 2 * root.r / h);
      if (padding > 0) {
        var dr = padding * k / 2;
        d3_layout_treeVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
        d3_layout_treeVisitAfter(root, function(d) {
          d.r -= dr;
        });
        k = Math.max(2 * root.r / w, 2 * root.r / h);
      }
      d3_layout_packTransform(root, w / 2, h / 2, 1 / k);
      return nodes;
    }
    pack.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return dr * dr - dx * dx - dy * dy > .001;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_treeVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      function firstWalk(node, previousSibling) {
        var children = node.children, layout = node._tree;
        if (children && (n = children.length)) {
          var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
          while (++i < n) {
            child = children[i];
            firstWalk(child, previousChild);
            ancestor = apportion(child, previousChild, ancestor);
            previousChild = child;
          }
          d3_layout_treeShift(node);
          var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
            layout.mod = layout.prelim - midpoint;
          } else {
            layout.prelim = midpoint;
          }
        } else {
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          }
        }
      }
      function secondWalk(node, x) {
        node.x = node._tree.prelim + x;
        var children = node.children;
        if (children && (n = children.length)) {
          var i = -1, n;
          x += node._tree.mod;
          while (++i < n) {
            secondWalk(children[i], x);
          }
        }
      }
      function apportion(node, previousSibling, ancestor) {
        if (previousSibling) {
          var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
            vom = d3_layout_treeLeft(vom);
            vop = d3_layout_treeRight(vop);
            vop._tree.ancestor = node;
            shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
            if (shift > 0) {
              d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim._tree.mod;
            sip += vip._tree.mod;
            som += vom._tree.mod;
            sop += vop._tree.mod;
          }
          if (vim && !d3_layout_treeRight(vop)) {
            vop._tree.thread = vim;
            vop._tree.mod += sim - sop;
          }
          if (vip && !d3_layout_treeLeft(vom)) {
            vom._tree.thread = vip;
            vom._tree.mod += sip - som;
            ancestor = node;
          }
        }
        return ancestor;
      }
      d3_layout_treeVisitAfter(root, function(node, previousSibling) {
        node._tree = {
          ancestor: node,
          prelim: 0,
          mod: 0,
          change: 0,
          shift: 0,
          number: previousSibling ? previousSibling._tree.number + 1 : 0
        };
      });
      firstWalk(root);
      secondWalk(root, -root._tree.prelim);
      var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost), right = d3_layout_treeSearch(root, d3_layout_treeRightmost), deep = d3_layout_treeSearch(root, d3_layout_treeDeepest), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2, y1 = deep.depth || 1;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = node.depth / y1 * size[1];
        delete node._tree;
      });
      return nodes;
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(node) {
    var children = node.children;
    return children && children.length ? children[0] : node._tree.thread;
  }
  function d3_layout_treeRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? children[n - 1] : node._tree.thread;
  }
  function d3_layout_treeSearch(node, compare) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child, n, i = -1;
      while (++i < n) {
        if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
          node = child;
        }
      }
    }
    return node;
  }
  function d3_layout_treeRightmost(a, b) {
    return a.x - b.x;
  }
  function d3_layout_treeLeftmost(a, b) {
    return b.x - a.x;
  }
  function d3_layout_treeDeepest(a, b) {
    return a.depth - b.depth;
  }
  function d3_layout_treeVisitAfter(node, callback) {
    function visit(node, previousSibling) {
      var children = node.children;
      if (children && (n = children.length)) {
        var child, previousChild = null, i = -1, n;
        while (++i < n) {
          child = children[i];
          visit(child, previousChild);
          previousChild = child;
        }
      }
      callback(node, previousSibling);
    }
    visit(node, null);
  }
  function d3_layout_treeShift(node) {
    var shift = 0, change = 0, children = node.children, i = children.length, child;
    while (--i >= 0) {
      child = children[i]._tree;
      child.prelim += shift;
      child.mod += shift;
      shift += child.shift + (change += child.change);
    }
  }
  function d3_layout_treeMove(ancestor, node, shift) {
    ancestor = ancestor._tree;
    node = node._tree;
    var change = shift / (node.number - ancestor.number);
    ancestor.change += change;
    node.change -= change;
    node.shift += shift;
    node.prelim += shift;
    node.mod += shift;
  }
  function d3_layout_treeAncestor(vim, node, ancestor) {
    return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  function d3_dsv(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, callback) {
      return d3.xhr(url, mimeType, callback).response(response);
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    dsv.parse = function(text) {
      var o;
      return dsv.parseRows(text, function(row) {
        if (o) return o(row);
        o = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.substring(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.substring(j, I - k);
        }
        return text.substring(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && !(a = f(a, n++))) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  }
  d3.csv = d3_dsv(",", "text/csv");
  d3.tsv = d3_dsv("	", "text/tab-separated-values");
  d3.geo = {};
  d3.geo.stream = function(object, listener) {
    if (d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      var coordinate = object.coordinates;
      listener.point(coordinate[0], coordinate[1]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length, coordinate;
      while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), Math.asin(Math.max(-1, Math.min(1, cartesian[2]))) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, maxDepth = 16;
    function resample(stream) {
      var λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = polygonLineStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function polygonLineStart() {
        var λ00, φ00, x00, y00, a00, b00, c00;
        lineStart();
        resample.point = function(λ, φ) {
          linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resample.point = linePoint;
        };
        resample.lineEnd = function() {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
          resample.lineEnd = lineEnd;
          lineEnd();
        };
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = Math.abs(Math.abs(c) - 1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || Math.abs((dx * dx2 + dy * dy2) / d2 - .5) > .3) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 60 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 20 ]).parallels([ 8, 18 ]);
    var puertoRico = d3.geo.albers().rotate([ 60, 0 ]).center([ 0, 10 ]).parallels([ 8, 18 ]);
    function albersUsa(coordinates) {
      return projection(coordinates)(coordinates);
    }
    function projection(point) {
      var lon = point[0], lat = point[1];
      return lat > 50 ? alaska : lon < -140 ? hawaii : lat < 21 ? puertoRico : lower48;
    }
    albersUsa.scale = function(x) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(x);
      alaska.scale(x * .6);
      hawaii.scale(x);
      puertoRico.scale(x * 1.5);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(x) {
      if (!arguments.length) return lower48.translate();
      var dz = lower48.scale(), dx = x[0], dy = x[1];
      lower48.translate(x);
      alaska.translate([ dx - .4 * dz, dy + .17 * dz ]);
      hawaii.translate([ dx - .19 * dz, dy + .2 * dz ]);
      puertoRico.translate([ dx + .58 * dz, dy + .43 * dz ]);
      return albersUsa;
    };
    return albersUsa.scale(lower48.scale());
  };
  function d3_geo_albers(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function albers(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    albers.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, Math.asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return albers;
  }
  (d3.geo.albers = function() {
    var φ0 = 29.5 * d3_radians, φ1 = 45.5 * d3_radians, m = d3_geo_projectionMutator(d3_geo_albers), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 * d3_degrees, φ1 * d3_degrees ];
      return m(φ0 = _[0] * d3_radians, φ1 = _[1] * d3_radians);
    };
    return p.rotate([ 98, 0 ]).center([ 0, 38 ]).scale(1e3);
  }).raw = d3_geo_albers;
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  d3.geo.bounds = d3_geo_bounds(d3_identity);
  function d3_geo_bounds(projectStream) {
    var x0, y0, x1, y1;
    var bound = {
      point: boundPoint,
      lineStart: d3_noop,
      lineEnd: d3_noop,
      polygonStart: function() {
        bound.lineEnd = boundPolygonLineEnd;
      },
      polygonEnd: function() {
        bound.point = boundPoint;
      }
    };
    function boundPoint(x, y) {
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }
    function boundPolygonLineEnd() {
      bound.point = bound.lineEnd = d3_noop;
    }
    return function(feature) {
      y1 = x1 = -(x0 = y0 = Infinity);
      d3.geo.stream(feature, projectStream(bound));
      return [ [ x0, y0 ], [ x1, y1 ] ];
    };
  }
  d3.geo.centroid = function(object) {
    d3_geo_centroidDimension = d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var m;
    if (d3_geo_centroidW && Math.abs(m = Math.sqrt(d3_geo_centroidX * d3_geo_centroidX + d3_geo_centroidY * d3_geo_centroidY + d3_geo_centroidZ * d3_geo_centroidZ)) > ε) {
      return [ Math.atan2(d3_geo_centroidY, d3_geo_centroidX) * d3_degrees, Math.asin(Math.max(-1, Math.min(1, d3_geo_centroidZ / m))) * d3_degrees ];
    }
  };
  var d3_geo_centroidDimension, d3_geo_centroidW, d3_geo_centroidX, d3_geo_centroidY, d3_geo_centroidZ;
  var d3_geo_centroid = {
    sphere: function() {
      if (d3_geo_centroidDimension < 2) {
        d3_geo_centroidDimension = 2;
        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      }
    },
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      if (d3_geo_centroidDimension < 2) {
        d3_geo_centroidDimension = 2;
        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      }
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    if (d3_geo_centroidDimension) return;
    ++d3_geo_centroidW;
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidX += (cosφ * Math.cos(λ) - d3_geo_centroidX) / d3_geo_centroidW;
    d3_geo_centroidY += (cosφ * Math.sin(λ) - d3_geo_centroidY) / d3_geo_centroidW;
    d3_geo_centroidZ += (Math.sin(φ) - d3_geo_centroidZ) / d3_geo_centroidW;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00;
    d3_geo_centroidDimension = 1;
    d3_geo_centroidLineStart();
    d3_geo_centroidDimension = 2;
    var linePoint = d3_geo_centroid.point;
    d3_geo_centroid.point = function(λ, φ) {
      linePoint(λ00 = λ, φ00 = φ);
    };
    d3_geo_centroid.lineEnd = function() {
      d3_geo_centroid.point(λ00, φ00);
      d3_geo_centroidLineEnd();
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
    };
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    if (d3_geo_centroidDimension > 1) return;
    if (d3_geo_centroidDimension < 1) {
      d3_geo_centroidDimension = 1;
      d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    }
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW += w;
      d3_geo_centroidX += w * (x0 + (x0 = x));
      d3_geo_centroidY += w * (y0 + (y0 = y));
      d3_geo_centroidZ += w * (z0 + (z0 = z));
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radians, precision) {
    var cr = Math.cos(radians), sr = Math.sin(radians);
    return function(from, to, direction, listener) {
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * 2 * π;
      } else {
        from = radians + direction * 2 * π;
        to = radians;
      }
      var point;
      for (var step = direction * precision, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = Math.acos(Math.max(-1, Math.min(1, -a[1])));
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate) {
    return function(listener) {
      var line = clipLine(listener);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          invisible = false;
          invisibleArea = visibleArea = 0;
          segments = [];
          listener.polygonStart();
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          if (segments.length) {
            d3_geo_clipPolygon(segments, interpolate, listener);
          } else if (visibleArea < -ε || invisible && invisibleArea < -ε) {
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          listener.polygonEnd();
          segments = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        if (pointVisible(λ, φ)) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        line.point(λ, φ);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments, visibleArea, invisibleArea, invisible;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), ring;
      function pointRing(λ, φ) {
        ringListener.point(λ, φ);
        ring.push([ λ, φ ]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        if (!n) {
          invisible = true;
          invisibleArea += d3_geo_clipAreaRing(ring, -1);
          ring = null;
          return;
        }
        ring = null;
        if (clean & 1) {
          segment = ringSegments[0];
          visibleArea += d3_geo_clipAreaRing(segment, 1);
          var n = segment.length - 1, i = -1, point;
          listener.lineStart();
          while (++i < n) listener.point((point = segment[i])[0], point[1]);
          listener.lineEnd();
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipPolygon(segments, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      var n = segment.length;
      if (n <= 1) return;
      var p0 = segment[0], p1 = segment[n - 1], a = {
        point: p0,
        points: segment,
        other: null,
        visited: false,
        entry: true,
        subject: true
      }, b = {
        point: p0,
        points: [ p0 ],
        other: a,
        visited: false,
        entry: false,
        subject: false
      };
      a.other = b;
      subject.push(a);
      clip.push(b);
      a = {
        point: p1,
        points: [ p1 ],
        other: null,
        visited: false,
        entry: false,
        subject: true
      };
      b = {
        point: p1,
        points: [ p1 ],
        other: a,
        visited: false,
        entry: true,
        subject: false
      };
      a.other = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(d3_geo_clipSort);
    d3_geo_clipLinkCircular(subject);
    d3_geo_clipLinkCircular(clip);
    if (!subject.length) return;
    var start = subject[0], current, points, point;
    while (1) {
      current = start;
      while (current.visited) if ((current = current.next) === start) return;
      points = current.points;
      listener.lineStart();
      do {
        current.visited = current.other.visited = true;
        if (current.entry) {
          if (current.subject) {
            for (var i = 0; i < points.length; i++) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.point, current.next.point, 1, listener);
          }
          current = current.next;
        } else {
          if (current.subject) {
            points = current.prev.points;
            for (var i = points.length; --i >= 0; ) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.point, current.prev.point, -1, listener);
          }
          current = current.prev;
        }
        current = current.other;
        points = current.points;
      } while (!current.visited);
      listener.lineEnd();
    }
  }
  function d3_geo_clipLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.next = b = array[i];
      b.prev = a;
      a = b;
    }
    a.next = b = array[0];
    b.prev = a;
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.point)[0] < 0 ? a[1] - π / 2 - ε : π / 2 - a[1]) - ((b = b.point)[0] < 0 ? b[1] - π / 2 - ε : π / 2 - b[1]);
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      }
    };
  }
  function d3_geo_clipAreaRing(ring, invisible) {
    if (!(n = ring.length)) return 0;
    var n, i = 0, area = 0, p = ring[0], λ = p[0], φ = p[1], cosφ = Math.cos(φ), x0 = Math.atan2(invisible * Math.sin(λ) * cosφ, Math.sin(φ)), y0 = 1 - invisible * Math.cos(λ) * cosφ, x1 = x0, x, y;
    while (++i < n) {
      p = ring[i];
      cosφ = Math.cos(φ = p[1]);
      x = Math.atan2(invisible * Math.sin(λ = p[0]) * cosφ, Math.sin(φ));
      y = 1 - invisible * Math.cos(λ) * cosφ;
      if (Math.abs(y0 - 2) < ε && Math.abs(y - 2) < ε) continue;
      if (Math.abs(y) < ε || Math.abs(y0) < ε) {} else if (Math.abs(Math.abs(x - x0) - π) < ε) {
        if (y + y0 > 2) area += 4 * (x - x0);
      } else if (Math.abs(y0 - 2) < ε) area += 4 * (x - x1); else area += ((3 * π + x - x0) % (2 * π) - π) * (y0 + y);
      x1 = x0, x0 = x, y0 = y;
    }
    return area;
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = Math.abs(λ1 - λ0);
        if (Math.abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? π / 2 : -π / 2);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (Math.abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (Math.abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return Math.abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * π / 2;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (Math.abs(from[0] - to[0]) > ε) {
      var s = (from[0] < to[0] ? 1 : -1) * π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_clipCircle(degrees) {
    var radians = degrees * d3_radians, cr = Math.cos(radians), interpolate = d3_geo_circleInterpolate(radians, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ);
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v0 = v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) listener.point(point1[0], point1[1]);
          point0 = point1;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b) {
      var pa = d3_geo_cartesian(a, 0), pb = d3_geo_cartesian(b, 0);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t = Math.sqrt(w * w - uu * (d3_geo_cartesianDot(A, A) - 1)), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      return d3_geo_spherical(q);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular).scale(250 / π);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  d3.geo.graticule = function() {
    var x1, x0, y1, y0, dx = 22.5, dy = dx, x, y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(x0 / dx) * dx, x1, dx).map(x).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ x(x0).concat(y(y1).slice(1), x(x1).reverse().slice(1), y(y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, precision);
      y = d3_geo_graticuleY(x0, x1, precision);
      return graticule;
    };
    return graticule.extent([ [ -180 + ε, -90 + ε ], [ 180 - ε, 90 - ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))), k = 1 / Math.sin(d);
    function interpolate(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) / d3_radians, Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_radians ];
    }
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_, precision = 6 * d3_radians, interpolate;
    function greatArc() {
      var p0 = source_ || source.apply(this, arguments), p1 = target_ || target.apply(this, arguments), i = interpolate || d3.geo.interpolate(p0, p1), t = 0, dt = precision / i.distance, coordinates = [ p0 ];
      while ((t += dt) < 1) coordinates.push(i(t));
      coordinates.push(p1);
      return {
        type: "LineString",
        coordinates: coordinates
      };
    }
    greatArc.distance = function() {
      return (interpolate || d3.geo.interpolate(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments))).distance;
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      interpolate = source_ && target_ ? d3.geo.interpolate(source_, target_) : null;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      interpolate = source_ && target_ ? d3.geo.interpolate(source_, target_) : null;
      return greatArc;
    };
    greatArc.precision = function(_) {
      if (!arguments.length) return precision / d3_radians;
      precision = _ * d3_radians;
      return greatArc;
    };
    return greatArc;
  };
  function d3_geo_mercator(λ, φ) {
    return [ λ / (2 * π), Math.max(-.5, Math.min(+.5, Math.log(Math.tan(π / 4 + φ / 2)) / (2 * π))) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ 2 * π * x, 2 * Math.atan(Math.exp(2 * π * y)) - π / 2 ];
  };
  (d3.geo.mercator = function() {
    return d3_geo_projection(d3_geo_mercator).scale(500);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream;
    function path(object) {
      if (object) d3.geo.stream(object, projectStream(contextStream.pointRadius(typeof pointRadius === "function" ? +pointRadius.apply(this, arguments) : pointRadius)));
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidDimension = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ ? [ d3_geo_centroidX / d3_geo_centroidZ, d3_geo_centroidY / d3_geo_centroidZ ] : undefined;
    };
    path.bounds = function(object) {
      return d3_geo_bounds(projectStream)(object);
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return path;
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      return path;
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : +_;
      return path;
    };
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + +2 * radius + "z";
  }
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(λ, φ) {
      return project([ λ * d3_degrees, φ * d3_degrees ]);
    });
    return function(stream) {
      stream = resample(stream);
      return {
        point: function(λ, φ) {
          stream.point(λ * d3_radians, φ * d3_radians);
        },
        sphere: function() {
          stream.sphere();
        },
        lineStart: function() {
          stream.lineStart();
        },
        lineEnd: function() {
          stream.lineEnd();
        },
        polygonStart: function() {
          stream.polygonStart();
        },
        polygonEnd: function() {
          stream.polygonEnd();
        }
      };
    };
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x, y);
      context.arc(x, y, pointRadius, 0, 2 * π);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += Math.abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    if (d3_geo_centroidDimension) return;
    d3_geo_centroidX += x;
    d3_geo_centroidY += y;
    ++d3_geo_centroidZ;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    if (d3_geo_centroidDimension !== 1) {
      if (d3_geo_centroidDimension < 1) {
        d3_geo_centroidDimension = 1;
        d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      } else return;
    }
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      x0 = x, y0 = y;
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX += z * (x0 + x) / 2;
      d3_geo_centroidY += z * (y0 + y) / 2;
      d3_geo_centroidZ += z;
      x0 = x, y0 = y;
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    if (d3_geo_centroidDimension < 2) {
      d3_geo_centroidDimension = 2;
      d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    }
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      var z = y0 * x - x0 * y;
      d3_geo_centroidX += z * (x0 + x);
      d3_geo_centroidY += z * (y0 + y);
      d3_geo_centroidZ += z * 3;
      x0 = x, y0 = y;
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingU, d3_geo_areaRingV;
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingU = 1, d3_geo_areaRingV = 0;
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * Math.atan2(d3_geo_areaRingV, d3_geo_areaRingU);
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u0 = d3_geo_areaRingU, v0 = d3_geo_areaRingV, u = cosφ0 * cosφ + k * Math.cos(dλ), v = k * Math.sin(dλ);
      d3_geo_areaRingU = u0 * u - v0 * v;
      d3_geo_areaRingV = v0 * u + u0 * v;
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, clip = d3_geo_clipAntimeridian, clipAngle = null;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(stream) {
      return d3_geo_projectionRadiansRotate(rotate, clip(projectResample(stream)));
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      clip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle(clipAngle = +_);
      return projection;
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadiansRotate(rotate, stream) {
    return {
      point: function(x, y) {
        y = rotate(x * d3_radians, y * d3_radians), x = y[0];
        stream.point(x > π ? x - 2 * π : x < -π ? x + 2 * π : x, y[1]);
      },
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_equirectangular;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - 2 * π : λ < -π ? λ + 2 * π : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδγ + y * sinδγ))) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδφ - x * sinδφ))) ];
    };
    return rotation;
  }
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  d3.geom = {};
  d3.geom.hull = function(vertices) {
    if (vertices.length < 3) return [];
    var len = vertices.length, plen = len - 1, points = [], stack = [], i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;
    for (i = 1; i < len; ++i) {
      if (vertices[i][1] < vertices[h][1]) {
        h = i;
      } else if (vertices[i][1] == vertices[h][1]) {
        h = vertices[i][0] < vertices[h][0] ? i : h;
      }
    }
    for (i = 0; i < len; ++i) {
      if (i === h) continue;
      y1 = vertices[i][1] - vertices[h][1];
      x1 = vertices[i][0] - vertices[h][0];
      points.push({
        angle: Math.atan2(y1, x1),
        index: i
      });
    }
    points.sort(function(a, b) {
      return a.angle - b.angle;
    });
    a = points[0].angle;
    v = points[0].index;
    u = 0;
    for (i = 1; i < plen; ++i) {
      j = points[i].index;
      if (a == points[i].angle) {
        x1 = vertices[v][0] - vertices[h][0];
        y1 = vertices[v][1] - vertices[h][1];
        x2 = vertices[j][0] - vertices[h][0];
        y2 = vertices[j][1] - vertices[h][1];
        if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {
          points[i].index = -1;
        } else {
          points[u].index = -1;
          a = points[i].angle;
          u = i;
          v = j;
        }
      } else {
        a = points[i].angle;
        u = i;
        v = j;
      }
    }
    stack.push(h);
    for (i = 0, j = 0; i < 2; ++j) {
      if (points[j].index !== -1) {
        stack.push(points[j].index);
        i++;
      }
    }
    sp = stack.length;
    for (;j < plen; ++j) {
      if (points[j].index === -1) continue;
      while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {
        --sp;
      }
      stack[sp++] = points[j].index;
    }
    var poly = [];
    for (i = 0; i < sp; ++i) {
      poly.push(vertices[stack[i]]);
    }
    return poly;
  };
  function d3_geom_hullCCW(i1, i2, i3, v) {
    var t, a, b, c, d, e, f;
    t = v[i1];
    a = t[0];
    b = t[1];
    t = v[i2];
    c = t[0];
    d = t[1];
    t = v[i3];
    e = t[0];
    f = t[1];
    return (f - b) * (c - a) - (d - b) * (e - a) > 0;
  }
  d3.geom.polygon = function(coordinates) {
    coordinates.area = function() {
      var i = 0, n = coordinates.length, area = coordinates[n - 1][1] * coordinates[0][0] - coordinates[n - 1][0] * coordinates[0][1];
      while (++i < n) {
        area += coordinates[i - 1][1] * coordinates[i][0] - coordinates[i - 1][0] * coordinates[i][1];
      }
      return area * .5;
    };
    coordinates.centroid = function(k) {
      var i = -1, n = coordinates.length, x = 0, y = 0, a, b = coordinates[n - 1], c;
      if (!arguments.length) k = -1 / (6 * coordinates.area());
      while (++i < n) {
        a = b;
        b = coordinates[i];
        c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }
      return [ x * k, y * k ];
    };
    coordinates.clip = function(subject) {
      var input, i = -1, n = coordinates.length, j, m, a = coordinates[n - 1], b, c, d;
      while (++i < n) {
        input = subject.slice();
        subject.length = 0;
        b = coordinates[i];
        c = input[(m = input.length) - 1];
        j = -1;
        while (++j < m) {
          d = input[j];
          if (d3_geom_polygonInside(d, a, b)) {
            if (!d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            subject.push(d);
          } else if (d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          c = d;
        }
        a = b;
      }
      return subject;
    };
    return coordinates;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  d3.geom.voronoi = function(vertices) {
    var polygons = vertices.map(function() {
      return [];
    }), Z = 1e6;
    d3_voronoi_tessellate(vertices, function(e) {
      var s1, s2, x1, x2, y1, y2;
      if (e.a === 1 && e.b >= 0) {
        s1 = e.ep.r;
        s2 = e.ep.l;
      } else {
        s1 = e.ep.l;
        s2 = e.ep.r;
      }
      if (e.a === 1) {
        y1 = s1 ? s1.y : -Z;
        x1 = e.c - e.b * y1;
        y2 = s2 ? s2.y : Z;
        x2 = e.c - e.b * y2;
      } else {
        x1 = s1 ? s1.x : -Z;
        y1 = e.c - e.a * x1;
        x2 = s2 ? s2.x : Z;
        y2 = e.c - e.a * x2;
      }
      var v1 = [ x1, y1 ], v2 = [ x2, y2 ];
      polygons[e.region.l.index].push(v1, v2);
      polygons[e.region.r.index].push(v1, v2);
    });
    polygons = polygons.map(function(polygon, i) {
      var cx = vertices[i][0], cy = vertices[i][1], angle = polygon.map(function(v) {
        return Math.atan2(v[0] - cx, v[1] - cy);
      }), order = d3.range(polygon.length).sort(function(a, b) {
        return angle[a] - angle[b];
      });
      return order.filter(function(d, i) {
        return !i || angle[d] - angle[order[i - 1]] > ε;
      }).map(function(d) {
        return polygon[d];
      });
    });
    polygons.forEach(function(polygon, i) {
      var n = polygon.length;
      if (!n) return polygon.push([ -Z, -Z ], [ -Z, Z ], [ Z, Z ], [ Z, -Z ]);
      if (n > 2) return;
      var p0 = vertices[i], p1 = polygon[0], p2 = polygon[1], x0 = p0[0], y0 = p0[1], x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], dx = Math.abs(x2 - x1), dy = y2 - y1;
      if (Math.abs(dy) < ε) {
        var y = y0 < y1 ? -Z : Z;
        polygon.push([ -Z, y ], [ Z, y ]);
      } else if (dx < ε) {
        var x = x0 < x1 ? -Z : Z;
        polygon.push([ x, -Z ], [ x, Z ]);
      } else {
        var y = (x2 - x1) * (y1 - y0) < (x1 - x0) * (y2 - y1) ? Z : -Z, z = Math.abs(dy) - dx;
        if (Math.abs(z) < ε) {
          polygon.push([ dy < 0 ? y : -y, y ]);
        } else {
          if (z > 0) y *= -1;
          polygon.push([ -Z, y ], [ Z, y ]);
        }
      }
    });
    return polygons;
  };
  var d3_voronoi_opposite = {
    l: "r",
    r: "l"
  };
  function d3_voronoi_tessellate(vertices, callback) {
    var Sites = {
      list: vertices.map(function(v, i) {
        return {
          index: i,
          x: v[0],
          y: v[1]
        };
      }).sort(function(a, b) {
        return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0;
      }),
      bottomSite: null
    };
    var EdgeList = {
      list: [],
      leftEnd: null,
      rightEnd: null,
      init: function() {
        EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.leftEnd.r = EdgeList.rightEnd;
        EdgeList.rightEnd.l = EdgeList.leftEnd;
        EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);
      },
      createHalfEdge: function(edge, side) {
        return {
          edge: edge,
          side: side,
          vertex: null,
          l: null,
          r: null
        };
      },
      insert: function(lb, he) {
        he.l = lb;
        he.r = lb.r;
        lb.r.l = he;
        lb.r = he;
      },
      leftBound: function(p) {
        var he = EdgeList.leftEnd;
        do {
          he = he.r;
        } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
        he = he.l;
        return he;
      },
      del: function(he) {
        he.l.r = he.r;
        he.r.l = he.l;
        he.edge = null;
      },
      right: function(he) {
        return he.r;
      },
      left: function(he) {
        return he.l;
      },
      leftRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[he.side];
      },
      rightRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[d3_voronoi_opposite[he.side]];
      }
    };
    var Geom = {
      bisect: function(s1, s2) {
        var newEdge = {
          region: {
            l: s1,
            r: s2
          },
          ep: {
            l: null,
            r: null
          }
        };
        var dx = s2.x - s1.x, dy = s2.y - s1.y, adx = dx > 0 ? dx : -dx, ady = dy > 0 ? dy : -dy;
        newEdge.c = s1.x * dx + s1.y * dy + (dx * dx + dy * dy) * .5;
        if (adx > ady) {
          newEdge.a = 1;
          newEdge.b = dy / dx;
          newEdge.c /= dx;
        } else {
          newEdge.b = 1;
          newEdge.a = dx / dy;
          newEdge.c /= dy;
        }
        return newEdge;
      },
      intersect: function(el1, el2) {
        var e1 = el1.edge, e2 = el2.edge;
        if (!e1 || !e2 || e1.region.r == e2.region.r) {
          return null;
        }
        var d = e1.a * e2.b - e1.b * e2.a;
        if (Math.abs(d) < 1e-10) {
          return null;
        }
        var xint = (e1.c * e2.b - e2.c * e1.b) / d, yint = (e2.c * e1.a - e1.c * e2.a) / d, e1r = e1.region.r, e2r = e2.region.r, el, e;
        if (e1r.y < e2r.y || e1r.y == e2r.y && e1r.x < e2r.x) {
          el = el1;
          e = e1;
        } else {
          el = el2;
          e = e2;
        }
        var rightOfSite = xint >= e.region.r.x;
        if (rightOfSite && el.side === "l" || !rightOfSite && el.side === "r") {
          return null;
        }
        return {
          x: xint,
          y: yint
        };
      },
      rightOf: function(he, p) {
        var e = he.edge, topsite = e.region.r, rightOfSite = p.x > topsite.x;
        if (rightOfSite && he.side === "l") {
          return 1;
        }
        if (!rightOfSite && he.side === "r") {
          return 0;
        }
        if (e.a === 1) {
          var dyp = p.y - topsite.y, dxp = p.x - topsite.x, fast = 0, above = 0;
          if (!rightOfSite && e.b < 0 || rightOfSite && e.b >= 0) {
            above = fast = dyp >= e.b * dxp;
          } else {
            above = p.x + p.y * e.b > e.c;
            if (e.b < 0) {
              above = !above;
            }
            if (!above) {
              fast = 1;
            }
          }
          if (!fast) {
            var dxs = topsite.x - e.region.l.x;
            above = e.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b);
            if (e.b < 0) {
              above = !above;
            }
          }
        } else {
          var yl = e.c - e.a * p.x, t1 = p.y - yl, t2 = p.x - topsite.x, t3 = yl - topsite.y;
          above = t1 * t1 > t2 * t2 + t3 * t3;
        }
        return he.side === "l" ? above : !above;
      },
      endPoint: function(edge, side, site) {
        edge.ep[side] = site;
        if (!edge.ep[d3_voronoi_opposite[side]]) return;
        callback(edge);
      },
      distance: function(s, t) {
        var dx = s.x - t.x, dy = s.y - t.y;
        return Math.sqrt(dx * dx + dy * dy);
      }
    };
    var EventQueue = {
      list: [],
      insert: function(he, site, offset) {
        he.vertex = site;
        he.ystar = site.y + offset;
        for (var i = 0, list = EventQueue.list, l = list.length; i < l; i++) {
          var next = list[i];
          if (he.ystar > next.ystar || he.ystar == next.ystar && site.x > next.vertex.x) {
            continue;
          } else {
            break;
          }
        }
        list.splice(i, 0, he);
      },
      del: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l && ls[i] != he; ++i) {}
        ls.splice(i, 1);
      },
      empty: function() {
        return EventQueue.list.length === 0;
      },
      nextEvent: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l; ++i) {
          if (ls[i] == he) return ls[i + 1];
        }
        return null;
      },
      min: function() {
        var elem = EventQueue.list[0];
        return {
          x: elem.vertex.x,
          y: elem.ystar
        };
      },
      extractMin: function() {
        return EventQueue.list.shift();
      }
    };
    EdgeList.init();
    Sites.bottomSite = Sites.list.shift();
    var newSite = Sites.list.shift(), newIntStar;
    var lbnd, rbnd, llbnd, rrbnd, bisector;
    var bot, top, temp, p, v;
    var e, pm;
    while (true) {
      if (!EventQueue.empty()) {
        newIntStar = EventQueue.min();
      }
      if (newSite && (EventQueue.empty() || newSite.y < newIntStar.y || newSite.y == newIntStar.y && newSite.x < newIntStar.x)) {
        lbnd = EdgeList.leftBound(newSite);
        rbnd = EdgeList.right(lbnd);
        bot = EdgeList.rightRegion(lbnd);
        e = Geom.bisect(bot, newSite);
        bisector = EdgeList.createHalfEdge(e, "l");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(lbnd, bisector);
        if (p) {
          EventQueue.del(lbnd);
          EventQueue.insert(lbnd, p, Geom.distance(p, newSite));
        }
        lbnd = bisector;
        bisector = EdgeList.createHalfEdge(e, "r");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(bisector, rbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, newSite));
        }
        newSite = Sites.list.shift();
      } else if (!EventQueue.empty()) {
        lbnd = EventQueue.extractMin();
        llbnd = EdgeList.left(lbnd);
        rbnd = EdgeList.right(lbnd);
        rrbnd = EdgeList.right(rbnd);
        bot = EdgeList.leftRegion(lbnd);
        top = EdgeList.rightRegion(rbnd);
        v = lbnd.vertex;
        Geom.endPoint(lbnd.edge, lbnd.side, v);
        Geom.endPoint(rbnd.edge, rbnd.side, v);
        EdgeList.del(lbnd);
        EventQueue.del(rbnd);
        EdgeList.del(rbnd);
        pm = "l";
        if (bot.y > top.y) {
          temp = bot;
          bot = top;
          top = temp;
          pm = "r";
        }
        e = Geom.bisect(bot, top);
        bisector = EdgeList.createHalfEdge(e, pm);
        EdgeList.insert(llbnd, bisector);
        Geom.endPoint(e, d3_voronoi_opposite[pm], v);
        p = Geom.intersect(llbnd, bisector);
        if (p) {
          EventQueue.del(llbnd);
          EventQueue.insert(llbnd, p, Geom.distance(p, bot));
        }
        p = Geom.intersect(bisector, rrbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, bot));
        }
      } else {
        break;
      }
    }
    for (lbnd = EdgeList.right(EdgeList.leftEnd); lbnd != EdgeList.rightEnd; lbnd = EdgeList.right(lbnd)) {
      callback(lbnd.edge);
    }
  }
  d3.geom.delaunay = function(vertices) {
    var edges = vertices.map(function() {
      return [];
    }), triangles = [];
    d3_voronoi_tessellate(vertices, function(e) {
      edges[e.region.l.index].push(vertices[e.region.r.index]);
    });
    edges.forEach(function(edge, i) {
      var v = vertices[i], cx = v[0], cy = v[1];
      edge.forEach(function(v) {
        v.angle = Math.atan2(v[0] - cx, v[1] - cy);
      });
      edge.sort(function(a, b) {
        return a.angle - b.angle;
      });
      for (var j = 0, m = edge.length - 1; j < m; j++) {
        triangles.push([ v, edge[j], edge[j + 1] ]);
      }
    });
    return triangles;
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var p, i = -1, n = points.length;
    if (arguments.length < 5) {
      if (arguments.length === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      } else {
        x1 = y1 = Infinity;
        x2 = y2 = -Infinity;
        while (++i < n) {
          p = points[i];
          if (p.x < x1) x1 = p.x;
          if (p.y < y1) y1 = p.y;
          if (p.x > x2) x2 = p.x;
          if (p.y > y2) y2 = p.y;
        }
      }
    }
    var dx = x2 - x1, dy = y2 - y1;
    if (dx > dy) y2 = y1 + dx; else x2 = x1 + dy;
    function insert(n, p, x1, y1, x2, y2) {
      if (isNaN(p.x) || isNaN(p.y)) return;
      if (n.leaf) {
        var v = n.point;
        if (v) {
          if (Math.abs(v.x - p.x) + Math.abs(v.y - p.y) < .01) {
            insertChild(n, p, x1, y1, x2, y2);
          } else {
            n.point = null;
            insertChild(n, v, x1, y1, x2, y2);
            insertChild(n, p, x1, y1, x2, y2);
          }
        } else {
          n.point = p;
        }
      } else {
        insertChild(n, p, x1, y1, x2, y2);
      }
    }
    function insertChild(n, p, x1, y1, x2, y2) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = p.x >= sx, bottom = p.y >= sy, i = (bottom << 1) + right;
      n.leaf = false;
      n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
      if (right) x1 = sx; else x2 = sx;
      if (bottom) y1 = sy; else y2 = sy;
      insert(n, p, x1, y1, x2, y2);
    }
    var root = d3_geom_quadtreeNode();
    root.add = function(p) {
      insert(root, p, x1, y1, x2, y2);
    };
    root.visit = function(f) {
      d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);
    };
    points.forEach(root.add);
    return root;
  };
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  d3.time = {};
  var d3_time = Date, d3_time_daySymbols = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
  function d3_time_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_time_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  var d3_time_formatDateTime = "%a %b %e %X %Y", d3_time_formatDate = "%m/%d/%Y", d3_time_formatTime = "%H:%M:%S";
  var d3_time_days = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], d3_time_dayAbbreviations = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], d3_time_months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], d3_time_monthAbbreviations = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
  d3.time.format = function(template) {
    var n = template.length;
    function format(date) {
      var string = [], i = -1, j = 0, c, p, f;
      while (++i < n) {
        if (template.charCodeAt(i) === 37) {
          string.push(template.substring(j, i));
          if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
          if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(template.substring(j, i));
      return string.join("");
    }
    format.parse = function(string) {
      var d = {
        y: 1900,
        m: 0,
        d: 1,
        H: 0,
        M: 0,
        S: 0,
        L: 0
      }, i = d3_time_parse(d, template, string, 0);
      if (i != string.length) return null;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      var date = new d3_time();
      date.setFullYear(d.y, d.m, d.d);
      date.setHours(d.H, d.M, d.S, d.L);
      return date;
    };
    format.toString = function() {
      return template;
    };
    return format;
  };
  function d3_time_parse(date, template, string, j) {
    var c, p, i = 0, n = template.length, m = string.length;
    while (i < n) {
      if (j >= m) return -1;
      c = template.charCodeAt(i++);
      if (c === 37) {
        p = d3_time_parsers[template.charAt(i++)];
        if (!p || (j = p(date, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_formatPad(value, fill, width) {
    value += "";
    var length = value.length;
    return length < width ? new Array(width - length + 1).join(fill) + value : value;
  }
  var d3_time_dayRe = d3_time_formatRe(d3_time_days), d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations), d3_time_monthRe = d3_time_formatRe(d3_time_months), d3_time_monthLookup = d3_time_formatLookup(d3_time_months), d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations), d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations);
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  };
  var d3_time_formats = {
    a: function(d) {
      return d3_time_dayAbbreviations[d.getDay()];
    },
    A: function(d) {
      return d3_time_days[d.getDay()];
    },
    b: function(d) {
      return d3_time_monthAbbreviations[d.getMonth()];
    },
    B: function(d) {
      return d3_time_months[d.getMonth()];
    },
    c: d3.time.format(d3_time_formatDateTime),
    d: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    e: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    H: function(d, p) {
      return d3_time_formatPad(d.getHours(), p, 2);
    },
    I: function(d, p) {
      return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
    },
    j: function(d, p) {
      return d3_time_formatPad(1 + d3.time.dayOfYear(d), p, 3);
    },
    L: function(d, p) {
      return d3_time_formatPad(d.getMilliseconds(), p, 3);
    },
    m: function(d, p) {
      return d3_time_formatPad(d.getMonth() + 1, p, 2);
    },
    M: function(d, p) {
      return d3_time_formatPad(d.getMinutes(), p, 2);
    },
    p: function(d) {
      return d.getHours() >= 12 ? "PM" : "AM";
    },
    S: function(d, p) {
      return d3_time_formatPad(d.getSeconds(), p, 2);
    },
    U: function(d, p) {
      return d3_time_formatPad(d3.time.sundayOfYear(d), p, 2);
    },
    w: function(d) {
      return d.getDay();
    },
    W: function(d, p) {
      return d3_time_formatPad(d3.time.mondayOfYear(d), p, 2);
    },
    x: d3.time.format(d3_time_formatDate),
    X: d3.time.format(d3_time_formatTime),
    y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 100, p, 2);
    },
    Y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
    },
    Z: d3_time_zone,
    "%": function() {
      return "%";
    }
  };
  var d3_time_parsers = {
    a: d3_time_parseWeekdayAbbrev,
    A: d3_time_parseWeekday,
    b: d3_time_parseMonthAbbrev,
    B: d3_time_parseMonth,
    c: d3_time_parseLocaleFull,
    d: d3_time_parseDay,
    e: d3_time_parseDay,
    H: d3_time_parseHour24,
    I: d3_time_parseHour24,
    L: d3_time_parseMilliseconds,
    m: d3_time_parseMonthNumber,
    M: d3_time_parseMinutes,
    p: d3_time_parseAmPm,
    S: d3_time_parseSeconds,
    x: d3_time_parseLocaleDate,
    X: d3_time_parseLocaleTime,
    y: d3_time_parseYear,
    Y: d3_time_parseFullYear
  };
  function d3_time_parseWeekdayAbbrev(date, string, i) {
    d3_time_dayAbbrevRe.lastIndex = 0;
    var n = d3_time_dayAbbrevRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseWeekday(date, string, i) {
    d3_time_dayRe.lastIndex = 0;
    var n = d3_time_dayRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseMonthAbbrev(date, string, i) {
    d3_time_monthAbbrevRe.lastIndex = 0;
    var n = d3_time_monthAbbrevRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseMonth(date, string, i) {
    d3_time_monthRe.lastIndex = 0;
    var n = d3_time_monthRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseLocaleFull(date, string, i) {
    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
  }
  function d3_time_parseLocaleDate(date, string, i) {
    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
  }
  function d3_time_parseLocaleTime(date, string, i) {
    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 4));
    return n ? (date.y = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i += n[0].length) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.m = n[0] - 1, i += n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.d = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.H = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.M = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.S = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 3));
    return n ? (date.L = +n[0], i += n[0].length) : -1;
  }
  var d3_time_numberRe = /^\s*\d+/;
  function d3_time_parseAmPm(date, string, i) {
    var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
    return n == null ? -1 : (date.p = n, i);
  }
  var d3_time_amPmLookup = d3.map({
    am: 0,
    pm: 1
  });
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = ~~(Math.abs(z) / 60), zm = Math.abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  d3.time.format.utc = function(template) {
    var local = d3.time.format(template);
    function format(date) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time();
        utc._ = date;
        return local(utc);
      } finally {
        d3_time = Date;
      }
    }
    format.parse = function(string) {
      try {
        d3_time = d3_time_utc;
        var date = local.parse(string);
        return date && date._;
      } finally {
        d3_time = Date;
      }
    };
    format.toString = local.toString;
    return format;
  };
  var d3_time_formatIso = d3.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_time(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_time(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_time = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_time = Date;
      }
    };
  }
  d3.time.second = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3.time.seconds = d3.time.second.range;
  d3.time.seconds.utc = d3.time.second.utc.range;
  d3.time.minute = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3.time.minutes = d3.time.minute.range;
  d3.time.minutes.utc = d3.time.minute.utc.range;
  d3.time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3.time.hours = d3.time.hour.range;
  d3.time.hours.utc = d3.time.hour.utc.range;
  d3.time.day = d3_time_interval(function(date) {
    var day = new d3_time(1970, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3.time.days = d3.time.day.range;
  d3.time.days.utc = d3.time.day.utc.range;
  d3.time.dayOfYear = function(date) {
    var year = d3.time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  d3_time_daySymbols.forEach(function(day, i) {
    day = day.toLowerCase();
    i = 7 - i;
    var interval = d3.time[day] = d3_time_interval(function(date) {
      (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3.time[day + "s"] = interval.range;
    d3.time[day + "s"].utc = interval.utc.range;
    d3.time[day + "OfYear"] = function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3.time.week = d3.time.sunday;
  d3.time.weeks = d3.time.sunday.range;
  d3.time.weeks.utc = d3.time.sunday.utc.range;
  d3.time.weekOfYear = d3.time.sundayOfYear;
  d3.time.month = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3.time.months = d3.time.month.range;
  d3.time.months.utc = d3.time.month.utc.range;
  d3.time.year = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3.time.years = d3.time.year.range;
  d3.time.years.utc = d3.time.year.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_nice(scale.domain(), function() {
        return m;
      }));
    };
    scale.ticks = function(m, k) {
      var extent = d3_time_scaleExtent(scale.domain());
      if (typeof m !== "function") {
        var span = extent[1] - extent[0], target = span / m, i = d3.bisect(d3_time_scaleSteps, target);
        if (i == d3_time_scaleSteps.length) return methods.year(extent, m);
        if (!i) return linear.ticks(m).map(d3_time_scaleDate);
        if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;
        m = methods[i];
        k = m[1];
        m = m[0].range;
      }
      return m(extent[0], new Date(+extent[1] + 1), k);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_time_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  function d3_time_scaleFormat(formats) {
    return function(date) {
      var i = formats.length - 1, f = formats[i];
      while (!f[1](date)) f = formats[--i];
      return f[0](date);
    };
  }
  function d3_time_scaleSetYear(y) {
    var d = new Date(y, 0, 1);
    d.setFullYear(y);
    return d;
  }
  function d3_time_scaleGetYear(d) {
    var y = d.getFullYear(), d0 = d3_time_scaleSetYear(y), d1 = d3_time_scaleSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3.time.second, 1 ], [ d3.time.second, 5 ], [ d3.time.second, 15 ], [ d3.time.second, 30 ], [ d3.time.minute, 1 ], [ d3.time.minute, 5 ], [ d3.time.minute, 15 ], [ d3.time.minute, 30 ], [ d3.time.hour, 1 ], [ d3.time.hour, 3 ], [ d3.time.hour, 6 ], [ d3.time.hour, 12 ], [ d3.time.day, 1 ], [ d3.time.day, 2 ], [ d3.time.week, 1 ], [ d3.time.month, 1 ], [ d3.time.month, 3 ], [ d3.time.year, 1 ] ];
  var d3_time_scaleLocalFormats = [ [ d3.time.format("%Y"), d3_true ], [ d3.time.format("%B"), function(d) {
    return d.getMonth();
  } ], [ d3.time.format("%b %d"), function(d) {
    return d.getDate() != 1;
  } ], [ d3.time.format("%a %d"), function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ d3.time.format("%I %p"), function(d) {
    return d.getHours();
  } ], [ d3.time.format("%I:%M"), function(d) {
    return d.getMinutes();
  } ], [ d3.time.format(":%S"), function(d) {
    return d.getSeconds();
  } ], [ d3.time.format(".%L"), function(d) {
    return d.getMilliseconds();
  } ] ];
  var d3_time_scaleLinear = d3.scale.linear(), d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);
  d3_time_scaleLocalMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);
  };
  d3.time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUTCFormats = [ [ d3.time.format.utc("%Y"), d3_true ], [ d3.time.format.utc("%B"), function(d) {
    return d.getUTCMonth();
  } ], [ d3.time.format.utc("%b %d"), function(d) {
    return d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%a %d"), function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%I %p"), function(d) {
    return d.getUTCHours();
  } ], [ d3.time.format.utc("%I:%M"), function(d) {
    return d.getUTCMinutes();
  } ], [ d3.time.format.utc(":%S"), function(d) {
    return d.getUTCSeconds();
  } ], [ d3.time.format.utc(".%L"), function(d) {
    return d.getUTCMilliseconds();
  } ] ];
  var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);
  function d3_time_scaleUTCSetYear(y) {
    var d = new Date(Date.UTC(y, 0, 1));
    d.setUTCFullYear(y);
    return d;
  }
  function d3_time_scaleUTCGetYear(d) {
    var y = d.getUTCFullYear(), d0 = d3_time_scaleUTCSetYear(y), d1 = d3_time_scaleUTCSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  d3_time_scaleUTCMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);
  };
  d3.time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
  };
  return d3;
}();
</script>
<script>
// Define functions to render linked interactive plots using d3.
// Another script should define e.g.
// <script>
//   var plot = new animint("#plot","path/to/plot.json");
// </script>
// Constructor for animint Object.
var animint = function (to_select, json_file) {
  var steps = [];
  var default_axis_px = 16;

   function wait_until_then(timeout, condFun, readyFun) {
    var args=arguments
    function checkFun() {
      if(condFun()) {
        readyFun(args[3],args[4]);
      } else{
        setTimeout(checkFun, timeout);
      }
    }
    checkFun();
  }

  function convert_R_types(resp_array, types){
    return resp_array.map(function (d) {
      for (var v_name in d) {
      	if(!is_interactive_aes(v_name)){
          var r_type = types[v_name];
          if (r_type == "integer") {
            d[v_name] = parseInt(d[v_name]);
          } else if (r_type == "numeric") {
            d[v_name] = parseFloat(d[v_name]);
          } else if (r_type == "factor" || r_type == "rgb" 
		     || r_type == "linetype" || r_type == "label" 
		     || r_type == "character") {
            // keep it as a character
          } else if (r_type == "character" & v_name == "outliers") {
            d[v_name] = parseFloat(d[v_name].split(" @ "));
          } 
      	}
      }
      return d;
    });
  }

  // replacing periods in variable with an underscore this makes sure
  // that selector doesn't confuse . in name with css selectors
  function safe_name(unsafe_name){
    return unsafe_name.replace(/[ .]/g, '_');
  }
  function legend_class_name(selector_name){
    return safe_name(selector_name) + "_variable";
  }

  function is_interactive_aes(v_name){
    if(v_name.indexOf("clickSelects") > -1){
      return true;
    }
    if(v_name.indexOf("showSelected") > -1){
      return true;
    }
    return false;
  }

  var linetypesize2dasharray = function (lt, size) {
    var isInt = function(n) {
      return typeof n === 'number' && parseFloat(n) == parseInt(n, 10) && !isNaN(n);
    };
    if(isInt(lt)){ // R integer line types.
      if(lt == 1){
        return null;
      }
      var o = {
        0: size * 0 + "," + size * 10,
        2: size * 4 + "," + size * 4,
        3: size + "," + size * 2,
        4: size + "," + size * 2 + "," + size * 4 + "," + size * 2,
        5: size * 8 + "," + size * 4,
        6: size * 2 + "," + size * 2 + "," + size * 6 + "," + size * 2
      };
    } else { // R defined line types
      if(lt == "solid" || lt === null){
        return null;
      }
      var o = {
        "blank": size * 0 + "," + size * 10,
        "none": size * 0 + "," + size * 10,
        "dashed": size * 4 + "," + size * 4,
        "dotted": size + "," + size * 2,
        "dotdash": size + "," + size * 2 + "," + size * 4 + "," + size * 2,
        "longdash": size * 8 + "," + size * 4,
        "twodash": size * 2 + "," + size * 2 + "," + size * 6 + "," + size * 2,
        "22": size * 2 + "," + size * 2,
        "42": size * 4 + "," + size * 2,
        "44": size * 4 + "," + size * 4,"13": size + "," + size * 3,
        "1343": size + "," + size * 3 + "," + size * 4 + "," + size * 3,
        "73": size * 7 + "," + size * 3,
        "2262": size * 2 + "," + size * 2 + "," + size * 6 + "," + size * 2,
        "12223242": size + "," + size * 2 + "," + size * 2 + "," + size * 2 + "," + size * 3 + "," + size * 2 + "," + size * 4 + "," + size * 2,
        "F282": size * 15 + "," + size * 2 + "," + size * 8 + "," + size * 2,
        "F4448444": size * 15 + "," + size * 4 + "," + size * 4 + "," + size * 4 + "," + size * 8 + "," + size * 4 + "," + size * 4 + "," + size * 4,
        "224282F2": size * 2 + "," + size * 2 + "," + size * 4 + "," + size * 2 + "," + size * 8 + "," + size * 2 + "," + size * 16 + "," + size * 2,
        "F1": size * 16 + "," + size
      };
    }

    if (lt in o){
      return o[lt];
    } else{ // manually specified line types
      str = lt.split("");
      strnum = str.map(function (d) {
        return size * parseInt(d, 16);
      });
      return strnum;
    }
  };

  var isArray = function(o) {
    return Object.prototype.toString.call(o) === '[object Array]';
  };

  // create a dummy element, apply the appropriate classes,
  // and then measure the element
  // Inspired from http://jsfiddle.net/uzddx/2/
  var measureText = function(pText, pFontSize, pAngle, pStyle) {
    if (!pText || pText.length === 0) return {height: 0, width: 0};
    if (pAngle === null || isNaN(pAngle)) pAngle = 0;

    var container = element.append('svg');
    // do we need to set the class so that styling is applied?
    //.attr('class', classname);

    container.append('text')
      .attr({x: -1000, y: -1000})
      .attr("transform", "rotate(" + pAngle + ")")
      .attr("style", pStyle)
      .attr("font-size", pFontSize)
      .text(pText);

    var bbox = container.node().getBBox();
    container.remove();

    return {height: bbox.height, width: bbox.width};
  };

  var nest_by_group = d3.nest().key(function(d){ return d.group; });
  var dirs = json_file.split("/");
  dirs.pop(); //if a directory path exists, remove the JSON file from dirs
  var element = d3.select(to_select);
  this.element = element;
  var viz_id = element.attr("id");
  var plot_widget_table = element.append("table");
  var plot_td = plot_widget_table.append("tr").append("td");
  plot_td.attr("class","plot_content");
  var widget_td = plot_widget_table.append("tr").append("td");
  var Widgets = {};
  this.Widgets = Widgets;
  var Selectors = {};
  this.Selectors = Selectors;
  var Plots = {};
  this.Plots = Plots;
  var Geoms = {};
  this.Geoms = Geoms;
  // SVGs must be stored separately from Geoms since they are
  // initialized first, with the Plots.
  var SVGs = {};
  this.SVGs = SVGs;
  var Animation = {};
  this.Animation = Animation;
  var all_geom_names = {};
  this.all_geom_names = all_geom_names;

  //creating an array to contain the selectize widgets
  var selectized_array = [];
  var data_object_geoms = {
    "line":true,
    "path":true,
    "ribbon":true,
    "polygon":true
  };
  var css = document.createElement('style');
  css.type = 'text/css';
  var styles = [".axis path{fill: none;stroke: black;shape-rendering: crispEdges;}",
            ".axis line{fill: none;stroke: black;shape-rendering: crispEdges;}",
            ".axis text {font-family: sans-serif;font-size: 11px;}"];

  var add_geom = function (g_name, g_info) {
    // Determine if data will be an object or an array.
    // added geom properties in steps array
    var geom = g_info.classed;
    var title = g_info.params.title || g_info.classed;
    var helpText = g_info.params.help || '';
    var help_showSelected = g_info.params.help_showSelected || '';
    var help_clickSelects = g_info.params.help_clickSelects || '';
    var description = helpText;
    if(g_info.params.hasOwnProperty("showSelected")){
      if(description != "")description += '<br>';
      description += 'Data are shown for the current selection of: ' + help_showSelected;
    }
    if(g_info.params.hasOwnProperty("clickSelects")){
      if(description != "")description += '<br>';
      description += 'Click to select: ' + help_clickSelects;
    }
    if(description == ""){
      description = "No interactions available";
    }
    steps.push({  // this add the geom to the steps array for guided tour
      element: '#' + viz_id + ' .' + geom,
      popover: {
        title: title,
        description: description
      }
    });
    if(g_info.geom in data_object_geoms){
      g_info.data_is_object = true;
    }else{
      g_info.data_is_object = false;
    }
    // Add a row to the loading table.
    g_info.tr = Widgets["loading"].append("tr");
    g_info.tr.append("td").text(g_name);
    g_info.tr.append("td").attr("class", "chunk");
    g_info.tr.append("td").attr("class", "downloaded").text(0);
    g_info.tr.append("td").text(g_info.total);
    g_info.tr.append("td").attr("class", "status").text("initialized");

    // load chunk tsv
    g_info.data = {};
    g_info.download_status = {};
    Geoms[g_name] = g_info;
    // Determine whether common chunk tsv exists
    // If yes, load it
    if(g_info.hasOwnProperty("columns") && g_info.columns.common){
      var common_tsv = get_tsv(g_info, "_common");
      g_info.common_tsv = common_tsv;
      var common_path = getTSVpath(common_tsv);
      d3.tsv(common_path, function (error, response) {
        var converted = convert_R_types(response, g_info.types);
        g_info.data[common_tsv] = nest_by_group.map(converted);
      });
    } else {
      g_info.common_tsv = null;
    }
    // Save this geom and load it!
    update_geom(g_name, null);
  };
  var add_plot = function (p_name, p_info) {
    // Each plot may have one or more legends. To make space for the
    // legends, we put each plot in a table with one row and two
    // columns: tdLeft and tdRight.
    var plot_table = plot_td.append("table").style("display", "inline-block");
    var plot_tr = plot_table.append("tr");
    var tdLeft = plot_tr.append("td");
    var tdRight = plot_tr.append("td").attr("class", p_name+"_legend");
    if(viz_id === null){
      p_info.plot_id = p_name;
    }else{
      p_info.plot_id = viz_id + "_" + p_name;
    }
    var svg = tdLeft.append("svg")
      .attr("id", p_info.plot_id)
      .attr("height", p_info.options.height)
      .attr("width", p_info.options.width);

    // divvy up width/height based on the panel layout
    var nrows = Math.max.apply(null, p_info.layout.ROW);
    var ncols = Math.max.apply(null, p_info.layout.COL);
    var panel_names = p_info.layout.PANEL;
    var npanels = Math.max.apply(null, panel_names);

    // Note axis names are "shared" across panels (just like the title)
    var xtitlepadding = 5 + measureText(p_info["xtitle"], default_axis_px).height;
    var ytitlepadding = 5 + measureText(p_info["ytitle"], default_axis_px).height;

    // 'margins' are fixed across panels and do not
    // include title/axis/label padding (since these are not
    // fixed across panels). They do, however, account for
    // spacing between panels
    var text_height_pixels = measureText("foo", 11).height;
    var margin = {
      left: 0,
      right: text_height_pixels * p_info.panel_margin_lines,
      top: text_height_pixels * p_info.panel_margin_lines,
      bottom: 0
    };
    var plotdim = {
      width: 0,
      height: 0,
      xstart: 0,
      xend: 0,
      ystart: 0,
      yend: 0,
      graph: {
	width: 0,
	height: 0
      },
      margin: margin,
      xlab: {
	x: 0,
	y: 0
      },
      ylab: {
	x: 0,
	y: 0
      },
      title: {
	x: 0,
	y: 0
      }
    };

    // Draw the title
    var titlepadding = measureText(p_info.title, p_info.title_size).height;
    // why are we giving the title padding if it is undefined?
    if (p_info.title === undefined) titlepadding = 0;
    plotdim.title.x = p_info.options.width / 2;
    plotdim.title.y = titlepadding;
    svg.append("text")
      .text(p_info.title)
      .attr("class", "plottitle")
      .attr("font-family", "sans-serif")
      .attr("font-size", p_info.title_size)
      .attr("transform", "translate(" + plotdim.title.x + "," + 
        plotdim.title.y + ")")
      .style("text-anchor", "middle");

    // grab max text size over axis labels and facet strip labels
    var axispaddingy = 5;
    if(p_info.hasOwnProperty("ylabs") && p_info.ylabs.length){
      axispaddingy += Math.max.apply(null, p_info.ylabs.map(function(entry){
	// + 5 to give a little extra space to avoid bad axis labels
	// in shiny.
	return measureText(entry, p_info.ysize).width + 5;
      }));
    }
    var axispaddingx = 30; // distance between tick marks and x axis name.
    if(p_info.hasOwnProperty("xlabs") && p_info.xlabs.length){
      // TODO: throw warning if text height is large portion of plot height?
      axispaddingx += Math.max.apply(null, p_info.xlabs.map(function(entry){
	     return measureText(entry, p_info.xsize, p_info.xangle).height;
      }));
      // TODO: carefully calculating this gets complicated with rotating xlabs
      //margin.right += 5;
    }
    plotdim.margin = margin;
    
    var strip_heights = p_info.strips.top.map(function(entry){ 
      return measureText(entry, p_info.strip_text_xsize).height;
    });
    var strip_widths = p_info.strips.right.map(function(entry){ 
      return measureText(entry, p_info.strip_text_ysize).height; 
    });

    // compute the number of x/y axes, max strip height per row, and
    // max strip width per columns, for calculating height/width of
    // graphing region.
    var row_strip_heights = [];
    var col_strip_widths = [];
    var n_xaxes = 0;
    var n_yaxes = 0;
    var current_row, current_col;
    for (var layout_i = 0; layout_i < npanels; layout_i++) {
      current_row = p_info.layout.ROW[layout_i] - 1;
      current_col = p_info.layout.COL[layout_i] - 1;
      if(row_strip_heights[current_row] === undefined){
	row_strip_heights[current_row] = [];
      }
      if(col_strip_widths[current_col] === undefined){
	col_strip_widths[current_col] = [];
      }
      row_strip_heights[current_row].push(strip_heights[layout_i]);
      col_strip_widths[current_col].push(strip_widths[layout_i]);
      if (p_info.layout.COL[layout_i] == 1) {
	n_xaxes += p_info.layout.AXIS_X[layout_i];
      }
      if (p_info.layout.ROW[layout_i] == 1) {
	n_yaxes += p_info.layout.AXIS_Y[layout_i];
      }
    }
    function cumsum_array(array_of_arrays){
      var cumsum = [], max_value, cumsum_value = 0;
      for(var i=0; i<array_of_arrays.length; i++){
	cumsum_value += d3.max(array_of_arrays[i]);
	cumsum[i] = cumsum_value;
      }
      return cumsum;
    }
    var cum_height_per_row = cumsum_array(row_strip_heights);
    var cum_width_per_col = cumsum_array(col_strip_widths);
    var strip_width = d3.max(cum_width_per_col);
    var strip_height = d3.max(cum_height_per_row);

    // the *entire graph* height/width
    var graph_width = p_info.options.width - 
        ncols * (margin.left + margin.right) -
	strip_width -
        n_yaxes * axispaddingy - ytitlepadding;
    var graph_height = p_info.options.height - 
        nrows * (margin.top + margin.bottom) -
	strip_height -
        titlepadding - n_xaxes * axispaddingx - xtitlepadding;

    // Impose the pixelated aspect ratio of the graph upon the width/height
    // proportions calculated by the compiler. This has to be done on the
    // rendering side since the precomputed proportions apply to the *graph*
    // and the graph size depends upon results of measureText()
    if (p_info.layout.coord_fixed[0]) {
      var aspect = (graph_height / nrows) / (graph_width / ncols);
    } else {
      var aspect = 1;
    }
    var wp = p_info.layout.width_proportion.map(function(x){
      return x * Math.min(1, aspect);
    })
    var hp = p_info.layout.height_proportion.map(function(x){
      return x * Math.min(1, 1/aspect);
    })

    // track the proportion of the graph that should be 'blank'
    // this is mainly used to implement coord_fixed()
    var graph_height_blank = 1;
    var graph_width_blank = 1;
    for (var layout_i = 0; layout_i < npanels; layout_i++) {
      if (p_info.layout.COL[layout_i] == 1) graph_height_blank -= hp[layout_i];
      if (p_info.layout.ROW[layout_i] == 1) graph_width_blank -= wp[layout_i];
    }
    // cumulative portion of the graph used
    var graph_width_cum = (graph_width_blank / 2) * graph_width;
    var graph_height_cum = (graph_height_blank / 2) * graph_height;

    // Bind plot data to this plot's SVG element
    svg.plot = p_info;
    Plots[p_name] = p_info;
    p_info.geoms.forEach(function (g_name) {
      var layer_g_element = svg.append("g").attr("class", g_name);
      panel_names.forEach(function(PANEL){
        layer_g_element.append("g").attr("class", "PANEL" + PANEL);
      });
      SVGs[g_name] = svg;
    });

    // create a grouping for strip labels (even if there are none).
    var topStrip = svg.append("g")
      .attr("class", "topStrip")
    ;
    var rightStrip = svg.append("g")
      .attr("class", "rightStrip")
    ;

    // this will hold x/y scales for each panel
    // eventually we inject this into Plots[p_name]
    var scales = {};
    n_xaxes = 0;
    n_yaxes = 0;
    // Draw a plot outline for every panel
    for (var layout_i = 0; layout_i < npanels; layout_i++) {
      var panel_i = layout_i + 1;
      var axis  = p_info["axis" + panel_i];

      //forces values to be in an array
      var xaxisvals = [];
      var xaxislabs = [];
      var yaxisvals = [];
      var yaxislabs = [];
      var outbreaks, outlabs;

      //function to write labels and breaks to their respective arrays
      var axislabs = function(breaks, labs, axis){
        if(axis=="x"){
          outbreaks = xaxisvals;
          outlabs = xaxislabs;
        } else {
          outbreaks = yaxisvals;
          outlabs = yaxislabs;
        } // set appropriate variable names
        if (isArray(breaks)) {
          breaks.forEach(function (d) {
            outbreaks.push(d);
          })
        } else {
          //breaks can be an object!
          for (key in breaks) {
            outbreaks.push(breaks[key]);
          }
        }
        if (labs){
          labs.forEach(function (d) {
            outlabs.push(d);
            // push each label provided into the array
          });
        } else {
          outbreaks.forEach(function (d) {
            outlabs.push("");
            // push a blank string to the array for each axis tick
            // if the specified label is null
          });
        }
      };

      if(axis["xticks"]){
	axislabs(axis.x, axis.xlab, "x");
      }
      if(axis["yticks"]){
	axislabs(axis.y, axis.ylab, "y");
      }

      // compute the current panel height/width
      plotdim.graph.height = graph_height * hp[layout_i];
      plotdim.graph.width = graph_width * wp[layout_i];

      current_row = p_info.layout.ROW[layout_i];
      current_col = p_info.layout.COL[layout_i];
      var draw_x = p_info.layout.AXIS_X[layout_i];
      var draw_y = p_info.layout.AXIS_Y[layout_i];
      // panels are drawn using a "typewriter approach" (left to right
      // & top to bottom) if the carriage is returned (ie, there is a
      // new row), change some parameters:
      var new_row = current_col <= p_info.layout.COL[layout_i - 1]
      if (new_row) {
	n_yaxes = 0;
	graph_width_cum = (graph_width_blank / 2) * graph_width;
	graph_height_cum += graph_height * hp[layout_i-1];
      }
      n_xaxes += draw_x;
      n_yaxes += draw_y;

      // calculate panel specific locations to be used in placing
      // axes, labels, etc.
      plotdim.xstart =  current_col * plotdim.margin.left +
        (current_col - 1) * plotdim.margin.right +
        graph_width_cum + n_yaxes * axispaddingy + ytitlepadding;
      // room for right strips should be distributed evenly across
      // panels to preserve aspect ratio
      plotdim.xend = plotdim.xstart + plotdim.graph.width;
      // total height of strips drawn thus far
      var strip_h = cum_height_per_row[current_row-1];
      plotdim.ystart = current_row * plotdim.margin.top +
        (current_row - 1) * plotdim.margin.bottom +
        graph_height_cum + titlepadding + strip_h;
      // room for xaxis title should be distributed evenly across
      // panels to preserve aspect ratio
      plotdim.yend = plotdim.ystart + plotdim.graph.height;
      // always add to the width (note it may have been reset earlier)
      graph_width_cum = graph_width_cum + plotdim.graph.width;

      // get the x position of the y-axis title (and add padding) when
      // rendering the first plot.
      if (layout_i === 0) {
	var ytitle_x = (plotdim.xstart - axispaddingy - ytitlepadding / 2);
	var xtitle_left = plotdim.xstart;
	var ytitle_top = plotdim.ystart;
      }
      // get the y position of the x-axis title when drawing the last
      // panel.
      if (layout_i === (npanels - 1)) {
	var xtitle_y = (plotdim.yend + axispaddingx);
	var xtitle_right = plotdim.xend;
	var ytitle_bottom = plotdim.yend;
      }

      var draw_strip = function(strip, side) {
        if (strip == "") {
          return(null);
        }
        var x, y, rotate, stripElement, strip_text_xy;
        if (side == "right") {
          x = plotdim.xend;
          y = (plotdim.ystart + plotdim.yend) / 2;
          rotate = 90;
	  stripElement = rightStrip;
          strip_text_xy = "y";
        }else{ //top
	  x = (plotdim.xstart + plotdim.xend) / 2;
          y = plotdim.ystart;
	  rotate = 0;
	  stripElement = topStrip;
          strip_text_xy = "x";
	}
	var trans_text = "translate(" + x + "," + y + ")";
	var rot_text = "rotate(" + rotate + ")";
        var strip_text_size = "strip_text_"+strip_text_xy+"size";
	stripElement
          .selectAll("." + side + "Strips")
          .data(strip)
          .enter()
          .append("text")
          .style("text-anchor", "middle")
          .style("font-size", p_info[strip_text_size])
          .text(function(d) { return d; })
        // NOTE: there could be multiple strips per panel
        // TODO: is there a better way to manage spacing?
          .attr("transform", trans_text + rot_text)
	;
      }
      draw_strip([p_info.strips.top[layout_i]], "top");
      draw_strip([p_info.strips.right[layout_i]], "right");

      // for each of the x and y axes, there is a "real" and fake
      // version. The real version will be used for plotting the
      // data, and the fake version is just for the display of the
      // axes.
      scales[panel_i] = {};
      scales[panel_i].x = d3.scale.linear()
        .domain(axis.xrange)
        .range([plotdim.xstart, plotdim.xend]);
      scales[panel_i].y = d3.scale.linear()
        .domain(axis.yrange)
        .range([plotdim.yend, plotdim.ystart]);
      if(draw_x){
        var xaxis = d3.svg.axis()
          .scale(scales[panel_i].x)
          .tickValues(xaxisvals)
          .tickFormat(function (d) {
            return xaxislabs[xaxisvals.indexOf(d)].toString();
          })
          .orient("bottom")
	;
  var axis_panel = "xaxis" + "_" + panel_i;
	var xaxis_g = svg.append("g")
          .attr("class", "xaxis axis " + axis_panel)
          .attr("transform", "translate(0," + plotdim.yend + ")")
          .call(xaxis);
	if(axis["xline"] == false){
	  var axis_path = xaxis_g.select("path.domain");
	  axis_path.remove();
	}
	xaxis_g.selectAll("text")
	  .style("text-anchor", p_info.xanchor)
	  .style("font-size", p_info.xsize)
	  .attr("transform", "rotate(" + p_info.xangle + " 0 9)");
      }
      if(draw_y){
	var yaxis = d3.svg.axis()
          .scale(scales[panel_i].y)
          .tickValues(yaxisvals)
          .tickFormat(function (d) {
            return yaxislabs[yaxisvals.indexOf(d)].toString();
          })
          .orient("left");
  var axis_panel = "yaxis" + "_" + panel_i;
	var yaxis_g = svg.append("g")
          .attr("class", "yaxis axis " + axis_panel)
          .attr("transform", "translate(" + (plotdim.xstart) + ",0)")
          .call(yaxis);
	if(axis["yline"] == false){
	  var axis_path = yaxis_g.select("path.domain");
	  axis_path.remove();
	}
  yaxis_g.selectAll(".tick text")
    .style("font-size", p_info.ysize);
      }

      if(!axis.xline) {
    	styles.push("#"+p_name+" #xaxis"+" path{stroke:none;}");
      }
      if(!axis.xticks) {
    	styles.push("#"+p_name+" #xaxis .tick"+" line{stroke:none;}");
      }
      if(!axis.yline) {
    	styles.push("#"+p_name+" #yaxis"+" path{stroke:none;}");
      }
      if(!axis.yticks) {
    	styles.push("#"+p_name+" #yaxis .tick"+" line{stroke:none;}");
      }
      
      // creating g element for background, grid lines, and border
      // uses insert to draw it right before plot title
      var background = svg.insert("g", ".plottitle")
        .attr("class", "background bgr" + panel_i);
      
      // drawing background
      if(Object.keys(p_info.panel_background).length > 1) {
        background.append("rect")
          .attr("x", plotdim.xstart)
          .attr("y", plotdim.ystart)
          .attr("width", plotdim.xend - plotdim.xstart)
          .attr("height", plotdim.yend - plotdim.ystart)
          .attr("class", "background_rect")
          .style("fill", p_info.panel_background.fill)
          .style("stroke", p_info.panel_background.colour)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(p_info.panel_background.linetype,
                                          p_info.panel_background.size);
          });
      }
      
      // drawing the grid lines
      ["grid_minor", "grid_major"].forEach(function(grid_class){
	var grid_background = p_info[grid_class];
        // if grid lines are defined
        if(grid_background.hasOwnProperty("size")) {
          var grid = background.append("g")
              .attr("class", grid_class);
	  ["x","y"].forEach(function(scale_var){
	    var const_var;
	    if(scale_var == "x"){
	      const_var = "y";
	    }else{
	      const_var = "x";
	    }
            grid.append("g")
              .attr("class", scale_var)
              .selectAll("line")
              .data(grid_background.loc[scale_var][layout_i])
              .enter()
              .append("line")
              .attr(const_var + "1", plotdim[const_var + "start"])
              .attr(const_var + "2", plotdim[const_var + "end"])
              .attr(scale_var + "1", function(d) {
		return scales[panel_i][scale_var](d);
	      })
              .attr(scale_var + "2", function(d) {
		return scales[panel_i][scale_var](d);
	      })
              .style("stroke", grid_background.colour)
              .style("stroke-linecap", grid_background.lineend)
              .style("stroke-width", grid_background.size)
              .style("stroke-dasharray", linetypesize2dasharray(
		grid_background.linetype, grid_background.size))
	    ;
	  });
	}
      });
      
      // drawing border
      // uses insert to draw it right before the #plottitle
      if(Object.keys(p_info.panel_border).length > 1) {
        background.append("rect")
          .attr("x", plotdim.xstart)
          .attr("y", plotdim.ystart)
          .attr("width", plotdim.xend - plotdim.xstart)
          .attr("height", plotdim.yend - plotdim.ystart)
          .attr("class", "border_rect")
          .style("fill", p_info.panel_border.fill)
          .style("stroke", p_info.panel_border.colour)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(p_info.panel_border.linetype,
                                          p_info.panel_border.size);
          });
      }

    } //end of for(layout_i
    // After drawing all backgrounds, we can draw the axis labels.
    if(p_info["ytitle"]){
      svg.append("text")
	.text(p_info["ytitle"])
	.attr("class", "ytitle")
	.style("text-anchor", "middle")
	.style("font-size", default_axis_px + "px")
	.attr("transform", "translate(" + 
	      ytitle_x +
	      "," +
	      (ytitle_top + ytitle_bottom)/2 + 
	      ")rotate(270)")
      ;
    }
    if(p_info["xtitle"]){
      svg.append("text")
	.text(p_info["xtitle"])
	.attr("class", "xtitle")
	.style("text-anchor", "middle")
	.style("font-size", default_axis_px + "px")
	.attr("transform", "translate(" + 
	      (xtitle_left + xtitle_right)/2 +
	      "," + 
	      xtitle_y + 
	      ")")
      ;
    }
    Plots[p_name].scales = scales;
  }; //end of add_plot()

  function update_legend_opacity(v_name){
    var s_info = Selectors[v_name];
    s_info.legend_tds.style("opacity", s_info.legend_update_fun);
  }

  var add_selector = function (s_name, s_info) {
    Selectors[s_name] = s_info;
    if(s_info.type == "multiple"){
      if(!isArray(s_info.selected)){
        s_info.selected = [s_info.selected];
      }
      // legend_update_fun is evaluated in the context of the
      // td.legend_entry_label.
      s_info.legend_update_fun = function(d){
	var i_value = s_info.selected.indexOf(this.textContent);
	if(i_value == -1){
	  return 0.5;
	}else{
	  return 1;
	}
      }
    }else{
      s_info.legend_update_fun = function(d){
	if(this.textContent == s_info.selected){
	  return 1;
	}else{
	  return 0.5;
	}
      }
    }
    s_info.legend_tds = 
      element.selectAll("tr."+legend_class_name(s_name)+" td.legend_entry_label")
    ;
    update_legend_opacity(s_name);
  }; //end of add_selector()

  function get_tsv(g_info, chunk_id){
    return g_info.classed + "_chunk" + chunk_id + ".tsv";
  }
  function getTSVpath(tsv_name){
    return dirs.concat(tsv_name).join("/");
  }
  
  /**
   * copy common chunk tsv to varied chunk tsv, returning an array of
   * objects.
  */
  function copy_chunk(g_info, varied_chunk) {
    var varied_by_group = nest_by_group.map(varied_chunk);
    var common_by_group = g_info.data[g_info.common_tsv];
    var new_varied_chunk = [];
    for(group_id in varied_by_group){
      var varied_one_group = varied_by_group[group_id];
      var common_one_group = common_by_group[group_id];
      var common_i = 0;
      for(var varied_i=0; varied_i < varied_one_group.length; varied_i++){
	// there are two cases: each group of varied data is of length
	// 1, or of length of the common data.
	if(common_one_group.length == varied_one_group.length){
	  common_i = varied_i;
	}
	var varied_obj = varied_one_group[varied_i];
	var common_obj = common_one_group[common_i];
	for(col in common_obj){
	  if(col != "group"){
	    varied_obj[col] = common_obj[col];
	  }
	}
	new_varied_chunk.push(varied_obj);
      }
    }
    return new_varied_chunk;
  }

  // update_geom is called from add_geom and update_selector. It
  // downloads data if necessary, and then calls draw_geom.
  var update_geom = function (g_name, selector_name) {
    var g_info = Geoms[g_name];
    // First apply chunk_order selector variables.
    var chunk_id = g_info.chunks;
    g_info.chunk_order.forEach(function (v_name) {
      if(chunk_id == null){
        return; // no data in a higher up chunk var.
      }
      var value = Selectors[v_name].selected;
      if(chunk_id.hasOwnProperty(value)){
	       chunk_id = chunk_id[value];
      }else{
	       chunk_id = null; // no data to show in this subset.
      }
    });
    if(chunk_id == null){
      draw_panels(g_info, [], selector_name); //draw nothing.
      return;
    }
    var tsv_name = get_tsv(g_info, chunk_id);
    // get the data if it has not yet been downloaded.
    g_info.tr.select("td.chunk").text(tsv_name);
    if(g_info.data.hasOwnProperty(tsv_name)){
      draw_panels(g_info, g_info.data[tsv_name], selector_name);
    }else{
      g_info.tr.select("td.status").text("downloading");
      var svg = SVGs[g_name];
      var loading = svg.append("text")
        .attr("class", "loading"+tsv_name)
	      .text("Downloading "+tsv_name+"...")
	      .attr("font-size", 9)
	      //.attr("x", svg.attr("width")/2)
        .attr("y", 10)
        .style("fill", "red");
      download_chunk(g_info, tsv_name, function(chunk){
      	loading.remove();
	draw_panels(g_info, chunk, selector_name);
      });
    }
  };
  var draw_panels = function(g_info, chunk, selector_name) {
    // derive the plot name from the geometry name
    var g_names = g_info.classed.split("_");
    var p_name = g_names[g_names.length - 1];
    var panels = Plots[p_name].layout.PANEL;
    panels.forEach(function(panel) {
      draw_geom(g_info, chunk, selector_name, panel);
    });
  };

  function download_next(g_name){
    var g_info = Geoms[g_name];
    var selector_value = Animation.sequence[g_info.seq_i];
    var chunk_id = g_info.chunks[selector_value];
    var tsv_name = get_tsv(g_info, chunk_id);
    g_info.seq_count += 1;
    if(Animation.sequence.length == g_info.seq_count){
      Animation.done_geoms[g_name] = 1;
      return;
    }
    g_info.seq_i += 1;
    if(g_info.seq_i == Animation.sequence.length){
      g_info.seq_i = 0;
    }
    if(typeof(chunk_id) == "string"){
      download_chunk(g_info, tsv_name, function(chunk){
	download_next(g_name);
      })
    }else{
      download_next(g_name);
    }
  }

  // download_chunk is called from update_geom and download_next.
  function download_chunk(g_info, tsv_name, funAfter){
    if(g_info.download_status.hasOwnProperty(tsv_name)){
      var chunk;
      if(g_info.data_is_object){
	chunk = {};
      }else{
	chunk = [];
      }
      funAfter(chunk);
      return; // do not download twice.
    }
    g_info.download_status[tsv_name] = "downloading";
    // prefix tsv file with appropriate path
    var tsv_file = getTSVpath(tsv_name);
    d3.tsv(tsv_file, function (error, response) {
      // First convert to correct types.
      g_info.download_status[tsv_name] = "processing";
      response = convert_R_types(response, g_info.types);
      wait_until_then(500, function(){
	if(g_info.common_tsv) {
          return g_info.data.hasOwnProperty(g_info.common_tsv);
	}else{
	  return true;
	}
      }, function(){
	if(g_info.common_tsv) {
          // copy data from common tsv to varied tsv
          response = copy_chunk(g_info, response);
	}
	var nest = d3.nest();
	g_info.nest_order.forEach(function (v_name) {
          nest.key(function (d) {
            return d[v_name];
          });
	});
	var chunk = nest.map(response);
	g_info.data[tsv_name] = chunk;
	g_info.tr.select("td.downloaded").text(d3.keys(g_info.data).length);
	g_info.download_status[tsv_name] = "saved";
	funAfter(chunk);
      });
    });
  }//download_chunk.

  // update_geom is responsible for obtaining a chunk of downloaded
  // data, and then calling draw_geom to actually draw it.
  var draw_geom = function(g_info, chunk, selector_name, PANEL){
    g_info.tr.select("td.status").text("displayed");
    var svg = SVGs[g_info.classed];
    // derive the plot name from the geometry name
    var g_names = g_info.classed.split("_");
    var p_name = g_names[g_names.length - 1];
    var scales = Plots[p_name].scales[PANEL];
    var selected_arrays = [ [] ]; //double array necessary.
    var has_clickSelects = g_info.aes.hasOwnProperty("clickSelects");
    var has_clickSelects_variable =
      g_info.aes.hasOwnProperty("clickSelects.variable");
    g_info.subset_order.forEach(function (aes_name) {
      var selected, values;
      var new_arrays = [];
      if(0 < aes_name.indexOf(".variable")){ 
	selected_arrays.forEach(function(old_array){
	  var some_data = chunk;
	  old_array.forEach(function(value){
            if(some_data.hasOwnProperty(value)) {
              some_data = some_data[value];
            } else {
              some_data = {};
            }
	  })
	  values = d3.keys(some_data);
	  values.forEach(function(s_name){
	    var selected = Selectors[s_name].selected;
	    var new_array = old_array.concat(s_name).concat(selected);
	    new_arrays.push(new_array);
	  })
	})
      }else{//not .variable aes:
	if(aes_name == "PANEL"){
	  selected = PANEL;
	}else{
          var s_name = g_info.aes[aes_name];
          selected = Selectors[s_name].selected;
	}
	if(isArray(selected)){ 
	  values = selected; //multiple selection.
	}else{
	  values = [selected]; //single selection.
	}
	values.forEach(function(value){
	  selected_arrays.forEach(function(old_array){
	    var new_array = old_array.concat(value);
	    new_arrays.push(new_array);
	  })
	})
      }
      selected_arrays = new_arrays;
    });
    // data can be either an array[] if it will be directly involved
    // in a data-bind, or an object{} if it will be involved in a
    // data-bind by group (e.g. geom_line).
    var data;
    if(g_info.data_is_object){
      data = {};
    }else{
      data = [];
    }
    selected_arrays.forEach(function(value_array){
      var some_data = chunk;
      value_array.forEach(function(value){
        if (some_data.hasOwnProperty(value)) {
          some_data = some_data[value];
        } else {
	  if(g_info.data_is_object){
	    some_data = {};
	  }else{
            some_data = [];
	  }
        }
      });
      if(g_info.data_is_object){
	if(isArray(some_data) && some_data.length){
	  data["0"] = some_data;
	}else{
	  for(k in some_data){
            data[k] = some_data[k];
          }
	}
      }else{//some_data is an array.
        data = data.concat(some_data);
      }
    });
    var aes = g_info.aes;
    var toXY = function (xy, a) {
      return function (d) {
        return scales[xy](d[a]);
      };
    };
    var layer_g_element = svg.select("g." + g_info.classed);
    var panel_g_element = layer_g_element.select("g.PANEL" + PANEL);
    var elements = panel_g_element.selectAll(".geom");

    // helper functions so we can write code that works for both
    // grouped and ungrouped geoms. get_one_row returns one row of
    // data (not one group), in both cases.
    var get_fun = function(fun){
      return function(input){
	var d = get_one_row(input);
	return fun(d);
      };
    };
    var get_attr = function(attr_name){
      return get_fun(function(d){
	return d[attr_name];
      });
    };

    var size = 2;
    var get_size;
    if(aes.hasOwnProperty("size")){
      get_size = get_attr("size");
    }else{
      get_size = function(d){
	return size;
      };
    }
    var get_style_on_stroke_width = get_size;
    
    // stroke_width for geom_point
    var stroke_width = 1;  // by default ggplot2 has 0.5, animint has 1
    var get_stroke_width;
    if(aes.hasOwnProperty("stroke")){
      get_stroke_width = get_attr("stroke");
    }else{
      get_stroke_width = function(d){
	return stroke_width;
      };
    }
    
    var linetype = "solid";
    var get_linetype;
    if(aes.hasOwnProperty("linetype")){
      get_linetype = get_attr("linetype");
    }else{
      get_linetype = function(d){
	return linetype;
      };
    }
    var get_dasharray = function(d){
      var lt = get_linetype(d);
      return linetypesize2dasharray(lt, get_size(d));
    };

    var alpha = 1, alpha_off = 0.5;
    var get_alpha;
    var get_alpha_off = function (d) {
      return alpha_off;
    };
    if(aes.hasOwnProperty("alpha")){
      get_alpha = get_attr("alpha");
      get_alpha_off = get_attr("alpha");
    } else {
      get_alpha = function(d){
	return alpha;
      };
    }
    
    var colour = "black", colour_off;
    var get_colour;
    var get_colour_off = function (d) {
      return colour_off;
    };
    if(aes.hasOwnProperty("colour")){
      get_colour = get_attr("colour");
      get_colour_off = get_colour;
    }else{
      get_colour = function (d) {
	return colour;
      };
    }
    var get_colour_off_default = get_colour;

    var fill = "black", fill_off = "black";
    var get_fill = function (d) {
      return fill;
    };
    var get_fill_off = function (d) {
      return fill_off;
    };
    
    var angle = 0;
    var get_angle;
    if(aes.hasOwnProperty("angle")){
      get_angle = get_attr("angle");
    }else{
      get_angle = function(d){
	return angle;
      };
    }
    var get_rotate = function(d){
      // x and y are the coordinates to rotate around, we choose the center 
      // point of the text because otherwise it will rotate around (0,0) of its 
      // coordinate system, which is the top left of the plot
      x = scales["x"](d["x"]);
      y = scales["y"](d["y"]);
      var angle = get_angle(d);
      // ggplot expects angles to be in degrees CCW, SVG uses degrees CW, so 
      // we negate the angle.
      return `rotate(${-angle}, ${x}, ${y})`;
    };
    
    // For aes(hjust) the compiler should make an "anchor" column.
    var text_anchor = "middle";
    var get_text_anchor;
    if(g_info.aes.hasOwnProperty("hjust")) {
      get_text_anchor = function(d){
	return d["anchor"];
      }
    }else{
      get_text_anchor = function(d){
	return text_anchor;
      }
    }

    var eActions, eAppend;
    var key_fun = null;
    if(g_info.aes.hasOwnProperty("key")){
      key_fun = function(d){
        return d.key;
      };
    }
    var get_one_row;//different for grouped and ungrouped geoms.
    var data_to_bind;
    g_info.style_list = [
      "opacity","stroke","stroke-width","stroke-dasharray","fill"];
    var line_style_list = [
      "opacity","stroke","stroke-width","stroke-dasharray"];
    var fill_comes_from="fill", fill_off_comes_from="fill_off";
    if(g_info.data_is_object) {

      // Lines, paths, polygons, and ribbons are a bit special. For
      // every unique value of the group variable, we take the
      // corresponding data rows and make 1 path. The tricky part is
      // that to use d3 I do a data-bind of some "fake" data which are
      // just group ids, which is the kv variable in the code below

      // // case of only 1 line and no groups.
      // if(!aes.hasOwnProperty("group")){
      //     kv = [{"key":0,"value":0}];
      //     data = {0:data};
      // }else{
      //     // we need to use a path for each group.
      //     var kv = d3.entries(d3.keys(data));
      //     kv = kv.map(function(d){
      // 	d[aes.group] = d.value;
      // 	return d;
      //     });
      // }

      // For an example consider breakpointError$error which is
      // defined using this R code

      // geom_line(aes(segments, error, group=bases.per.probe,
      //    clickSelects=bases.per.probe), data=only.error, lwd=4)

      // Inside update_geom the variables take the following values
      // (pseudo-Javascript code)

      // var kv = [{"key":"0","value":"133","bases.per.probe":"133"},
      //           {"key":"1","value":"2667","bases.per.probe":"2667"}];
      // var data = {"133":[array of 20 points used to draw the line for group 133],
      //             "2667":[array of 20 points used to draw the line for group 2667]};

      // I do elements.data(kv) so that when I set the d attribute of
      // each path, I need to select the correct group before
      // returning anything.

      // e.attr("d",function(group_info){
      //     var one_group = data[group_info.value];
      //     return lineThing(one_group);
      // })

      // To make color work I think you just have to select the group
      // and take the color of the first element, e.g.

      // .style("stroke",function(group_info){
      //     var one_group = data[group_info.value];
      //     var one_row = one_group[0];
      //     return get_color(one_row);
      // }

      // In order to get d3 lines to play nice, bind fake "data" (group
      // id's) -- the kv variable. Then each separate object is plotted
      // using path (case of only 1 thing and no groups).

      // we need to use a path for each group.
      var keyed_data = {}, one_group, group_id, k;
      for(group_id in data){
	one_group = data[group_id];
	one_row = one_group[0];
	if(one_row.hasOwnProperty("key")){
	  k = one_row.key;
	}else{
	  k = group_id;
	}
	keyed_data[k] = one_group;
      }
      var kv_array = d3.entries(d3.keys(keyed_data));
      var kv = kv_array.map(function (d) {
        //d[aes.group] = d.value;

        // Need to store the clickSelects value that will
        // be passed to the selector when we click on this
        // item.
        d.clickSelects = keyed_data[d.value][0].clickSelects;
        return d;
      });

      // line, path, and polygon use d3.svg.line(),
      // ribbon uses d3.svg.area()
      // we have to define lineThing accordingly.
      if (g_info.geom == "ribbon") {
        var lineThing = d3.svg.area()
          .x(toXY("x", "x"))
          .y(toXY("y", "ymax"))
          .y0(toXY("y", "ymin"));
      } else {
        var lineThing = d3.svg.line()
          .x(toXY("x", "x"))
          .y(toXY("y", "y"));
      }
      if(["line","path"].includes(g_info.geom)){
	fill = "none";
	fill_off = "none";
      }
      // select the correct group before returning anything.
      key_fun = function(group_info){
	return group_info.value;
      };
      data_to_bind = kv;
      get_one_row = function(group_info) {
        var one_group = keyed_data[group_info.value];
        var one_row = one_group[0];
	return one_row;
      };
      eActions = function (e) {
        e.attr("d", function (d) {
          var one_group = keyed_data[d.value];
          // filter NaN since they make the whole line disappear!
	  var no_na = one_group.filter(function(d){
            if(g_info.geom == "ribbon"){
              return !isNaN(d.x) && !isNaN(d.ymin) && !isNaN(d.ymax);
            }else{
              return !isNaN(d.x) && !isNaN(d.y);
            }
          });
          return lineThing(no_na);
        })
      };
      eAppend = "path";
    }else{
      get_one_row = function(d){
	return d;
      }
      data_to_bind = data;
      if (g_info.geom == "segment") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("x1", function (d) {
            return scales.x(d["x"]);
          })
            .attr("x2", function (d) {
              return scales.x(d["xend"]);
            })
            .attr("y1", function (d) {
              return scales.y(d["y"]);
            })
            .attr("y2", function (d) {
              return scales.y(d["yend"]);
            })
	};
	eAppend = "line";
      }
      if (g_info.geom == "linerange") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("x1", function (d) {
            return scales.x(d["x"]);
          })
            .attr("x2", function (d) {
              return scales.x(d["x"]);
            })
            .attr("y1", function (d) {
              return scales.y(d["ymax"]);
            })
            .attr("y2", function (d) {
              return scales.y(d["ymin"]);
            })
	  ;
	};
	eAppend = "line";
      }
      if (g_info.geom == "vline") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("x1", toXY("x", "xintercept"))
            .attr("x2", toXY("x", "xintercept"))
            .attr("y1", scales.y.range()[0])
            .attr("y2", scales.y.range()[1])
	  ;
	};
	eAppend = "line";
      }
      if (g_info.geom == "hline") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("y1", toXY("y", "yintercept"))
            .attr("y2", toXY("y", "yintercept"))
            .attr("x1", scales.x.range()[0])
            .attr("x2", scales.x.range()[1])
	  ;
	};
	eAppend = "line";
      }
      if (g_info.geom == "text") {
	size = 12;//default
	get_colour = function(d){
	  return "none";
	};
	get_colour_off = function(d) {
	  return "none";
	};
	fill_comes_from = "colour";
	fill_off_comes_from = "colour_off";
	g_info.style_list = [
	  "opacity","fill"];
	eActions = function (e) {
          e.attr("x", toXY("x", "x"))
            .attr("y", toXY("y", "y"))
            .attr("font-size", get_size)
            .style("text-anchor", get_text_anchor)
            .attr("transform", get_rotate)
            .text(function (d) {
              return d.label;
            })
	  ;
	};
	eAppend = "text";
      }
      if (g_info.geom == "point") {
	// point is special because it takes SVG fill from ggplot
	// colour, if fill is not specified.
	if(!(
	  g_info.params.hasOwnProperty("fill") ||
	    aes.hasOwnProperty("fill")
	)){
	  fill_comes_from = "colour";
	}
	if(!g_info.params.hasOwnProperty("fill_off")){
	  fill_off_comes_from = "colour_off";
	}
	get_style_on_stroke_width = get_stroke_width;//not size.
	eActions = function (e) {
          e.attr("cx", toXY("x", "x"))
            .attr("cy", toXY("y", "y"))
            .attr("r", get_size)
	  ;
	};
	eAppend = "circle";
      }
      var rect_geoms = ["tallrect","widerect","rect"];
      if(rect_geoms.includes(g_info.geom)){
	eAppend = "rect";
	if (g_info.geom == "tallrect") {
	  eActions = function (e) {
            e.attr("x", toXY("x", "xmin"))
              .attr("width", function (d) {
		return scales.x(d["xmax"]) - scales.x(d["xmin"]);
              })
              .attr("y", scales.y.range()[1])
              .attr("height", scales.y.range()[0] - scales.y.range()[1])
	    ;
	  };
	}
	if (g_info.geom == "widerect") {
	  eActions = function (e) {
            e.attr("y", toXY("y", "ymax"))
              .attr("height", function (d) {
		return scales.y(d["ymin"]) - scales.y(d["ymax"]);
              })
              .attr("x", scales.x.range()[0])
              .attr("width", scales.x.range()[1] - scales.x.range()[0])
	    ;
	  };
	}
	if (g_info.geom == "rect") {
	  alpha_off = alpha;
	  colour_off = "transparent";
	  get_colour_off_default = get_colour_off;
	  eActions = function (e) {
            e.attr("x", toXY("x", "xmin"))
              .attr("width", function (d) {
		return Math.abs(scales.x(d.xmax) - scales.x(d.xmin));
              })
              .attr("y", toXY("y", "ymax"))
              .attr("height", function (d) {
		return Math.abs(scales.y(d.ymin) - scales.y(d.ymax));
              })
	    ;
	  };
	}
      }
    }
    // set params after geom-specific code, because each geom may have
    // a different default.
    if (g_info.params.hasOwnProperty("stroke")) {
      stroke_width = g_info.params.stroke;
    }
    if (g_info.params.hasOwnProperty("linetype")) {
      linetype = g_info.params.linetype;
    }
    if(g_info.params.hasOwnProperty("alpha")){
      alpha = g_info.params.alpha;
      alpha_off = alpha - 0.5
    }
    if(g_info.params.hasOwnProperty("alpha_off")){
      alpha_off = g_info.params.alpha_off;
    }
    if(g_info.params.hasOwnProperty("anchor")){
      text_anchor = g_info.params["anchor"];
    }
    if(g_info.params.hasOwnProperty("colour")){
      colour = g_info.params.colour;
    }
    if(g_info.params.hasOwnProperty("colour_off")){
      colour_off = g_info.params.colour_off;
    }else{
      get_colour_off = get_colour_off_default;
    }
    if (g_info.params.hasOwnProperty("angle")) {
      angle = g_info.params["angle"];
    }
    if (g_info.params.hasOwnProperty(fill_comes_from)) {
      fill = g_info.params[fill_comes_from];
    }
    if (g_info.params.hasOwnProperty(fill_off_comes_from)) {
      fill_off = g_info.params[fill_off_comes_from];
    }else{
      fill_off = fill;
    }
    if(aes.hasOwnProperty(fill_comes_from)){
      get_fill = get_attr(fill_comes_from);
      get_fill_off = get_attr(fill_comes_from);
    };
    if (g_info.params.hasOwnProperty("size")) {
      size = g_info.params.size;
    }
    var styleActions = function(e){
      g_info.style_list.forEach(function(s){
	e.style(s, function(d) {
	  var style_on_fun = style_on_funs[s];
	  return style_on_fun(d);
	});
      });
    };
    var style_on_funs = {
      "opacity": get_alpha,
      "stroke": get_colour,
      "fill": get_fill,
      "stroke-width": get_style_on_stroke_width,
      "stroke-dasharray": get_dasharray
    };
    var style_off_funs = {
      "opacity": get_alpha_off,
      "stroke": get_colour_off,
      "fill": get_fill_off
    };
    // TODO cleanup.
    var select_style_default = ["opacity","stroke","fill"];
    g_info.select_style = select_style_default.filter(
      X => g_info.style_list.includes(X));
    var over_fun = function(e){
      g_info.select_style.forEach(function(s){
        e.style(s, function (d) {
          return style_on_funs[s](d);
        });
      });
    };
    var out_fun = function(e){
      g_info.select_style.forEach(function(s){
        e.style(s, function (d) {
          var select_on = style_on_funs[s](d);
          var select_off = style_off_funs[s](d);
          if(has_clickSelects){
            return ifSelectedElse(
	      d.clickSelects,
	      g_info.aes.clickSelects,
              select_on, select_off);
          }else if(has_clickSelects_variable){
            return ifSelectedElse(
	      d["clickSelects.value"],
              d["clickSelects.variable"],
              select_on, select_off);
          }
        });
      });
    };
    elements = elements.data(data_to_bind, key_fun);
    elements.exit().remove();
    var enter = elements.enter();
    if(g_info.aes.hasOwnProperty("href")){
      enter = enter.append("svg:a")
        .append("svg:"+eAppend);
    }else{
      enter = enter.append(eAppend)
	.attr("class", "geom");
    }
    var moreActions = function(e){};
    if (has_clickSelects || has_clickSelects_variable) {
      moreActions = out_fun;
      elements.call(out_fun)
        .on("mouseover", function (d) {
          d3.select(this).call(over_fun);
        })
        .on("mouseout", function (d) {
          d3.select(this).call(out_fun);
        })
      ;
      if(has_clickSelects){
	elements.on("click", function (d) {
            var s_name = g_info.aes.clickSelects;
            update_selector(s_name, d.clickSelects);
	});
      }else{
	elements.on("click", function(d){
	  var s_name = d["clickSelects.variable"];
	  var s_value = d["clickSelects.value"];
	  update_selector(s_name, s_value);
	});
      }
    }
    // Set attributes of only the entering elements. This is needed to
    // prevent things from flying around from the upper left when they
    // enter the plot.
    var doActions = function(e) {
      eActions(e);
      styleActions(e);
      moreActions(e)
    };
    doActions(enter);  // DO NOT DELETE!
    var has_tooltip = g_info.aes.hasOwnProperty("tooltip");
    if(has_clickSelects || has_tooltip || has_clickSelects_variable){
      var text_fun;
      if(has_tooltip){
        text_fun = function(d){
	  return d.tooltip;
	};
      }else if(has_clickSelects){
	text_fun = function(d){
          var v_name = g_info.aes.clickSelects;
          return v_name + " " + d.clickSelects;
	};
      }else{ //clickSelects_variable
	text_fun = function(d){
	  return d["clickSelects.variable"] + " " + d["clickSelects.value"];
	};
      }
      // if elements have an existing title, remove it.
      elements.selectAll("title").remove();
      elements.append("svg:title")
        .text(get_fun(text_fun))
      ;
    }
    if(Selectors.hasOwnProperty(selector_name)){
      var milliseconds = Selectors[selector_name].duration;
      elements = elements.transition().duration(milliseconds);
    }
    if(g_info.aes.hasOwnProperty("id")){
      elements.attr("id", get_attr("id"));
    }
    if(g_info.aes.hasOwnProperty("href")){
      // elements are <a>, children are e.g. <circle>
      var linked_geoms = elements.select(eAppend);
      doActions(linked_geoms);
      elements.attr("xlink:href", get_attr("href"))
        .attr("target", "_blank")
        .attr("class", "geom");
    }else{
      // elements are e.g. <circle>
      doActions(elements); // Set the attributes of all elements (enter/exit/stay)
    }
  };
  
  var value_tostring = function(selected_values) {
      //function that is helpful to change the format of the string
      var selector_url="#"
      for (var selc_var in selected_values){
          if(selected_values.hasOwnProperty(selc_var)){
              var values_str=selected_values[selc_var].join();
              var sub_url=selc_var.concat("=","{",values_str,"}");
              selector_url=selector_url.concat(sub_url);
          }
      }
      var url_nohash=window.location.href.match(/(^[^#]*)/)[0];
      selector_url=url_nohash.concat(selector_url);
      return  selector_url;
 };
  
  var get_values=function(){
      // function that is useful to get the selected values
      var selected_values={}
      for(var s_name in Selectors){
          var s_info=Selectors[s_name];
          var initial_selections = [];
          if(s_info.type==="single"){
              initial_selections=[s_info.selected];
          }
          else{
          for(var i in s_info.selected) {
            initial_selections[i] =  s_info.selected[i];
          }
          }
          selected_values[s_name]=initial_selections;    
      }
      return selected_values;
  };
  
  // update scales for the plots that have update_axes option in
  // theme_animint
  function update_scales(p_name, axes, v_name, value){
    // Get pre-computed domain
    var axis_domains = Plots[p_name]["axis_domains"];
    if(!isArray(axes)){
      axes = [axes];
    }
    if(axis_domains != null){
      axes.forEach(function(xyaxis){
        // For Each PANEL, update the axes
        Plots[p_name].layout.PANEL.forEach(function(panel_i, i){
          // Determine whether this panel has a scale or not
          // If not we just update the scales according to the common
          // scale and skip the updating of axis
          var draw_axes = Plots[p_name].layout["AXIS_"+ xyaxis.toUpperCase()][i];
          if(draw_axes){
            var use_panel = panel_i;
          }else{
            var use_panel = Plots[p_name].layout.PANEL[0];
          }
          // We update the current selection of the plot every time
          // and use it to index the correct domain
          var curr_select = axis_domains[xyaxis].curr_select;
          if(axis_domains[xyaxis].selectors.indexOf(v_name) > -1){
            curr_select[v_name] = value;
            var str = use_panel+".";
            for(selec in curr_select){
              str = str + curr_select[selec] + "_";
            }
            str = str.substring(0, str.length - 1); // Strip off trailing underscore
            var use_domain = axis_domains[xyaxis]["domains"][str];
          }
          if(use_domain != null){
            Plots[p_name]["scales"][panel_i][xyaxis].domain(use_domain);
            var scales = Plots[p_name]["scales"][panel_i][xyaxis];
            // major and minor grid lines as calculated in the compiler
            var grid_vals = Plots[p_name]["axis_domains"][xyaxis]["grids"][str];

            // Once scales are updated, update the axis ticks if needed
            if(draw_axes){
              // Tick values are same as major grid lines
              update_axes(p_name, xyaxis, panel_i, grid_vals[1]);
            }
            // Update major and minor grid lines
            update_grids(p_name, xyaxis, panel_i, grid_vals, scales);
          }
        });
      });
    }
  }

  // Update the axis ticks etc. once plot is zoomed in/out
  // currently called from update_scales.
  function update_axes(p_name, axes, panel_i, tick_vals){
    var orientation;
    if(axes == "x"){
      orientation = "bottom";
    }else{
      orientation = "left";
    }
    if(!isArray(tick_vals)){
      tick_vals = [tick_vals];
    }
    var xyaxis = d3.svg.axis()
          .scale(Plots[p_name]["scales"][panel_i][axes])
          .orient(orientation)
          .tickValues(tick_vals);
    // update existing axis
    var xyaxis_g = element.select("#plot_"+p_name).select("."+axes+"axis_"+panel_i)
          .transition()
          .duration(1000)
          .call(xyaxis);
  }

  // Update major/minor grids once axes ticks have been updated
  function update_grids(p_name, axes, panel_i, grid_vals, scales){
    // Select panel to update
    var bgr = element.select("#plot_"+p_name).select(".bgr"+panel_i);
    // Update major and minor grid lines
    ["minor", "major"].forEach(function(grid_class, j){
      var lines = bgr.select(".grid_"+grid_class).select("."+axes);
      var xy1, xy2;
      if(axes == "x"){
        xy1 = lines.select("line").attr("y1");
        xy2 = lines.select("line").attr("y2");
      }else{
        xy1 = lines.select("line").attr("x1");
        xy2 = lines.select("line").attr("x2");
      }
      
      // Get default values for grid lines like colour, stroke etc.
      var grid_background = Plots[p_name]["grid_"+grid_class];
      var col = grid_background.colour;
      var lt = grid_background.linetype;
      var size = grid_background.size;
      var cap = grid_background.lineend;

      // Remove old lines
      lines.selectAll("line")
        .remove();

      if(!isArray(grid_vals[j])){
        grid_vals[j] = [grid_vals[j]];
      }

      if(axes == "x"){
        lines.selectAll("line")
          .data(grid_vals[j])
          .enter()
          .append("line")
          .attr("y1", xy1)
          .attr("y2", xy2)
          .attr("x1", function(d) { return scales(d); })
          .attr("x2", function(d) { return scales(d); })
          .style("stroke", col)
          .style("stroke-linecap", cap)
          .style("stroke-width", size)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(lt, size);
          });
      }else{
        lines.selectAll("line")
          .data(grid_vals[j])
          .enter()
          .append("line")
          .attr("x1", xy1)
          .attr("x2", xy2)
          .attr("y1", function(d) { return scales(d); })
          .attr("y2", function(d) { return scales(d); })
          .style("stroke", col)
          .style("stroke-linecap", cap)
          .style("stroke-width", size)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(lt, size);
          });
      }
    });
  }

  var update_selector = function (v_name, value) {
    if(!Selectors.hasOwnProperty(v_name)){
      return;
    }
    value = value + "";
    var s_info = Selectors[v_name];
    if(s_info.type == "single"){
      // value is the new selection.
      s_info.selected = value;
    }else{
      // value should be added or removed from the selection.
      var i_value = s_info.selected.indexOf(value);
      if(i_value == -1){
        // not found, add to selection.
	s_info.selected.push(value);
      }else{
	// found, remove from selection.
	s_info.selected.splice(i_value, 1);
      }
    }
    // update_selector_url()
    // if there are levels, then there is a selectize widget which
    // should be updated.
    if(isArray(s_info.levels)){
      // the jquery ids
      if(s_info.type == "single") {
	var selected_ids = v_name.concat("___", value);
      } else {
	var selected_ids = [];
	for(i in s_info.selected) {
          selected_ids[i] = v_name.concat("___", s_info.selected[i]);
	}
      }
      // from
      // https://github.com/brianreavis/selectize.js/blob/master/docs/api.md:
      // setValue(value, silent) If "silent" is truthy, no change
      // event will be fired on the original input.
      selectized_array[v_name].setValue(selected_ids, true);
    }

    // For each updated geom, check if the axes of the plot need to be
    // updated and update them
    s_info.update.forEach(function(g_name){
      var plot_name = g_name.split("_").pop();
      var axes = Plots[plot_name]["options"]["update_axes"];
      if(axes != null){
        update_scales(plot_name, axes, v_name, value);
      }
    });

    update_legend_opacity(v_name);
    s_info.update.forEach(function(g_name){
      update_geom(g_name, v_name);
    });
  };

  var ifSelectedElse = function (s_value, s_name, selected, not_selected) {
    var is_selected;
    var s_info = Selectors[s_name];
    if(s_info.type == "single"){
      is_selected = s_value == s_info.selected;
    }else{
      is_selected = s_info.selected.indexOf(s_value) != -1;
    }
    if(is_selected){
      return selected;
    } else {
      return not_selected;
    }
  };
  
  function update_next_animation(){
    var values = d3.values(Animation.done_geoms);
    if(d3.sum(values) == values.length){
      // If the values in done_geoms are all 1, then we have loaded
      // all of the animation-related chunks, and we can start
      // playing the animation.
      var v_name = Animation.variable;
      var cur = Selectors[v_name].selected;
      var next = Animation.next[cur];
      update_selector(v_name, next);
    }
  }

  // The main idea of how legends work:

  // 1. In getLegend in animint.R I export the legend entries as a
  // list of rows that can be used in a data() bind in D3.

  // 2. Here in add_legend I create a <table> for every legend, and
  // then I bind the legend entries to <tr>, <td>, and <svg> elements.
  var add_legend = function(p_name, p_info){
    // case of multiple legends, d3 reads legend structure in as an array
    var tdRight = element.select("td."+p_name+"_legend");
    var legendkeys = d3.keys(p_info.legend);
    for(var i=0; i<legendkeys.length; i++){
      var legend_key = legendkeys[i];
      var l_info = p_info.legend[legend_key];
      // the table that contains one row for each legend element.
      var legend_table = tdRight.append("table")
	.attr("class", "legend")
      ;
      var legend_class = legend_class_name(l_info["class"]);
      var legend_id = p_info.plot_id + "_" + legend_class;
      // the legend table with breaks/value/label .
      // TODO: variable and value should be set in the compiler! What
      // if label is different from the data value?
      for(var entry_i=0; entry_i < l_info.entries.length; entry_i++){
	var entry = l_info.entries[entry_i];
	entry.variable = l_info.selector;
	entry.value = entry.label;
	entry.id = safe_name(legend_id + "_" + entry["label"]);
  	entry.text_size = l_info.text_size;
      }
      var legend_rows = legend_table.selectAll("tr")
        .data(l_info.entries)
        .enter()
        .append("tr")
      // in a good data viz there should not be more than one legend
      // that shows the same thing, so there should be no duplicate
      // id.
        .attr("id", function(d) { return d["id"]; })
	.attr("class", legend_class)
      ;
      if(l_info.selector != null){
	legend_rows
	  .on("click", function(d) { 
            update_selector(d.variable, d.value);
	  })
	  .attr("title", function(d) {
            return "Toggle " + d.value;
	  })
	  .attr("style", "cursor:pointer")
	;
      }
      var first_tr = legend_table.insert("tr", "tr");
      var first_th = first_tr.append("th")
	.attr("align", "left")
	.attr("colspan", 2)
        .text(l_info.title)
        .attr("class", legend_class)
        .style("font-size", l_info.title_size)
      ;
      var legend_svgs = legend_rows.append("td")
        .append("svg")
  	    .attr("id", function(d){return d["id"]+"_svg";})
  	    .attr("height", 14)
  	    .attr("width", 20);
      var pointscale = d3.scale.linear().domain([0,7]).range([1,4]);
      // scale points so they are visible in the legend. (does not
      // affect plot scaling)
      var linescale = d3.scale.linear().domain([0,6]).range([1,4]);
      // scale lines so they are visible in the legend. (does not
      // affect plot scaling)
      if(l_info.geoms.indexOf("polygon")>-1){
        // aesthetics that would draw a rect
        legend_svgs.append("rect")
          .attr("x", 2)
	        .attr("y", 2)
	        .attr("width", 10)
	        .attr("height", 10)
          .style("stroke-width", function(d){return d["polygonsize"]||1;})
          .style("stroke-dasharray", function(d){
            return linetypesize2dasharray(d["polygonlinetype"], d["size"]||2);
          })
          .style("stroke", function(d){return d["polygoncolour"] || "#000000";})
          .style("fill", function(d){return d["polygonfill"] || "#FFFFFF";})
          .style("opacity", function(d){return d["polygonalpha"]||1;});
      }
      if(l_info.geoms.indexOf("text")>-1){
        // aesthetics that would draw a rect
        legend_svgs.append("text")
	        .attr("x", 10)
	        .attr("y", 14)
          	.style("fill", function(d){return d["textcolour"]||1;})
	        .style("text-anchor", "middle")
          	.attr("font-size", function(d){return d["textsize"]||1;})
	        .text("a");
      }
      if(l_info.geoms.indexOf("path")>-1){
        // aesthetics that would draw a line
        legend_svgs.append("line")
          .attr("x1", 1).attr("x2", 19).attr("y1", 7).attr("y2", 7)
          .style("stroke-width", function(d){
            return linescale(d["pathsize"])||2;
          })
          .style("stroke-dasharray", function(d){
            return linetypesize2dasharray(d["pathlinetype"], d["pathsize"] || 2);
          })
          .style("stroke", function(d){return d["pathcolour"] || "#000000";})
          .style("opacity", function(d){return d["pathalpha"]||1;});
      }
      if(l_info.geoms.indexOf("point")>-1){
        // aesthetics that would draw a point
        legend_svgs.append("circle")
          .attr("cx", 10)
          .attr("cy", 7)
          .attr("r", function(d){return pointscale(d["pointsize"])||4;})
          .style("stroke", function(d){return d["pointcolour"] || "#000000";})
          .style("fill", function(d){
            return d["pointfill"] || d["pointcolour"] || "#000000";
          })
          .style("opacity", function(d){return d["pointalpha"]||1;});
      }
      legend_rows.append("td")
	.attr("align", "left") // TODO: right for numbers?
	.attr("class", "legend_entry_label")
	.attr("id", function(d){ return d["id"]+"_label"; })
  	.style("font-size", function(d){ return d["text_size"]})
	.text(function(d){ return d["label"];});
    }
  }

  // Download the main description of the interactive plot.
  d3.json(json_file, function (error, response) {
    if(response.hasOwnProperty("title")){
      // This selects the title of the web page, outside of wherever
      // the animint is defined, usually a <div> -- so it is OK to use
      // global d3.select here.
      d3.select("title").text(response.title);
    }
    // Add plots.
    for (var p_name in response.plots) {
      add_plot(p_name, response.plots[p_name]);
      add_legend(p_name, response.plots[p_name]);
      // Append style sheet to document head.
      css.appendChild(document.createTextNode(styles.join(" ")));
      document.head.appendChild(css);
    }
    // Then add selectors and start downloading the first data subset.
    for (var s_name in response.selectors) {
      add_selector(s_name, response.selectors[s_name]);
    }
    
    // Update the scales/axes of the plots if needed
    // We do this so that the plots zoom in initially after loading
    for (var p_name in response.plots) {
      if(response.plots[p_name].axis_domains !== null){
        for(var xy in response.plots[p_name].axis_domains){
          var selectors = response.plots[p_name].axis_domains[xy].selectors;
          if(!isArray(selectors)){
            selectors = [selectors];
          }
          update_scales(p_name, xy, selectors[0],
            response.selectors[selectors[0]].selected);
        }
      }
    }

    ////////////////////////////////////////////
    // Widgets at bottom of page
    ////////////////////////////////////////////
     // Function to start the tour
     var element = d3.select('body');
    if(response.hasOwnProperty("source")){
      widget_td.append("a")
	.attr("class","a_source_href")
	.attr("href", response.source)
	.text("source");
    }
    widget_td
      .append('button')
      .attr('class', 'animint_start_tour')
      .text('Start Tour')
      .on('click', function () {
        const driver = window.driver.js.driver;
        const driverObj = driver({
          showProgress: true,
          steps: steps,
        });
        driverObj.drive();
      });
    // loading table.
    var show_hide_table = widget_td.append("button")
      .text("Show download status table");
    show_hide_table
      .on("click", function(){
        if(this.textContent == "Show download status table"){
          loading.style("display", "");
          show_hide_table.text("Hide download status table");
        }else{
          loading.style("display", "none");
          show_hide_table.text("Show download status table");
        }
      });
    var loading = widget_td.append("table")
      .style("display", "none");
    Widgets["loading"] = loading;
    var tr = loading.append("tr");
    tr.append("th").text("geom");
    tr.append("th").attr("class", "chunk").text("selected chunk");
    tr.append("th").attr("class", "downloaded").text("downloaded");
    tr.append("th").attr("class", "total").text("total");
    tr.append("th").attr("class", "status").text("status");
    
    // Add geoms and construct nest operators.
    for (var g_name in response.geoms) {
      add_geom(g_name, response.geoms[g_name]);
    }
    
    // Animation control widgets.
    var show_message = "Show animation controls";
    // add a button to view the animation widgets
    var show_hide_animation_controls = widget_td.append("button")
      .text(show_message)
      .attr("id", viz_id + "_show_hide_animation_controls")
      .on("click", function(){
        if(this.textContent == show_message){
          time_table.style("display", "");
          show_hide_animation_controls.text("Hide animation controls");
        }else{
          time_table.style("display", "none");
          show_hide_animation_controls.text(show_message);
        }
      })
    ;
    // table of the animint widgets
    var time_table = widget_td.append("table")
      .style("display", "none");
    var first_tr = time_table.append("tr");
    var first_th = first_tr.append("th");
    // if there's a time variable, add a button to pause the animint
    if(response.time){
      Animation.next = {};
      Animation.ms = response.time.ms;
      Animation.variable = response.time.variable;
      Animation.sequence = response.time.sequence;
      Widgets["play_pause"] = first_th.append("button")
	.text("Play")
        .attr("id", "play_pause")
	.on("click", function(){
          if(this.textContent == "Play"){
            Animation.play();
          }else{
            Animation.pause(false);
          }
        })
      ;
    }
    first_tr.append("th").text("milliseconds");
    if(response.time){
      var second_tr = time_table.append("tr");
      second_tr.append("td").text("updates");
      second_tr.append("td").append("input")
	.attr("id", "updates_ms")
	.attr("type", "text")
	.attr("value", Animation.ms)
	.on("change", function(){
          Animation.pause(false);
          Animation.ms = this.value;
          Animation.play();
        })
      ;
    }
    for(s_name in Selectors){
      var s_info = Selectors[s_name];
      if(!s_info.hasOwnProperty("duration")){
        s_info.duration = 0;
      }
    }
    var selector_array = d3.keys(Selectors);
    var duration_rows = time_table.selectAll("tr.duration")
      .data(selector_array)
      .enter()
      .append("tr");
    duration_rows
      .append("td")
      .text(function(s_name){return s_name;});
    var duration_tds = duration_rows.append("td");
    var duration_inputs = duration_tds
      .append("input")
      .attr("id", function(s_name){
        return viz_id + "_duration_ms_" + s_name;
      })
      .attr("type", "text")
      .on("change", function(s_name){
        Selectors[s_name].duration = this.value;
      })
      .attr("value", function(s_name){
        return Selectors[s_name].duration;
      });
    // selector widgets
    var toggle_message = "Show selection menus";
    var show_or_hide_fun = function(){
      if(this.textContent == toggle_message){
        selector_table.style("display", "");
        show_hide_selector_widgets.text("Hide selection menus");
        d3.select(".urltable").style("display","")
      }else{
        selector_table.style("display", "none");
        show_hide_selector_widgets.text(toggle_message);
        d3.select(".urltable").style("display","none")
      }
    }
    var show_hide_selector_widgets = widget_td.append("button")
      .text(toggle_message)
      .attr("class", "show_hide_selector_widgets")
      .on("click", show_or_hide_fun)
    ;
    // adding a table for selector widgets
    var selector_table = widget_td.append("table")
      .style("display", "none")
      .attr("class", "table_selector_widgets")
    ;
    var selector_first_tr = selector_table.append("tr");
    selector_first_tr
      .append("th")
      .text("Variable")
    ;
    selector_first_tr
      .append("th")
      .text("Selected value(s)")
    ;
    // video link
    if(response.hasOwnProperty("video")){
      widget_td.append("a")
	.attr("class","a_video_href")
	.attr("href", response.video)
	.text("video");
    }
    // looping through and adding a row for each selector
    for(s_name in Selectors) {
      var s_info = Selectors[s_name];
      // for .variable .value selectors, levels is undefined and we do
      // not want to make a selectize widget.

      // TODO: why does it take so long to initialize the selectize
      // widget when there are many (>1000) values?
      if(isArray(s_info.levels)){
	// If there were no geoms that specified clickSelects for this
	// selector, then there is no way to select it other than the
	// selectize widgets (and possibly legends). So in this case
	// we show the selectize widgets by default.
	var selector_widgets_hidden = 
	  show_hide_selector_widgets.text() == toggle_message;
	var has_no_clickSelects = 
	  !Selectors[s_name].hasOwnProperty("clickSelects")
	var has_no_legend = 
	  !Selectors[s_name].hasOwnProperty("legend")
	if(selector_widgets_hidden && has_no_clickSelects && has_no_legend){
	  var node = show_hide_selector_widgets.node();
	  show_or_hide_fun.apply(node);
	}
	// removing "." from name so it can be used in ids
	var s_name_id = legend_class_name(s_name);

	// adding a row for each selector
	var selector_widget_row = selector_table
          .append("tr")
          .attr("class", function() { return s_name_id + "_selector_widget"; })
	;
	selector_widget_row.append("td").text(s_name);
	// adding the selector
	var selector_widget_select = selector_widget_row
          .append("td")
          .append("select")
          .attr("class", function() { return s_name_id + "_input"; })
          .attr("placeholder", function() { return "Toggle " + s_name; });
	// adding an option for each level of the variable
	selector_widget_select.selectAll("option")
          .data(s_info.levels)
          .enter()
          .append("option")
          .attr("value", function(d) { return d; })
          .text(function(d) { return d; });
	// making sure that the first option is blank
	selector_widget_select
          .insert("option")
          .attr("value", "")
          .text(function() { return "Toggle " + s_name; });
	
	// calling selectize
	var selectize_selector = to_select + ' .' + s_name_id + "_input";
	if(s_info.type == "single") {
          // setting up array of selector and options
          var selector_values = [];
          for(i in s_info.levels) {
            selector_values[i] = {
              id: s_name.concat("___", s_info.levels[i]), 
              text: s_info.levels[i]
            };
          }
          // the id of the first selector
          var selected_id = s_name.concat("___", s_info.selected);

          // if single selection, only allow one item
          var $temp = $(selectize_selector)
            .selectize({
              create: false, 
              valueField: 'id',
              labelField: 'text',
              searchField: ['text'],
              options: selector_values, 
              items: [selected_id],
              maxItems: 1, 
              allowEmptyOption: true,
              onChange: function(value) {
		// extracting the name and the level to update
		var selector_name = value.split("___")[0];
		var selected_level = value.split("___")[1];
		// updating the selector
		update_selector(selector_name, selected_level);
              }
            })
          ;
	} else { // multiple selection:
          // setting up array of selector and options
          var selector_values = [];
          if(typeof s_info.levels == "object") {
            for(i in s_info.levels) {
              selector_values[i] = {
		id: s_name.concat("___", s_info.levels[i]), 
		text: s_info.levels[i]
              };
            }
          } else {
            selector_values[0] = {
              id: s_name.concat("___", s_info.levels), 
              text: s_info.levels
            };
          }
          // setting up an array to contain the initally selected elements
          var initial_selections = [];
          for(i in s_info.selected) {
            initial_selections[i] = s_name.concat("___", s_info.selected[i]);
          }
          
          // construct the selectize
          var $temp = $(selectize_selector)
            .selectize({
              create: false, 
              valueField: 'id',
              labelField: 'text',
              searchField: ['text'],
              options: selector_values, 
              items: initial_selections,
              maxItems: s_info.levels.length, 
              allowEmptyOption: true,
              onChange: function(value) { 
		// if nothing is selected, remove what is currently selected
		if(value == null) {
                  // extracting the selector ids from the options
                  var the_ids = Object.keys($(this)[0].options);
                  // the name of the appropriate selector
                  var selector_name = the_ids[0].split("___")[0];
                  // the previously selected elements
                  var old_selections = Selectors[selector_name].selected;
                  // updating the selector for each of the old selections
                  old_selections.forEach(function(element) {
                    update_selector(selector_name, element);
                  });
		} else { // value is not null:
                  // grabbing the name of the selector from the selected value
                  var selector_name = value[0].split("___")[0];
                  // identifying the levels that should be selected
                  var specified_levels = [];
                  for(i in value) {
                    specified_levels[i] = value[i].split("___")[1];
                  }
                  // the previously selected entries
                  old_selections = Selectors[selector_name].selected;
                  
                  // the levels that need to have selections turned on
                  specified_levels
                    .filter(function(n) {
                      return old_selections.indexOf(n) == -1;
                    })
                    .forEach(function(element) {
                      update_selector(selector_name, element);
                    })
                  ;
                  // the levels that need to be turned off
                  // - same approach
                  old_selections
                    .filter(function(n) {
                      return specified_levels.indexOf(n) == -1;
                    })
                    .forEach(function(element) {
                      update_selector(selector_name, element);
                    })
                  ;
		}//value==null
              }//onChange
            })//selectize
          ;
	}//single or multiple selection.
	selectized_array[s_name] = $temp[0].selectize;
      }//levels, is.variable.value
    } // close for loop through selector widgets
    // If this is an animation, then start downloading all the rest of
    // the data, and start the animation.
    if (response.time) {
      var i, prev, cur;
      for (var i = 0; i < Animation.sequence.length; i++) {
        if (i == 0) {
          prev = Animation.sequence[Animation.sequence.length-1];
        } else {
          prev = Animation.sequence[i - 1];
        }
        cur = Animation.sequence[i];
        Animation.next[prev] = cur;
      }
      Animation.timer = null;
      Animation.play = function(){
	if(Animation.timer == null){ // only play if not already playing.
    	  // as shown on http://bl.ocks.org/mbostock/3808234
    	  Animation.timer = setInterval(update_next_animation, Animation.ms);
    	  Widgets["play_pause"].text("Pause");
	}
      };
      Animation.play_after_visible = false;
      Animation.pause = function(play_after_visible){
        Animation.play_after_visible = play_after_visible;
        clearInterval(Animation.timer);
	Animation.timer = null;
        Widgets["play_pause"].text("Play");
      };
      var s_info = Selectors[Animation.variable];
      Animation.done_geoms = {};
      s_info.update.forEach(function(g_name){
        var g_info = Geoms[g_name];
        if(g_info.chunk_order.length == 1 &&
	   g_info.chunk_order[0] == Animation.variable){
	  g_info.seq_i = Animation.sequence.indexOf(s_info.selected);
	  g_info.seq_count = 0;
	  Animation.done_geoms[g_name] = 0;
	  download_next(g_name);
	}
      });
      Animation.play();
      all_geom_names = d3.keys(response.geoms);

      // This code starts/stops the animation timer when the page is
      // hidden, inspired by
      // http://stackoverflow.com/questions/1060008
      function onchange (evt) {
        if(document.visibilityState == "visible"){
          if(Animation.play_after_visible){
            Animation.play();
          }
        }else{
          if(Widgets["play_pause"].text() == "Pause"){
            Animation.pause(true);
          }
        }
      };
      document.addEventListener("visibilitychange", onchange);
    }
    // update_selector_url()
    var check_func=function(){
      var status_array = $('.status').map(function(){
        return $.trim($(this).text());
      }).get();
      status_array=status_array.slice(1)
      return status_array.every(function(elem){ return elem === "displayed"});           
    }
    if(window.location.hash) {
      var fragment=window.location.hash;
      fragment=fragment.slice(1);
      fragment=decodeURI(fragment)
      var frag_array=fragment.split(/(.*?})/);
      frag_array=frag_array.filter(function(x){ return x!=""})
      frag_array.forEach(function(selector_string){ 
        var selector_hash=selector_string.split("=");
        var selector_nam=selector_hash[0];
        var selector_values=selector_hash[1];
        var re = /\{(.*?)\}/;
        selector_values = re.exec(selector_values)[1];
        var array_values = selector_values.split(',');
	if(Selectors.hasOwnProperty(selector_nam)){
          var s_info = Selectors[selector_nam]
          if(s_info.type=="single"){//TODO fix
            array_values.forEach(function(element) {
              wait_until_then(100, check_func, update_selector,selector_nam,element)
              if(response.time)Animation.pause(true)
            });   
          }else{
            var old_selections = Selectors[selector_nam].selected;
            // the levels that need to have selections turned on
            array_values
              .filter(function(n) {
		return old_selections.indexOf(n) == -1;
              })
              .forEach(function(element) {
		wait_until_then(100, check_func, update_selector,selector_nam,element)
		if(response.time){
                  Animation.pause(true)
		}
              });
            old_selections
              .filter(function(n) {
		return array_values.indexOf(n) == -1;
              })
              .forEach(function(element) {
		wait_until_then(100, check_func, update_selector,selector_nam,element)
		if(response.time){
                  Animation.pause(true)
		}
              });     
          }//if(single) else multiple selection
	}//if(Selectors.hasOwnProperty(selector_nam))
      })//frag_array.forEach
    }//if(window.location.hash)
  });
};

</script>
<script>
/*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l="1.11.3",m=function(a,b){return new m.fn.init(a,b)},n=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,o=/^-ms-/,p=/-([\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:"jQuery"+(l+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===m.type(a)},isArray:Array.isArray||function(a){return"array"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,"ms-").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(n,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function r(a){var b="length"in a&&a.length,c=m.type(a);return"function"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);m.find=s,m.expr=s.selectors,m.expr[":"]=m.expr.pseudos,m.unique=s.uniqueSort,m.text=s.getText,m.isXMLDoc=s.isXML,m.contains=s.contains;var t=m.expr.match.needsContext,u=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,v=/^.[^:#\[\.,]*$/;function w(a,b,c){if(m.isFunction(b))return m.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return m.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(v.test(b))return m.filter(b,a,c);b=m.filter(b,a)}return m.grep(a,function(a){return m.inArray(a,b)>=0!==c})}m.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?m.find.matchesSelector(d,a)?[d]:[]:m.find.matches(a,m.grep(b,function(a){return 1===a.nodeType}))},m.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(m(a).filter(function(){for(b=0;e>b;b++)if(m.contains(d[b],this))return!0}));for(b=0;e>b;b++)m.find(a,d[b],c);return c=this.pushStack(e>1?m.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(w(this,a||[],!1))},not:function(a){return this.pushStack(w(this,a||[],!0))},is:function(a){return!!w(this,"string"==typeof a&&t.test(a)?m(a):a||[],!1).length}});var x,y=a.document,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=m.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||x).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof m?b[0]:b,m.merge(this,m.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:y,!0)),u.test(c[1])&&m.isPlainObject(b))for(c in b)m.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=y.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return x.find(a);this.length=1,this[0]=d}return this.context=y,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):m.isFunction(a)?"undefined"!=typeof x.ready?x.ready(a):a(m):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),m.makeArray(a,this))};A.prototype=m.fn,x=m(y);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};m.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!m(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),m.fn.extend({has:function(a){var b,c=m(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(m.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=t.test(a)||"string"!=typeof a?m(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&m.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?m.unique(f):f)},index:function(a){return a?"string"==typeof a?m.inArray(this[0],m(a)):m.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(m.unique(m.merge(this.get(),m(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}m.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return m.dir(a,"parentNode")},parentsUntil:function(a,b,c){return m.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return m.dir(a,"nextSibling")},prevAll:function(a){return m.dir(a,"previousSibling")},nextUntil:function(a,b,c){return m.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return m.dir(a,"previousSibling",c)},siblings:function(a){return m.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return m.sibling(a.firstChild)},contents:function(a){return m.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:m.merge([],a.childNodes)}},function(a,b){m.fn[a]=function(c,d){var e=m.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=m.filter(d,e)),this.length>1&&(C[a]||(e=m.unique(e)),B.test(a)&&(e=e.reverse())),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return m.each(a.match(E)||[],function(a,c){b[c]=!0}),b}m.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):m.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){m.each(b,function(b,c){var d=m.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&m.each(arguments,function(a,c){var d;while((d=m.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?m.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},m.extend({Deferred:function(a){var b=[["resolve","done",m.Callbacks("once memory"),"resolved"],["reject","fail",m.Callbacks("once memory"),"rejected"],["notify","progress",m.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return m.Deferred(function(c){m.each(b,function(b,f){var g=m.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&m.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?m.extend(a,d):d}},e={};return d.pipe=d.then,m.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&m.isFunction(a.promise)?e:0,g=1===f?a:m.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&m.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;m.fn.ready=function(a){return m.ready.promise().done(a),this},m.extend({isReady:!1,readyWait:1,holdReady:function(a){a?m.readyWait++:m.ready(!0)},ready:function(a){if(a===!0?!--m.readyWait:!m.isReady){if(!y.body)return setTimeout(m.ready);m.isReady=!0,a!==!0&&--m.readyWait>0||(H.resolveWith(y,[m]),m.fn.triggerHandler&&(m(y).triggerHandler("ready"),m(y).off("ready")))}}});function I(){y.addEventListener?(y.removeEventListener("DOMContentLoaded",J,!1),a.removeEventListener("load",J,!1)):(y.detachEvent("onreadystatechange",J),a.detachEvent("onload",J))}function J(){(y.addEventListener||"load"===event.type||"complete"===y.readyState)&&(I(),m.ready())}m.ready.promise=function(b){if(!H)if(H=m.Deferred(),"complete"===y.readyState)setTimeout(m.ready);else if(y.addEventListener)y.addEventListener("DOMContentLoaded",J,!1),a.addEventListener("load",J,!1);else{y.attachEvent("onreadystatechange",J),a.attachEvent("onload",J);var c=!1;try{c=null==a.frameElement&&y.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!m.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}I(),m.ready()}}()}return H.promise(b)};var K="undefined",L;for(L in m(k))break;k.ownLast="0"!==L,k.inlineBlockNeedsLayout=!1,m(function(){var a,b,c,d;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",k.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(d))}),function(){var a=y.createElement("div");if(null==k.deleteExpando){k.deleteExpando=!0;try{delete a.test}catch(b){k.deleteExpando=!1}}a=null}(),m.acceptData=function(a){var b=m.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var M=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,N=/([A-Z])/g;function O(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(N,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:M.test(c)?m.parseJSON(c):c}catch(e){}m.data(a,b,c)}else c=void 0}return c}function P(a){var b;for(b in a)if(("data"!==b||!m.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;

return!0}function Q(a,b,d,e){if(m.acceptData(a)){var f,g,h=m.expando,i=a.nodeType,j=i?m.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||m.guid++:h),j[k]||(j[k]=i?{}:{toJSON:m.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=m.extend(j[k],b):j[k].data=m.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[m.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[m.camelCase(b)])):f=g,f}}function R(a,b,c){if(m.acceptData(a)){var d,e,f=a.nodeType,g=f?m.cache:a,h=f?a[m.expando]:m.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){m.isArray(b)?b=b.concat(m.map(b,m.camelCase)):b in d?b=[b]:(b=m.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!P(d):!m.isEmptyObject(d))return}(c||(delete g[h].data,P(g[h])))&&(f?m.cleanData([a],!0):k.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}m.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?m.cache[a[m.expando]]:a[m.expando],!!a&&!P(a)},data:function(a,b,c){return Q(a,b,c)},removeData:function(a,b){return R(a,b)},_data:function(a,b,c){return Q(a,b,c,!0)},_removeData:function(a,b){return R(a,b,!0)}}),m.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=m.data(f),1===f.nodeType&&!m._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=m.camelCase(d.slice(5)),O(f,d,e[d])));m._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){m.data(this,a)}):arguments.length>1?this.each(function(){m.data(this,a,b)}):f?O(f,a,m.data(f,a)):void 0},removeData:function(a){return this.each(function(){m.removeData(this,a)})}}),m.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=m._data(a,b),c&&(!d||m.isArray(c)?d=m._data(a,b,m.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=m.queue(a,b),d=c.length,e=c.shift(),f=m._queueHooks(a,b),g=function(){m.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return m._data(a,c)||m._data(a,c,{empty:m.Callbacks("once memory").add(function(){m._removeData(a,b+"queue"),m._removeData(a,c)})})}}),m.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?m.queue(this[0],a):void 0===b?this:this.each(function(){var c=m.queue(this,a,b);m._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&m.dequeue(this,a)})},dequeue:function(a){return this.each(function(){m.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=m.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=m._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=["Top","Right","Bottom","Left"],U=function(a,b){return a=b||a,"none"===m.css(a,"display")||!m.contains(a.ownerDocument,a)},V=m.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===m.type(c)){e=!0;for(h in c)m.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,m.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(m(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},W=/^(?:checkbox|radio)$/i;!function(){var a=y.createElement("input"),b=y.createElement("div"),c=y.createDocumentFragment();if(b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",k.leadingWhitespace=3===b.firstChild.nodeType,k.tbody=!b.getElementsByTagName("tbody").length,k.htmlSerialize=!!b.getElementsByTagName("link").length,k.html5Clone="<:nav></:nav>"!==y.createElement("nav").cloneNode(!0).outerHTML,a.type="checkbox",a.checked=!0,c.appendChild(a),k.appendChecked=a.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,c.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,k.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){k.noCloneEvent=!1}),b.cloneNode(!0).click()),null==k.deleteExpando){k.deleteExpando=!0;try{delete b.test}catch(d){k.deleteExpando=!1}}}(),function(){var b,c,d=y.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(k[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),k[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var X=/^(?:input|select|textarea)$/i,Y=/^key/,Z=/^(?:mouse|pointer|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=/^([^.]*)(?:\.(.+)|)$/;function aa(){return!0}function ba(){return!1}function ca(){try{return y.activeElement}catch(a){}}m.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=m.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof m===K||a&&m.event.triggered===a.type?void 0:m.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(E)||[""],h=b.length;while(h--)f=_.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=m.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=m.event.special[o]||{},l=m.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&m.expr.match.needsContext.test(e),namespace:p.join(".")},i),(n=g[o])||(n=g[o]=[],n.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?n.splice(n.delegateCount++,0,l):n.push(l),m.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m.hasData(a)&&m._data(a);if(r&&(k=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=_.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=m.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,n=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=n.length;while(f--)g=n[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(n.splice(f,1),g.selector&&n.delegateCount--,l.remove&&l.remove.call(a,g));i&&!n.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||m.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)m.event.remove(a,o+b[j],c,d,!0);m.isEmptyObject(k)&&(delete r.handle,m._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,o=[d||y],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||y,3!==d.nodeType&&8!==d.nodeType&&!$.test(p+m.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[m.expando]?b:new m.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:m.makeArray(c,[b]),k=m.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!m.isWindow(d)){for(i=k.delegateType||p,$.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||y)&&o.push(l.defaultView||l.parentWindow||a)}n=0;while((h=o[n++])&&!b.isPropagationStopped())b.type=n>1?i:k.bindType||p,f=(m._data(h,"events")||{})[b.type]&&m._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&m.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&m.acceptData(d)&&g&&d[p]&&!m.isWindow(d)){l=d[g],l&&(d[g]=null),m.event.triggered=p;try{d[p]()}catch(r){}m.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=m.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(m._data(this,"events")||{})[a.type]||[],k=m.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=m.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((m.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?m(c,this).index(i)>=0:m.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[m.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=Z.test(e)?this.mouseHooks:Y.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new m.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||y),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||y,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ca()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ca()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return m.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return m.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=m.extend(new m.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?m.event.trigger(e,null,b):m.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},m.removeEvent=y.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===K&&(a[d]=null),a.detachEvent(d,c))},m.Event=function(a,b){return this instanceof m.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?aa:ba):this.type=a,b&&m.extend(this,b),this.timeStamp=a&&a.timeStamp||m.now(),void(this[m.expando]=!0)):new m.Event(a,b)},m.Event.prototype={isDefaultPrevented:ba,isPropagationStopped:ba,isImmediatePropagationStopped:ba,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=aa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=aa,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=aa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},m.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){m.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!m.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.submitBubbles||(m.event.special.submit={setup:function(){return m.nodeName(this,"form")?!1:void m.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=m.nodeName(b,"input")||m.nodeName(b,"button")?b.form:void 0;c&&!m._data(c,"submitBubbles")&&(m.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),m._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&m.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return m.nodeName(this,"form")?!1:void m.event.remove(this,"._submit")}}),k.changeBubbles||(m.event.special.change={setup:function(){return X.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(m.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),m.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),m.event.simulate("change",this,a,!0)})),!1):void m.event.add(this,"beforeactivate._change",function(a){var b=a.target;X.test(b.nodeName)&&!m._data(b,"changeBubbles")&&(m.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||m.event.simulate("change",this.parentNode,a,!0)}),m._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return m.event.remove(this,"._change"),!X.test(this.nodeName)}}),k.focusinBubbles||m.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){m.event.simulate(b,a.target,m.event.fix(a),!0)};m.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=m._data(d,b);e||d.addEventListener(a,c,!0),m._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=m._data(d,b)-1;e?m._data(d,b,e):(d.removeEventListener(a,c,!0),m._removeData(d,b))}}}),m.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=ba;else if(!d)return this;return 1===e&&(g=d,d=function(a){return m().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=m.guid++)),this.each(function(){m.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,m(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=ba),this.each(function(){m.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){m.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?m.event.trigger(a,b,c,!0):void 0}});function da(a){var b=ea.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var ea="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",fa=/ jQuery\d+="(?:null|\d+)"/g,ga=new RegExp("<(?:"+ea+")[\\s/>]","i"),ha=/^\s+/,ia=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ja=/<([\w:]+)/,ka=/<tbody/i,la=/<|&#?\w+;/,ma=/<(?:script|style|link)/i,na=/checked\s*(?:[^=]|=\s*.checked.)/i,oa=/^$|\/(?:java|ecma)script/i,pa=/^true\/(.*)/,qa=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ra={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:k.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},sa=da(y),ta=sa.appendChild(y.createElement("div"));ra.optgroup=ra.option,ra.tbody=ra.tfoot=ra.colgroup=ra.caption=ra.thead,ra.th=ra.td;function ua(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==K?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==K?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||m.nodeName(d,b)?f.push(d):m.merge(f,ua(d,b));return void 0===b||b&&m.nodeName(a,b)?m.merge([a],f):f}function va(a){W.test(a.type)&&(a.defaultChecked=a.checked)}function wa(a,b){return m.nodeName(a,"table")&&m.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function xa(a){return a.type=(null!==m.find.attr(a,"type"))+"/"+a.type,a}function ya(a){var b=pa.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function za(a,b){for(var c,d=0;null!=(c=a[d]);d++)m._data(c,"globalEval",!b||m._data(b[d],"globalEval"))}function Aa(a,b){if(1===b.nodeType&&m.hasData(a)){var c,d,e,f=m._data(a),g=m._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)m.event.add(b,c,h[c][d])}g.data&&(g.data=m.extend({},g.data))}}function Ba(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!k.noCloneEvent&&b[m.expando]){e=m._data(b);for(d in e.events)m.removeEvent(b,d,e.handle);b.removeAttribute(m.expando)}"script"===c&&b.text!==a.text?(xa(b).text=a.text,ya(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),k.html5Clone&&a.innerHTML&&!m.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&W.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}m.extend({clone:function(a,b,c){var d,e,f,g,h,i=m.contains(a.ownerDocument,a);if(k.html5Clone||m.isXMLDoc(a)||!ga.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(ta.innerHTML=a.outerHTML,ta.removeChild(f=ta.firstChild)),!(k.noCloneEvent&&k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||m.isXMLDoc(a)))for(d=ua(f),h=ua(a),g=0;null!=(e=h[g]);++g)d[g]&&Ba(e,d[g]);if(b)if(c)for(h=h||ua(a),d=d||ua(f),g=0;null!=(e=h[g]);g++)Aa(e,d[g]);else Aa(a,f);return d=ua(f,"script"),d.length>0&&za(d,!i&&ua(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,l,n=a.length,o=da(b),p=[],q=0;n>q;q++)if(f=a[q],f||0===f)if("object"===m.type(f))m.merge(p,f.nodeType?[f]:f);else if(la.test(f)){h=h||o.appendChild(b.createElement("div")),i=(ja.exec(f)||["",""])[1].toLowerCase(),l=ra[i]||ra._default,h.innerHTML=l[1]+f.replace(ia,"<$1></$2>")+l[2],e=l[0];while(e--)h=h.lastChild;if(!k.leadingWhitespace&&ha.test(f)&&p.push(b.createTextNode(ha.exec(f)[0])),!k.tbody){f="table"!==i||ka.test(f)?"<table>"!==l[1]||ka.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)m.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}m.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),k.appendChecked||m.grep(ua(p,"input"),va),q=0;while(f=p[q++])if((!d||-1===m.inArray(f,d))&&(g=m.contains(f.ownerDocument,f),h=ua(o.appendChild(f),"script"),g&&za(h),c)){e=0;while(f=h[e++])oa.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=m.expando,j=m.cache,l=k.deleteExpando,n=m.event.special;null!=(d=a[h]);h++)if((b||m.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)n[e]?m.event.remove(d,e):m.removeEvent(d,e,g.handle);j[f]&&(delete j[f],l?delete d[i]:typeof d.removeAttribute!==K?d.removeAttribute(i):d[i]=null,c.push(f))}}}),m.fn.extend({text:function(a){return V(this,function(a){return void 0===a?m.text(this):this.empty().append((this[0]&&this[0].ownerDocument||y).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?m.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||m.cleanData(ua(c)),c.parentNode&&(b&&m.contains(c.ownerDocument,c)&&za(ua(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&m.cleanData(ua(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&m.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return m.clone(this,a,b)})},html:function(a){return V(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(fa,""):void 0;if(!("string"!=typeof a||ma.test(a)||!k.htmlSerialize&&ga.test(a)||!k.leadingWhitespace&&ha.test(a)||ra[(ja.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(ia,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(m.cleanData(ua(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,m.cleanData(ua(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,n=this,o=l-1,p=a[0],q=m.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&na.test(p))return this.each(function(c){var d=n.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(i=m.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=m.map(ua(i,"script"),xa),f=g.length;l>j;j++)d=i,j!==o&&(d=m.clone(d,!0,!0),f&&m.merge(g,ua(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,m.map(g,ya),j=0;f>j;j++)d=g[j],oa.test(d.type||"")&&!m._data(d,"globalEval")&&m.contains(h,d)&&(d.src?m._evalUrl&&m._evalUrl(d.src):m.globalEval((d.text||d.textContent||d.innerHTML||"").replace(qa,"")));i=c=null}return this}}),m.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){m.fn[a]=function(a){for(var c,d=0,e=[],g=m(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),m(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Ca,Da={};function Ea(b,c){var d,e=m(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:m.css(e[0],"display");return e.detach(),f}function Fa(a){var b=y,c=Da[a];return c||(c=Ea(a,b),"none"!==c&&c||(Ca=(Ca||m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ca[0].contentWindow||Ca[0].contentDocument).document,b.write(),b.close(),c=Ea(a,b),Ca.detach()),Da[a]=c),c}!function(){var a;k.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,d;return c=y.getElementsByTagName("body")[0],c&&c.style?(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(y.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(d),a):void 0}}();var Ga=/^margin/,Ha=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ia,Ja,Ka=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ia=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||m.contains(a.ownerDocument,a)||(g=m.style(a,b)),Ha.test(g)&&Ga.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):y.documentElement.currentStyle&&(Ia=function(a){return a.currentStyle},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ha.test(g)&&!Ka.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function La(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h;if(b=y.createElement("div"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=d&&d.style){c.cssText="float:left;opacity:.5",k.opacity="0.5"===c.opacity,k.cssFloat=!!c.cssFloat,b.style.backgroundClip="content-box",b.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===b.style.backgroundClip,k.boxSizing=""===c.boxSizing||""===c.MozBoxSizing||""===c.WebkitBoxSizing,m.extend(k,{reliableHiddenOffsets:function(){return null==g&&i(),g},boxSizingReliable:function(){return null==f&&i(),f},pixelPosition:function(){return null==e&&i(),e},reliableMarginRight:function(){return null==h&&i(),h}});function i(){var b,c,d,i;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),b.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",e=f=!1,h=!0,a.getComputedStyle&&(e="1%"!==(a.getComputedStyle(b,null)||{}).top,f="4px"===(a.getComputedStyle(b,null)||{width:"4px"}).width,i=b.appendChild(y.createElement("div")),i.style.cssText=b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",i.style.marginRight=i.style.width="0",b.style.width="1px",h=!parseFloat((a.getComputedStyle(i,null)||{}).marginRight),b.removeChild(i)),b.innerHTML="<table><tr><td></td><td>t</td></tr></table>",i=b.getElementsByTagName("td"),i[0].style.cssText="margin:0;border:0;padding:0;display:none",g=0===i[0].offsetHeight,g&&(i[0].style.display="",i[1].style.display="none",g=0===i[0].offsetHeight),c.removeChild(d))}}}(),m.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Ma=/alpha\([^)]*\)/i,Na=/opacity\s*=\s*([^)]*)/,Oa=/^(none|table(?!-c[ea]).+)/,Pa=new RegExp("^("+S+")(.*)$","i"),Qa=new RegExp("^([+-])=("+S+")","i"),Ra={position:"absolute",visibility:"hidden",display:"block"},Sa={letterSpacing:"0",fontWeight:"400"},Ta=["Webkit","O","Moz","ms"];function Ua(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ta.length;while(e--)if(b=Ta[e]+c,b in a)return b;return d}function Va(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=m._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&U(d)&&(f[g]=m._data(d,"olddisplay",Fa(d.nodeName)))):(e=U(d),(c&&"none"!==c||!e)&&m._data(d,"olddisplay",e?c:m.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Wa(a,b,c){var d=Pa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Xa(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=m.css(a,c+T[f],!0,e)),d?("content"===c&&(g-=m.css(a,"padding"+T[f],!0,e)),"margin"!==c&&(g-=m.css(a,"border"+T[f]+"Width",!0,e))):(g+=m.css(a,"padding"+T[f],!0,e),"padding"!==c&&(g+=m.css(a,"border"+T[f]+"Width",!0,e)));return g}function Ya(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ia(a),g=k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Ja(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ha.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Xa(a,b,c||(g?"border":"content"),d,f)+"px"}m.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Ja(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":k.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=m.camelCase(b),i=a.style;if(b=m.cssProps[h]||(m.cssProps[h]=Ua(i,h)),g=m.cssHooks[b]||m.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Qa.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(m.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||m.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=m.camelCase(b);return b=m.cssProps[h]||(m.cssProps[h]=Ua(a.style,h)),g=m.cssHooks[b]||m.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Ja(a,b,d)),"normal"===f&&b in Sa&&(f=Sa[b]),""===c||c?(e=parseFloat(f),c===!0||m.isNumeric(e)?e||0:f):f}}),m.each(["height","width"],function(a,b){m.cssHooks[b]={get:function(a,c,d){return c?Oa.test(m.css(a,"display"))&&0===a.offsetWidth?m.swap(a,Ra,function(){return Ya(a,b,d)}):Ya(a,b,d):void 0},set:function(a,c,d){var e=d&&Ia(a);return Wa(a,c,d?Xa(a,b,d,k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,e),e):0)}}}),k.opacity||(m.cssHooks.opacity={get:function(a,b){return Na.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=m.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===m.trim(f.replace(Ma,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Ma.test(f)?f.replace(Ma,e):f+" "+e)}}),m.cssHooks.marginRight=La(k.reliableMarginRight,function(a,b){return b?m.swap(a,{display:"inline-block"},Ja,[a,"marginRight"]):void 0}),m.each({margin:"",padding:"",border:"Width"},function(a,b){m.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+T[d]+b]=f[d]||f[d-2]||f[0];return e}},Ga.test(a)||(m.cssHooks[a+b].set=Wa)}),m.fn.extend({css:function(a,b){return V(this,function(a,b,c){var d,e,f={},g=0;if(m.isArray(b)){for(d=Ia(a),e=b.length;e>g;g++)f[b[g]]=m.css(a,b[g],!1,d);return f}return void 0!==c?m.style(a,b,c):m.css(a,b)},a,b,arguments.length>1)},show:function(){return Va(this,!0)},hide:function(){return Va(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){U(this)?m(this).show():m(this).hide()})}});function Za(a,b,c,d,e){
return new Za.prototype.init(a,b,c,d,e)}m.Tween=Za,Za.prototype={constructor:Za,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(m.cssNumber[c]?"":"px")},cur:function(){var a=Za.propHooks[this.prop];return a&&a.get?a.get(this):Za.propHooks._default.get(this)},run:function(a){var b,c=Za.propHooks[this.prop];return this.options.duration?this.pos=b=m.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Za.propHooks._default.set(this),this}},Za.prototype.init.prototype=Za.prototype,Za.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=m.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){m.fx.step[a.prop]?m.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[m.cssProps[a.prop]]||m.cssHooks[a.prop])?m.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Za.propHooks.scrollTop=Za.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},m.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},m.fx=Za.prototype.init,m.fx.step={};var $a,_a,ab=/^(?:toggle|show|hide)$/,bb=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),cb=/queueHooks$/,db=[ib],eb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=bb.exec(b),f=e&&e[3]||(m.cssNumber[a]?"":"px"),g=(m.cssNumber[a]||"px"!==f&&+d)&&bb.exec(m.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,m.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function fb(){return setTimeout(function(){$a=void 0}),$a=m.now()}function gb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=T[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function hb(a,b,c){for(var d,e=(eb[b]||[]).concat(eb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,l,n=this,o={},p=a.style,q=a.nodeType&&U(a),r=m._data(a,"fxshow");c.queue||(h=m._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,n.always(function(){n.always(function(){h.unqueued--,m.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=m.css(a,"display"),l="none"===j?m._data(a,"olddisplay")||Fa(a.nodeName):j,"inline"===l&&"none"===m.css(a,"float")&&(k.inlineBlockNeedsLayout&&"inline"!==Fa(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",k.shrinkWrapBlocks()||n.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],ab.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||m.style(a,d)}else j=void 0;if(m.isEmptyObject(o))"inline"===("none"===j?Fa(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=m._data(a,"fxshow",{}),f&&(r.hidden=!q),q?m(a).show():n.done(function(){m(a).hide()}),n.done(function(){var b;m._removeData(a,"fxshow");for(b in o)m.style(a,b,o[b])});for(d in o)g=hb(q?r[d]:0,d,n),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=m.camelCase(c),e=b[d],f=a[c],m.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=m.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=db.length,h=m.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=$a||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:m.extend({},b),opts:m.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:$a||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=m.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);g>f;f++)if(d=db[f].call(j,a,k,j.opts))return d;return m.map(k,hb,j),m.isFunction(j.opts.start)&&j.opts.start.call(a,j),m.fx.timer(m.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}m.Animation=m.extend(kb,{tweener:function(a,b){m.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],eb[c]=eb[c]||[],eb[c].unshift(b)},prefilter:function(a,b){b?db.unshift(a):db.push(a)}}),m.speed=function(a,b,c){var d=a&&"object"==typeof a?m.extend({},a):{complete:c||!c&&b||m.isFunction(a)&&a,duration:a,easing:c&&b||b&&!m.isFunction(b)&&b};return d.duration=m.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in m.fx.speeds?m.fx.speeds[d.duration]:m.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){m.isFunction(d.old)&&d.old.call(this),d.queue&&m.dequeue(this,d.queue)},d},m.fn.extend({fadeTo:function(a,b,c,d){return this.filter(U).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=m.isEmptyObject(a),f=m.speed(b,c,d),g=function(){var b=kb(this,m.extend({},a),f);(e||m._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=m.timers,g=m._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&cb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&m.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=m._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=m.timers,g=d?d.length:0;for(c.finish=!0,m.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),m.each(["toggle","show","hide"],function(a,b){var c=m.fn[b];m.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),m.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){m.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),m.timers=[],m.fx.tick=function(){var a,b=m.timers,c=0;for($a=m.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||m.fx.stop(),$a=void 0},m.fx.timer=function(a){m.timers.push(a),a()?m.fx.start():m.timers.pop()},m.fx.interval=13,m.fx.start=function(){_a||(_a=setInterval(m.fx.tick,m.fx.interval))},m.fx.stop=function(){clearInterval(_a),_a=null},m.fx.speeds={slow:600,fast:200,_default:400},m.fn.delay=function(a,b){return a=m.fx?m.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e;b=y.createElement("div"),b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=y.createElement("select"),e=c.appendChild(y.createElement("option")),a=b.getElementsByTagName("input")[0],d.style.cssText="top:1px",k.getSetAttribute="t"!==b.className,k.style=/top/.test(d.getAttribute("style")),k.hrefNormalized="/a"===d.getAttribute("href"),k.checkOn=!!a.value,k.optSelected=e.selected,k.enctype=!!y.createElement("form").enctype,c.disabled=!0,k.optDisabled=!e.disabled,a=y.createElement("input"),a.setAttribute("value",""),k.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),k.radioValue="t"===a.value}();var lb=/\r/g;m.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=m.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,m(this).val()):a,null==e?e="":"number"==typeof e?e+="":m.isArray(e)&&(e=m.map(e,function(a){return null==a?"":a+""})),b=m.valHooks[this.type]||m.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=m.valHooks[e.type]||m.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(lb,""):null==c?"":c)}}}),m.extend({valHooks:{option:{get:function(a){var b=m.find.attr(a,"value");return null!=b?b:m.trim(m.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&m.nodeName(c.parentNode,"optgroup"))){if(b=m(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=m.makeArray(b),g=e.length;while(g--)if(d=e[g],m.inArray(m.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),m.each(["radio","checkbox"],function(){m.valHooks[this]={set:function(a,b){return m.isArray(b)?a.checked=m.inArray(m(a).val(),b)>=0:void 0}},k.checkOn||(m.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var mb,nb,ob=m.expr.attrHandle,pb=/^(?:checked|selected)$/i,qb=k.getSetAttribute,rb=k.input;m.fn.extend({attr:function(a,b){return V(this,m.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){m.removeAttr(this,a)})}}),m.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===K?m.prop(a,b,c):(1===f&&m.isXMLDoc(a)||(b=b.toLowerCase(),d=m.attrHooks[b]||(m.expr.match.bool.test(b)?nb:mb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=m.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void m.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=m.propFix[c]||c,m.expr.match.bool.test(c)?rb&&qb||!pb.test(c)?a[d]=!1:a[m.camelCase("default-"+c)]=a[d]=!1:m.attr(a,c,""),a.removeAttribute(qb?c:d)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&m.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),nb={set:function(a,b,c){return b===!1?m.removeAttr(a,c):rb&&qb||!pb.test(c)?a.setAttribute(!qb&&m.propFix[c]||c,c):a[m.camelCase("default-"+c)]=a[c]=!0,c}},m.each(m.expr.match.bool.source.match(/\w+/g),function(a,b){var c=ob[b]||m.find.attr;ob[b]=rb&&qb||!pb.test(b)?function(a,b,d){var e,f;return d||(f=ob[b],ob[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,ob[b]=f),e}:function(a,b,c){return c?void 0:a[m.camelCase("default-"+b)]?b.toLowerCase():null}}),rb&&qb||(m.attrHooks.value={set:function(a,b,c){return m.nodeName(a,"input")?void(a.defaultValue=b):mb&&mb.set(a,b,c)}}),qb||(mb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},ob.id=ob.name=ob.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},m.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:mb.set},m.attrHooks.contenteditable={set:function(a,b,c){mb.set(a,""===b?!1:b,c)}},m.each(["width","height"],function(a,b){m.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),k.style||(m.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var sb=/^(?:input|select|textarea|button|object)$/i,tb=/^(?:a|area)$/i;m.fn.extend({prop:function(a,b){return V(this,m.prop,a,b,arguments.length>1)},removeProp:function(a){return a=m.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),m.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!m.isXMLDoc(a),f&&(b=m.propFix[b]||b,e=m.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=m.find.attr(a,"tabindex");return b?parseInt(b,10):sb.test(a.nodeName)||tb.test(a.nodeName)&&a.href?0:-1}}}}),k.hrefNormalized||m.each(["href","src"],function(a,b){m.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),k.optSelected||(m.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),m.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){m.propFix[this.toLowerCase()]=this}),k.enctype||(m.propFix.enctype="encoding");var ub=/[\t\r\n\f]/g;m.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=m.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?m.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(m.isFunction(a)?function(c){m(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=m(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===K||"boolean"===c)&&(this.className&&m._data(this,"__className__",this.className),this.className=this.className||a===!1?"":m._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ub," ").indexOf(b)>=0)return!0;return!1}}),m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){m.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),m.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var vb=m.now(),wb=/\?/,xb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;m.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=m.trim(b+"");return e&&!m.trim(e.replace(xb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():m.error("Invalid JSON: "+b)},m.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||m.error("Invalid XML: "+b),c};var yb,zb,Ab=/#.*$/,Bb=/([?&])_=[^&]*/,Cb=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Db=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Eb=/^(?:GET|HEAD)$/,Fb=/^\/\//,Gb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Hb={},Ib={},Jb="*/".concat("*");try{zb=location.href}catch(Kb){zb=y.createElement("a"),zb.href="",zb=zb.href}yb=Gb.exec(zb.toLowerCase())||[];function Lb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(m.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Mb(a,b,c,d){var e={},f=a===Ib;function g(h){var i;return e[h]=!0,m.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Nb(a,b){var c,d,e=m.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&m.extend(!0,a,c),a}function Ob(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Pb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}m.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:zb,type:"GET",isLocal:Db.test(yb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Jb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":m.parseJSON,"text xml":m.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Nb(Nb(a,m.ajaxSettings),b):Nb(m.ajaxSettings,a)},ajaxPrefilter:Lb(Hb),ajaxTransport:Lb(Ib),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=m.ajaxSetup({},b),l=k.context||k,n=k.context&&(l.nodeType||l.jquery)?m(l):m.event,o=m.Deferred(),p=m.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Cb.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||zb)+"").replace(Ab,"").replace(Fb,yb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=m.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(c=Gb.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===yb[1]&&c[2]===yb[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(yb[3]||("http:"===yb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=m.param(k.data,k.traditional)),Mb(Hb,k,b,v),2===t)return v;h=m.event&&k.global,h&&0===m.active++&&m.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Eb.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(wb.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Bb.test(e)?e.replace(Bb,"$1_="+vb++):e+(wb.test(e)?"&":"?")+"_="+vb++)),k.ifModified&&(m.lastModified[e]&&v.setRequestHeader("If-Modified-Since",m.lastModified[e]),m.etag[e]&&v.setRequestHeader("If-None-Match",m.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Jb+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Mb(Ib,k,b,v)){v.readyState=1,h&&n.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Ob(k,v,c)),u=Pb(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(m.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(m.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&n.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(n.trigger("ajaxComplete",[v,k]),--m.active||m.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return m.get(a,b,c,"json")},getScript:function(a,b){return m.get(a,void 0,b,"script")}}),m.each(["get","post"],function(a,b){m[b]=function(a,c,d,e){return m.isFunction(c)&&(e=e||d,d=c,c=void 0),m.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),m._evalUrl=function(a){return m.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},m.fn.extend({wrapAll:function(a){if(m.isFunction(a))return this.each(function(b){m(this).wrapAll(a.call(this,b))});if(this[0]){var b=m(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(m.isFunction(a)?function(b){m(this).wrapInner(a.call(this,b))}:function(){var b=m(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=m.isFunction(a);return this.each(function(c){m(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){m.nodeName(this,"body")||m(this).replaceWith(this.childNodes)}).end()}}),m.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!k.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||m.css(a,"display"))},m.expr.filters.visible=function(a){return!m.expr.filters.hidden(a)};var Qb=/%20/g,Rb=/\[\]$/,Sb=/\r?\n/g,Tb=/^(?:submit|button|image|reset|file)$/i,Ub=/^(?:input|select|textarea|keygen)/i;function Vb(a,b,c,d){var e;if(m.isArray(b))m.each(b,function(b,e){c||Rb.test(a)?d(a,e):Vb(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==m.type(b))d(a,b);else for(e in b)Vb(a+"["+e+"]",b[e],c,d)}m.param=function(a,b){var c,d=[],e=function(a,b){b=m.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=m.ajaxSettings&&m.ajaxSettings.traditional),m.isArray(a)||a.jquery&&!m.isPlainObject(a))m.each(a,function(){e(this.name,this.value)});else for(c in a)Vb(c,a[c],b,e);return d.join("&").replace(Qb,"+")},m.fn.extend({serialize:function(){return m.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=m.prop(this,"elements");return a?m.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!m(this).is(":disabled")&&Ub.test(this.nodeName)&&!Tb.test(a)&&(this.checked||!W.test(a))}).map(function(a,b){var c=m(this).val();return null==c?null:m.isArray(c)?m.map(c,function(a){return{name:b.name,value:a.replace(Sb,"\r\n")}}):{name:b.name,value:c.replace(Sb,"\r\n")}}).get()}}),m.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&Zb()||$b()}:Zb;var Wb=0,Xb={},Yb=m.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Xb)Xb[a](void 0,!0)}),k.cors=!!Yb&&"withCredentials"in Yb,Yb=k.ajax=!!Yb,Yb&&m.ajaxTransport(function(a){if(!a.crossDomain||k.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Wb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Xb[g],b=void 0,f.onreadystatechange=m.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Xb[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function Zb(){try{return new a.XMLHttpRequest}catch(b){}}function $b(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}m.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return m.globalEval(a),a}}}),m.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),m.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=y.head||m("head")[0]||y.documentElement;return{send:function(d,e){b=y.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var _b=[],ac=/(=)\?(?=&|$)|\?\?/;m.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=_b.pop()||m.expando+"_"+vb++;return this[a]=!0,a}}),m.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(ac.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&ac.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=m.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(ac,"$1"+e):b.jsonp!==!1&&(b.url+=(wb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||m.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,_b.push(e)),g&&m.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),m.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||y;var d=u.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=m.buildFragment([a],b,e),e&&e.length&&m(e).remove(),m.merge([],d.childNodes))};var bc=m.fn.load;m.fn.load=function(a,b,c){if("string"!=typeof a&&bc)return bc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=m.trim(a.slice(h,a.length)),a=a.slice(0,h)),m.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&m.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?m("<div>").append(m.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},m.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){m.fn[b]=function(a){return this.on(b,a)}}),m.expr.filters.animated=function(a){return m.grep(m.timers,function(b){return a===b.elem}).length};var cc=a.document.documentElement;function dc(a){return m.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}m.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=m.css(a,"position"),l=m(a),n={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=m.css(a,"top"),i=m.css(a,"left"),j=("absolute"===k||"fixed"===k)&&m.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),m.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(n.top=b.top-h.top+g),null!=b.left&&(n.left=b.left-h.left+e),"using"in b?b.using.call(a,n):l.css(n)}},m.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){m.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,m.contains(b,e)?(typeof e.getBoundingClientRect!==K&&(d=e.getBoundingClientRect()),c=dc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===m.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),m.nodeName(a[0],"html")||(c=a.offset()),c.top+=m.css(a[0],"borderTopWidth",!0),c.left+=m.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-m.css(d,"marginTop",!0),left:b.left-c.left-m.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||cc;while(a&&!m.nodeName(a,"html")&&"static"===m.css(a,"position"))a=a.offsetParent;return a||cc})}}),m.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);m.fn[a]=function(d){return V(this,function(a,d,e){var f=dc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?m(f).scrollLeft():e,c?e:m(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),m.each(["top","left"],function(a,b){m.cssHooks[b]=La(k.pixelPosition,function(a,c){return c?(c=Ja(a,b),Ha.test(c)?m(a).position()[b]+"px":c):void 0})}),m.each({Height:"height",Width:"width"},function(a,b){m.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){m.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return V(this,function(b,c,d){var e;return m.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?m.css(b,c,g):m.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),m.fn.size=function(){return this.length},m.fn.andSelf=m.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return m});var ec=a.jQuery,fc=a.$;return m.noConflict=function(b){return a.$===m&&(a.$=fc),b&&a.jQuery===m&&(a.jQuery=ec),m},typeof b===K&&(a.jQuery=a.$=m),m});
</script>
<script>
/*! selectize.js - v0.12.1 | https://github.com/brianreavis/selectize.js | Apache License (v2) */
!function(a,b){"function"==typeof define&&define.amd?define("sifter",b):"object"==typeof exports?module.exports=b():a.Sifter=b()}(this,function(){var a=function(a,b){this.items=a,this.settings=b||{diacritics:!0}};a.prototype.tokenize=function(a){if(a=d(String(a||"").toLowerCase()),!a||!a.length)return[];var b,c,f,h,i=[],j=a.split(/ +/);for(b=0,c=j.length;c>b;b++){if(f=e(j[b]),this.settings.diacritics)for(h in g)g.hasOwnProperty(h)&&(f=f.replace(new RegExp(h,"g"),g[h]));i.push({string:j[b],regex:new RegExp(f,"i")})}return i},a.prototype.iterator=function(a,b){var c;c=f(a)?Array.prototype.forEach||function(a){for(var b=0,c=this.length;c>b;b++)a(this[b],b,this)}:function(a){for(var b in this)this.hasOwnProperty(b)&&a(this[b],b,this)},c.apply(a,[b])},a.prototype.getScoreFunction=function(a,b){var c,d,e,f;c=this,a=c.prepareSearch(a,b),e=a.tokens,d=a.options.fields,f=e.length;var g=function(a,b){var c,d;return a?(a=String(a||""),d=a.search(b.regex),-1===d?0:(c=b.string.length/a.length,0===d&&(c+=.5),c)):0},h=function(){var a=d.length;return a?1===a?function(a,b){return g(b[d[0]],a)}:function(b,c){for(var e=0,f=0;a>e;e++)f+=g(c[d[e]],b);return f/a}:function(){return 0}}();return f?1===f?function(a){return h(e[0],a)}:"and"===a.options.conjunction?function(a){for(var b,c=0,d=0;f>c;c++){if(b=h(e[c],a),0>=b)return 0;d+=b}return d/f}:function(a){for(var b=0,c=0;f>b;b++)c+=h(e[b],a);return c/f}:function(){return 0}},a.prototype.getSortFunction=function(a,c){var d,e,f,g,h,i,j,k,l,m,n;if(f=this,a=f.prepareSearch(a,c),n=!a.query&&c.sort_empty||c.sort,l=function(a,b){return"$score"===a?b.score:f.items[b.id][a]},h=[],n)for(d=0,e=n.length;e>d;d++)(a.query||"$score"!==n[d].field)&&h.push(n[d]);if(a.query){for(m=!0,d=0,e=h.length;e>d;d++)if("$score"===h[d].field){m=!1;break}m&&h.unshift({field:"$score",direction:"desc"})}else for(d=0,e=h.length;e>d;d++)if("$score"===h[d].field){h.splice(d,1);break}for(k=[],d=0,e=h.length;e>d;d++)k.push("desc"===h[d].direction?-1:1);return i=h.length,i?1===i?(g=h[0].field,j=k[0],function(a,c){return j*b(l(g,a),l(g,c))}):function(a,c){var d,e,f;for(d=0;i>d;d++)if(f=h[d].field,e=k[d]*b(l(f,a),l(f,c)))return e;return 0}:null},a.prototype.prepareSearch=function(a,b){if("object"==typeof a)return a;b=c({},b);var d=b.fields,e=b.sort,g=b.sort_empty;return d&&!f(d)&&(b.fields=[d]),e&&!f(e)&&(b.sort=[e]),g&&!f(g)&&(b.sort_empty=[g]),{options:b,query:String(a||"").toLowerCase(),tokens:this.tokenize(a),total:0,items:[]}},a.prototype.search=function(a,b){var c,d,e,f,g=this;return d=this.prepareSearch(a,b),b=d.options,a=d.query,f=b.score||g.getScoreFunction(d),a.length?g.iterator(g.items,function(a,e){c=f(a),(b.filter===!1||c>0)&&d.items.push({score:c,id:e})}):g.iterator(g.items,function(a,b){d.items.push({score:1,id:b})}),e=g.getSortFunction(d,b),e&&d.items.sort(e),d.total=d.items.length,"number"==typeof b.limit&&(d.items=d.items.slice(0,b.limit)),d};var b=function(a,b){return"number"==typeof a&&"number"==typeof b?a>b?1:b>a?-1:0:(a=h(String(a||"")),b=h(String(b||"")),a>b?1:b>a?-1:0)},c=function(a){var b,c,d,e;for(b=1,c=arguments.length;c>b;b++)if(e=arguments[b])for(d in e)e.hasOwnProperty(d)&&(a[d]=e[d]);return a},d=function(a){return(a+"").replace(/^\s+|\s+$|/g,"")},e=function(a){return(a+"").replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")},f=Array.isArray||$&&$.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},g={a:"[aÀÁÂÃÄÅàáâãäåĀāąĄ]",c:"[cÇçćĆčČ]",d:"[dđĐďĎ]",e:"[eÈÉÊËèéêëěĚĒēęĘ]",i:"[iÌÍÎÏìíîïĪī]",l:"[lłŁ]",n:"[nÑñňŇńŃ]",o:"[oÒÓÔÕÕÖØòóôõöøŌō]",r:"[rřŘ]",s:"[sŠšśŚ]",t:"[tťŤ]",u:"[uÙÚÛÜùúûüůŮŪū]",y:"[yŸÿýÝ]",z:"[zŽžżŻźŹ]"},h=function(){var a,b,c,d,e="",f={};for(c in g)if(g.hasOwnProperty(c))for(d=g[c].substring(2,g[c].length-1),e+=d,a=0,b=d.length;b>a;a++)f[d.charAt(a)]=c;var h=new RegExp("["+e+"]","g");return function(a){return a.replace(h,function(a){return f[a]}).toLowerCase()}}();return a}),function(a,b){"function"==typeof define&&define.amd?define("microplugin",b):"object"==typeof exports?module.exports=b():a.MicroPlugin=b()}(this,function(){var a={};a.mixin=function(a){a.plugins={},a.prototype.initializePlugins=function(a){var c,d,e,f=this,g=[];if(f.plugins={names:[],settings:{},requested:{},loaded:{}},b.isArray(a))for(c=0,d=a.length;d>c;c++)"string"==typeof a[c]?g.push(a[c]):(f.plugins.settings[a[c].name]=a[c].options,g.push(a[c].name));else if(a)for(e in a)a.hasOwnProperty(e)&&(f.plugins.settings[e]=a[e],g.push(e));for(;g.length;)f.require(g.shift())},a.prototype.loadPlugin=function(b){var c=this,d=c.plugins,e=a.plugins[b];if(!a.plugins.hasOwnProperty(b))throw new Error('Unable to find "'+b+'" plugin');d.requested[b]=!0,d.loaded[b]=e.fn.apply(c,[c.plugins.settings[b]||{}]),d.names.push(b)},a.prototype.require=function(a){var b=this,c=b.plugins;if(!b.plugins.loaded.hasOwnProperty(a)){if(c.requested[a])throw new Error('Plugin has circular dependency ("'+a+'")');b.loadPlugin(a)}return c.loaded[a]},a.define=function(b,c){a.plugins[b]={name:b,fn:c}}};var b={isArray:Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)}};return a}),function(a,b){"function"==typeof define&&define.amd?define("selectize",["jquery","sifter","microplugin"],b):"object"==typeof exports?module.exports=b(require("jquery"),require("sifter"),require("microplugin")):a.Selectize=b(a.jQuery,a.Sifter,a.MicroPlugin)}(this,function(a,b,c){"use strict";var d=function(a,b){if("string"!=typeof b||b.length){var c="string"==typeof b?new RegExp(b,"i"):b,d=function(a){var b=0;if(3===a.nodeType){var e=a.data.search(c);if(e>=0&&a.data.length>0){var f=a.data.match(c),g=document.createElement("span");g.className="highlight";var h=a.splitText(e),i=(h.splitText(f[0].length),h.cloneNode(!0));g.appendChild(i),h.parentNode.replaceChild(g,h),b=1}}else if(1===a.nodeType&&a.childNodes&&!/(script|style)/i.test(a.tagName))for(var j=0;j<a.childNodes.length;++j)j+=d(a.childNodes[j]);return b};return a.each(function(){d(this)})}},e=function(){};e.prototype={on:function(a,b){this._events=this._events||{},this._events[a]=this._events[a]||[],this._events[a].push(b)},off:function(a,b){var c=arguments.length;return 0===c?delete this._events:1===c?delete this._events[a]:(this._events=this._events||{},void(a in this._events!=!1&&this._events[a].splice(this._events[a].indexOf(b),1)))},trigger:function(a){if(this._events=this._events||{},a in this._events!=!1)for(var b=0;b<this._events[a].length;b++)this._events[a][b].apply(this,Array.prototype.slice.call(arguments,1))}},e.mixin=function(a){for(var b=["on","off","trigger"],c=0;c<b.length;c++)a.prototype[b[c]]=e.prototype[b[c]]};var f=/Mac/.test(navigator.userAgent),g=65,h=13,i=27,j=37,k=38,l=80,m=39,n=40,o=78,p=8,q=46,r=16,s=f?91:17,t=f?18:17,u=9,v=1,w=2,x=!/android/i.test(window.navigator.userAgent)&&!!document.createElement("form").validity,y=function(a){return"undefined"!=typeof a},z=function(a){return"undefined"==typeof a||null===a?null:"boolean"==typeof a?a?"1":"0":a+""},A=function(a){return(a+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")},B=function(a){return(a+"").replace(/\$/g,"$$$$")},C={};C.before=function(a,b,c){var d=a[b];a[b]=function(){return c.apply(a,arguments),d.apply(a,arguments)}},C.after=function(a,b,c){var d=a[b];a[b]=function(){var b=d.apply(a,arguments);return c.apply(a,arguments),b}};var D=function(a){var b=!1;return function(){b||(b=!0,a.apply(this,arguments))}},E=function(a,b){var c;return function(){var d=this,e=arguments;window.clearTimeout(c),c=window.setTimeout(function(){a.apply(d,e)},b)}},F=function(a,b,c){var d,e=a.trigger,f={};a.trigger=function(){var c=arguments[0];return-1===b.indexOf(c)?e.apply(a,arguments):void(f[c]=arguments)},c.apply(a,[]),a.trigger=e;for(d in f)f.hasOwnProperty(d)&&e.apply(a,f[d])},G=function(a,b,c,d){a.on(b,c,function(b){for(var c=b.target;c&&c.parentNode!==a[0];)c=c.parentNode;return b.currentTarget=c,d.apply(this,[b])})},H=function(a){var b={};if("selectionStart"in a)b.start=a.selectionStart,b.length=a.selectionEnd-b.start;else if(document.selection){a.focus();var c=document.selection.createRange(),d=document.selection.createRange().text.length;c.moveStart("character",-a.value.length),b.start=c.text.length-d,b.length=d}return b},I=function(a,b,c){var d,e,f={};if(c)for(d=0,e=c.length;e>d;d++)f[c[d]]=a.css(c[d]);else f=a.css();b.css(f)},J=function(b,c){if(!b)return 0;var d=a("<test>").css({position:"absolute",top:-99999,left:-99999,width:"auto",padding:0,whiteSpace:"pre"}).text(b).appendTo("body");I(c,d,["letterSpacing","fontSize","fontFamily","fontWeight","textTransform"]);var e=d.width();return d.remove(),e},K=function(a){var b=null,c=function(c,d){var e,f,g,h,i,j,k,l;c=c||window.event||{},d=d||{},c.metaKey||c.altKey||(d.force||a.data("grow")!==!1)&&(e=a.val(),c.type&&"keydown"===c.type.toLowerCase()&&(f=c.keyCode,g=f>=97&&122>=f||f>=65&&90>=f||f>=48&&57>=f||32===f,f===q||f===p?(l=H(a[0]),l.length?e=e.substring(0,l.start)+e.substring(l.start+l.length):f===p&&l.start?e=e.substring(0,l.start-1)+e.substring(l.start+1):f===q&&"undefined"!=typeof l.start&&(e=e.substring(0,l.start)+e.substring(l.start+1))):g&&(j=c.shiftKey,k=String.fromCharCode(c.keyCode),k=j?k.toUpperCase():k.toLowerCase(),e+=k)),h=a.attr("placeholder"),!e&&h&&(e=h),i=J(e,a)+4,i!==b&&(b=i,a.width(i),a.triggerHandler("resize")))};a.on("keydown keyup update blur",c),c()},L=function(c,d){var e,f,g,h,i=this;h=c[0],h.selectize=i;var j=window.getComputedStyle&&window.getComputedStyle(h,null);if(g=j?j.getPropertyValue("direction"):h.currentStyle&&h.currentStyle.direction,g=g||c.parents("[dir]:first").attr("dir")||"",a.extend(i,{order:0,settings:d,$input:c,tabIndex:c.attr("tabindex")||"",tagType:"select"===h.tagName.toLowerCase()?v:w,rtl:/rtl/i.test(g),eventNS:".selectize"+ ++L.count,highlightedValue:null,isOpen:!1,isDisabled:!1,isRequired:c.is("[required]"),isInvalid:!1,isLocked:!1,isFocused:!1,isInputHidden:!1,isSetup:!1,isShiftDown:!1,isCmdDown:!1,isCtrlDown:!1,ignoreFocus:!1,ignoreBlur:!1,ignoreHover:!1,hasOptions:!1,currentResults:null,lastValue:"",caretPos:0,loading:0,loadedSearches:{},$activeOption:null,$activeItems:[],optgroups:{},options:{},userOptions:{},items:[],renderCache:{},onSearchChange:null===d.loadThrottle?i.onSearchChange:E(i.onSearchChange,d.loadThrottle)}),i.sifter=new b(this.options,{diacritics:d.diacritics}),i.settings.options){for(e=0,f=i.settings.options.length;f>e;e++)i.registerOption(i.settings.options[e]);delete i.settings.options}if(i.settings.optgroups){for(e=0,f=i.settings.optgroups.length;f>e;e++)i.registerOptionGroup(i.settings.optgroups[e]);delete i.settings.optgroups}i.settings.mode=i.settings.mode||(1===i.settings.maxItems?"single":"multi"),"boolean"!=typeof i.settings.hideSelected&&(i.settings.hideSelected="multi"===i.settings.mode),i.initializePlugins(i.settings.plugins),i.setupCallbacks(),i.setupTemplates(),i.setup()};return e.mixin(L),c.mixin(L),a.extend(L.prototype,{setup:function(){var b,c,d,e,g,h,i,j,k,l=this,m=l.settings,n=l.eventNS,o=a(window),p=a(document),q=l.$input;if(i=l.settings.mode,j=q.attr("class")||"",b=a("<div>").addClass(m.wrapperClass).addClass(j).addClass(i),c=a("<div>").addClass(m.inputClass).addClass("items").appendTo(b),d=a('<input type="text" autocomplete="off" />').appendTo(c).attr("tabindex",q.is(":disabled")?"-1":l.tabIndex),h=a(m.dropdownParent||b),e=a("<div>").addClass(m.dropdownClass).addClass(i).hide().appendTo(h),g=a("<div>").addClass(m.dropdownContentClass).appendTo(e),l.settings.copyClassesToDropdown&&e.addClass(j),b.css({width:q[0].style.width}),l.plugins.names.length&&(k="plugin-"+l.plugins.names.join(" plugin-"),b.addClass(k),e.addClass(k)),(null===m.maxItems||m.maxItems>1)&&l.tagType===v&&q.attr("multiple","multiple"),l.settings.placeholder&&d.attr("placeholder",m.placeholder),!l.settings.splitOn&&l.settings.delimiter){var u=l.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");l.settings.splitOn=new RegExp("\\s*"+u+"+\\s*")}q.attr("autocorrect")&&d.attr("autocorrect",q.attr("autocorrect")),q.attr("autocapitalize")&&d.attr("autocapitalize",q.attr("autocapitalize")),l.$wrapper=b,l.$control=c,l.$control_input=d,l.$dropdown=e,l.$dropdown_content=g,e.on("mouseenter","[data-selectable]",function(){return l.onOptionHover.apply(l,arguments)}),e.on("mousedown click","[data-selectable]",function(){return l.onOptionSelect.apply(l,arguments)}),G(c,"mousedown","*:not(input)",function(){return l.onItemSelect.apply(l,arguments)}),K(d),c.on({mousedown:function(){return l.onMouseDown.apply(l,arguments)},click:function(){return l.onClick.apply(l,arguments)}}),d.on({mousedown:function(a){a.stopPropagation()},keydown:function(){return l.onKeyDown.apply(l,arguments)},keyup:function(){return l.onKeyUp.apply(l,arguments)},keypress:function(){return l.onKeyPress.apply(l,arguments)},resize:function(){l.positionDropdown.apply(l,[])},blur:function(){return l.onBlur.apply(l,arguments)},focus:function(){return l.ignoreBlur=!1,l.onFocus.apply(l,arguments)},paste:function(){return l.onPaste.apply(l,arguments)}}),p.on("keydown"+n,function(a){l.isCmdDown=a[f?"metaKey":"ctrlKey"],l.isCtrlDown=a[f?"altKey":"ctrlKey"],l.isShiftDown=a.shiftKey}),p.on("keyup"+n,function(a){a.keyCode===t&&(l.isCtrlDown=!1),a.keyCode===r&&(l.isShiftDown=!1),a.keyCode===s&&(l.isCmdDown=!1)}),p.on("mousedown"+n,function(a){if(l.isFocused){if(a.target===l.$dropdown[0]||a.target.parentNode===l.$dropdown[0])return!1;l.$control.has(a.target).length||a.target===l.$control[0]||l.blur(a.target)}}),o.on(["scroll"+n,"resize"+n].join(" "),function(){l.isOpen&&l.positionDropdown.apply(l,arguments)}),o.on("mousemove"+n,function(){l.ignoreHover=!1}),this.revertSettings={$children:q.children().detach(),tabindex:q.attr("tabindex")},q.attr("tabindex",-1).hide().after(l.$wrapper),a.isArray(m.items)&&(l.setValue(m.items),delete m.items),x&&q.on("invalid"+n,function(a){a.preventDefault(),l.isInvalid=!0,l.refreshState()}),l.updateOriginalInput(),l.refreshItems(),l.refreshState(),l.updatePlaceholder(),l.isSetup=!0,q.is(":disabled")&&l.disable(),l.on("change",this.onChange),q.data("selectize",l),q.addClass("selectized"),l.trigger("initialize"),m.preload===!0&&l.onSearchChange("")},setupTemplates:function(){var b=this,c=b.settings.labelField,d=b.settings.optgroupLabelField,e={optgroup:function(a){return'<div class="optgroup">'+a.html+"</div>"},optgroup_header:function(a,b){return'<div class="optgroup-header">'+b(a[d])+"</div>"},option:function(a,b){return'<div class="option">'+b(a[c])+"</div>"},item:function(a,b){return'<div class="item">'+b(a[c])+"</div>"},option_create:function(a,b){return'<div class="create">Add <strong>'+b(a.input)+"</strong>&hellip;</div>"}};b.settings.render=a.extend({},e,b.settings.render)},setupCallbacks:function(){var a,b,c={initialize:"onInitialize",change:"onChange",item_add:"onItemAdd",item_remove:"onItemRemove",clear:"onClear",option_add:"onOptionAdd",option_remove:"onOptionRemove",option_clear:"onOptionClear",optgroup_add:"onOptionGroupAdd",optgroup_remove:"onOptionGroupRemove",optgroup_clear:"onOptionGroupClear",dropdown_open:"onDropdownOpen",dropdown_close:"onDropdownClose",type:"onType",load:"onLoad",focus:"onFocus",blur:"onBlur"};for(a in c)c.hasOwnProperty(a)&&(b=this.settings[c[a]],b&&this.on(a,b))},onClick:function(a){var b=this;b.isFocused||(b.focus(),a.preventDefault())},onMouseDown:function(b){{var c=this,d=b.isDefaultPrevented();a(b.target)}if(c.isFocused){if(b.target!==c.$control_input[0])return"single"===c.settings.mode?c.isOpen?c.close():c.open():d||c.setActiveItem(null),!1}else d||window.setTimeout(function(){c.focus()},0)},onChange:function(){this.$input.trigger("change")},onPaste:function(b){var c=this;c.isFull()||c.isInputHidden||c.isLocked?b.preventDefault():c.settings.splitOn&&setTimeout(function(){for(var b=a.trim(c.$control_input.val()||"").split(c.settings.splitOn),d=0,e=b.length;e>d;d++)c.createItem(b[d])},0)},onKeyPress:function(a){if(this.isLocked)return a&&a.preventDefault();var b=String.fromCharCode(a.keyCode||a.which);return this.settings.create&&"multi"===this.settings.mode&&b===this.settings.delimiter?(this.createItem(),a.preventDefault(),!1):void 0},onKeyDown:function(a){var b=(a.target===this.$control_input[0],this);if(b.isLocked)return void(a.keyCode!==u&&a.preventDefault());switch(a.keyCode){case g:if(b.isCmdDown)return void b.selectAll();break;case i:return void(b.isOpen&&(a.preventDefault(),a.stopPropagation(),b.close()));case o:if(!a.ctrlKey||a.altKey)break;case n:if(!b.isOpen&&b.hasOptions)b.open();else if(b.$activeOption){b.ignoreHover=!0;var c=b.getAdjacentOption(b.$activeOption,1);c.length&&b.setActiveOption(c,!0,!0)}return void a.preventDefault();case l:if(!a.ctrlKey||a.altKey)break;case k:if(b.$activeOption){b.ignoreHover=!0;var d=b.getAdjacentOption(b.$activeOption,-1);d.length&&b.setActiveOption(d,!0,!0)}return void a.preventDefault();case h:return void(b.isOpen&&b.$activeOption&&(b.onOptionSelect({currentTarget:b.$activeOption}),a.preventDefault()));case j:return void b.advanceSelection(-1,a);case m:return void b.advanceSelection(1,a);case u:return b.settings.selectOnTab&&b.isOpen&&b.$activeOption&&(b.onOptionSelect({currentTarget:b.$activeOption}),b.isFull()||a.preventDefault()),void(b.settings.create&&b.createItem()&&a.preventDefault());case p:case q:return void b.deleteSelection(a)}return!b.isFull()&&!b.isInputHidden||(f?a.metaKey:a.ctrlKey)?void 0:void a.preventDefault()},onKeyUp:function(a){var b=this;if(b.isLocked)return a&&a.preventDefault();var c=b.$control_input.val()||"";b.lastValue!==c&&(b.lastValue=c,b.onSearchChange(c),b.refreshOptions(),b.trigger("type",c))},onSearchChange:function(a){var b=this,c=b.settings.load;c&&(b.loadedSearches.hasOwnProperty(a)||(b.loadedSearches[a]=!0,b.load(function(d){c.apply(b,[a,d])})))},onFocus:function(a){var b=this,c=b.isFocused;return b.isDisabled?(b.blur(),a&&a.preventDefault(),!1):void(b.ignoreFocus||(b.isFocused=!0,"focus"===b.settings.preload&&b.onSearchChange(""),c||b.trigger("focus"),b.$activeItems.length||(b.showInput(),b.setActiveItem(null),b.refreshOptions(!!b.settings.openOnFocus)),b.refreshState()))},onBlur:function(a,b){var c=this;if(c.isFocused&&(c.isFocused=!1,!c.ignoreFocus)){if(!c.ignoreBlur&&document.activeElement===c.$dropdown_content[0])return c.ignoreBlur=!0,void c.onFocus(a);var d=function(){c.close(),c.setTextboxValue(""),c.setActiveItem(null),c.setActiveOption(null),c.setCaret(c.items.length),c.refreshState(),(b||document.body).focus(),c.ignoreFocus=!1,c.trigger("blur")};c.ignoreFocus=!0,c.settings.create&&c.settings.createOnBlur?c.createItem(null,!1,d):d()}},onOptionHover:function(a){this.ignoreHover||this.setActiveOption(a.currentTarget,!1)},onOptionSelect:function(b){var c,d,e=this;b.preventDefault&&(b.preventDefault(),b.stopPropagation()),d=a(b.currentTarget),d.hasClass("create")?e.createItem(null,function(){e.settings.closeAfterSelect&&e.close()}):(c=d.attr("data-value"),"undefined"!=typeof c&&(e.lastQuery=null,e.setTextboxValue(""),e.addItem(c),e.settings.closeAfterSelect?e.close():!e.settings.hideSelected&&b.type&&/mouse/.test(b.type)&&e.setActiveOption(e.getOption(c))))},onItemSelect:function(a){var b=this;b.isLocked||"multi"===b.settings.mode&&(a.preventDefault(),b.setActiveItem(a.currentTarget,a))},load:function(a){var b=this,c=b.$wrapper.addClass(b.settings.loadingClass);b.loading++,a.apply(b,[function(a){b.loading=Math.max(b.loading-1,0),a&&a.length&&(b.addOption(a),b.refreshOptions(b.isFocused&&!b.isInputHidden)),b.loading||c.removeClass(b.settings.loadingClass),b.trigger("load",a)}])},setTextboxValue:function(a){var b=this.$control_input,c=b.val()!==a;c&&(b.val(a).triggerHandler("update"),this.lastValue=a)},getValue:function(){return this.tagType===v&&this.$input.attr("multiple")?this.items:this.items.join(this.settings.delimiter)},setValue:function(a,b){var c=b?[]:["change"];F(this,c,function(){this.clear(b),this.addItems(a,b)})},setActiveItem:function(b,c){var d,e,f,g,h,i,j,k,l=this;if("single"!==l.settings.mode){if(b=a(b),!b.length)return a(l.$activeItems).removeClass("active"),l.$activeItems=[],void(l.isFocused&&l.showInput());if(d=c&&c.type.toLowerCase(),"mousedown"===d&&l.isShiftDown&&l.$activeItems.length){for(k=l.$control.children(".active:last"),g=Array.prototype.indexOf.apply(l.$control[0].childNodes,[k[0]]),h=Array.prototype.indexOf.apply(l.$control[0].childNodes,[b[0]]),g>h&&(j=g,g=h,h=j),e=g;h>=e;e++)i=l.$control[0].childNodes[e],-1===l.$activeItems.indexOf(i)&&(a(i).addClass("active"),l.$activeItems.push(i));c.preventDefault()}else"mousedown"===d&&l.isCtrlDown||"keydown"===d&&this.isShiftDown?b.hasClass("active")?(f=l.$activeItems.indexOf(b[0]),l.$activeItems.splice(f,1),b.removeClass("active")):l.$activeItems.push(b.addClass("active")[0]):(a(l.$activeItems).removeClass("active"),l.$activeItems=[b.addClass("active")[0]]);l.hideInput(),this.isFocused||l.focus()}},setActiveOption:function(b,c,d){var e,f,g,h,i,j=this;j.$activeOption&&j.$activeOption.removeClass("active"),j.$activeOption=null,b=a(b),b.length&&(j.$activeOption=b.addClass("active"),(c||!y(c))&&(e=j.$dropdown_content.height(),f=j.$activeOption.outerHeight(!0),c=j.$dropdown_content.scrollTop()||0,g=j.$activeOption.offset().top-j.$dropdown_content.offset().top+c,h=g,i=g-e+f,g+f>e+c?j.$dropdown_content.stop().animate({scrollTop:i},d?j.settings.scrollDuration:0):c>g&&j.$dropdown_content.stop().animate({scrollTop:h},d?j.settings.scrollDuration:0)))},selectAll:function(){var a=this;"single"!==a.settings.mode&&(a.$activeItems=Array.prototype.slice.apply(a.$control.children(":not(input)").addClass("active")),a.$activeItems.length&&(a.hideInput(),a.close()),a.focus())},hideInput:function(){var a=this;a.setTextboxValue(""),a.$control_input.css({opacity:0,position:"absolute",left:a.rtl?1e4:-1e4}),a.isInputHidden=!0},showInput:function(){this.$control_input.css({opacity:1,position:"relative",left:0}),this.isInputHidden=!1},focus:function(){var a=this;a.isDisabled||(a.ignoreFocus=!0,a.$control_input[0].focus(),window.setTimeout(function(){a.ignoreFocus=!1,a.onFocus()},0))},blur:function(a){this.$control_input[0].blur(),this.onBlur(null,a)},getScoreFunction:function(a){return this.sifter.getScoreFunction(a,this.getSearchOptions())},getSearchOptions:function(){var a=this.settings,b=a.sortField;return"string"==typeof b&&(b=[{field:b}]),{fields:a.searchField,conjunction:a.searchConjunction,sort:b}},search:function(b){var c,d,e,f=this,g=f.settings,h=this.getSearchOptions();if(g.score&&(e=f.settings.score.apply(this,[b]),"function"!=typeof e))throw new Error('Selectize "score" setting must be a function that returns a function');if(b!==f.lastQuery?(f.lastQuery=b,d=f.sifter.search(b,a.extend(h,{score:e})),f.currentResults=d):d=a.extend(!0,{},f.currentResults),g.hideSelected)for(c=d.items.length-1;c>=0;c--)-1!==f.items.indexOf(z(d.items[c].id))&&d.items.splice(c,1);return d},refreshOptions:function(b){var c,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s;"undefined"==typeof b&&(b=!0);var t=this,u=a.trim(t.$control_input.val()),v=t.search(u),w=t.$dropdown_content,x=t.$activeOption&&z(t.$activeOption.attr("data-value"));for(g=v.items.length,"number"==typeof t.settings.maxOptions&&(g=Math.min(g,t.settings.maxOptions)),h={},i=[],c=0;g>c;c++)for(j=t.options[v.items[c].id],k=t.render("option",j),l=j[t.settings.optgroupField]||"",m=a.isArray(l)?l:[l],e=0,f=m&&m.length;f>e;e++)l=m[e],t.optgroups.hasOwnProperty(l)||(l=""),h.hasOwnProperty(l)||(h[l]=[],i.push(l)),h[l].push(k);for(this.settings.lockOptgroupOrder&&i.sort(function(a,b){var c=t.optgroups[a].$order||0,d=t.optgroups[b].$order||0;return c-d}),n=[],c=0,g=i.length;g>c;c++)l=i[c],t.optgroups.hasOwnProperty(l)&&h[l].length?(o=t.render("optgroup_header",t.optgroups[l])||"",o+=h[l].join(""),n.push(t.render("optgroup",a.extend({},t.optgroups[l],{html:o})))):n.push(h[l].join(""));if(w.html(n.join("")),t.settings.highlight&&v.query.length&&v.tokens.length)for(c=0,g=v.tokens.length;g>c;c++)d(w,v.tokens[c].regex);if(!t.settings.hideSelected)for(c=0,g=t.items.length;g>c;c++)t.getOption(t.items[c]).addClass("selected");p=t.canCreate(u),p&&(w.prepend(t.render("option_create",{input:u})),s=a(w[0].childNodes[0])),t.hasOptions=v.items.length>0||p,t.hasOptions?(v.items.length>0?(r=x&&t.getOption(x),r&&r.length?q=r:"single"===t.settings.mode&&t.items.length&&(q=t.getOption(t.items[0])),q&&q.length||(q=s&&!t.settings.addPrecedence?t.getAdjacentOption(s,1):w.find("[data-selectable]:first"))):q=s,t.setActiveOption(q),b&&!t.isOpen&&t.open()):(t.setActiveOption(null),b&&t.isOpen&&t.close())},addOption:function(b){var c,d,e,f=this;if(a.isArray(b))for(c=0,d=b.length;d>c;c++)f.addOption(b[c]);else(e=f.registerOption(b))&&(f.userOptions[e]=!0,f.lastQuery=null,f.trigger("option_add",e,b))},registerOption:function(a){var b=z(a[this.settings.valueField]);return!b||this.options.hasOwnProperty(b)?!1:(a.$order=a.$order||++this.order,this.options[b]=a,b)},registerOptionGroup:function(a){var b=z(a[this.settings.optgroupValueField]);return b?(a.$order=a.$order||++this.order,this.optgroups[b]=a,b):!1},addOptionGroup:function(a,b){b[this.settings.optgroupValueField]=a,(a=this.registerOptionGroup(b))&&this.trigger("optgroup_add",a,b)},removeOptionGroup:function(a){this.optgroups.hasOwnProperty(a)&&(delete this.optgroups[a],this.renderCache={},this.trigger("optgroup_remove",a))},clearOptionGroups:function(){this.optgroups={},this.renderCache={},this.trigger("optgroup_clear")},updateOption:function(b,c){var d,e,f,g,h,i,j,k=this;if(b=z(b),f=z(c[k.settings.valueField]),null!==b&&k.options.hasOwnProperty(b)){if("string"!=typeof f)throw new Error("Value must be set in option data");j=k.options[b].$order,f!==b&&(delete k.options[b],g=k.items.indexOf(b),-1!==g&&k.items.splice(g,1,f)),c.$order=c.$order||j,k.options[f]=c,h=k.renderCache.item,i=k.renderCache.option,h&&(delete h[b],delete h[f]),i&&(delete i[b],delete i[f]),-1!==k.items.indexOf(f)&&(d=k.getItem(b),e=a(k.render("item",c)),d.hasClass("active")&&e.addClass("active"),d.replaceWith(e)),k.lastQuery=null,k.isOpen&&k.refreshOptions(!1)}},removeOption:function(a,b){var c=this;a=z(a);var d=c.renderCache.item,e=c.renderCache.option;d&&delete d[a],e&&delete e[a],delete c.userOptions[a],delete c.options[a],c.lastQuery=null,c.trigger("option_remove",a),c.removeItem(a,b)},clearOptions:function(){var a=this;a.loadedSearches={},a.userOptions={},a.renderCache={},a.options=a.sifter.items={},a.lastQuery=null,a.trigger("option_clear"),a.clear()},getOption:function(a){return this.getElementWithValue(a,this.$dropdown_content.find("[data-selectable]"))},getAdjacentOption:function(b,c){var d=this.$dropdown.find("[data-selectable]"),e=d.index(b)+c;return e>=0&&e<d.length?d.eq(e):a()},getElementWithValue:function(b,c){if(b=z(b),"undefined"!=typeof b&&null!==b)for(var d=0,e=c.length;e>d;d++)if(c[d].getAttribute("data-value")===b)return a(c[d]);return a()},getItem:function(a){return this.getElementWithValue(a,this.$control.children())},addItems:function(b,c){for(var d=a.isArray(b)?b:[b],e=0,f=d.length;f>e;e++)this.isPending=f-1>e,this.addItem(d[e],c)},addItem:function(b,c){var d=c?[]:["change"];F(this,d,function(){var d,e,f,g,h,i=this,j=i.settings.mode;return b=z(b),-1!==i.items.indexOf(b)?void("single"===j&&i.close()):void(i.options.hasOwnProperty(b)&&("single"===j&&i.clear(c),"multi"===j&&i.isFull()||(d=a(i.render("item",i.options[b])),h=i.isFull(),i.items.splice(i.caretPos,0,b),i.insertAtCaret(d),(!i.isPending||!h&&i.isFull())&&i.refreshState(),i.isSetup&&(f=i.$dropdown_content.find("[data-selectable]"),i.isPending||(e=i.getOption(b),g=i.getAdjacentOption(e,1).attr("data-value"),i.refreshOptions(i.isFocused&&"single"!==j),g&&i.setActiveOption(i.getOption(g))),!f.length||i.isFull()?i.close():i.positionDropdown(),i.updatePlaceholder(),i.trigger("item_add",b,d),i.updateOriginalInput({silent:c})))))})},removeItem:function(a,b){var c,d,e,f=this;c="object"==typeof a?a:f.getItem(a),a=z(c.attr("data-value")),d=f.items.indexOf(a),-1!==d&&(c.remove(),c.hasClass("active")&&(e=f.$activeItems.indexOf(c[0]),f.$activeItems.splice(e,1)),f.items.splice(d,1),f.lastQuery=null,!f.settings.persist&&f.userOptions.hasOwnProperty(a)&&f.removeOption(a,b),d<f.caretPos&&f.setCaret(f.caretPos-1),f.refreshState(),f.updatePlaceholder(),f.updateOriginalInput({silent:b}),f.positionDropdown(),f.trigger("item_remove",a,c))},createItem:function(b,c){var d=this,e=d.caretPos;b=b||a.trim(d.$control_input.val()||"");var f=arguments[arguments.length-1];if("function"!=typeof f&&(f=function(){}),"boolean"!=typeof c&&(c=!0),!d.canCreate(b))return f(),!1;d.lock();var g="function"==typeof d.settings.create?this.settings.create:function(a){var b={};return b[d.settings.labelField]=a,b[d.settings.valueField]=a,b},h=D(function(a){if(d.unlock(),!a||"object"!=typeof a)return f();var b=z(a[d.settings.valueField]);return"string"!=typeof b?f():(d.setTextboxValue(""),d.addOption(a),d.setCaret(e),d.addItem(b),d.refreshOptions(c&&"single"!==d.settings.mode),void f(a))}),i=g.apply(this,[b,h]);return"undefined"!=typeof i&&h(i),!0},refreshItems:function(){this.lastQuery=null,this.isSetup&&this.addItem(this.items),this.refreshState(),this.updateOriginalInput()},refreshState:function(){var a,b=this;b.isRequired&&(b.items.length&&(b.isInvalid=!1),b.$control_input.prop("required",a)),b.refreshClasses()},refreshClasses:function(){var b=this,c=b.isFull(),d=b.isLocked;b.$wrapper.toggleClass("rtl",b.rtl),b.$control.toggleClass("focus",b.isFocused).toggleClass("disabled",b.isDisabled).toggleClass("required",b.isRequired).toggleClass("invalid",b.isInvalid).toggleClass("locked",d).toggleClass("full",c).toggleClass("not-full",!c).toggleClass("input-active",b.isFocused&&!b.isInputHidden).toggleClass("dropdown-active",b.isOpen).toggleClass("has-options",!a.isEmptyObject(b.options)).toggleClass("has-items",b.items.length>0),b.$control_input.data("grow",!c&&!d)},isFull:function(){return null!==this.settings.maxItems&&this.items.length>=this.settings.maxItems},updateOriginalInput:function(a){var b,c,d,e,f=this;if(a=a||{},f.tagType===v){for(d=[],b=0,c=f.items.length;c>b;b++)e=f.options[f.items[b]][f.settings.labelField]||"",d.push('<option value="'+A(f.items[b])+'" selected="selected">'+A(e)+"</option>");d.length||this.$input.attr("multiple")||d.push('<option value="" selected="selected"></option>'),f.$input.html(d.join(""))}else f.$input.val(f.getValue()),f.$input.attr("value",f.$input.val());f.isSetup&&(a.silent||f.trigger("change",f.$input.val()))},updatePlaceholder:function(){if(this.settings.placeholder){var a=this.$control_input;this.items.length?a.removeAttr("placeholder"):a.attr("placeholder",this.settings.placeholder),a.triggerHandler("update",{force:!0})}},open:function(){var a=this;a.isLocked||a.isOpen||"multi"===a.settings.mode&&a.isFull()||(a.focus(),a.isOpen=!0,a.refreshState(),a.$dropdown.css({visibility:"hidden",display:"block"}),a.positionDropdown(),a.$dropdown.css({visibility:"visible"}),a.trigger("dropdown_open",a.$dropdown))},close:function(){var a=this,b=a.isOpen;"single"===a.settings.mode&&a.items.length&&a.hideInput(),a.isOpen=!1,a.$dropdown.hide(),a.setActiveOption(null),a.refreshState(),b&&a.trigger("dropdown_close",a.$dropdown)},positionDropdown:function(){var a=this.$control,b="body"===this.settings.dropdownParent?a.offset():a.position();b.top+=a.outerHeight(!0),this.$dropdown.css({width:a.outerWidth(),top:b.top,left:b.left})},clear:function(a){var b=this;b.items.length&&(b.$control.children(":not(input)").remove(),b.items=[],b.lastQuery=null,b.setCaret(0),b.setActiveItem(null),b.updatePlaceholder(),b.updateOriginalInput({silent:a}),b.refreshState(),b.showInput(),b.trigger("clear"))},insertAtCaret:function(b){var c=Math.min(this.caretPos,this.items.length);0===c?this.$control.prepend(b):a(this.$control[0].childNodes[c]).before(b),this.setCaret(c+1)},deleteSelection:function(b){var c,d,e,f,g,h,i,j,k,l=this;if(e=b&&b.keyCode===p?-1:1,f=H(l.$control_input[0]),l.$activeOption&&!l.settings.hideSelected&&(i=l.getAdjacentOption(l.$activeOption,-1).attr("data-value")),g=[],l.$activeItems.length){for(k=l.$control.children(".active:"+(e>0?"last":"first")),h=l.$control.children(":not(input)").index(k),e>0&&h++,c=0,d=l.$activeItems.length;d>c;c++)g.push(a(l.$activeItems[c]).attr("data-value"));
b&&(b.preventDefault(),b.stopPropagation())}else(l.isFocused||"single"===l.settings.mode)&&l.items.length&&(0>e&&0===f.start&&0===f.length?g.push(l.items[l.caretPos-1]):e>0&&f.start===l.$control_input.val().length&&g.push(l.items[l.caretPos]));if(!g.length||"function"==typeof l.settings.onDelete&&l.settings.onDelete.apply(l,[g])===!1)return!1;for("undefined"!=typeof h&&l.setCaret(h);g.length;)l.removeItem(g.pop());return l.showInput(),l.positionDropdown(),l.refreshOptions(!0),i&&(j=l.getOption(i),j.length&&l.setActiveOption(j)),!0},advanceSelection:function(a,b){var c,d,e,f,g,h,i=this;0!==a&&(i.rtl&&(a*=-1),c=a>0?"last":"first",d=H(i.$control_input[0]),i.isFocused&&!i.isInputHidden?(f=i.$control_input.val().length,g=0>a?0===d.start&&0===d.length:d.start===f,g&&!f&&i.advanceCaret(a,b)):(h=i.$control.children(".active:"+c),h.length&&(e=i.$control.children(":not(input)").index(h),i.setActiveItem(null),i.setCaret(a>0?e+1:e))))},advanceCaret:function(a,b){var c,d,e=this;0!==a&&(c=a>0?"next":"prev",e.isShiftDown?(d=e.$control_input[c](),d.length&&(e.hideInput(),e.setActiveItem(d),b&&b.preventDefault())):e.setCaret(e.caretPos+a))},setCaret:function(b){var c=this;if(b="single"===c.settings.mode?c.items.length:Math.max(0,Math.min(c.items.length,b)),!c.isPending){var d,e,f,g;for(f=c.$control.children(":not(input)"),d=0,e=f.length;e>d;d++)g=a(f[d]).detach(),b>d?c.$control_input.before(g):c.$control.append(g)}c.caretPos=b},lock:function(){this.close(),this.isLocked=!0,this.refreshState()},unlock:function(){this.isLocked=!1,this.refreshState()},disable:function(){var a=this;a.$input.prop("disabled",!0),a.$control_input.prop("disabled",!0).prop("tabindex",-1),a.isDisabled=!0,a.lock()},enable:function(){var a=this;a.$input.prop("disabled",!1),a.$control_input.prop("disabled",!1).prop("tabindex",a.tabIndex),a.isDisabled=!1,a.unlock()},destroy:function(){var b=this,c=b.eventNS,d=b.revertSettings;b.trigger("destroy"),b.off(),b.$wrapper.remove(),b.$dropdown.remove(),b.$input.html("").append(d.$children).removeAttr("tabindex").removeClass("selectized").attr({tabindex:d.tabindex}).show(),b.$control_input.removeData("grow"),b.$input.removeData("selectize"),a(window).off(c),a(document).off(c),a(document.body).off(c),delete b.$input[0].selectize},render:function(a,b){var c,d,e="",f=!1,g=this,h=/^[\t \r\n]*<([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?)/i;return("option"===a||"item"===a)&&(c=z(b[g.settings.valueField]),f=!!c),f&&(y(g.renderCache[a])||(g.renderCache[a]={}),g.renderCache[a].hasOwnProperty(c))?g.renderCache[a][c]:(e=g.settings.render[a].apply(this,[b,A]),("option"===a||"option_create"===a)&&(e=e.replace(h,"<$1 data-selectable")),"optgroup"===a&&(d=b[g.settings.optgroupValueField]||"",e=e.replace(h,'<$1 data-group="'+B(A(d))+'"')),("option"===a||"item"===a)&&(e=e.replace(h,'<$1 data-value="'+B(A(c||""))+'"')),f&&(g.renderCache[a][c]=e),e)},clearCache:function(a){var b=this;"undefined"==typeof a?b.renderCache={}:delete b.renderCache[a]},canCreate:function(a){var b=this;if(!b.settings.create)return!1;var c=b.settings.createFilter;return!(!a.length||"function"==typeof c&&!c.apply(b,[a])||"string"==typeof c&&!new RegExp(c).test(a)||c instanceof RegExp&&!c.test(a))}}),L.count=0,L.defaults={options:[],optgroups:[],plugins:[],delimiter:",",splitOn:null,persist:!0,diacritics:!0,create:!1,createOnBlur:!1,createFilter:null,highlight:!0,openOnFocus:!0,maxOptions:1e3,maxItems:null,hideSelected:null,addPrecedence:!1,selectOnTab:!1,preload:!1,allowEmptyOption:!1,closeAfterSelect:!1,scrollDuration:60,loadThrottle:300,loadingClass:"loading",dataAttr:"data-data",optgroupField:"optgroup",valueField:"value",labelField:"text",optgroupLabelField:"label",optgroupValueField:"value",lockOptgroupOrder:!1,sortField:"$order",searchField:["text"],searchConjunction:"and",mode:null,wrapperClass:"selectize-control",inputClass:"selectize-input",dropdownClass:"selectize-dropdown",dropdownContentClass:"selectize-dropdown-content",dropdownParent:null,copyClassesToDropdown:!0,render:{}},a.fn.selectize=function(b){var c=a.fn.selectize.defaults,d=a.extend({},c,b),e=d.dataAttr,f=d.labelField,g=d.valueField,h=d.optgroupField,i=d.optgroupLabelField,j=d.optgroupValueField,k=function(b,c){var h,i,j,k,l=b.attr(e);if(l)for(c.options=JSON.parse(l),h=0,i=c.options.length;i>h;h++)c.items.push(c.options[h][g]);else{var m=a.trim(b.val()||"");if(!d.allowEmptyOption&&!m.length)return;for(j=m.split(d.delimiter),h=0,i=j.length;i>h;h++)k={},k[f]=j[h],k[g]=j[h],c.options.push(k);c.items=j}},l=function(b,c){var k,l,m,n,o=c.options,p={},q=function(a){var b=e&&a.attr(e);return"string"==typeof b&&b.length?JSON.parse(b):null},r=function(b,e){b=a(b);var i=z(b.attr("value"));if(i||d.allowEmptyOption)if(p.hasOwnProperty(i)){if(e){var j=p[i][h];j?a.isArray(j)?j.push(e):p[i][h]=[j,e]:p[i][h]=e}}else{var k=q(b)||{};k[f]=k[f]||b.text(),k[g]=k[g]||i,k[h]=k[h]||e,p[i]=k,o.push(k),b.is(":selected")&&c.items.push(i)}},s=function(b){var d,e,f,g,h;for(b=a(b),f=b.attr("label"),f&&(g=q(b)||{},g[i]=f,g[j]=f,c.optgroups.push(g)),h=a("option",b),d=0,e=h.length;e>d;d++)r(h[d],f)};for(c.maxItems=b.attr("multiple")?null:1,n=b.children(),k=0,l=n.length;l>k;k++)m=n[k].tagName.toLowerCase(),"optgroup"===m?s(n[k]):"option"===m&&r(n[k])};return this.each(function(){if(!this.selectize){var e,f=a(this),g=this.tagName.toLowerCase(),h=f.attr("placeholder")||f.attr("data-placeholder");h||d.allowEmptyOption||(h=f.children('option[value=""]').text());var i={placeholder:h,options:[],optgroups:[],items:[]};"select"===g?l(f,i):k(f,i),e=new L(f,a.extend(!0,{},c,i,b))}})},a.fn.selectize.defaults=L.defaults,a.fn.selectize.support={validity:x},L.define("drag_drop",function(){if(!a.fn.sortable)throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');if("multi"===this.settings.mode){var b=this;b.lock=function(){var a=b.lock;return function(){var c=b.$control.data("sortable");return c&&c.disable(),a.apply(b,arguments)}}(),b.unlock=function(){var a=b.unlock;return function(){var c=b.$control.data("sortable");return c&&c.enable(),a.apply(b,arguments)}}(),b.setup=function(){var c=b.setup;return function(){c.apply(this,arguments);var d=b.$control.sortable({items:"[data-value]",forcePlaceholderSize:!0,disabled:b.isLocked,start:function(a,b){b.placeholder.css("width",b.helper.css("width")),d.css({overflow:"visible"})},stop:function(){d.css({overflow:"hidden"});var c=b.$activeItems?b.$activeItems.slice():null,e=[];d.children("[data-value]").each(function(){e.push(a(this).attr("data-value"))}),b.setValue(e),b.setActiveItem(c)}})}}()}}),L.define("dropdown_header",function(b){var c=this;b=a.extend({title:"Untitled",headerClass:"selectize-dropdown-header",titleRowClass:"selectize-dropdown-header-title",labelClass:"selectize-dropdown-header-label",closeClass:"selectize-dropdown-header-close",html:function(a){return'<div class="'+a.headerClass+'"><div class="'+a.titleRowClass+'"><span class="'+a.labelClass+'">'+a.title+'</span><a href="javascript:void(0)" class="'+a.closeClass+'">&times;</a></div></div>'}},b),c.setup=function(){var d=c.setup;return function(){d.apply(c,arguments),c.$dropdown_header=a(b.html(b)),c.$dropdown.prepend(c.$dropdown_header)}}()}),L.define("optgroup_columns",function(b){var c=this;b=a.extend({equalizeWidth:!0,equalizeHeight:!0},b),this.getAdjacentOption=function(b,c){var d=b.closest("[data-group]").find("[data-selectable]"),e=d.index(b)+c;return e>=0&&e<d.length?d.eq(e):a()},this.onKeyDown=function(){var a=c.onKeyDown;return function(b){var d,e,f,g;return!this.isOpen||b.keyCode!==j&&b.keyCode!==m?a.apply(this,arguments):(c.ignoreHover=!0,g=this.$activeOption.closest("[data-group]"),d=g.find("[data-selectable]").index(this.$activeOption),g=b.keyCode===j?g.prev("[data-group]"):g.next("[data-group]"),f=g.find("[data-selectable]"),e=f.eq(Math.min(f.length-1,d)),void(e.length&&this.setActiveOption(e)))}}();var d=function(){var a,b=d.width,c=document;return"undefined"==typeof b&&(a=c.createElement("div"),a.innerHTML='<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>',a=a.firstChild,c.body.appendChild(a),b=d.width=a.offsetWidth-a.clientWidth,c.body.removeChild(a)),b},e=function(){var e,f,g,h,i,j,k;if(k=a("[data-group]",c.$dropdown_content),f=k.length,f&&c.$dropdown_content.width()){if(b.equalizeHeight){for(g=0,e=0;f>e;e++)g=Math.max(g,k.eq(e).height());k.css({height:g})}b.equalizeWidth&&(j=c.$dropdown_content.innerWidth()-d(),h=Math.round(j/f),k.css({width:h}),f>1&&(i=j-h*(f-1),k.eq(f-1).css({width:i})))}};(b.equalizeHeight||b.equalizeWidth)&&(C.after(this,"positionDropdown",e),C.after(this,"refreshOptions",e))}),L.define("remove_button",function(b){if("single"!==this.settings.mode){b=a.extend({label:"&times;",title:"Remove",className:"remove",append:!0},b);var c=this,d='<a href="javascript:void(0)" class="'+b.className+'" tabindex="-1" title="'+A(b.title)+'">'+b.label+"</a>",e=function(a,b){var c=a.search(/(<\/[^>]+>\s*)$/);return a.substring(0,c)+b+a.substring(c)};this.setup=function(){var f=c.setup;return function(){if(b.append){var g=c.settings.render.item;c.settings.render.item=function(){return e(g.apply(this,arguments),d)}}f.apply(this,arguments),this.$control.on("click","."+b.className,function(b){if(b.preventDefault(),!c.isLocked){var d=a(b.currentTarget).parent();c.setActiveItem(d),c.deleteSelection()&&c.setCaret(c.items.length)}})}}()}}),L.define("restore_on_backspace",function(a){var b=this;a.text=a.text||function(a){return a[this.settings.labelField]},this.onKeyDown=function(){var c=b.onKeyDown;return function(b){var d,e;return b.keyCode===p&&""===this.$control_input.val()&&!this.$activeItems.length&&(d=this.caretPos-1,d>=0&&d<this.items.length)?(e=this.options[this.items[d]],this.deleteSelection(b)&&(this.setTextboxValue(a.text.apply(this,[e])),this.refreshOptions(!0)),void b.preventDefault()):c.apply(this,arguments)}}()}),L});
</script>
<link rel="stylesheet" type="text/css" href="SimulationsAnimintRegression/vendor/selectize.css" />
<script>
this.driver = this.driver || {};
this.driver.js = (function (I) {
  'use strict';
  let O = {};
  function z(e = {}) {
    O = {
      animate: !0,
      allowClose: !0,
      overlayOpacity: 0.7,
      smoothScroll: !1,
      showProgress: !1,
      stagePadding: 10,
      stageRadius: 5,
      popoverOffset: 10,
      showButtons: ['next', 'previous', 'close'],
      disableButtons: [],
      overlayColor: '#000',
      ...e,
    };
  }
  function s(e) {
    return e ? O[e] : O;
  }
  function W(e, t, o, n) {
    return (e /= n / 2) < 1
      ? (o / 2) * e * e + t
      : (-o / 2) * (--e * (e - 2) - 1) + t;
  }
  function D(e) {
    if (!e || ie(e)) return;
    const t = s('smoothScroll');
    e.scrollIntoView({
      behavior: !t || ne(e) ? 'auto' : 'smooth',
      inline: 'center',
      block: 'center',
    });
  }
  function ne(e) {
    if (!e || !e.parentElement) return;
    const t = e.parentElement;
    return t.scrollHeight > t.clientHeight;
  }
  function ie(e) {
    const t = e.getBoundingClientRect();
    return (
      t.top >= 0 &&
      t.left >= 0 &&
      t.bottom <=
        (window.innerHeight || document.documentElement.clientHeight) &&
      t.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
  }
  let _ = {};
  function b(e, t) {
    _[e] = t;
  }
  function d(e) {
    return e ? _[e] : _;
  }
  function re() {
    _ = {};
  }
  let T = {};
  function N(e, t) {
    T[e] = t;
  }
  function L(e) {
    var t;
    (t = T[e]) == null || t.call(T);
  }
  function se() {
    T = {};
  }
  function ae(e, t, o, n) {
    let p = d('__activeStagePosition');
    const r = p || o.getBoundingClientRect(),
      f = n.getBoundingClientRect(),
      w = W(e, r.x, f.x - r.x, t),
      i = W(e, r.y, f.y - r.y, t),
      h = W(e, r.width, f.width - r.width, t),
      a = W(e, r.height, f.height - r.height, t);
    (p = { x: w, y: i, width: h, height: a }),
      q(p),
      b('__activeStagePosition', p);
  }
  function F(e) {
    if (!e) return;
    const t = e.getBoundingClientRect(),
      o = { x: t.x, y: t.y, width: t.width, height: t.height };
    b('__activeStagePosition', o), q(o);
  }
  function le() {
    const e = d('__activeStagePosition'),
      t = d('__overlaySvg');
    if (!e) return;
    if (!t) {
      console.warn('No stage svg found.');
      return;
    }
    const o = window.innerWidth,
      n = window.innerHeight;
    t.setAttribute('viewBox', `0 0 ${o} ${n}`);
  }
  function ce(e) {
    const t = de(e);
    document.body.appendChild(t),
      j(t, (o) => {
        o.target.tagName === 'path' && L('overlayClick');
      }),
      b('__overlaySvg', t);
  }
  function q(e) {
    const t = d('__overlaySvg');
    if (!t) {
      ce(e);
      return;
    }
    const o = t.firstElementChild;
    if ((o == null ? void 0 : o.tagName) !== 'path')
      throw new Error('no path element found in stage svg');
    o.setAttribute('d', V(e));
  }
  function de(e) {
    const t = window.innerWidth,
      o = window.innerHeight,
      n = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    n.classList.add('driver-overlay', 'driver-overlay-animated'),
      n.setAttribute('viewBox', `0 0 ${t} ${o}`),
      n.setAttribute('xmlSpace', 'preserve'),
      n.setAttribute('xmlnsXlink', 'http://www.w3.org/1999/xlink'),
      n.setAttribute('version', '1.1'),
      n.setAttribute('preserveAspectRatio', 'xMinYMin slice'),
      (n.style.fillRule = 'evenodd'),
      (n.style.clipRule = 'evenodd'),
      (n.style.strokeLinejoin = 'round'),
      (n.style.strokeMiterlimit = '2'),
      (n.style.zIndex = '10000'),
      (n.style.position = 'fixed'),
      (n.style.top = '0'),
      (n.style.left = '0'),
      (n.style.width = '100%'),
      (n.style.height = '100%');
    const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    return (
      p.setAttribute('d', V(e)),
      (p.style.fill = s('overlayColor') || 'rgb(0,0,0)'),
      (p.style.opacity = `${s('overlayOpacity')}`),
      (p.style.pointerEvents = 'auto'),
      (p.style.cursor = 'auto'),
      n.appendChild(p),
      n
    );
  }
  function V(e) {
    const t = window.innerWidth,
      o = window.innerHeight,
      n = s('stagePadding') || 0,
      p = s('stageRadius') || 0,
      r = e.width + n * 2,
      f = e.height + n * 2,
      w = Math.min(p, r / 2, f / 2),
      i = Math.floor(Math.max(w, 0)),
      h = e.x - n + i,
      a = e.y - n,
      l = r - i * 2,
      c = f - i * 2;
    return `M${t},0L0,0L0,${o}L${t},${o}L${t},0Z
    M${h},${a} h${l} a${i},${i} 0 0 1 ${i},${i} v${c} a${i},${i} 0 0 1 -${i},${i} h-${l} a${i},${i} 0 0 1 -${i},-${i} v-${c} a${i},${i} 0 0 1 ${i},-${i} z`;
  }
  function pe() {
    const e = d('__overlaySvg');
    e && e.remove();
  }
  function ue() {
    const e = document.getElementById('driver-dummy-element');
    if (e) return e;
    let t = document.createElement('div');
    return (
      (t.id = 'driver-dummy-element'),
      (t.style.width = '0'),
      (t.style.height = '0'),
      (t.style.pointerEvents = 'none'),
      (t.style.opacity = '0'),
      (t.style.position = 'fixed'),
      (t.style.top = '50%'),
      (t.style.left = '50%'),
      document.body.appendChild(t),
      t
    );
  }
  function X(e) {
    const { element: t } = e;
    let o = typeof t == 'string' ? document.querySelector(t) : t;
    o || (o = ue()), he(o, e);
  }
  function ve() {
    const e = d('activeElement'),
      t = d('activeStep');
    e && (F(e), le(), J(e, t));
  }
  function he(e, t) {
    const n = Date.now(),
      p = d('activeStep'),
      r = d('activeElement') || e,
      f = !r || r === e,
      w = e.id === 'driver-dummy-element',
      i = r.id === 'driver-dummy-element',
      h = s('animate'),
      a = t.onHighlightStarted || s('onHighlightStarted'),
      l = (t == null ? void 0 : t.onHighlighted) || s('onHighlighted'),
      c = (p == null ? void 0 : p.onDeselected) || s('onDeselected'),
      m = s(),
      g = d();
    !f && c && c(i ? void 0 : r, p, { config: m, state: g }),
      a && a(w ? void 0 : e, t, { config: m, state: g });
    const u = !f && h;
    let v = !1;
    me();
    const P = () => {
      if (d('__transitionCallback') !== P) return;
      const k = Date.now() - n,
        y = 400 - k <= 400 / 2;
      t.popover && y && !v && u && (K(e, t), (v = !0)),
        s('animate') && k < 400
          ? ae(k, 400, r, e)
          : (F(e),
            l && l(w ? void 0 : e, t, { config: s(), state: d() }),
            b('__transitionCallback', void 0),
            b('previousStep', p),
            b('previousElement', r),
            b('activeStep', t),
            b('activeElement', e)),
        window.requestAnimationFrame(P);
    };
    b('__transitionCallback', P),
      window.requestAnimationFrame(P),
      D(e),
      !u && t.popover && K(e, t),
      r.classList.remove('driver-active-element'),
      e.classList.add('driver-active-element');
  }
  function fe() {
    var e;
    (e = document.getElementById('driver-dummy-element')) == null || e.remove(),
      document.querySelectorAll('.driver-active-element').forEach((t) => {
        t.classList.remove('driver-active-element');
      });
  }
  function $() {
    const e = d('__resizeTimeout');
    e && window.cancelAnimationFrame(e),
      b('__resizeTimeout', window.requestAnimationFrame(ve));
  }
  function Y(e) {
    s('allowKeyboardControl');
    e.key === 'Escape'
      ? L('escapePress')
      : e.key === 'ArrowRight'
      ? L('arrowRightPress')
      : e.key === 'ArrowLeft' && L('arrowLeftPress');
  }
  function j(e, t, o) {
    const n = (r, f) => {
      const w = r.target;
      e.contains(w) &&
        ((!o || o(w)) &&
          (r.preventDefault(),
          r.stopPropagation(),
          r.stopImmediatePropagation()),
        f == null || f(r));
    };
    document.addEventListener('pointerdown', n, !0),
      document.addEventListener('mousedown', n, !0),
      document.addEventListener('pointerup', n, !0),
      document.addEventListener('mouseup', n, !0),
      document.addEventListener(
        'click',
        (r) => {
          n(r, t);
        },
        !0
      );
  }
  function ge() {
    window.addEventListener('keyup', Y, !1),
      window.addEventListener('resize', $),
      window.addEventListener('scroll', $);
  }
  function we() {
    window.removeEventListener('keyup', Y),
      window.removeEventListener('resize', $),
      window.removeEventListener('scroll', $);
  }
  function me() {
    const e = d('popover');
    e && (e.wrapper.style.display = 'none');
  }
  function K(e, t) {
    var k, C;
    let o = d('popover');
    o && document.body.removeChild(o.wrapper),
      (o = xe()),
      document.body.appendChild(o.wrapper);
    const {
      title: n,
      description: p,
      showButtons: r,
      disableButtons: f,
      showProgress: w,
      nextBtnText: i = s('nextBtnText') || 'Next &rarr;',
      prevBtnText: h = s('prevBtnText') || '&larr; Previous',
      progressText: a = s('progressText') || '{current} of {total}',
    } = t.popover || {};
    (o.nextButton.innerHTML = i),
      (o.previousButton.innerHTML = h),
      (o.progress.innerHTML = a),
      n
        ? ((o.title.innerText = n), (o.title.style.display = 'block'))
        : (o.title.style.display = 'none'),
      p
        ? ((o.description.innerHTML = p),
          (o.description.style.display = 'block'))
        : (o.description.style.display = 'none');
    const l = r || s('showButtons'),
      c = w || s('showProgress') || !1,
      m =
        (l == null ? void 0 : l.includes('next')) ||
        (l == null ? void 0 : l.includes('previous')) ||
        c;
    (o.closeButton.style.display = l.includes('close') ? 'block' : 'none'),
      m
        ? ((o.footer.style.display = 'flex'),
          (o.progress.style.display = c ? 'block' : 'none'),
          (o.nextButton.style.display = l.includes('next') ? 'block' : 'none'),
          (o.previousButton.style.display = l.includes('previous')
            ? 'block'
            : 'none'))
        : (o.footer.style.display = 'none');
    const g = f || s('disableButtons') || [];
    g != null &&
      g.includes('next') &&
      o.nextButton.classList.add('driver-popover-btn-disabled'),
      g != null &&
        g.includes('previous') &&
        o.previousButton.classList.add('driver-popover-btn-disabled'),
      g != null &&
        g.includes('close') &&
        o.closeButton.classList.add('driver-popover-btn-disabled');
    const u = o.wrapper;
    (u.style.display = 'block'),
      (u.style.left = ''),
      (u.style.top = ''),
      (u.style.bottom = ''),
      (u.style.right = '');
    const v = o.arrow;
    v.className = 'driver-popover-arrow';
    const P =
      ((k = t.popover) == null ? void 0 : k.popoverClass) ||
      s('popoverClass') ||
      '';
    (u.className = `driver-popover ${P}`.trim()),
      j(
        o.wrapper,
        (y) => {
          var A, M, R;
          const x = y.target,
            H =
              ((A = t.popover) == null ? void 0 : A.onNextClick) ||
              s('onNextClick'),
            E =
              ((M = t.popover) == null ? void 0 : M.onPrevClick) ||
              s('onPrevClick'),
            B =
              ((R = t.popover) == null ? void 0 : R.onCloseClick) ||
              s('onCloseClick');
          if (x.classList.contains('driver-popover-next-btn'))
            return H ? H(e, t, { config: s(), state: d() }) : L('nextClick');
          if (x.classList.contains('driver-popover-prev-btn'))
            return E ? E(e, t, { config: s(), state: d() }) : L('prevClick');
          if (x.classList.contains('driver-popover-close-btn'))
            return B ? B(e, t, { config: s(), state: d() }) : L('closeClick');
        },
        (y) =>
          !(o != null && o.description.contains(y)) &&
          !(o != null && o.title.contains(y)) &&
          y.className.includes('driver-popover')
      ),
      b('popover', o),
      J(e, t),
      D(u);
    const S =
      ((C = t.popover) == null ? void 0 : C.onPopoverRendered) ||
      s('onPopoverRendered');
    S && S(o, { config: s(), state: d() });
  }
  function Q() {
    const e = d('popover');
    if (!(e != null && e.wrapper)) return;
    const t = e.wrapper.getBoundingClientRect(),
      o = s('stagePadding') || 0,
      n = s('popoverOffset') || 0;
    return {
      width: t.width + o + n,
      height: t.height + o + n,
      realWidth: t.width,
      realHeight: t.height,
    };
  }
  function Z(e, t) {
    const {
      elementDimensions: o,
      popoverDimensions: n,
      popoverPadding: p,
      popoverArrowDimensions: r,
    } = t;
    return e === 'start'
      ? Math.max(
          Math.min(o.top - p, window.innerHeight - n.realHeight - r.width),
          r.width
        )
      : e === 'end'
      ? Math.max(
          Math.min(
            o.top - (n == null ? void 0 : n.realHeight) + o.height + p,
            window.innerHeight - (n == null ? void 0 : n.realHeight) - r.width
          ),
          r.width
        )
      : e === 'center'
      ? Math.max(
          Math.min(
            o.top + o.height / 2 - (n == null ? void 0 : n.realHeight) / 2,
            window.innerHeight - (n == null ? void 0 : n.realHeight) - r.width
          ),
          r.width
        )
      : 0;
  }
  function G(e, t) {
    const {
      elementDimensions: o,
      popoverDimensions: n,
      popoverPadding: p,
      popoverArrowDimensions: r,
    } = t;
    return e === 'start'
      ? Math.max(
          Math.min(o.left - p, window.innerWidth - n.realWidth - r.width),
          r.width
        )
      : e === 'end'
      ? Math.max(
          Math.min(
            o.left - (n == null ? void 0 : n.realWidth) + o.width + p,
            window.innerWidth - (n == null ? void 0 : n.realWidth) - r.width
          ),
          r.width
        )
      : e === 'center'
      ? Math.max(
          Math.min(
            o.left + o.width / 2 - (n == null ? void 0 : n.realWidth) / 2,
            window.innerWidth - (n == null ? void 0 : n.realWidth) - r.width
          ),
          r.width
        )
      : 0;
  }
  function J(e, t) {
    const o = d('popover');
    if (!o) return;
    const { align: n = 'start', side: p = 'left' } =
        (t == null ? void 0 : t.popover) || {},
      r = n,
      f = e.id === 'driver-dummy-element' ? 'over' : p,
      w = s('stagePadding') || 0,
      i = Q(),
      h = o.arrow.getBoundingClientRect(),
      a = e.getBoundingClientRect(),
      l = a.top - i.height;
    let c = l >= 0;
    const m = window.innerHeight - (a.bottom + i.height);
    let g = m >= 0;
    const u = a.left - i.width;
    let v = u >= 0;
    const P = window.innerWidth - (a.right + i.width);
    let S = P >= 0;
    const k = !c && !g && !v && !S;
    let C = f;
    if (
      (f === 'top' && c
        ? (S = v = g = !1)
        : f === 'bottom' && g
        ? (S = v = c = !1)
        : f === 'left' && v
        ? (S = c = g = !1)
        : f === 'right' && S && (v = c = g = !1),
      f === 'over')
    ) {
      const y = window.innerWidth / 2 - i.realWidth / 2,
        x = window.innerHeight / 2 - i.realHeight / 2;
      (o.wrapper.style.left = `${y}px`),
        (o.wrapper.style.right = 'auto'),
        (o.wrapper.style.top = `${x}px`),
        (o.wrapper.style.bottom = 'auto');
    } else if (k) {
      const y = window.innerWidth / 2 - (i == null ? void 0 : i.realWidth) / 2,
        x = 10;
      (o.wrapper.style.left = `${y}px`),
        (o.wrapper.style.right = 'auto'),
        (o.wrapper.style.bottom = `${x}px`),
        (o.wrapper.style.top = 'auto');
    } else if (v) {
      const y = Math.min(
          u,
          window.innerWidth - (i == null ? void 0 : i.realWidth) - h.width
        ),
        x = Z(r, {
          elementDimensions: a,
          popoverDimensions: i,
          popoverPadding: w,
          popoverArrowDimensions: h,
        });
      (o.wrapper.style.left = `${y}px`),
        (o.wrapper.style.top = `${x}px`),
        (o.wrapper.style.bottom = 'auto'),
        (o.wrapper.style.right = 'auto'),
        (C = 'left');
    } else if (S) {
      const y = Math.min(
          P,
          window.innerWidth - (i == null ? void 0 : i.realWidth) - h.width
        ),
        x = Z(r, {
          elementDimensions: a,
          popoverDimensions: i,
          popoverPadding: w,
          popoverArrowDimensions: h,
        });
      (o.wrapper.style.right = `${y}px`),
        (o.wrapper.style.top = `${x}px`),
        (o.wrapper.style.bottom = 'auto'),
        (o.wrapper.style.left = 'auto'),
        (C = 'right');
    } else if (c) {
      const y = Math.min(l, window.innerHeight - i.realHeight - h.width);
      let x = G(r, {
        elementDimensions: a,
        popoverDimensions: i,
        popoverPadding: w,
        popoverArrowDimensions: h,
      });
      (o.wrapper.style.top = `${y}px`),
        (o.wrapper.style.left = `${x}px`),
        (o.wrapper.style.bottom = 'auto'),
        (o.wrapper.style.right = 'auto'),
        (C = 'top');
    } else if (g) {
      const y = Math.min(
        m,
        window.innerHeight - (i == null ? void 0 : i.realHeight) - h.width
      );
      let x = G(r, {
        elementDimensions: a,
        popoverDimensions: i,
        popoverPadding: w,
        popoverArrowDimensions: h,
      });
      (o.wrapper.style.left = `${x}px`),
        (o.wrapper.style.bottom = `${y}px`),
        (o.wrapper.style.top = 'auto'),
        (o.wrapper.style.right = 'auto'),
        (C = 'bottom');
    }
    k ? o.arrow.classList.add('driver-popover-arrow-none') : ye(r, C, e);
  }
  function ye(e, t, o) {
    const n = d('popover');
    if (!n) return;
    const p = o.getBoundingClientRect(),
      r = Q(),
      f = n.arrow,
      w = r.width,
      i = window.innerWidth,
      h = p.width,
      a = p.left,
      l = r.height,
      c = window.innerHeight,
      m = p.top,
      g = p.height;
    f.className = 'driver-popover-arrow';
    let u = t,
      v = e;
    t === 'top'
      ? (a + h <= 0
          ? ((u = 'right'), (v = 'end'))
          : a + h - w <= 0 && ((u = 'top'), (v = 'start')),
        a >= i
          ? ((u = 'left'), (v = 'end'))
          : a + w >= i && ((u = 'top'), (v = 'end')))
      : t === 'bottom'
      ? (a + h <= 0
          ? ((u = 'right'), (v = 'start'))
          : a + h - w <= 0 && ((u = 'bottom'), (v = 'start')),
        a >= i
          ? ((u = 'left'), (v = 'start'))
          : a + w >= i && ((u = 'bottom'), (v = 'end')))
      : t === 'left'
      ? (m + g <= 0
          ? ((u = 'bottom'), (v = 'end'))
          : m + g - l <= 0 && ((u = 'left'), (v = 'start')),
        m >= c
          ? ((u = 'top'), (v = 'end'))
          : m + l >= c && ((u = 'left'), (v = 'end')))
      : t === 'right' &&
        (m + g <= 0
          ? ((u = 'bottom'), (v = 'start'))
          : m + g - l <= 0 && ((u = 'right'), (v = 'start')),
        m >= c
          ? ((u = 'top'), (v = 'start'))
          : m + l >= c && ((u = 'right'), (v = 'end'))),
      u
        ? (f.classList.add(`driver-popover-arrow-side-${u}`),
          f.classList.add(`driver-popover-arrow-align-${v}`))
        : f.classList.add('driver-popover-arrow-none');
  }
  function xe() {
    const e = document.createElement('div');
    e.classList.add('driver-popover');
    const t = document.createElement('div');
    t.classList.add('driver-popover-arrow');
    const o = document.createElement('div');
    o.classList.add('driver-popover-title'),
      (o.style.display = 'none'),
      (o.innerText = 'Popover Title');
    const n = document.createElement('div');
    n.classList.add('driver-popover-description'),
      (n.style.display = 'none'),
      (n.innerText = 'Popover description is here');
    const p = document.createElement('button');
    p.classList.add('driver-popover-close-btn'), (p.innerHTML = '&times;');
    const r = document.createElement('div');
    r.classList.add('driver-popover-footer');
    const f = document.createElement('span');
    f.classList.add('driver-popover-progress-text'), (f.innerText = '');
    const w = document.createElement('span');
    w.classList.add('driver-popover-navigation-btns');
    const i = document.createElement('button');
    i.classList.add('driver-popover-prev-btn'),
      (i.innerHTML = '&larr; Previous');
    const h = document.createElement('button');
    return (
      h.classList.add('driver-popover-next-btn'),
      (h.innerHTML = 'Next &rarr;'),
      w.appendChild(i),
      w.appendChild(h),
      r.appendChild(f),
      r.appendChild(w),
      e.appendChild(p),
      e.appendChild(t),
      e.appendChild(o),
      e.appendChild(n),
      e.appendChild(r),
      {
        wrapper: e,
        arrow: t,
        title: o,
        description: n,
        footer: r,
        previousButton: i,
        nextButton: h,
        closeButton: p,
        footerButtons: w,
        progress: f,
      }
    );
  }
  function Ce() {
    var t;
    const e = d('popover');
    e && ((t = e.wrapper.parentElement) == null || t.removeChild(e.wrapper));
  }
  const Se = '';
  function be(e = {}) {
    z(e);
    function t() {
      s('allowClose') && h();
    }
    function o() {
      const a = d('activeIndex'),
        l = s('steps') || [];
      if (typeof a > 'u') return;
      const c = a + 1;
      l[c] ? i(c) : h();
    }
    function n() {
      const a = d('activeIndex'),
        l = s('steps') || [];
      if (typeof a > 'u') return;
      const c = a - 1;
      l[c] ? i(c) : h();
    }
    function p(a) {
      (s('steps') || [])[a] ? i(a) : h();
    }
    function r() {
      var v;
      if (d('__transitionCallback')) return;
      const l = d('activeIndex'),
        c = d('activeStep'),
        m = d('activeElement');
      if (typeof l > 'u' || typeof c > 'u' || typeof d('activeIndex') > 'u')
        return;
      const u =
        ((v = c.popover) == null ? void 0 : v.onPrevClick) || s('onPrevClick');
      if (u) return u(m, c, { config: s(), state: d() });
      n();
    }
    function f() {
      var u;
      if (d('__transitionCallback')) return;
      const l = d('activeIndex'),
        c = d('activeStep'),
        m = d('activeElement');
      if (typeof l > 'u' || typeof c > 'u') return;
      const g =
        ((u = c.popover) == null ? void 0 : u.onNextClick) || s('onNextClick');
      if (g) return g(m, c, { config: s(), state: d() });
      o();
    }
    function w() {
      d('isInitialized') ||
        (b('isInitialized', !0),
        document.body.classList.add(
          'driver-active',
          s('animate') ? 'driver-fade' : 'driver-simple'
        ),
        ge(),
        N('overlayClick', t),
        N('escapePress', t),
        N('arrowLeftPress', r),
        N('arrowRightPress', f));
    }
    function i(a = 0) {
      var B, A, M, R, U, ee, te, oe;
      const l = s('steps');
      if (!l) {
        console.error('No steps to drive through'), h();
        return;
      }
      if (!l[a]) {
        h();
        return;
      }
      b('activeIndex', a);
      const c = l[a],
        m = l[a + 1],
        g = l[a - 1],
        u =
          ((B = c.popover) == null ? void 0 : B.doneBtnText) ||
          s('doneBtnText') ||
          'Done',
        v = s('allowClose'),
        P =
          typeof ((A = c.popover) == null ? void 0 : A.showProgress) < 'u'
            ? (M = c.popover) == null
              ? void 0
              : M.showProgress
            : s('showProgress'),
        k = (
          ((R = c.popover) == null ? void 0 : R.progressText) ||
          s('progressText') ||
          '{{current}} of {{total}}'
        )
          .replace('{{current}}', `${a + 1}`)
          .replace('{{total}}', `${l.length}`),
        C =
          ((U = c.popover) == null ? void 0 : U.showButtons) ||
          s('showButtons'),
        y = ['next', 'previous', ...(v ? ['close'] : [])].filter(
          (Pe) => !(C != null && C.length) || C.includes(Pe)
        ),
        x =
          ((ee = c.popover) == null ? void 0 : ee.onNextClick) ||
          s('onNextClick'),
        H =
          ((te = c.popover) == null ? void 0 : te.onPrevClick) ||
          s('onPrevClick'),
        E =
          ((oe = c.popover) == null ? void 0 : oe.onCloseClick) ||
          s('onCloseClick');
      X({
        ...c,
        popover: {
          showButtons: y,
          nextBtnText: m ? void 0 : u,
          disableButtons: [...(g ? [] : ['previous'])],
          showProgress: P,
          progressText: k,
          onNextClick:
            x ||
            (() => {
              m ? i(a + 1) : h();
            }),
          onPrevClick:
            H ||
            (() => {
              i(a - 1);
            }),
          onCloseClick:
            E ||
            (() => {
              h();
            }),
          ...((c == null ? void 0 : c.popover) || {}),
        },
      });
    }
    function h(a = !0) {
      const l = d('activeElement'),
        c = d('activeStep'),
        m = s('onDestroyStarted');
      if (a && m) {
        const v = !l || (l == null ? void 0 : l.id) === 'driver-dummy-element';
        m(v ? void 0 : l, c, { config: s(), state: d() });
        return;
      }
      const g = (c == null ? void 0 : c.onDeselected) || s('onDeselected'),
        u = s('onDestroyed');
      if (
        (document.body.classList.remove(
          'driver-active',
          'driver-fade',
          'driver-simple'
        ),
        we(),
        Ce(),
        fe(),
        pe(),
        se(),
        re(),
        l && c)
      ) {
        const v = l.id === 'driver-dummy-element';
        g && g(v ? void 0 : l, c, { config: s(), state: d() }),
          u && u(v ? void 0 : l, c, { config: s(), state: d() });
      }
    }
    return {
      isActive: () => d('isInitialized') || !1,
      refresh: $,
      drive: (a = 0) => {
        w(), i(a);
      },
      setConfig: z,
      getConfig: s,
      getState: d,
      getActiveIndex: () => d('activeIndex'),
      getActiveStep: () => d('activeStep'),
      getActiveElement: () => d('activeElement'),
      getPreviousElement: () => d('previousElement'),
      getPreviousStep: () => d('previousStep'),
      moveNext: o,
      movePrevious: n,
      moveTo: p,
      hasNextStep: () => {
        const a = s('steps') || [],
          l = d('activeIndex');
        return l !== void 0 && a[l + 1];
      },
      hasPreviousStep: () => {
        const a = s('steps') || [],
          l = d('activeIndex');
        return l !== void 0 && a[l - 1];
      },
      highlight: (a) => {
        w(),
          X({
            ...a,
            popover: a.popover
              ? {
                  showButtons: [],
                  showProgress: !1,
                  progressText: '',
                  ...a.popover,
                }
              : void 0,
          });
      },
      destroy: () => {
        h(!1);
      },
    };
  }
  return (
    (I.driver = be),
    Object.defineProperty(I, Symbol.toStringTag, { value: 'Module' }),
    I
  );
})({});
</script>
<style type="text/css">
.driver-active .driver-overlay,
.driver-active * {
  pointer-events: none
}

.driver-active .driver-active-element,
.driver-active .driver-active-element *,
.driver-popover,
.driver-popover * {
  pointer-events: auto
}

@keyframes animate-fade-in {
  0% {
    opacity: 0
  }

  to {
    opacity: 1
  }
}

.driver-fade .driver-overlay {
  animation: animate-fade-in .2s ease-in-out
}

.driver-fade .driver-popover {
  animation: animate-fade-in .2s
}

.driver-popover {
  all: unset;
  box-sizing: border-box;
  color: #2d2d2d;
  margin: 0;
  padding: 15px;
  border-radius: 5px;
  min-width: 250px;
  max-width: 300px;
  box-shadow: 0 1px 10px #0006;
  z-index: 1000000000;
  position: fixed;
  top: 0;
  right: 0;
  background-color: #fff
}

.driver-popover * {
  font-family: Helvetica Neue, Inter, ui-sans-serif, "Apple Color Emoji", Helvetica, Arial, sans-serif
}

.driver-popover-title {
  font: 19px/normal sans-serif;
  font-weight: 700;
  display: block;
  position: relative;
  line-height: 1.5;
  zoom: 1;
  margin: 0
}

.driver-popover-close-btn {
  all: unset;
  position: absolute;
  top: 0;
  right: 0;
  width: 32px;
  height: 28px;
  cursor: pointer;
  font-size: 18px;
  font-weight: 500;
  color: #d2d2d2;
  z-index: 1;
  text-align: center;
  transition: color;
  transition-duration: .2s
}

.driver-popover-close-btn:hover {
  color: #2d2d2d
}

.driver-popover-title[style*=block]+.driver-popover-description {
  margin-top: 5px
}

.driver-popover-description {
  margin-bottom: 0;
  font: 14px/normal sans-serif;
  line-height: 1.5;
  font-weight: 400;
  zoom: 1
}

.driver-popover-footer {
  margin-top: 15px;
  text-align: right;
  zoom: 1;
  display: flex;
  align-items: center;
  justify-content: space-between
}

.driver-popover-progress-text {
  font-size: 13px;
  font-weight: 400;
  color: #a2a2a2;
  zoom: 1
}

.driver-popover-footer button {
  all: unset;
  display: inline-block;
  box-sizing: border-box;
  padding: 3px 7px;
  text-decoration: none;
  text-shadow: 1px 1px 0 #fff;
  background-color: #fff;
  color: #2d2d2d;
  font: 12px/normal sans-serif;
  cursor: pointer;
  outline: 0;
  zoom: 1;
  line-height: 1.3;
  border: 1px solid #ccc;
  border-radius: 3px
}

.driver-popover-footer .driver-popover-btn-disabled {
  opacity: .5;
  pointer-events: none
}

:not(body):has(> .driver-active-element) {
  overflow: hidden !important
}

.driver-popover-footer button:hover {
  background-color: #f7f7f7
}

.driver-popover-navigation-btns {
  display: flex;
  flex-grow: 1;
  justify-content: flex-end
}

.driver-popover-navigation-btns button+button {
  margin-left: 4px
}

.driver-popover-arrow {
  content: "";
  position: absolute;
  border: 5px solid #fff
}

.driver-popover-arrow-side-over {
  display: none
}

.driver-popover-arrow-side-left {
  left: 100%;
  border-right-color: transparent;
  border-bottom-color: transparent;
  border-top-color: transparent
}

.driver-popover-arrow-side-right {
  right: 100%;
  border-left-color: transparent;
  border-bottom-color: transparent;
  border-top-color: transparent
}

.driver-popover-arrow-side-top {
  top: 100%;
  border-right-color: transparent;
  border-bottom-color: transparent;
  border-left-color: transparent
}

.driver-popover-arrow-side-bottom {
  bottom: 100%;
  border-left-color: transparent;
  border-top-color: transparent;
  border-right-color: transparent
}

.driver-popover-arrow-side-center {
  display: none
}

.driver-popover-arrow-side-left.driver-popover-arrow-align-start,
.driver-popover-arrow-side-right.driver-popover-arrow-align-start {
  top: 15px
}

.driver-popover-arrow-side-top.driver-popover-arrow-align-start,
.driver-popover-arrow-side-bottom.driver-popover-arrow-align-start {
  left: 15px
}

.driver-popover-arrow-align-end.driver-popover-arrow-side-left,
.driver-popover-arrow-align-end.driver-popover-arrow-side-right {
  bottom: 15px
}

.driver-popover-arrow-side-top.driver-popover-arrow-align-end,
.driver-popover-arrow-side-bottom.driver-popover-arrow-align-end {
  right: 15px
}

.driver-popover-arrow-side-left.driver-popover-arrow-align-center,
.driver-popover-arrow-side-right.driver-popover-arrow-align-center {
  top: 50%;
  margin-top: -5px
}

.driver-popover-arrow-side-top.driver-popover-arrow-align-center,
.driver-popover-arrow-side-bottom.driver-popover-arrow-align-center {
  left: 50%;
  margin-left: -5px
}

.driver-popover-arrow-none {
  display: none
}
</style>
<p></p>
<div id='SimulationsAnimintRegression'></div>
<script>var SimulationsAnimintRegression = new animint("#SimulationsAnimintRegression", "SimulationsAnimintRegression/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-13-train-predict-subsets-regression&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-13-train-predict-subsets-regression/">https://tdhock.github.io/2023-12-13-train-predict-subsets-regression/</a></p>
<h2 id="sec:simulated-classification-problems_1">Simulated classification problems</h2>
<p>The previous section investigated a simulated regression problem, whereas in this section we simulate a binary classification problem.
Assume there is a data set with some rows from one person, some rows
from another,</p>
<pre><code class="language-r">N &lt;- 200
library(data.table)
(full.dt &lt;- data.table(
  label=factor(rep(c(&quot;spam&quot;,&quot;not spam&quot;), l=N)),
  person=rep(1:2, each=0.5*N)
)[, signal := ifelse(label==&quot;not spam&quot;, 0, 3)][])
#&gt;         label person signal
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;
#&gt;   1:     spam      1      3
#&gt;   2: not spam      1      0
#&gt;   3:     spam      1      3
#&gt;   4: not spam      1      0
#&gt;   5:     spam      1      3
#&gt;  ---                       
#&gt; 196: not spam      2      0
#&gt; 197:     spam      2      3
#&gt; 198: not spam      2      0
#&gt; 199:     spam      2      3
#&gt; 200: not spam      2      0
</code></pre>
<p>Above each row has an person ID between 1 and 2.
We can imagine a spam filtering system, that has training data for multiple people (here just two).
Each row in the table above represents a message which has been labeled as spam or not, by one of the two people.
Can we train on one person, and accurately predict on the other person?
To do that we will need some features, which we generate/simulate below:</p>
<pre><code class="language-r">set.seed(1)
n.people &lt;- length(unique(full.dt$person))
for(person.i in 1:n.people){
  use.signal.vec &lt;- list(
    easy=rep(if(person.i==1)TRUE else FALSE, N),
    impossible=full.dt$person==person.i)
  for(task_id in names(use.signal.vec)){
    use.signal &lt;- use.signal.vec[[task_id]]
    full.dt[
    , paste0(&quot;x&quot;,person.i,&quot;_&quot;,task_id) := ifelse(
      use.signal, signal, 0
    )+rnorm(N)][]
  }
}
full.dt
#&gt;         label person signal    x1_easy x1_impossible    x2_easy x2_impossible
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;      &lt;num&gt;         &lt;num&gt;      &lt;num&gt;         &lt;num&gt;
#&gt;   1:     spam      1      3  2.3735462     3.4094018  1.0744410    -0.3410670
#&gt;   2: not spam      1      0  0.1836433     1.6888733  1.8956548     1.5024245
#&gt;   3:     spam      1      3  2.1643714     4.5865884 -0.6029973     0.5283077
#&gt;   4: not spam      1      0  1.5952808    -0.3309078 -0.3908678     0.5421914
#&gt;   5:     spam      1      3  3.3295078     0.7147645 -0.4162220    -0.1366734
#&gt;  ---                                                                         
#&gt; 196: not spam      2      0 -1.0479844    -0.9243128  0.7682782    -1.0293917
#&gt; 197:     spam      2      3  4.4411577     1.5929138 -0.8161606     2.9890743
#&gt; 198: not spam      2      0 -1.0158475     0.0450106 -0.4361069    -1.2249912
#&gt; 199:     spam      2      3  3.4119747    -0.7151284  0.9047050     0.4038886
#&gt; 200: not spam      2      0 -0.3810761     0.8652231 -0.7630863     1.1691226
</code></pre>
<p>In the table above, there are two sets of two features:</p>
<ul>
<li>For easy features, one is correlated with the label (<code>x1_easy</code>), and
one is random noise (<code>x2_easy</code>), so the algorithm just needs to
learn to ignore the noise feature, and concentrate on the signal
feature. That should be possible given data from either person (same
signal in each person).</li>
<li>Each impossible feature is correlated with the label (when feature
number same as person number), or is just noise (when person number
different from feature number). So if the algorithm has access to
the correct person (same as test, say person 2), then it needs to
learn to use the corresponding feature <code>x2_impossible</code>. But if
the algorithm does not have access to that person, then the best it
can do is same as featureless (predict most frequent class label in
train data).</li>
</ul>
<h3 id="sec:static-visualization-of-simulated-data_2">Static visualization of simulated data</h3>
<p>Below we reshape the data to a table which is more suitable for visualization:</p>
<pre><code class="language-r">(scatter.dt &lt;- nc::capture_melt_multiple(
  full.dt,
  column=&quot;x[12]&quot;,
  &quot;_&quot;,
  task_id=&quot;easy|impossible&quot;))
#&gt;         label person signal    task_id         x1         x2
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;     &lt;char&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;   1:     spam      1      3       easy  2.3735462  1.0744410
#&gt;   2: not spam      1      0       easy  0.1836433  1.8956548
#&gt;   3:     spam      1      3       easy  2.1643714 -0.6029973
#&gt;   4: not spam      1      0       easy  1.5952808 -0.3908678
#&gt;   5:     spam      1      3       easy  3.3295078 -0.4162220
#&gt;  ---                                                        
#&gt; 396: not spam      2      0 impossible -0.9243128 -1.0293917
#&gt; 397:     spam      2      3 impossible  1.5929138  2.9890743
#&gt; 398: not spam      2      0 impossible  0.0450106 -1.2249912
#&gt; 399:     spam      2      3 impossible -0.7151284  0.4038886
#&gt; 400: not spam      2      0 impossible  0.8652231  1.1691226
</code></pre>
<p>Below we visualize the pattern for each person and feature type:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x1, x2, color=label),
      shape=1,
      data=scatter.dt)+
    facet_grid(
      task_id ~ person,
      labeller=label_both)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-13" /></p>
<p>In the plot above, it is apparent that</p>
<ul>
<li>for easy features (left), the two label classes differ in x1 values
for both people. So it should be possible/easy to train on person 1, and
predict accurately on person 2.</li>
<li>for impossible features (right), the two people have different label
patterns. For person 1, the two label classes differ in x1 values,
whereas for person 2, the two label classes differ in x2 values. So
it should be impossible to train on person 1, and predict accurately
on person 2.</li>
</ul>
<h3 id="sec:benchmark-computing-test-error_2">Benchmark: computing test error</h3>
<p>We use the code below to create a list of classification tasks, for
use in the mlr3 framework.</p>
<pre><code class="language-r">class.task.list &lt;- list()
for(task_id in c(&quot;easy&quot;,&quot;impossible&quot;)){
  feature.names &lt;- grep(task_id, names(full.dt), value=TRUE)
  task.col.names &lt;- c(feature.names, &quot;label&quot;, &quot;person&quot;)
  task.dt &lt;- full.dt[, task.col.names, with=FALSE]
  this.task &lt;- mlr3::TaskClassif$new(
    task_id, task.dt, target=&quot;label&quot;)
  this.task$col_roles$subset &lt;- &quot;person&quot;
  this.task$col_roles$stratum &lt;- c(&quot;person&quot;,&quot;label&quot;)
  this.task$col_roles$feature &lt;- setdiff(names(task.dt), this.task$col_roles$stratum)
  class.task.list[[task_id]] &lt;- this.task
}
class.task.list
#&gt; $easy
#&gt; &lt;TaskClassif:easy&gt; (200 x 3)
#&gt; * Target: label
#&gt; * Properties: twoclass, strata
#&gt; * Features (2):
#&gt;   - dbl (2): x1_easy, x2_easy
#&gt; * Strata: person, label
#&gt; 
#&gt; $impossible
#&gt; &lt;TaskClassif:impossible&gt; (200 x 3)
#&gt; * Target: label
#&gt; * Properties: twoclass, strata
#&gt; * Features (2):
#&gt;   - dbl (2): x1_impossible, x2_impossible
#&gt; * Strata: person, label
</code></pre>
<p>Note in the code above that person is assigned roles subset and
stratum, whereas label is assigned roles target and stratum.  When
adapting the code above to real data, the important part is the
<code>mlr3::TaskClassif</code> line which tells mlr3 what data set to use, and
what columns should be used for target/subset/stratum.</p>
<p>The code below is used to define a K-fold cross-validation experiment,</p>
<pre><code class="language-r">(class_same_other &lt;- mlr3resampling::ResamplingSameOtherCV$new())
#&gt; &lt;ResamplingSameOtherCV&gt; : Same versus Other Cross-Validation
#&gt; * Iterations:
#&gt; * Instantiated: FALSE
#&gt; * Parameters:
#&gt; List of 1
#&gt;  $ folds: int 3
</code></pre>
<p>The code below is used to define the learning algorithms to test,</p>
<pre><code class="language-r">(class.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerClassifRpart$new(),
  mlr3::LearnerClassifFeatureless$new()))
#&gt; [[1]]
#&gt; &lt;LearnerClassifRpart:classif.rpart&gt;: Classification Tree
#&gt; * Model: -
#&gt; * Parameters: xval=0
#&gt; * Packages: mlr3, rpart
#&gt; * Predict Types:  [response], prob
#&gt; * Feature Types: logical, integer, numeric, factor, ordered
#&gt; * Properties: importance, missings, multiclass, selected_features,
#&gt;   twoclass, weights
#&gt; 
#&gt; [[2]]
#&gt; &lt;LearnerClassifFeatureless:classif.featureless&gt;: Featureless Classification Learner
#&gt; * Model: -
#&gt; * Parameters: method=mode
#&gt; * Packages: mlr3
#&gt; * Predict Types:  [response], prob
#&gt; * Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt;   POSIXct, Date
#&gt; * Properties: featureless, importance, missings, multiclass,
#&gt;   selected_features, twoclass
</code></pre>
<p>The code below defines the grid of tasks, learners, and resamplings.</p>
<pre><code class="language-r">(class.bench.grid &lt;- mlr3::benchmark_grid(
  class.task.list,
  class.learner.list,
  class_same_other))
#&gt;          task             learner    resampling
#&gt;        &lt;char&gt;              &lt;char&gt;        &lt;char&gt;
#&gt; 1:       easy       classif.rpart same_other_cv
#&gt; 2:       easy classif.featureless same_other_cv
#&gt; 3: impossible       classif.rpart same_other_cv
#&gt; 4: impossible classif.featureless same_other_cv
</code></pre>
<p>The code below runs the benchmark experiment grid. Note that each
iteration can be parallelized by declaring a future plan.</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(class.bench.result &lt;- mlr3::benchmark(
  class.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 72 rows with 4 resampling runs
#&gt;  nr    task_id          learner_id resampling_id iters warnings errors
#&gt;   1       easy       classif.rpart same_other_cv    18        0      0
#&gt;   2       easy classif.featureless same_other_cv    18        0      0
#&gt;   3 impossible       classif.rpart same_other_cv    18        0      0
#&gt;   4 impossible classif.featureless same_other_cv    18        0      0
</code></pre>
<p>Below we compute scores (test error) for each resampling iteration,
and show the first row of the result.</p>
<pre><code class="language-r">class.bench.score &lt;- mlr3resampling::score(class.bench.result)
class.bench.score[1]
#&gt;    train.subsets test.fold test.subset person iteration                  test
#&gt;           &lt;char&gt;     &lt;int&gt;       &lt;int&gt;  &lt;int&gt;     &lt;int&gt;                &lt;list&gt;
#&gt; 1:           all         1           1      1         1  1, 2, 8,11,12,18,...
#&gt;                    train                                uhash    nr
#&gt;                   &lt;list&gt;                               &lt;char&gt; &lt;int&gt;
#&gt; 1:  3, 4, 5, 6, 9,10,... b3c0cfc8-913b-4d38-91cb-fbe51f1ce62d     1
#&gt;                  task task_id                             learner    learner_id
#&gt;                &lt;list&gt;  &lt;char&gt;                              &lt;list&gt;        &lt;char&gt;
#&gt; 1: &lt;TaskClassif:easy&gt;    easy &lt;LearnerClassifRpart:classif.rpart&gt; classif.rpart
#&gt;                 resampling resampling_id     prediction_test classif.ce
#&gt;                     &lt;list&gt;        &lt;char&gt;              &lt;list&gt;      &lt;num&gt;
#&gt; 1: &lt;ResamplingSameOtherCV&gt; same_other_cv &lt;PredictionClassif&gt; 0.08823529
#&gt;    algorithm
#&gt;       &lt;char&gt;
#&gt; 1:     rpart
</code></pre>
<p>Finally we plot the test error values below.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      classif.ce, train.subsets, color=algorithm),
      shape=1,
      data=class.bench.score)+
    facet_grid(
      person ~ task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-20" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>for the easy task, training on same is just as good as all or other
subsets.</li>
<li>for the impossible task, we must train on same subset for minimal
test error; training on all is almost as good, because the pattern
in person 1 is orthogonal to person 2; training on other is just as
bad as featureless, because patterns are different.</li>
<li>in a real data task, training on other will most likely not be quite as bad as in the impossible task above, but also not as good as in the easy task.</li>
</ul>
<h3 id="sec:interactive-visualization-of-data-test-error-and-splits_2">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">inst &lt;- class.bench.score$resampling[[1]]$instance
rect.expand &lt;- 0.3
grid.value.dt &lt;- scatter.dt[
, lapply(.SD, function(x)do.call(seq, c(as.list(range(x)), l=21)))
, .SDcols=c(&quot;x1&quot;,&quot;x2&quot;)]
grid.class.dt &lt;- data.table(
  label=full.dt$label[1],
  do.call(
    CJ, grid.value.dt
  )
)
class.pred.dt.list &lt;- list()
class.point.dt.list &lt;- list()
for(score.i in 1:nrow(class.bench.score)){
  class.bench.row &lt;- class.bench.score[score.i]
  task.dt &lt;- data.table(
    class.bench.row$task[[1]]$data(),
    class.bench.row$resampling[[1]]$instance$id.dt)
  names(task.dt)[2:3] &lt;- c(&quot;x1&quot;,&quot;x2&quot;)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=class.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ][]
  class.point.dt.list[[score.i]] &lt;- data.table(
    class.bench.row[, .(task_id, iteration)],
    i.points)
  if(class.bench.row$algorithm!=&quot;featureless&quot;){
    i.learner &lt;- class.bench.row$learner[[1]]
    i.learner$predict_type &lt;- &quot;prob&quot;
    i.task &lt;- class.bench.row$task[[1]]
    setnames(grid.class.dt, names(i.task$data()))
    grid.class.task &lt;- mlr3::TaskClassif$new(
      &quot;grid&quot;, grid.class.dt, target=&quot;label&quot;)
    pred.grid &lt;- as.data.table(
      i.learner$predict(grid.class.task)
    )[, data.table(grid.class.dt, prob.spam)]
    names(pred.grid)[2:3] &lt;- c(&quot;x1&quot;,&quot;x2&quot;)
    pred.wide &lt;- dcast(pred.grid, x1 ~ x2, value.var=&quot;prob.spam&quot;)
    prob.mat &lt;- as.matrix(pred.wide[,-1])
    contour.list &lt;- contourLines(
      grid.value.dt$x1, grid.value.dt$x2, prob.mat, levels=0.5)
    class.pred.dt.list[[score.i]] &lt;- data.table(
      class.bench.row[, .(
        task_id, iteration, algorithm
      )],
      data.table(contour.i=seq_along(contour.list))[, {
        do.call(data.table, contour.list[[contour.i]])[, .(level, x1=x, x2=y)]
      }, by=contour.i]
    )
  }
}
(class.pred.dt &lt;- rbindlist(class.pred.dt.list))
#&gt;         task_id iteration algorithm contour.i level       x1        x2
#&gt;          &lt;char&gt;     &lt;int&gt;    &lt;char&gt;     &lt;int&gt; &lt;num&gt;    &lt;num&gt;     &lt;num&gt;
#&gt;   1:       easy         1     rpart         1   0.5 1.856156 -3.008049
#&gt;   2:       easy         1     rpart         1   0.5 1.856156 -2.606579
#&gt;   3:       easy         1     rpart         1   0.5 1.856156 -2.205109
#&gt;   4:       easy         1     rpart         1   0.5 1.856156 -1.803639
#&gt;   5:       easy         1     rpart         1   0.5 1.856156 -1.402169
#&gt;  ---                                                                  
#&gt; 766: impossible        18     rpart         1   0.5 3.743510  1.225096
#&gt; 767: impossible        18     rpart         1   0.5 4.158037  1.225096
#&gt; 768: impossible        18     rpart         1   0.5 4.572564  1.225096
#&gt; 769: impossible        18     rpart         1   0.5 4.987091  1.225096
#&gt; 770: impossible        18     rpart         1   0.5 5.401618  1.225096
(class.point.dt &lt;- rbindlist(class.point.dt.list))
#&gt;           task_id iteration set.name row_id    label         x1         x2
#&gt;            &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;   &lt;fctr&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;     1:       easy         1     test      1     spam  2.3735462  1.0744410
#&gt;     2:       easy         1     test      2 not spam  0.1836433  1.8956548
#&gt;     3:       easy         1    train      3     spam  2.1643714 -0.6029973
#&gt;     4:       easy         1    train      4 not spam  1.5952808 -0.3908678
#&gt;     5:       easy         1    train      5     spam  3.3295078 -0.4162220
#&gt;    ---                                                                    
#&gt; 14396: impossible        18    train    196 not spam -0.9243128 -1.0293917
#&gt; 14397: impossible        18    train    197     spam  1.5929138  2.9890743
#&gt; 14398: impossible        18    train    198 not spam  0.0450106 -1.2249912
#&gt; 14399: impossible        18    train    199     spam -0.7151284  0.4038886
#&gt; 14400: impossible        18    train    200 not spam  0.8652231  1.1691226
#&gt;         fold person subset display_row
#&gt;        &lt;int&gt;  &lt;int&gt;  &lt;int&gt;       &lt;int&gt;
#&gt;     1:     1      1      1           1
#&gt;     2:     1      1      1           2
#&gt;     3:     2      1      1          35
#&gt;     4:     2      1      1          36
#&gt;     5:     2      1      1          37
#&gt;    ---                                
#&gt; 14396:     2      2      2         166
#&gt; 14397:     2      2      2         167
#&gt; 14398:     1      2      2         133
#&gt; 14399:     1      2      2         134
#&gt; 14400:     2      2      2         168

set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
make_person_subset &lt;- function(DT){
  DT[, &quot;person/subset&quot; := person]
}
make_person_subset(class.point.dt)
make_person_subset(class.bench.score)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;SOAK algorithm: train/predict on subsets, classification&quot;,
    video=&quot;https://vimeo.com/manage/videos/1053464329&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=350, width=350)+
      scale_fill_manual(values=set.colors)+
      scale_color_manual(values=c(spam=&quot;black&quot;,&quot;not spam&quot;=&quot;white&quot;))+
      geom_point(aes(
        x1, x2, color=label, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        help=&quot;One dot for each train/test/unused data point.&quot;,
        stroke=2,
        shape=21,
        data=class.point.dt)+
      geom_path(aes(
        x1, x2, 
        group=paste(algorithm, iteration, contour.i)),
        showSelected=c(&quot;iteration&quot;,&quot;algorithm&quot;),
        help=&quot;Red path represents decision boundary of rpart decision tree learning algorithm.&quot;,
        color=algo.colors[[&quot;rpart&quot;]],
        data=class.pred.dt)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;)+
      scale_y_continuous(
        breaks=seq(-100, 100, by=2)),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=350, width=350)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      scale_y_continuous(
        &quot;Classification error on test set&quot;,
        breaks=seq(0, 1, by=0.25))+
      scale_fill_manual(values=algo.colors)+
      scale_x_discrete(
        &quot;People/subsets in train set&quot;)+
      geom_hline(aes(
        yintercept=yint),
        help=&quot;Horizontal lines highlight baseline error rate of 50%.&quot;,
        data=data.table(yint=0.5),
        color=&quot;grey50&quot;)+
      geom_point(aes(
        train.subsets, classif.ce, fill=algorithm),
        help=&quot;One dot per test set and learning algorithm.&quot;,
        shape=1,
        size=5,
        stroke=2,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=class.bench.score)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both),
    diagram=ggplot()+
      ggtitle(&quot;Select train/test split&quot;)+
      theme_bw()+
      theme_animint(height=350, width=300)+
      facet_grid(
        . ~ train.subsets,
        scales=&quot;free&quot;,
        space=&quot;free&quot;)+
      scale_size_manual(values=c(subset=3, fold=1))+
      scale_color_manual(values=c(subset=&quot;orange&quot;, fold=&quot;grey50&quot;))+
      geom_rect(aes(
        xmin=-Inf, xmax=Inf,
        color=rows,
        size=rows,
        ymin=display_row, ymax=display_end),
        help=&quot;One rect per chunk of data with common fold (grey) and subset (gold).&quot;,
        fill=NA,
        data=inst$viz.rect.dt)+
      scale_fill_manual(values=set.colors)+
      geom_text(aes(
        x=ifelse(rows==&quot;subset&quot;, Inf, -Inf),
        y=(display_row+display_end)/2,
        hjust=ifelse(rows==&quot;subset&quot;, 1, 0),
        label=paste0(rows, &quot;=&quot;, ifelse(rows==&quot;subset&quot;, subset, fold))),
        help=&quot;Text labels indicate chunks of data with common fold (grey) and subset (gold).&quot;,
        showSelected=&quot;rows&quot;,
        data=data.table(train.name=&quot;same&quot;, inst$viz.rect.dt))+
      geom_rect(aes(
        xmin=iteration-rect.expand, ymin=display_row,
        xmax=iteration+rect.expand, ymax=display_end,
        fill=set.name),
        help=&quot;One rect per chunk of data assigned to train/test set in cross-validation.&quot;,
        alpha=0.5,
        alpha_off=0.5,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=inst$viz.set.dt)+
      scale_x_continuous(
        &quot;Split number / cross-validation iteration&quot;,
        breaks=c(1,6, 7,12, 13,18))+
      scale_y_continuous(
        &quot;Row number&quot;),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Older_resamplers.Rmd&quot;)
  viz
}
</code></pre>
<p></p>
<div id='SimulationsAnimintClassification'></div>
<script>var SimulationsAnimintClassification = new animint("#SimulationsAnimintClassification", "SimulationsAnimintClassification/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-13-train-predict-subsets-classification&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-13-train-predict-subsets-classification/">https://tdhock.github.io/2023-12-13-train-predict-subsets-classification/</a></p>
<h2 id="sec:conclusion_1">Conclusion</h2>
<p>In this section we have shown how to use mlr3resampling for comparing
test error of models trained on same/all/other subsets.</p>
<h1 id="chp:variable-size-train-resampler">Variable size train resampler</h1>
<p>The goal of this section is to explain how to
<code>ResamplingVariableSizeTrainCV</code>, which can be used to determine how
many train data are necessary to provide accurate predictions on a
given test set.</p>
<h2 id="sec:simulated-regression-problems_2">Simulated regression problems</h2>
<p>The code below creates data for simulated regression problems. First
we define a vector of input values,</p>
<pre><code class="language-r">N &lt;- 300
abs.x &lt;- 10
set.seed(1)
x.vec &lt;- runif(N, -abs.x, abs.x)
str(x.vec)
#&gt;  num [1:300] -4.69 -2.56 1.46 8.16 -5.97 ...
</code></pre>
<p>Below we define a list of two true regression functions (tasks in mlr3
terminology) for our simulated data,</p>
<pre><code class="language-r">reg.pattern.list &lt;- list(
  sin=sin,
  constant=function(x)0)
</code></pre>
<p>The constant function represents a regression problem which can be
solved by always predicting the mean value of outputs (featureless is
the best possible learning algorithm). The sin function will be used
to generate data with a non-linear pattern that will need to be
learned. Below we use a for loop over these two functions/tasks, to
simulate the data which will be used as input to the learning
algorithms:</p>
<pre><code class="language-r">library(data.table)
reg.task.list &lt;- list()
reg.data.list &lt;- list()
for(task_id in names(reg.pattern.list)){
  f &lt;- reg.pattern.list[[task_id]]
  task.dt &lt;- data.table(
    x=x.vec,
    y = f(x.vec)+rnorm(N,sd=0.5))
  reg.data.list[[task_id]] &lt;- data.table(task_id, task.dt)
  reg.task.list[[task_id]] &lt;- mlr3::TaskRegr$new(
    task_id, task.dt, target=&quot;y&quot;
  )
}
(reg.data &lt;- rbindlist(reg.data.list))
#&gt;       task_id         x          y
#&gt;        &lt;char&gt;     &lt;num&gt;      &lt;num&gt;
#&gt;   1:      sin -4.689827  1.2248390
#&gt;   2:      sin -2.557522 -0.5607042
#&gt;   3:      sin  1.457067  0.8345056
#&gt;   4:      sin  8.164156  0.4875994
#&gt;   5:      sin -5.966361 -0.4321800
#&gt;  ---                              
#&gt; 596: constant  3.628850 -0.6728968
#&gt; 597: constant -8.016618  0.5168327
#&gt; 598: constant -7.621949 -0.4058882
#&gt; 599: constant -8.991207  0.9008627
#&gt; 600: constant  8.585078  0.8857710
</code></pre>
<p>In the table above, the input is x, and the output is y. Below we
visualize these data, with one task in each facet/panel:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x, y),
      data=reg.data)+
    facet_grid(task_id ~ ., labeller=label_both)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-24" /></p>
<p>In the plot above we can see two different simulated data sets
(constant and sin).  Note that the code above used the <code>animint2</code>
package, which provides interactive extensions to the static graphics
of the <code>ggplot2</code> package (see below section Interactive data viz).</p>
<h3 id="sec:visualizing-instance-table">Visualizing instance table</h3>
<p>In the code below, we define a K-fold cross-validation experiment,
with K=3 folds.</p>
<pre><code class="language-r">reg_size_cv &lt;- mlr3resampling::ResamplingVariableSizeTrainCV$new()
reg_size_cv$param_set$values$train_sizes &lt;- 6
reg_size_cv
#&gt; &lt;ResamplingVariableSizeTrainCV&gt; : Cross-Validation with variable size train sets
#&gt; * Iterations:
#&gt; * Instantiated: FALSE
#&gt; * Parameters:
#&gt; List of 4
#&gt;  $ folds         : int 3
#&gt;  $ min_train_data: int 10
#&gt;  $ random_seeds  : int 3
#&gt;  $ train_sizes   : int 6
</code></pre>
<p>In the output above we can see the parameters of the resampling
object, all of which should be integer scalars:</p>
<ul>
<li><code>folds</code> is the number of cross-validation folds.</li>
<li><code>min_train_data</code> is the minimum number of train data to consider.</li>
<li><code>random_seeds</code> is the number of random seeds, each of which
determines a different random ordering of the train data. The random
ordering determines which data are included in small train set
sizes.</li>
<li><code>train_sizes</code> is the number of train set sizes, evenly spaced on a
log scale, from <code>min_train_data</code> to the max number of train data
(determined by <code>folds</code>).</li>
</ul>
<p>Below we instantiate the resampling on one of the tasks:</p>
<pre><code class="language-r">reg_size_cv$instantiate(reg.task.list[[&quot;sin&quot;]])
reg_size_cv$instance
#&gt; $iteration.dt
#&gt;     test.fold  seed small_stratum_size train_size_i train_size
#&gt;         &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt;  1:         1     1                 10            1         10
#&gt;  2:         1     1                 18            2         18
#&gt;  3:         1     1                 33            3         33
#&gt;  4:         1     1                 60            4         60
#&gt;  5:         1     1                110            5        110
#&gt;  6:         1     1                200            6        200
#&gt;  7:         1     2                 10            1         10
#&gt;  8:         1     2                 18            2         18
#&gt;  9:         1     2                 33            3         33
#&gt; 10:         1     2                 60            4         60
#&gt; 11:         1     2                110            5        110
#&gt; 12:         1     2                200            6        200
#&gt; 13:         1     3                 10            1         10
#&gt; 14:         1     3                 18            2         18
#&gt; 15:         1     3                 33            3         33
#&gt; 16:         1     3                 60            4         60
#&gt; 17:         1     3                110            5        110
#&gt; 18:         1     3                200            6        200
#&gt; 19:         2     1                 10            1         10
#&gt; 20:         2     1                 18            2         18
#&gt; 21:         2     1                 33            3         33
#&gt; 22:         2     1                 60            4         60
#&gt; 23:         2     1                110            5        110
#&gt; 24:         2     1                200            6        200
#&gt; 25:         2     2                 10            1         10
#&gt; 26:         2     2                 18            2         18
#&gt; 27:         2     2                 33            3         33
#&gt; 28:         2     2                 60            4         60
#&gt; 29:         2     2                110            5        110
#&gt; 30:         2     2                200            6        200
#&gt; 31:         2     3                 10            1         10
#&gt; 32:         2     3                 18            2         18
#&gt; 33:         2     3                 33            3         33
#&gt; 34:         2     3                 60            4         60
#&gt; 35:         2     3                110            5        110
#&gt; 36:         2     3                200            6        200
#&gt; 37:         3     1                 10            1         10
#&gt; 38:         3     1                 18            2         18
#&gt; 39:         3     1                 33            3         33
#&gt; 40:         3     1                 60            4         60
#&gt; 41:         3     1                110            5        110
#&gt; 42:         3     1                200            6        200
#&gt; 43:         3     2                 10            1         10
#&gt; 44:         3     2                 18            2         18
#&gt; 45:         3     2                 33            3         33
#&gt; 46:         3     2                 60            4         60
#&gt; 47:         3     2                110            5        110
#&gt; 48:         3     2                200            6        200
#&gt; 49:         3     3                 10            1         10
#&gt; 50:         3     3                 18            2         18
#&gt; 51:         3     3                 33            3         33
#&gt; 52:         3     3                 60            4         60
#&gt; 53:         3     3                110            5        110
#&gt; 54:         3     3                200            6        200
#&gt;     test.fold  seed small_stratum_size train_size_i train_size
#&gt;                           train                  test iteration train_min_size
#&gt;                          &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt;  1: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         1             10
#&gt;  2: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         2             18
#&gt;  3: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         3             33
#&gt;  4: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         4             60
#&gt;  5: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         5            110
#&gt;  6: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         6            200
#&gt;  7: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         7             10
#&gt;  8: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         8             18
#&gt;  9: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         9             33
#&gt; 10: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        10             60
#&gt; 11: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        11            110
#&gt; 12: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        12            200
#&gt; 13:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        13             10
#&gt; 14:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        14             18
#&gt; 15:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        15             33
#&gt; 16:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        16             60
#&gt; 17:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        17            110
#&gt; 18:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        18            200
#&gt; 19: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        19             10
#&gt; 20: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        20             18
#&gt; 21: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        21             33
#&gt; 22: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        22             60
#&gt; 23: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        23            110
#&gt; 24: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        24            200
#&gt; 25: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        25             10
#&gt; 26: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        26             18
#&gt; 27: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        27             33
#&gt; 28: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        28             60
#&gt; 29: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        29            110
#&gt; 30: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        30            200
#&gt; 31:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        31             10
#&gt; 32:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        32             18
#&gt; 33:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        33             33
#&gt; 34:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        34             60
#&gt; 35:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        35            110
#&gt; 36:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        36            200
#&gt; 37: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        37             10
#&gt; 38: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        38             18
#&gt; 39: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        39             33
#&gt; 40: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        40             60
#&gt; 41: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        41            110
#&gt; 42: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        42            200
#&gt; 43: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        43             10
#&gt; 44: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        44             18
#&gt; 45: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        45             33
#&gt; 46: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        46             60
#&gt; 47: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        47            110
#&gt; 48: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        48            200
#&gt; 49:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        49             10
#&gt; 50:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        50             18
#&gt; 51:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        51             33
#&gt; 52:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        52             60
#&gt; 53:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        53            110
#&gt; 54:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        54            200
#&gt;                           train                  test iteration train_min_size
#&gt; 
#&gt; $id.dt
#&gt;      row_id  fold
#&gt;       &lt;int&gt; &lt;int&gt;
#&gt;   1:      1     1
#&gt;   2:      2     3
#&gt;   3:      3     3
#&gt;   4:      4     2
#&gt;   5:      5     3
#&gt;  ---             
#&gt; 296:    296     2
#&gt; 297:    297     1
#&gt; 298:    298     1
#&gt; 299:    299     3
#&gt; 300:    300     2
</code></pre>
<p>Above we see the instance, which need not be examined by the user, but
for informational purposes, it contains the following data:</p>
<ul>
<li><code>iteration.dt</code> has one row for each train/test split,</li>
<li><code>id.dt</code> has one row for each data point.</li>
</ul>
<h3 id="sec:benchmark-computing-test-error_3">Benchmark: computing test error</h3>
<p>In the code below, we define two learners to compare,</p>
<pre><code class="language-r">(reg.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerRegrRpart$new(),
  mlr3::LearnerRegrFeatureless$new()))
#&gt; [[1]]
#&gt; &lt;LearnerRegrRpart:regr.rpart&gt;: Regression Tree
#&gt; * Model: -
#&gt; * Parameters: xval=0
#&gt; * Packages: mlr3, rpart
#&gt; * Predict Types:  [response]
#&gt; * Feature Types: logical, integer, numeric, factor, ordered
#&gt; * Properties: importance, missings, selected_features, weights
#&gt; 
#&gt; [[2]]
#&gt; &lt;LearnerRegrFeatureless:regr.featureless&gt;: Featureless Regression Learner
#&gt; * Model: -
#&gt; * Parameters: robust=FALSE
#&gt; * Packages: mlr3, stats
#&gt; * Predict Types:  [response], se, quantiles
#&gt; * Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt;   POSIXct, Date
#&gt; * Properties: featureless, importance, missings, selected_features
</code></pre>
<p>The code above defines</p>
<ul>
<li><code>regr.rpart</code>: Regression Tree learning algorithm, which should be
able to learn the non-linear pattern in the sin data (if there are
enough data in the train set).</li>
<li><code>regr.featureless</code>: Featureless Regression learning algorithm, which
should be optimal for the constant data, and can be used as a
baseline in the sin data. When the rpart learner gets smaller
prediction error rates than featureless, then we know that it has
learned some non-trivial relationship between inputs and outputs.</li>
</ul>
<p>In the code below, we define the benchmark grid, which is all
combinations of tasks (constant and sin), learners (rpart and
featureless), and the one resampling method.</p>
<pre><code class="language-r">(reg.bench.grid &lt;- mlr3::benchmark_grid(
  reg.task.list,
  reg.learner.list,
  reg_size_cv))
#&gt;        task          learner             resampling
#&gt;      &lt;char&gt;           &lt;char&gt;                 &lt;char&gt;
#&gt; 1:      sin       regr.rpart variable_size_train_cv
#&gt; 2:      sin regr.featureless variable_size_train_cv
#&gt; 3: constant       regr.rpart variable_size_train_cv
#&gt; 4: constant regr.featureless variable_size_train_cv
</code></pre>
<p>In the code below, we execute the benchmark experiment (optionally in parallel
using the multisession future plan).</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(reg.bench.result &lt;- mlr3::benchmark(
  reg.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 216 rows with 4 resampling runs
#&gt;  nr  task_id       learner_id          resampling_id iters warnings errors
#&gt;   1      sin       regr.rpart variable_size_train_cv    54        0      0
#&gt;   2      sin regr.featureless variable_size_train_cv    54        0      0
#&gt;   3 constant       regr.rpart variable_size_train_cv    54        0      0
#&gt;   4 constant regr.featureless variable_size_train_cv    54        0      0
</code></pre>
<p>The code below computes the test error for each split, and visualizes
the information stored in the first row of the result:</p>
<pre><code class="language-r">reg.bench.score &lt;- mlr3resampling::score(reg.bench.result)
reg.bench.score[1]
#&gt;    test.fold  seed small_stratum_size train_size_i train_size
#&gt;        &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt; 1:         1     1                 10            1         10
#&gt;                          train                  test iteration train_min_size
#&gt;                         &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt; 1: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         1             10
#&gt;                                   uhash    nr           task task_id
#&gt;                                  &lt;char&gt; &lt;int&gt;         &lt;list&gt;  &lt;char&gt;
#&gt; 1: 135b26e0-bf1d-4603-b1e6-0c49bc0b0c7d     1 &lt;TaskRegr:sin&gt;     sin
#&gt;                          learner learner_id                      resampling
#&gt;                           &lt;list&gt;     &lt;char&gt;                          &lt;list&gt;
#&gt; 1: &lt;LearnerRegrRpart:regr.rpart&gt; regr.rpart &lt;ResamplingVariableSizeTrainCV&gt;
#&gt;             resampling_id  prediction_test  regr.mse algorithm
#&gt;                    &lt;char&gt;           &lt;list&gt;     &lt;num&gt;    &lt;char&gt;
#&gt; 1: variable_size_train_cv &lt;PredictionRegr&gt; 0.8008255     rpart
</code></pre>
<p>The output above contains all of the results related to a particular
train/test split. In particular for our purposes, the interesting
columns are:</p>
<ul>
<li><code>test.fold</code> is the cross-validation fold ID.</li>
<li><code>seed</code> is the random seed used to determine the train set order.</li>
<li><code>train_size</code> is the number of data in the train set.</li>
<li><code>train</code> and <code>test</code> are vectors of row numbers assigned to each set.</li>
<li><code>iteration</code> is an ID for the train/test split, for a particular
learning algorithm and task. It is the row number of <code>iteration.dt</code>
(see instance above), which has one row for each unique combination
of <code>test.fold</code>, <code>seed</code>, and <code>train_size</code>.</li>
<li><code>learner</code> is the mlr3 learner object, which can be used to compute
predictions on new data (including a grid of inputs, to show
predictions in the visualization below).</li>
<li><code>regr.mse</code> is the mean squared error on the test set.</li>
<li><code>algorithm</code> is the name of the learning algorithm (same as
<code>learner_id</code> but without <code>regr.</code> prefix).</li>
</ul>
<p>The code below visualizes the resulting test accuracy numbers.</p>
<pre><code class="language-r">train_size_vec &lt;- unique(reg.bench.score$train_size)
if(require(animint2)){
  ggplot()+
    scale_x_log10(
      breaks=train_size_vec)+
    scale_y_log10()+
    geom_line(aes(
      train_size, regr.mse,
      group=paste(algorithm, seed),
      color=algorithm),
      shape=1,
      data=reg.bench.score)+
    geom_point(aes(
      train_size, regr.mse, color=algorithm),
      shape=1,
      data=reg.bench.score)+
    facet_grid(
      test.fold~task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-31" /></p>
<p>Above we plot the test error for each fold and train set size.
There is a different panel for each task and test fold.
Each line represents a random seed (ordering of data in train set),
and each dot represents a specific train set size.
So the plot above shows that some variation in test error, for a given test fold,
is due to the random ordering of the train data.</p>
<p>Below we summarize each train set size, by taking the mean and standard deviation over each random seed.</p>
<pre><code class="language-r">reg.mean.dt &lt;- dcast(
  reg.bench.score,
  task_id + train_size + test.fold + algorithm ~ .,
  list(mean, sd),
  value.var=&quot;regr.mse&quot;)
if(require(animint2)){
  ggplot()+
    scale_x_log10(
      breaks=train_size_vec)+
    scale_y_log10()+
    geom_ribbon(aes(
      train_size,
      ymin=regr.mse_mean-regr.mse_sd,
      ymax=regr.mse_mean+regr.mse_sd,
      fill=algorithm),
      alpha=0.5,
      data=reg.mean.dt)+
    geom_line(aes(
      train_size, regr.mse_mean, color=algorithm),
      shape=1,
      data=reg.mean.dt)+
    facet_grid(
      test.fold~task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
#&gt; Warning in grid.Call.graphics(C_polygon, x$x, x$y, index): la semi-transparence
#&gt; n'est pas supportée sur ce périphérique : signalé seulement une fois par page
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-32" /></p>
<p>The plot above shows a line for the mean,
and a ribbon for the standard deviation,
over the three random seeds.
It is clear from the plot above that</p>
<ul>
<li>in constant task, the featureless always has smaller or equal
prediction error rates than rpart, which indicates that rpart
sometimes overfits for large sample sizes.</li>
<li>in sin task, more than 30 samples are required for rpart to be more
accurate than featureless, which indicates it has learned a
non-trivial relationship between input and output.</li>
</ul>
<h3 id="sec:interactive-data-viz">Interactive data viz</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">grid.dt &lt;- data.table(x=seq(-abs.x, abs.x, l=101), y=0)
grid.task &lt;- mlr3::TaskRegr$new(&quot;grid&quot;, grid.dt, target=&quot;y&quot;)
pred.dt.list &lt;- list()
point.dt.list &lt;- list()
for(score.i in 1:nrow(reg.bench.score)){
  reg.bench.row &lt;- reg.bench.score[score.i]
  task.dt &lt;- data.table(
    reg.bench.row$task[[1]]$data(),
    reg.bench.row$resampling[[1]]$instance$id.dt)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=reg.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ]
  point.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(task_id, iteration)],
    i.points)
  i.learner &lt;- reg.bench.row$learner[[1]]
  pred.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(
      task_id, iteration, algorithm
    )],
    as.data.table(
      i.learner$predict(grid.task)
    )[, .(x=grid.dt$x, y=response)]
  )
}
(pred.dt &lt;- rbindlist(pred.dt.list))
#&gt;         task_id iteration   algorithm     x           y
#&gt;          &lt;char&gt;     &lt;int&gt;      &lt;char&gt; &lt;num&gt;       &lt;num&gt;
#&gt;     1:      sin         1       rpart -10.0  0.25011658
#&gt;     2:      sin         1       rpart  -9.8  0.25011658
#&gt;     3:      sin         1       rpart  -9.6  0.25011658
#&gt;     4:      sin         1       rpart  -9.4  0.25011658
#&gt;     5:      sin         1       rpart  -9.2  0.25011658
#&gt;    ---                                                 
#&gt; 21812: constant        54 featureless   9.2 -0.03385654
#&gt; 21813: constant        54 featureless   9.4 -0.03385654
#&gt; 21814: constant        54 featureless   9.6 -0.03385654
#&gt; 21815: constant        54 featureless   9.8 -0.03385654
#&gt; 21816: constant        54 featureless  10.0 -0.03385654
(point.dt &lt;- rbindlist(point.dt.list))
#&gt;         task_id iteration set.name row_id          y         x  fold
#&gt;          &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;      &lt;num&gt;     &lt;num&gt; &lt;int&gt;
#&gt;     1:      sin         1     test      1  1.2248390 -4.689827     1
#&gt;     2:      sin         1   unused      2 -0.5607042 -2.557522     3
#&gt;     3:      sin         1   unused      3  0.8345056  1.457067     3
#&gt;     4:      sin         1   unused      4  0.4875994  8.164156     2
#&gt;     5:      sin         1   unused      5 -0.4321800 -5.966361     3
#&gt;    ---                                                              
#&gt; 64796: constant        54    train    296 -0.6728968  3.628850     2
#&gt; 64797: constant        54    train    297  0.5168327 -8.016618     1
#&gt; 64798: constant        54    train    298 -0.4058882 -7.621949     1
#&gt; 64799: constant        54     test    299  0.9008627 -8.991207     3
#&gt; 64800: constant        54    train    300  0.8857710  8.585078     2
set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Variable size train set, regression&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      geom_point(aes(
        x, y, fill=set.name),
        help=&quot;One dot per sample in train/test/unused set.&quot;,
        showSelected=&quot;iteration&quot;,
        size=3,
        shape=21,
        data=point.dt)+
      scale_size_manual(values=c(
        featureless=3,
        rpart=2))+
      scale_color_manual(values=algo.colors)+
      geom_line(aes(
        x, y,
        color=algorithm,
        size=algorithm,
        group=paste(algorithm, iteration)),
        help=&quot;One line per learned prediction function.&quot;,
        showSelected=&quot;iteration&quot;,
        data=pred.dt)+
      facet_grid(
        task_id ~ .,
        labeller=label_both),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(width=500)+
      theme(
        panel.margin=grid::unit(1, &quot;lines&quot;),
        legend.position=&quot;none&quot;)+
      scale_y_log10(
        &quot;Mean squared error on test set&quot;)+
      scale_color_manual(values=algo.colors)+
      scale_x_log10(
        &quot;Train set size&quot;,
        breaks=train_size_vec)+
      geom_line(aes(
        train_size, regr.mse,
        group=paste(algorithm, seed),
        color=algorithm),
        help=&quot;One line per algorithm and random seed used to order train set.&quot;,
        clickSelects=&quot;seed&quot;,
        alpha_off=0.2,
        showSelected=&quot;algorithm&quot;,
        size=4,
        data=reg.bench.score)+
      facet_grid(
        test.fold~task_id,
        labeller=label_both,
        scales=&quot;free&quot;)+
      geom_point(aes(
        train_size, regr.mse,
        color=algorithm),
        help=&quot;One point per algorithm and train set size, for the selected random ordering.&quot;,
        size=5,
        stroke=3,
        fill=&quot;black&quot;,
        fill_off=NA,
        showSelected=c(&quot;algorithm&quot;,&quot;seed&quot;),
        clickSelects=&quot;iteration&quot;,
        data=reg.bench.score),
    video=&quot;https://vimeo.com/manage/videos/1053467310&quot;,
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Older_resamplers.Rmd&quot;)
  viz
}
</code></pre>
<p></p>
<div id='ResamplingVariableSizeTrainCVAnimintRegression'></div>
<script>var ResamplingVariableSizeTrainCVAnimintRegression = new animint("#ResamplingVariableSizeTrainCVAnimintRegression", "ResamplingVariableSizeTrainCVAnimintRegression/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-26-train-sizes-regression&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-26-train-sizes-regression/">https://tdhock.github.io/2023-12-26-train-sizes-regression/</a></p>
<p>The interactive data viz consists of two plots:</p>
<ul>
<li>The first plot shows the data, with each point colored according to
the set it was assigned, in the currently selected
split/iteration. The red/blue lines additionally show the learned
prediction functions for the currently selected split/iteration.</li>
<li>The second plot shows the test error rates, as a function of train
set size. Clicking a line selects the corresponding random seed,
which makes the corresponding points on that line appear. Clicking a
point selects the corresponding iteration (seed, test fold, and train
set size).</li>
</ul>
<h2 id="sec:simulated-classification-problems_2">Simulated classification problems</h2>
<p>Whereas in the section above, we focused on regression (output is a real number),
in this section we simulate a binary classification problem (output if a factor with two levels).</p>
<pre><code class="language-r">class.N &lt;- 900
class.abs.x &lt;- 1
rclass &lt;- function(){
  runif(class.N, -class.abs.x, class.abs.x)
}
library(data.table)
set.seed(1)
class.x.dt &lt;- data.table(x1=rclass(), x2=rclass())
class.fun.list &lt;- list(
  constant=function(...)0.5,
  xor=function(x1, x2)xor(x1&gt;0, x2&gt;0))
class.data.list &lt;- list()
class.task.list &lt;- list()
for(task_id in names(class.fun.list)){
  class.fun &lt;- class.fun.list[[task_id]]
  y &lt;- factor(ifelse(
    class.x.dt[, class.fun(x1, x2)+rnorm(class.N, sd=0.5)]&gt;0.5,
    &quot;spam&quot;, &quot;not&quot;))
  task.dt &lt;- data.table(class.x.dt, y)
  this.task &lt;- mlr3::TaskClassif$new(
    task_id, task.dt, target=&quot;y&quot;)
  this.task$col_roles$stratum &lt;- &quot;y&quot;
  class.task.list[[task_id]] &lt;- this.task
  class.data.list[[task_id]] &lt;- data.table(task_id, task.dt)
}
(class.data &lt;- rbindlist(class.data.list))
#&gt;        task_id         x1          x2      y
#&gt;         &lt;char&gt;      &lt;num&gt;       &lt;num&gt; &lt;fctr&gt;
#&gt;    1: constant -0.4689827  0.66379798    not
#&gt;    2: constant -0.2557522  0.53368551   spam
#&gt;    3: constant  0.1457067 -0.45443937   spam
#&gt;    4: constant  0.8164156 -0.62367340    not
#&gt;    5: constant -0.5966361 -0.54847633   spam
#&gt;   ---                                       
#&gt; 1796:      xor -0.7614714 -0.01958119    not
#&gt; 1797:      xor  0.1871909 -0.96323285    not
#&gt; 1798:      xor -0.9253746 -0.64121842    not
#&gt; 1799:      xor -0.9808564 -0.40121772   spam
#&gt; 1800:      xor -0.6768077 -0.44607188    not
</code></pre>
<p>The simulated data table above consists of two input features (<code>x1</code>
and <code>x2</code>) along with an output/label to predict (<code>y</code>). Below we count
the number of times each label appears in each task:</p>
<pre><code class="language-r">class.data[, .(count=.N), by=.(task_id, y)]
#&gt;     task_id      y count
#&gt;      &lt;char&gt; &lt;fctr&gt; &lt;int&gt;
#&gt; 1: constant    not   462
#&gt; 2: constant   spam   438
#&gt; 3:      xor   spam   462
#&gt; 4:      xor    not   438
</code></pre>
<p>The table above shows that the <code>spam</code> label is the minority class
(<code>not</code> is majority, so that will be the prediction of the featureless
baseline). Below we visualize the data in the feature space:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x1, x2, color=y),
      shape=1,
      data=class.data)+
    facet_grid(. ~ task_id, labeller=label_both)+
    coord_equal()
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-35" /></p>
<p>The plot above shows how the output <code>y</code> is related to the two inputs <code>x1</code> and
<code>x2</code>, for the two tasks.</p>
<ul>
<li>For the constant task, the two inputs are not related to the output.</li>
<li>For the xor task, the spam label is associated with either <code>x1</code> or
<code>x2</code> being negative (but not both).</li>
</ul>
<p>In the mlr3 code below, we define a list of learners, our resampling
method, and a benchmark grid:</p>
<pre><code class="language-r">class.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerClassifRpart$new(),
  mlr3::LearnerClassifFeatureless$new())
size_cv &lt;- mlr3resampling::ResamplingVariableSizeTrainCV$new()
(class.bench.grid &lt;- mlr3::benchmark_grid(
  class.task.list,
  class.learner.list,
  size_cv))
#&gt;        task             learner             resampling
#&gt;      &lt;char&gt;              &lt;char&gt;                 &lt;char&gt;
#&gt; 1: constant       classif.rpart variable_size_train_cv
#&gt; 2: constant classif.featureless variable_size_train_cv
#&gt; 3:      xor       classif.rpart variable_size_train_cv
#&gt; 4:      xor classif.featureless variable_size_train_cv
</code></pre>
<p>Below we run the learning algorithm for each of the train/test splits
defined by our benchmark grid:</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(class.bench.result &lt;- mlr3::benchmark(
  class.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 180 rows with 4 resampling runs
#&gt;  nr  task_id          learner_id          resampling_id iters warnings errors
#&gt;   1 constant       classif.rpart variable_size_train_cv    45        0      0
#&gt;   2 constant classif.featureless variable_size_train_cv    45        0      0
#&gt;   3      xor       classif.rpart variable_size_train_cv    45        0      0
#&gt;   4      xor classif.featureless variable_size_train_cv    45        0      0
</code></pre>
<p>Below we compute scores (test error) for each resampling iteration,
and show the first row of the result.</p>
<pre><code class="language-r">class.bench.score &lt;- mlr3resampling::score(class.bench.result)
class.bench.score[1]
#&gt;    test.fold  seed small_stratum_size train_size_i train_size
#&gt;        &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt; 1:         1     1                 10            1         21
#&gt;                          train                  test iteration train_min_size
#&gt;                         &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt; 1:  91,746,863,730,208,508,...  4,10,12,33,40,49,...         1             21
#&gt;                                   uhash    nr                   task  task_id
#&gt;                                  &lt;char&gt; &lt;int&gt;                 &lt;list&gt;   &lt;char&gt;
#&gt; 1: 07a471a4-79fe-4696-a03f-4e93faf133f9     1 &lt;TaskClassif:constant&gt; constant
#&gt;                                learner    learner_id
#&gt;                                 &lt;list&gt;        &lt;char&gt;
#&gt; 1: &lt;LearnerClassifRpart:classif.rpart&gt; classif.rpart
#&gt;                         resampling          resampling_id     prediction_test
#&gt;                             &lt;list&gt;                 &lt;char&gt;              &lt;list&gt;
#&gt; 1: &lt;ResamplingVariableSizeTrainCV&gt; variable_size_train_cv &lt;PredictionClassif&gt;
#&gt;    classif.ce algorithm
#&gt;         &lt;num&gt;    &lt;char&gt;
#&gt; 1:  0.5266667     rpart
</code></pre>
<p>The output above has columns which are very similar to the regression
example in the previous section. The main difference is the
<code>classif.ce</code> column, which is the classification error on the test
set.</p>
<p>Finally we plot the test error values below.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_line(aes(
      train_size, classif.ce,
      group=paste(algorithm, seed),
      color=algorithm),
      shape=1,
      data=class.bench.score)+
    geom_point(aes(
      train_size, classif.ce, color=algorithm),
      shape=1,
      data=class.bench.score)+
    facet_grid(
      task_id ~ test.fold,
      labeller=label_both)+
    scale_x_log10(
      breaks=unique(class.bench.score$train_size))+
    scale_y_continuous(
      &quot;Test error rate&quot;,
      limits=c(0.1,0.6),
      breaks=seq(0.1,0.6,by=0.1))
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-39" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>in constant task, rpart does not have significantly lower error
rates than featureless, which is expected, because the best
prediction function is constant (predict the most frequent class, no
relationship between inputs and output).</li>
<li>in xor task, more than 30 samples are required for rpart to be more
accurate than featureless, which indicates it has learned a
non-trivial relationship between inputs and output.</li>
</ul>
<p>Exercise for the reader: compute and plot mean and SD for these
classification tasks, similar to the plot for the regression tasks in
the previous section.</p>
<h3 id="sec:interactive-visualization-of-data-test-error-and-splits_3">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">class.grid.vec &lt;- seq(-class.abs.x, class.abs.x, l=21)
class.grid.dt &lt;- CJ(x1=class.grid.vec, x2=class.grid.vec)
class.pred.dt.list &lt;- list()
class.point.dt.list &lt;- list()
for(score.i in 1:nrow(class.bench.score)){
  class.bench.row &lt;- class.bench.score[score.i]
  task.dt &lt;- data.table(
    class.bench.row$task[[1]]$data(),
    class.bench.row$resampling[[1]]$instance$id.dt)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=class.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ][]
  class.point.dt.list[[score.i]] &lt;- data.table(
    class.bench.row[, .(task_id, iteration)],
    i.points)
  if(class.bench.row$algorithm!=&quot;featureless&quot;){
    i.learner &lt;- class.bench.row$learner[[1]]
    i.learner$predict_type &lt;- &quot;prob&quot;
    i.task &lt;- class.bench.row$task[[1]]
    grid.class.task &lt;- mlr3::TaskClassif$new(
      &quot;grid&quot;, class.grid.dt[, label:=factor(NA,levels(task.dt$y))], target=&quot;label&quot;)
    pred.grid &lt;- as.data.table(
      i.learner$predict(grid.class.task)
    )[, data.table(class.grid.dt, prob.spam)]
    pred.wide &lt;- dcast(pred.grid, x1 ~ x2, value.var=&quot;prob.spam&quot;)
    prob.mat &lt;- as.matrix(pred.wide[,-1])
    if(length(table(prob.mat))&gt;1){
      contour.list &lt;- contourLines(
        class.grid.vec, class.grid.vec, prob.mat, levels=0.5)
      class.pred.dt.list[[score.i]] &lt;- data.table(
        class.bench.row[, .(
          task_id, iteration, algorithm
        )],
        data.table(contour.i=seq_along(contour.list))[, {
          do.call(data.table, contour.list[[contour.i]])[, .(level, x1=x, x2=y)]
        }, by=contour.i]
      )
    }
  }
}
(class.pred.dt &lt;- rbindlist(class.pred.dt.list))
#&gt;        task_id iteration algorithm contour.i level         x1         x2
#&gt;         &lt;char&gt;     &lt;int&gt;    &lt;char&gt;     &lt;int&gt; &lt;num&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;    1: constant         1     rpart         1   0.5 -1.0000000 -0.3531915
#&gt;    2: constant         1     rpart         1   0.5 -0.9000000 -0.3531915
#&gt;    3: constant         1     rpart         1   0.5 -0.8000000 -0.3531915
#&gt;    4: constant         1     rpart         1   0.5 -0.7000000 -0.3531915
#&gt;    5: constant         1     rpart         1   0.5 -0.6000000 -0.3531915
#&gt;   ---                                                                   
#&gt; 5502:      xor        45     rpart         2   0.5  0.7000000  0.0499392
#&gt; 5503:      xor        45     rpart         2   0.5  0.8000000  0.0499392
#&gt; 5504:      xor        45     rpart         2   0.5  0.8465335  0.0000000
#&gt; 5505:      xor        45     rpart         2   0.5  0.9000000 -0.0460000
#&gt; 5506:      xor        45     rpart         2   0.5  1.0000000 -0.0460000
(class.point.dt &lt;- rbindlist(class.point.dt.list))
#&gt;          task_id iteration set.name row_id      y         x1          x2  fold
#&gt;           &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt; &lt;fctr&gt;      &lt;num&gt;       &lt;num&gt; &lt;int&gt;
#&gt;      1: constant         1   unused      1    not -0.4689827  0.66379798     3
#&gt;      2: constant         1   unused      2   spam -0.2557522  0.53368551     2
#&gt;      3: constant         1   unused      3   spam  0.1457067 -0.45443937     2
#&gt;      4: constant         1     test      4    not  0.8164156 -0.62367340     1
#&gt;      5: constant         1     test      5   spam -0.5966361 -0.54847633     1
#&gt;     ---                                                                       
#&gt; 161996:      xor        45     test    896    not -0.7614714 -0.01958119     3
#&gt; 161997:      xor        45     test    897    not  0.1871909 -0.96323285     3
#&gt; 161998:      xor        45    train    898    not -0.9253746 -0.64121842     2
#&gt; 161999:      xor        45    train    899   spam -0.9808564 -0.40121772     1
#&gt; 162000:      xor        45    train    900    not -0.6768077 -0.44607188     1

set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Variable size train sets, classification&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      theme_animint(width=600)+
      coord_equal()+
      scale_fill_manual(values=set.colors)+
      scale_color_manual(values=c(spam=&quot;black&quot;,&quot;not spam&quot;=&quot;white&quot;))+
      geom_point(aes(
        x1, x2, color=y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        help=&quot;One dot per data sample in the train/test/unused set.&quot;,
        size=3,
        stroke=2,
        shape=21,
        data=class.point.dt)+
      geom_path(aes(
        x1, x2, 
        group=paste(algorithm, iteration, contour.i)),
        showSelected=c(&quot;iteration&quot;,&quot;algorithm&quot;),
        help=&quot;Red path represents decision boundary of rpart decision tree learning algorithm.&quot;,
        color=algo.colors[[&quot;rpart&quot;]],
        data=class.pred.dt)+
      facet_grid(
        . ~ task_id,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      scale_y_continuous(
        &quot;Classification error on test set&quot;,
        limits=c(0.1,0.6),
        breaks=seq(0.1,0.6,by=0.1))+
      scale_color_manual(values=algo.colors)+
      scale_x_log10(
        &quot;Train set size&quot;,
        breaks=unique(class.bench.score$train_size))+
      geom_line(aes(
        train_size, classif.ce,
        group=paste(algorithm, seed),
        color=algorithm),
        help=&quot;One line per algorithm and random seed used to order train set.&quot;,
        clickSelects=&quot;seed&quot;,
        alpha_off=0.2,
        showSelected=&quot;algorithm&quot;,
        size=4,
        data=class.bench.score)+
      facet_grid(
        test.fold~task_id,
        labeller=label_both,
        scales=&quot;free&quot;)+
      geom_point(aes(
        train_size, classif.ce,
        color=algorithm),
        size=5,
        stroke=3,
        fill=&quot;black&quot;,
        fill_off=NA,
        help=&quot;One point per algorithm and train set size, for the selected random ordering.&quot;,
        showSelected=c(&quot;algorithm&quot;,&quot;seed&quot;),
        clickSelects=&quot;iteration&quot;,
        data=class.bench.score),
    video=&quot;https://vimeo.com/1053477025&quot;,
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Older_resamplers.Rmd&quot;)
  viz
}
</code></pre>
<p></p>
<div id='ResamplingVariableSizeTrainCVAnimintClassification'></div>
<script>var ResamplingVariableSizeTrainCVAnimintClassification = new animint("#ResamplingVariableSizeTrainCVAnimintClassification", "ResamplingVariableSizeTrainCVAnimintClassification/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-27-train-sizes-classification&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-27-train-sizes-classification/">https://tdhock.github.io/2023-12-27-train-sizes-classification/</a></p>
<p>The interactive data viz consists of two plots</p>
<ul>
<li>The first plot shows the data, with each point colored according to
its label/y value (black outline for spam, white outline for not),
and the set it was assigned (fill color) in the currently selected
split/iteration. The red lines additionally show the learned
decision boundary for rpart, given the currently selected
split/iteration.  For constant, the ideal decision boundary is none
(always predict the most frequent class), and for xor, the ideal
decision boundary looks like a plus sign.</li>
<li>The second plot shows the test error rates, as a function of train
set size. Clicking a line selects the corresponding random seed,
which makes the corresponding points on that line appear. Clicking a
point selects the corresponding iteration (seed, test fold, and train
set size).</li>
</ul>
<h2 id="sec:conclusion_2">Conclusion</h2>
<p>In this section we have shown how to use mlr3resampling for comparing
test error of models trained on different sized train sets.</p>
<h1 id="chp:session-info">Session info</h1>
<pre><code class="language-r">sessionInfo()
#&gt; R version 4.4.3 (2025-02-28)
#&gt; Platform: x86_64-pc-linux-gnu
#&gt; Running under: Ubuntu 24.04.2 LTS
#&gt; 
#&gt; Matrix products: default
#&gt; BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.12.0 
#&gt; LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.12.0
#&gt; 
#&gt; locale:
#&gt;  [1] LC_CTYPE=fr_FR.UTF-8       LC_NUMERIC=C              
#&gt;  [3] LC_TIME=fr_FR.UTF-8        LC_COLLATE=C              
#&gt;  [5] LC_MONETARY=fr_FR.UTF-8    LC_MESSAGES=fr_FR.UTF-8   
#&gt;  [7] LC_PAPER=fr_FR.UTF-8       LC_NAME=C                 
#&gt;  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
#&gt; [11] LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C       
#&gt; 
#&gt; time zone: Europe/Paris
#&gt; tzcode source: system (glibc)
#&gt; 
#&gt; attached base packages:
#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     
#&gt; 
#&gt; other attached packages:
#&gt; [1] lgr_0.4.4                animint2_2025.1.28       directlabels_2024.1.21  
#&gt; [4] mlr3resampling_2025.3.30 mlr3_0.23.0              ggplot2_3.5.1           
#&gt; [7] data.table_1.17.0       
#&gt; 
#&gt; loaded via a namespace (and not attached):
#&gt;  [1] future_1.34.0        generics_0.1.3       stringi_1.8.7       
#&gt;  [4] listenv_0.9.1        digest_0.6.37        magrittr_2.0.3      
#&gt;  [7] evaluate_1.0.3       grid_4.4.3           plyr_1.8.9          
#&gt; [10] backports_1.5.0      scales_1.3.0         mlr3tuning_1.3.0    
#&gt; [13] codetools_0.2-20     mlr3measures_1.0.0   palmerpenguins_0.1.1
#&gt; [16] cli_3.6.4            rlang_1.1.5          crayon_1.5.3        
#&gt; [19] parallelly_1.43.0    litedown_0.6         future.apply_1.11.3 
#&gt; [22] munsell_0.5.1        commonmark_1.9.5     withr_3.0.2         
#&gt; [25] nc_2025.3.24         tools_4.4.3          parallel_4.4.3      
#&gt; [28] reshape2_1.4.4       RJSONIO_1.3-1.9      uuid_1.2-1          
#&gt; [31] checkmate_2.3.2      dplyr_1.1.4          colorspace_2.1-1    
#&gt; [34] globals_0.16.3       bbotk_1.5.0          vctrs_0.6.5         
#&gt; [37] R6_2.6.1             mime_0.13            rpart_4.1.24        
#&gt; [40] lifecycle_1.0.4      stringr_1.5.1        mlr3misc_0.16.0     
#&gt; [43] pkgconfig_2.0.3      pillar_1.10.1        gtable_0.3.6        
#&gt; [46] Rcpp_1.0.14          glue_1.8.0           paradox_1.0.1       
#&gt; [49] xfun_0.51            tibble_3.2.1         tidyselect_1.2.1    
#&gt; [52] knitr_1.50           farver_2.1.2         labeling_0.4.3      
#&gt; [55] compiler_4.4.3       quadprog_1.5-8       markdown_2.0
</code></pre>
</div>
</body>
</html>
