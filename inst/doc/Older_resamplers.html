<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Same/Other/All resampler</title>
<style type="text/css">
/**
 * Prism.s theme ported from highlight.js's xcode style
 */
pre code {
  padding: 1em;
}
.token.comment {
  color: #007400;
}
.token.punctuation {
  color: #999;
}
.token.tag,
.token.selector {
  color: #aa0d91;
}
.token.boolean,
.token.number,
.token.constant,
.token.symbol {
  color: #1c00cf;
}
.token.property,
.token.attr-name,
.token.string,
.token.char,
.token.builtin {
  color: #c41a16;
}
.token.inserted {
  background-color: #ccffd8;
}
.token.deleted {
  background-color: #ffebe9;
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: #9a6e3a;
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: #836c28;
}
.token.function,
.token.class-name {
  color: #DD4A68;
}
.token.regex,
.token.important,
.token.variable {
  color: #5c2699;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
</style>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  box-sizing: border-box;
}
body, .footnotes, code { font-size: .9em; }
li li { font-size: .95em; }
*, *:before, *:after {
  box-sizing: inherit;
}
pre, img { max-width: 100%; }
pre, pre:hover {
  white-space: pre-wrap;
  word-break: break-all;
}
pre code {
  display: block;
  overflow-x: auto;
}
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre) > code, code[class] { background-color: #F8F8F8; }
code.language-undefined, pre > code:not([class]) {
  background-color: inherit;
  border: 1px solid #eee;
}
table {
  margin: auto;
  border-top: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color: #666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC .numbered li { list-style: none; }
#TOC .numbered { padding-left: 0; }
#TOC .numbered ul { padding-left: 1em; }
table, .body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.footnote-ref a::before { content: "["; }
.footnote-ref a::after { content: "]"; }
section.footnotes::before {
  content: "";
  display: block;
  max-width: 20em;
}

@media print {
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  tr, img { page-break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  pre { white-space: pre; }
}
</style>
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>Same/Other/All resampler</h1></div>
<div class="author"><h2></h2></div>
<div class="date"><h3></h3></div>
</div>
<div class="body">
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Older resamplers}
-->
<p>The goal of this vignette is to explain the older resamplers:
<code>ResamplingVariableSizeTrainCV</code> and <code>ResamplingSameOtherCV</code>, which
output some data which are useful for visualizing the train/test
splits. If you do not want to visualize the train/test splits, then it
is recommended to instead use the newere resampler,
<code>ResamplingSameOtherSizesCV</code> (see other vignette).</p>
<h1 id="same-other-all-resampler">Same/Other/All resampler</h1>
<p>The goal of thie section is to explain how to quantify the extent to
which it is possible to train on one data subset, and predict on
another data subset. This kind of problem occurs frequently in many
different problem domains:</p>
<ul>
<li>geography: can we train on one region (say Europe) and accurately
predict on another? (North America)</li>
<li>time series: can we train on one time period (2000) and accurately
predict on another? (2001)</li>
<li>personalization: can we train on one person (Alice) and accurately
predict on another? (Bob)</li>
</ul>
<p>The ideas are similar to my previous blog posts about how to do this
in
<a href="https://tdhock.github.io/blog/2022/generalization-to-new-subsets/">python</a>
and <a href="https://tdhock.github.io/blog/2023/R-gen-new-subsets/">R</a>. Below
we explain how to use <code>mlr3resampling</code> for this purpose, in simulated
regression and classification problems. To use this method in
real data, the important sections to read below are named “Benchmark:
computing test error,” which show how to create these cross-validation
experiments using mlr3 code.</p>
<h2 id="simulated-regression-problems_1">Simulated regression problems</h2>
<p>We begin by generating some data which can be used with regression algorithms.
Assume there is a data set with some rows from one person, some rows
from another,</p>
<pre><code class="language-r">N &lt;- 300
library(data.table)
set.seed(1)
abs.x &lt;- 2
reg.dt &lt;- data.table(
  x=runif(N, -abs.x, abs.x),
  person=rep(1:2, each=0.5*N))
reg.pattern.list &lt;- list(
  easy=function(x, person)x^2,
  impossible=function(x, person)(x^2+person*3)*(-1)^person)
reg.task.list &lt;- list()
for(task_id in names(reg.pattern.list)){
  f &lt;- reg.pattern.list[[task_id]]
  yname &lt;- paste0(&quot;y_&quot;,task_id)
  reg.dt[, (yname) := f(x,person)+rnorm(N)][]
  task.dt &lt;- reg.dt[, c(&quot;x&quot;,&quot;person&quot;,yname), with=FALSE]
  reg.task &lt;- mlr3::TaskRegr$new(
    task_id, task.dt, target=yname)
  reg.task$col_roles$subset &lt;- &quot;person&quot;
  reg.task$col_roles$stratum &lt;- &quot;person&quot;
  reg.task$col_roles$feature &lt;- &quot;x&quot;
  reg.task.list[[task_id]] &lt;- reg.task
}
reg.dt
#&gt;               x person      y_easy y_impossible
#&gt;           &lt;num&gt;  &lt;int&gt;       &lt;num&gt;        &lt;num&gt;
#&gt;   1: -0.9379653      1  1.32996609    -2.918082
#&gt;   2: -0.5115044      1  0.24307692    -3.866062
#&gt;   3:  0.2914135      1 -0.23314657    -3.837799
#&gt;   4:  1.6328312      1  1.73677545    -7.221749
#&gt;   5: -1.1932723      1 -0.06356159    -5.877792
#&gt;  ---                                           
#&gt; 296:  0.7257701      2 -2.48130642     5.180948
#&gt; 297: -1.6033236      2  1.20453459     9.604312
#&gt; 298: -1.5243898      2  1.89966190     7.511988
#&gt; 299: -1.7982414      2  3.47047566    11.035397
#&gt; 300:  1.7170157      2  0.60541972    10.719685
</code></pre>
<p>The table above shows some simulated data for two regression problems:</p>
<ul>
<li>easy problem has the same pattern for each person, so it is possible/easy to train on one person, and accurately predict on another.</li>
<li>impossible problem has a different pattern for each person, so it is impossible to train on one person, and accurately predict on another.</li>
<li>when adapting the code above to real data, the important part is the
<code>mlr3::TaskRegr</code> line which tells mlr3 what data set to use, what is
the target column, and what is the subset/stratum column.</li>
</ul>
<h3 id="static-visualization-of-simulated-data_1">Static visualization of simulated data</h3>
<p>First we reshape the data using the code below,</p>
<pre><code class="language-r">(reg.tall &lt;- nc::capture_melt_single(
  reg.dt,
  task_id=&quot;easy|impossible&quot;,
  value.name=&quot;y&quot;))
#&gt;               x person    task_id           y
#&gt;           &lt;num&gt;  &lt;int&gt;     &lt;char&gt;       &lt;num&gt;
#&gt;   1: -0.9379653      1       easy  1.32996609
#&gt;   2: -0.5115044      1       easy  0.24307692
#&gt;   3:  0.2914135      1       easy -0.23314657
#&gt;   4:  1.6328312      1       easy  1.73677545
#&gt;   5: -1.1932723      1       easy -0.06356159
#&gt;  ---                                         
#&gt; 596:  0.7257701      2 impossible  5.18094849
#&gt; 597: -1.6033236      2 impossible  9.60431191
#&gt; 598: -1.5243898      2 impossible  7.51198770
#&gt; 599: -1.7982414      2 impossible 11.03539747
#&gt; 600:  1.7170157      2 impossible 10.71968480
</code></pre>
<p>The table above is a more convenient form for the visualization which we create using the code below,</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x, y),
      data=reg.tall)+
    facet_grid(
      task_id ~ person,
      labeller=label_both,
      space=&quot;free&quot;,
      scales=&quot;free&quot;)+
    scale_y_continuous(
      breaks=seq(-100, 100, by=2))
}
#&gt; Loading required package: animint2
#&gt; Registered S3 methods overwritten by 'animint2':
#&gt;   method                   from   
#&gt;   [.uneval                 ggplot2
#&gt;   drawDetails.zeroGrob     ggplot2
#&gt;   grid.draw.absoluteGrob   ggplot2
#&gt;   grobHeight.absoluteGrob  ggplot2
#&gt;   grobHeight.zeroGrob      ggplot2
#&gt;   grobWidth.absoluteGrob   ggplot2
#&gt;   grobWidth.zeroGrob       ggplot2
#&gt;   grobX.absoluteGrob       ggplot2
#&gt;   grobY.absoluteGrob       ggplot2
#&gt;   heightDetails.titleGrob  ggplot2
#&gt;   heightDetails.zeroGrob   ggplot2
#&gt;   makeContext.dotstackGrob ggplot2
#&gt;   print.element            ggplot2
#&gt;   print.ggplot2_bins       ggplot2
#&gt;   print.rel                ggplot2
#&gt;   print.theme              ggplot2
#&gt;   print.uneval             ggplot2
#&gt;   widthDetails.titleGrob   ggplot2
#&gt;   widthDetails.zeroGrob    ggplot2
#&gt; 
#&gt; Attaching package: 'animint2'
#&gt; The following objects are masked from 'package:ggplot2':
#&gt; 
#&gt;     %+%, %+replace%, Coord, CoordCartesian, CoordFixed, CoordFlip,
#&gt;     CoordMap, CoordPolar, CoordQuickmap, CoordTrans, Geom, GeomAbline,
#&gt;     GeomAnnotationMap, GeomArea, GeomBar, GeomBlank, GeomContour,
#&gt;     GeomCrossbar, GeomCurve, GeomCustomAnn, GeomDensity, GeomDensity2d,
#&gt;     GeomDotplot, GeomErrorbar, GeomErrorbarh, GeomHex, GeomHline,
#&gt;     GeomLabel, GeomLine, GeomLinerange, GeomLogticks, GeomMap,
#&gt;     GeomPath, GeomPoint, GeomPointrange, GeomPolygon, GeomRaster,
#&gt;     GeomRasterAnn, GeomRect, GeomRibbon, GeomRug, GeomSegment,
#&gt;     GeomSmooth, GeomSpoke, GeomStep, GeomText, GeomTile, GeomViolin,
#&gt;     GeomVline, Position, PositionDodge, PositionFill, PositionIdentity,
#&gt;     PositionJitter, PositionJitterdodge, PositionNudge, PositionStack,
#&gt;     Scale, ScaleContinuous, ScaleContinuousDate,
#&gt;     ScaleContinuousDatetime, ScaleContinuousIdentity,
#&gt;     ScaleContinuousPosition, ScaleDiscrete, ScaleDiscreteIdentity,
#&gt;     ScaleDiscretePosition, Stat, StatBin, StatBin2d, StatBindot,
#&gt;     StatBinhex, StatContour, StatCount, StatDensity, StatDensity2d,
#&gt;     StatEcdf, StatEllipse, StatFunction, StatIdentity, StatQq,
#&gt;     StatSmooth, StatSum, StatSummary, StatSummary2d, StatSummaryBin,
#&gt;     StatSummaryHex, StatUnique, StatYdensity, aes, aes_, aes_all,
#&gt;     aes_auto, aes_q, aes_string, annotate, annotation_custom,
#&gt;     annotation_logticks, annotation_map, annotation_raster,
#&gt;     as_labeller, autoplot, benchplot, borders, calc_element,
#&gt;     continuous_scale, coord_cartesian, coord_equal, coord_fixed,
#&gt;     coord_flip, coord_map, coord_munch, coord_polar, coord_quickmap,
#&gt;     coord_trans, cut_interval, cut_number, cut_width, discrete_scale,
#&gt;     draw_key_abline, draw_key_blank, draw_key_crossbar,
#&gt;     draw_key_dotplot, draw_key_label, draw_key_path, draw_key_point,
#&gt;     draw_key_pointrange, draw_key_polygon, draw_key_rect,
#&gt;     draw_key_smooth, draw_key_text, draw_key_vline, draw_key_vpath,
#&gt;     economics, economics_long, element_blank, element_grob,
#&gt;     element_line, element_rect, element_text, expand_limits,
#&gt;     facet_grid, facet_null, facet_wrap, fortify, geom_abline,
#&gt;     geom_area, geom_bar, geom_bin2d, geom_blank, geom_contour,
#&gt;     geom_count, geom_crossbar, geom_curve, geom_density,
#&gt;     geom_density2d, geom_density_2d, geom_dotplot, geom_errorbar,
#&gt;     geom_errorbarh, geom_freqpoly, geom_hex, geom_histogram,
#&gt;     geom_hline, geom_jitter, geom_label, geom_line, geom_linerange,
#&gt;     geom_map, geom_path, geom_point, geom_pointrange, geom_polygon,
#&gt;     geom_qq, geom_raster, geom_rect, geom_ribbon, geom_rug,
#&gt;     geom_segment, geom_smooth, geom_spoke, geom_step, geom_text,
#&gt;     geom_tile, geom_violin, geom_vline, gg_dep, ggplot, ggplotGrob,
#&gt;     ggplot_build, ggplot_gtable, ggsave, ggtitle, guide_colorbar,
#&gt;     guide_colourbar, guide_legend, guides, is.Coord, is.facet,
#&gt;     is.ggplot, is.theme, label_both, label_bquote, label_context,
#&gt;     label_parsed, label_value, label_wrap_gen, labeller, labs,
#&gt;     last_plot, layer, layer_data, layer_grob, layer_scales, lims,
#&gt;     map_data, margin, mean_cl_boot, mean_cl_normal, mean_sdl, mean_se,
#&gt;     median_hilow, position_dodge, position_fill, position_identity,
#&gt;     position_jitter, position_jitterdodge, position_nudge,
#&gt;     position_stack, presidential, qplot, quickplot, rel,
#&gt;     remove_missing, resolution, scale_alpha, scale_alpha_continuous,
#&gt;     scale_alpha_discrete, scale_alpha_identity, scale_alpha_manual,
#&gt;     scale_color_brewer, scale_color_continuous, scale_color_discrete,
#&gt;     scale_color_distiller, scale_color_gradient, scale_color_gradient2,
#&gt;     scale_color_gradientn, scale_color_grey, scale_color_hue,
#&gt;     scale_color_identity, scale_color_manual, scale_colour_brewer,
#&gt;     scale_colour_continuous, scale_colour_date, scale_colour_datetime,
#&gt;     scale_colour_discrete, scale_colour_distiller,
#&gt;     scale_colour_gradient, scale_colour_gradient2,
#&gt;     scale_colour_gradientn, scale_colour_grey, scale_colour_hue,
#&gt;     scale_colour_identity, scale_colour_manual, scale_fill_brewer,
#&gt;     scale_fill_continuous, scale_fill_date, scale_fill_datetime,
#&gt;     scale_fill_discrete, scale_fill_distiller, scale_fill_gradient,
#&gt;     scale_fill_gradient2, scale_fill_gradientn, scale_fill_grey,
#&gt;     scale_fill_hue, scale_fill_identity, scale_fill_manual,
#&gt;     scale_linetype, scale_linetype_continuous, scale_linetype_discrete,
#&gt;     scale_linetype_identity, scale_linetype_manual, scale_radius,
#&gt;     scale_shape, scale_shape_continuous, scale_shape_discrete,
#&gt;     scale_shape_identity, scale_shape_manual, scale_size,
#&gt;     scale_size_area, scale_size_continuous, scale_size_date,
#&gt;     scale_size_datetime, scale_size_discrete, scale_size_identity,
#&gt;     scale_size_manual, scale_x_continuous, scale_x_date,
#&gt;     scale_x_datetime, scale_x_discrete, scale_x_log10, scale_x_reverse,
#&gt;     scale_x_sqrt, scale_y_continuous, scale_y_date, scale_y_datetime,
#&gt;     scale_y_discrete, scale_y_log10, scale_y_reverse, scale_y_sqrt,
#&gt;     should_stop, stat_bin, stat_bin2d, stat_bin_2d, stat_bin_hex,
#&gt;     stat_binhex, stat_contour, stat_count, stat_density,
#&gt;     stat_density2d, stat_density_2d, stat_ecdf, stat_ellipse,
#&gt;     stat_function, stat_identity, stat_qq, stat_smooth, stat_spoke,
#&gt;     stat_sum, stat_summary, stat_summary2d, stat_summary_2d,
#&gt;     stat_summary_bin, stat_summary_hex, stat_unique, stat_ydensity,
#&gt;     theme, theme_bw, theme_classic, theme_dark, theme_get, theme_gray,
#&gt;     theme_grey, theme_light, theme_linedraw, theme_minimal,
#&gt;     theme_replace, theme_set, theme_update, theme_void,
#&gt;     transform_position, update_geom_defaults, update_labels,
#&gt;     update_stat_defaults, waiver, xlab, xlim, ylab, ylim, zeroGrob
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-3" /></p>
<p>In the simulated data above, we can see that</p>
<ul>
<li>for the easy pattern, it is the same for both people, so it should
be possible/easy to train on one person, and accurately predict on
another.</li>
<li>for the impossible pattern, it is different for each person, so it
should not be possible to train on one person, and accurately
predict on another.</li>
</ul>
<h3 id="benchmark-computing-test-error_1">Benchmark: computing test error</h3>
<p>In the code below, we define a K-fold cross-validation experiment.</p>
<pre><code class="language-r">(reg_same_other &lt;- mlr3resampling::ResamplingSameOtherCV$new())
#&gt; &lt;ResamplingSameOtherCV&gt; : Same versus Other Cross-Validation
#&gt; * Iterations:
#&gt; * Instantiated: FALSE
#&gt; * Parameters:
#&gt; List of 1
#&gt;  $ folds: int 3
</code></pre>
<p>In the code below, we define two learners to compare,</p>
<pre><code class="language-r">(reg.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerRegrRpart$new(),
  mlr3::LearnerRegrFeatureless$new()))
#&gt; [[1]]
#&gt; &lt;LearnerRegrRpart:regr.rpart&gt;: Regression Tree
#&gt; * Model: -
#&gt; * Parameters: xval=0
#&gt; * Packages: mlr3, rpart
#&gt; * Predict Types:  [response]
#&gt; * Feature Types: logical, integer, numeric, factor, ordered
#&gt; * Properties: importance, missings, selected_features, weights
#&gt; 
#&gt; [[2]]
#&gt; &lt;LearnerRegrFeatureless:regr.featureless&gt;: Featureless Regression Learner
#&gt; * Model: -
#&gt; * Parameters: robust=FALSE
#&gt; * Packages: mlr3, stats
#&gt; * Predict Types:  [response], se
#&gt; * Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt;   POSIXct
#&gt; * Properties: featureless, importance, missings, selected_features
</code></pre>
<p>In the code below, we define the benchmark grid, which is all
combinations of tasks (easy and impossible), learners (rpart and
featureless), and the one resampling method.</p>
<pre><code class="language-r">(reg.bench.grid &lt;- mlr3::benchmark_grid(
  reg.task.list,
  reg.learner.list,
  reg_same_other))
#&gt;          task          learner    resampling
#&gt;        &lt;char&gt;           &lt;char&gt;        &lt;char&gt;
#&gt; 1:       easy       regr.rpart same_other_cv
#&gt; 2:       easy regr.featureless same_other_cv
#&gt; 3: impossible       regr.rpart same_other_cv
#&gt; 4: impossible regr.featureless same_other_cv
</code></pre>
<p>In the code below, we execute the benchmark experiment (in parallel
using the multisession future plan).</p>
<pre><code class="language-r">if(FALSE){#for CRAN.
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
#&gt; Loading required package: lgr
#&gt; 
#&gt; Attaching package: 'lgr'
#&gt; The following object is masked from 'package:ggplot2':
#&gt; 
#&gt;     Layout
(reg.bench.result &lt;- mlr3::benchmark(
  reg.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 72 rows with 4 resampling runs
#&gt;  nr    task_id       learner_id resampling_id iters warnings errors
#&gt;   1       easy       regr.rpart same_other_cv    18        0      0
#&gt;   2       easy regr.featureless same_other_cv    18        0      0
#&gt;   3 impossible       regr.rpart same_other_cv    18        0      0
#&gt;   4 impossible regr.featureless same_other_cv    18        0      0
</code></pre>
<p>The code below computes the test error for each split,</p>
<pre><code class="language-r">reg.bench.score &lt;- mlr3resampling::score(reg.bench.result)
reg.bench.score[1]
#&gt;    train.subsets test.fold test.subset person iteration                  test
#&gt;           &lt;char&gt;     &lt;int&gt;       &lt;int&gt;  &lt;int&gt;     &lt;int&gt;                &lt;list&gt;
#&gt; 1:           all         1           1      1         1  1, 3, 5, 6,12,13,...
#&gt;                    train                                uhash    nr
#&gt;                   &lt;list&gt;                               &lt;char&gt; &lt;int&gt;
#&gt; 1:  4, 7, 9,10,18,20,... e839f8b2-a366-4406-abe4-627c12967073     1
#&gt;               task task_id                       learner learner_id
#&gt;             &lt;list&gt;  &lt;char&gt;                        &lt;list&gt;     &lt;char&gt;
#&gt; 1: &lt;TaskRegr:easy&gt;    easy &lt;LearnerRegrRpart:regr.rpart&gt; regr.rpart
#&gt;                 resampling resampling_id       prediction regr.mse algorithm
#&gt;                     &lt;list&gt;        &lt;char&gt;           &lt;list&gt;    &lt;num&gt;    &lt;char&gt;
#&gt; 1: &lt;ResamplingSameOtherCV&gt; same_other_cv &lt;PredictionRegr&gt; 1.638015     rpart
</code></pre>
<p>The code below visualizes the resulting test accuracy numbers.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    scale_x_log10()+
    geom_point(aes(
      regr.mse, train.subsets, color=algorithm),
      shape=1,
      data=reg.bench.score)+
    facet_grid(
      task_id ~ person,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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iPW8cw0AUM9qCcS9e/e++eabhJAXXnjB29t79erV9VEUAIAz1BKI48ePf+65544cOWIwGLKysubPn18/ZQEA1L9aAtFoNPbt23f79u0DBw4MCQkxm831UxYAQP2r5SxzZGTkq6++evDgwdOnT8+ZM6dx48b1UxYAQP2rZQtxzZo1MTExmzdv9vHxYVl23bp19VMWAED9qyUQ3zMCQKwAACAASURBVH///YkTJ9quEJw9e/aHH35YH0UBADjDXXeZ27RpQwi5fv16SkqKbY7FYqn7cAAAAC7nrluIhw8fPnz48HPPPXf4L3/++eeff/5Zn8UBQEOzd+/eYcOG3euz1q9f37Vr1+LiYtuWVmpq6pAhQx5CdQ/qroHo7+/v7++/fv36nTt3fvTRRyqV6sCBA+IO+gYAbs9qtarV6qSkpN9++83ZtdSulrPMc+bMOX78+NWrVymlS5cuPXr06CeffFI/lQGA0wmCMHXq1E2bNvn4+MTHxzuG5uN5/p133vn9998DAwPDwsKSkpJeffXVDz/88Oeff6aUjho1avbs2ampqV9++eX58+dHjhz51FNPLV68mGGY69evT548efjw4aWlpcOGDTtz5kz79u1Xr1595syZ5ORkPz+/7OzsmJgYSunFixdNJtPvv/8u+mCgNaglEH/55ZeTJ0++8MILLMvu3LmzZcuWCESAR8f58+ezs7OvXr1KCGnXrt3EiRNt83/99dcLFy5kZWUVFBS0bt06KSlpx44du3btsg1y2rt37yeeeMLT03PXrl2nTp0KDw9PTU0lhHz99ddnz55dunRpamrqvn37srOzw8LCevbsuXfvXn9//9TUVNuQgP7+/ps2bVq0aNHgwYP37t17x3H1H5JaAtFkMjkuxjYYDOIOCwwADVz79u1/+umnP/7449ixY7du3XKMcrZnz56xY8dyHBcSEtKzZ09CyP79+1999VUPDw9CyMiRI/fv3//cc8/FxsaGh4ffseXu3bs3b96cENKpUye9Xm+bY9sYDAgIePrppwkhzZo1KykpqZc3alfLZTeTJ0/u16/flStXkpOTn3rqKcf3AwA8Co4cOdKrV6+MjIxnn322U6dOjvlWq9VxXx3baOqCIDjuKkEptY39XMOtGoKDg6vMqXyKwlmnK2oJxLfeeuuTTz4ZPny41Wr97rvvpk6dWj9lAUBDsGfPnv79+//zn/8MCgrKyMhw7C/GxcX98MMPVqu1sLBw3759tjk///yzwWDQ6/U///xzr1697thgA78JTO0DxPbp06dPnz4Ew38BPHqGDx8+adKkLl26NG/efPLkyR9++OH06dMJIaNGjTp+/HirVq1atGgxePBgHx+f55577ujRo5GRkYIgDB8+PCkpyXbcsDIfHx8fH58xY8bU8f7DDMNwXL0OYl3LLQT27t27bdu2xYsXv/DCC3v27FmyZMno0aPrqzbcQsAOtxDALQTuxlm3EDh8+HBOTs7o0aOtVmvfvn2/++67iIiI+26t4cDwXwBwz9q1a7dp06auXbvGxMQkJSW5RxqSWneZbcN/ffDBBxj+CwAcfH19t27d6uwqxIfhvwAA7DD8FwCAXS1biDKZTK/Xf/jhh1KpND4+vkmTJvVTFgA0BDzP266arjsPDw/HBYkup5ZAHD9+fHFx8cSJEymly5YtO3fu3BdffFE/lQFAQ1DH893uoZZA3Ldv36VLl2xXovfr169169YIRABwV7UcQwwLC3NcrVZSUhIQEPDwSwIAcI67biHOnTuXEBIWFta5c+dBgwYRQjZu3PjKK6/UX2kAAPXrroFo++l1cHDwU089ZZvzwQcf4BYCAEAIIbYDi0xNu5jl5eXPPffc8uXL27ZtK8prfvPNNwEBAYMHDxaltTu6ayCOHz+eELJ9+/bKM2sYuwIAHhHswRR68zrhBaFlK2u32Lstdu7cud69e9echnv37j1x4sS7775b/aGKigovLy8Ryr0XtZxUcYz6ffv27f3790+dOvVug1gAwKOA3s6nOq1l2GhCCPv7elJWSlR33nFcvXr1qVOnEhISFi5caDAYQkNDv/3229u3b0+ePJkQ4uHh8eOPP65atSo7Ozs3NzchIeHZZ5+dO3du3759MzMzd+3apVQqP//881dffdXxXFuzpaWllWeePHly4cKFFoslKSmpc+fOjukJEybcz7ur+xg2t2/fnjhx4qZNm+7jZQDAFfE8X2VYDeZSNlUXW7vGEELYgylCy1Z849DKC3h6etquQ0xNTd2zZw/HcS1atBg6dOjChQubNWv2+OOPm83m7t27v/zyywsWLLh8+fKJEyfkcnmLFi0qB+KZM2eWLFkyf/78ys+tqKgICAjIzMysPPPChQtRUVEDBw5cv359RkaGY3rEiBH38X5rOctcWWBgYFZW1n28BgC4DaFJMybrPL1yicm5yNy4ygcG1bx8Tk7Ohg0b3njjjUuXLvn4+AQFBa1cuXLixIkXLlyofoWjY7TEbt26VX/uHRscN27cli1bEhISpFJp5en7e3e17DKPGTPGMZ2enh4VFXV/LwMA7kGQycwDX2LPniYMYxk0jNQ2XmHLli2DgoJee+21jRs3tmzZ8vPPPx8xYkTv3r379etn2z0VBIHjONutAv7888+EhARCiC3Rqjz3xo0b1WceOHBgwYIF/v7+sbGxM2bMcEzf321Oa9llrnxSRS6X9+jRQy6X38fLAIArqr7LXKsqu8zTpk0bPny4RCJp1qzZkiVLDhw48Omnn3p7e3t6eoaEhAwdOvSVV15ZsGDBRx995OPj4+vrO2nSpLS0NE9Pz6FDh5aWllZ+ru0s89NPP1155n/+85/ly5crlcqWLVvGxMQ4pm0XDt6reziGWPmeCQDwKHiQQHRFtWzuOnfE7Mo9QSnlOE7cARkppZRScX+qyXEcz/PitsmyrO2WPWJhGIZhmLrf3UIikVQ5KKPT6Wr4KrXdIUjEmsVdAxKJxGq1itVHon+KpFJp3Ufz5jiuoqLiPl6l+ijoQOoyuMPy5csdI2bHxcXVZyBWHmaD4zi5XF5eXi5i+w/pFgJGo1H0Wwjc64gjNbPdQuCe2qwSiHq9vtZbCIhYs7hrQCqVms3mBnsLAaVSWVFRUfdbCNzffTV8fX0RiNXVcpbZNmL29u3bMWI2ALg9jJgNAHfFMIynp+c9PcV1DyCSWgNxzZo1a9eunTFjBkbMBngECYJwr8eUZDKZ62ZiLYGoUqkmTpxom541a1bl+4ICgNsTBOFeD5TJZLKHVEw9uIdfqly9etU2BA4AgFu6h0AMDw/XaDQPrxQAAOeqZZdZo9Hs3bvXcUkBx3EPdTAyAAAnqiUQx44dazQaw8PDbf9lGAaBCADuqpZAtFgsW7ZsqZ9SAMAlHKzQLC8o5iiZGhQYrfSoeeE6jvNaUVFx7Nixuw0WW29qCcQWLVqUlpbizgEAYJNnMn91u+j78GZmQXj10rWfIh7zZu98KmLlypW2cV6Dg4O1Wi3DMPn5+StXriwvL688Ruzq1atti5lMpuzs7MGDB7do0aJ+39P/1HJS5ebNmyEhIU8//fSQv9RPWQDQMJ3TG+K9PZUM48OyPbyUmTX+ZjEoKOj7778nhDRr1mzx4sU9evT4/vvv8/Ly3nnnnd9//91qtV6/ft2x2NixY52bhqTWLcRJkyZNmjSpfkoBgIavnUL+Q5F6VICflZAjGu24RjXdmtg2zishxDaUaqdOnTZt2jRw4MC5c+f++OOPjjFiHYs53V0DsWvXrr/99tvixYurzO/Ro8dDLgkAGq4mUsnoAL9XL19nKHkrOMiHZWtY2DEmyLFjx/r27fvf//73jmPEOhar+2iED8ldA/Gtt97y8/N7880367MaAGj4+qm8+qnu7X54J06cePHFF81m85o1a06ePPnpp5+uXLkyPDx87dq1oaH2W7I0adLk/fffHzx4cMuWLR9C1XVy10AcOnQoISQ2NvbixYu26xDNZvPcuXO3bdtWf9UBgMt67bXXHNOzZs3q0qWLbTouLi4uLq768q1atTp69Gg9FXcXtRxDnD59+o4dO27dutWpU6cLFy5MmTKlfsoCAKh/tQTi7t27z58///HHH/fv379Ro0b//Oc/66csAHAbCxYscHYJdVXLZTelpaWEkG7duh08eLBZs2ZXrlypl6oAAJygli3EQYMG9e/f/6effnrnnXcKCgoCAmo6xQ4AboZSKpFInF1F/aklEJcsWXL+/PnAwMBvv/127969S5curZ+yAKAhoJQ+UncerikQ1Wr1ihUr3nvvPUJIbGxsbGxsfVUFAOAENR1DVKlUP//8M44bAsAjoqYtRJZl27Vr16lTp9jYWMcdCzds2FAvhQEA1LdajiFOnTp16tSp9VMKAIBz1RKIa9eurXwiZfTo0fgtMwC4q7sGYps2bQgh169fT0lJsc2xWCwYGBEA3NhdA/Hw4cOEkEmTJn399deOmQhEAHBjdw1Ef39/Qsj69evrsRgAAGe6h9uQAgC4NwQiAICdKwViodl8zmA0/n1M3Wyj6ZLRVHlOntly3mC0/n0xtuC2JOs8NZuI1coW3KZaTX1U/Mi4ZDRl/70XKrMKwnmDMc9sqf4QtVjY2/lGne6s3qC2Wv/2kFbDFtwmVitTVkoLbhNnj6UMj4JaLrupmU6n+/TTT69cuSKRSCZPntyxY0dBEFasWHHkyBGlUhkVFfX6669nZmZu2rTJy8srLy+vVatWlNKbN29aLJb3339fIpFs3rx5+/btHMf17Nlz2LBhNbzW5tKyTTfyHmeY2Tr9V02CQyUSgZCpufmeLCsQYuD5z0ODKSFfF6nP6A1hUmmaXv99s1AlwxBCFNs2sjdv8F7esj928H4BlqZhkhK1tdljQnTMg7x9sJl+85aUYRhCNDz/ZWgw/fujOp4fcz2vo0J+w2xuK5NODfR3PETLShU7t6qDm+TcuHatVbtFjUJf9lU95+1JCJGcO81dzrH6ByjOn7WENiO+voqiAv1zg0mNA9YDPKAHCsQDBw54enquWrUqLS3t6NGjHTt2vH79uu1Og4SQyZMnJyUlEUIyMjK+//57nudHjBgxc+bM0aNHL1iwIC0tTSqVHjx48LPPPuM4btGiRfv37+/VqxchZOfOnbdv36aUDh482PFaa3Lz/9OxnVGvP63VrVaXftw05LRW11gh/6hJCCFk5o2bOQJpo5Af1ht/fzyCELJRXbpVqx/bKIDotGzudevUdwjHkTWrGJ2W7fcsIUT280ohtifDsgwj5mYywzBSqZQV9e+W4ziFQiFugwzD1L3N6m/H8YP/dJ3eRypd2CyUEDInN/+CVYj29OA4jhBia39DYfHIRgEv+fsSQgZnX6YymfyvFc4cShESn19k4oc/2WvYll8HPdVzcPblIUGBhBD2YoZ1xFhWpxXyb7IhIWzvfsKhfR43rwut2j742xe3jyilHMdRSmtftM7kcnkd7y4i7qcXHigQW7duvXHjxjVr1kRHR7/xxhuEkLCwsOnTp58+fTo7O7ukpMRkMtkWs40g5O3tHRkZSQgJDAzUaDQ3b97UaDSLFi0ihKjV6uzsbFsgFhUV3bx5k1Ja+SPLEMpSyrKst0RioZRlWQtlPFnOtowXx1koJQwjZxjHnCKrlWVZIhDKMKxUSiilLEf++vOmnIRhGPrX8mKpUnbDbJNhmHtqs/pfu+O5Fobx5Cr1AkNZlrUtb5tppjTgrwUUDCNUWuGU5wW5wmLSeUmllKFSjmMpw7IsEQTKcizHEUGgMjnheUoplcsZQRDEWA+UUhFzhFIqegexLOv02y09mh4oEJs3b/7FF18cPHhw3bp1Mpls5syZmZmZS5YsiY+Pj46OPnv2rG2xyh++ytMymSwhIWHQoEGEEJ7nHZ+AkSNH2iaKioocC/dReozLyonk2A2lZfODG2k0mtZEWFBWnmyxCEQ4pdNPVXlZdLoQhr576WpzqeS30vLvmoZoNBrCMB6e3vTrz6yBwdy1K4LKx3TkMFNUIPj58wYDy7JGo/FBVkIVKpVKr9fbvgnEolQqtVqtiA3KZDK5XK7R1PVAqkKhkMlkledotVpbf7UQhLSKikVXrzOUpmq047yVGo1GqVQKgqDT6QghCXLp2Ot5uVrtdZM5gBCi1ztelW3bUbZlw5QWrXP277wd0mRVVk4fhcxWlaxRMNnyG98oWHbjusVbJfz3IJ+epn9hqFDnmmugUqkMBoNYfWTb3jTUeHvieyKXy7Vare3+nHVZWKzXBfKAgfjLL7/wPD98+PCYmJjx48cLgpCWltatW7eBAwcWFhbm5uZa/36YvIrIyMilS5cmJiZKpdI5c+YkJSXVMMLY+EC/Kwx7pqh4eZOQQI4lhHCU/tAs5IBWRwkZ5+/LUkoI+bhxo+M6Q4HF/FOzUC/WHr664aMl6WcZdaHulXGCXMZev2pp3c7aOPSB3jwQQghhKV3VNOSgVscL5PVmPly1bUk/lv05LPSARtvKS9nN42876dbARvqkgaE3b0ifjDvk4T1eJm0js9+O0hjbk72Vx5SXacZOYAtvcwyjHzxMYNFj8HA90Cesd+/eycnJKSkpLMuOHz+eUhoXF7ds2bLp06cHBQUlJSWtXbt2yJAh1Z/IMAzLsi1btuzTp8+MGTNMJtOTTz5Z63iLkZ7Kpqa/bc1xlD7tqayyWFcPOSF//9qk1Nwh0vE/y+Nt7ultQs04SvtU64XKPBnmWe8737VSUHqaH2/jQ0j/ag9Zg0OswSGEEGuz5oJSKYi6jQxwR7QhH6qovMvMcZy3t7darRaxfY7jHuVd5rKysjour1AoHOO/2RQXF9fwyam8yywKcdeAuH0k+i5zQECAWq2u+y5zXl7efbyKr69vYGDgfTzRveEUFQCAHQIRAMAOgQgAYIdABACwQyACANghEAEA7BCIAAB2CEQAt2K1WssrmTt3rm3C2XW5BvwWCsCtTJ48WaPROAabKCgo+Mc//kEI+eGHH5xal2tAIAK4lebNm7/77ruO/y5evPjNN990Yj2uBbvMAG5l1KhRP/3004ULFwghV65cmTZtmrMrciUIRAC3snjxYr1en5ycXFpaumzZsq+++srZFbkSBCKAWykrKxs3blxiYmJWVtaCBQsOHDjg7IpcCQIRwK00bty4oKCgY8eOGRkZhBAvrzsPvAZ3hJMqAG6lefPm48ePDwsLy8nJ2bNnT0wM7qR2DxCIAG4lMzNz4cKFtvt8SaXS0NBQZ1fkSrDLDOBWpk2bduzYsYiICErp6dOn9Xq9sytyJQhEALcyd+5ci8Wi0WhmzZp1/vz5+fPnO7siV4JABHArJSUlY8aMSUlJiY+PnzlzZk5OjrMrciUIRAC3wrKsWq1OTU2NiYk5efKkVCp1dkWuBIEI4FZGjhw5cuRImUzWtm3bI0eOzJgxw9kVuRKcZQZwK4mJiQkJCZRSQsiUKVOcXY6LQSACuJVdu3bdcf4zzzxTz5W4IgQigFu5cuUKISQrK6uwsPDJJ590djkuBoEI4FYmTJhACLl27dqkSZP8/PxeeuklZ1fkShCIAG7FYDCsWbNmx44d48aNO3bsmNFoHDVqlLOLchk4ywzgVkaPHq1Wq1etWjVgwIB58+ZdvnzZ2RW5EmwhAriJvLy8kJCQ2bNnt23b1jaHZdkPPvjAuVW5FmwhAriJrVu3EkIcaWjjuLkK1AUCEQDADoEIAGCHQAQAsEMgAgDYIRABAOxw2Q2Am+jbty8hJD09vcr88PDwo0eP9u7d2xlFuRgEIoCbaNGiBSFkw4YNVeZPmjRp/fr1CMS6QCACuJXZs2fv3LnzzJkzgiBERkYmJSWxLLt8+XJn1+UaEIgAbuXLL78sKCjo37+/IAhbt27NycmZPn26s4tyGQhEALdy/Pjxn376yfYDlSeeeGLkyJHOrsiV4CwzgFvx8fFx3Hq0oqLC19fXufW4FmwhAriVbt26jR8/vlevXjzP79u3r0OHDuvWrSOEDBs2zNmluQAEIoBbCQkJGTRokG16yJAhzi3G5SAQAdxKz549ZTKZ7SZTgiAYjUa5XO7solwGjiECuJXExMT8/HzbdG5ubmJionPrcS3YQgRwKxs3blSpVLbpkJCQjRs3Orce14JABHArfn5+jmmWZSv/F2qFXWYAADsEIgCAHXaZAdwKRrt5EA8lECsqKt59992vv/46IyNj69at77777sN4FQCoDqPdPIiGsoXI87xWq/Xy8nJ2IY+WVK3uQIW2/4UzzW5cyfMNaNIkVFNSsrdRqLLZYwO8vRjq7PoeeZbsTPWJYzqLWaPwKAto9N+INs08lS/6eLP0rn1T/WLsoKAgjHZTR+IE4rp16/bt20cp7d2798svv7xs2bLCwsLly5fHxcVpNJrk5OQrV66EhYVNmzZNLpdv3rx5+/btHMf17Nlz2LBhGRkZ27Ztu379eq9evV588UVR6oG62KfRbSgt+7/0E9orl3+JjJ5y9njRjWs/xyVMu3x+J+E/DWrydiN/Z9f4SOPS0wr/PJzbKLj9jWsVmoo0mWLYwd07EwfOu100Nzjwbs9av369bYLn+fT09A4dOnz88cf1VbLLEyEQT5w4cerUqSVLlhBCZs2a9fjjj0+cOPHq1asTJkzIyMg4d+7cN99806hRo/fee+/s2bNyufzgwYOfffYZx3GLFi3av39/UFDQqVOnFi9eHBwcbGtw/vz5mZmZDMOsXLnS8SqUUoZhfHx8Hrzgym0SQhQKhYhtsiyrVCo9PDxEbJNhGIlEImKDtpW522Bc1DLCb9fvG/ompipVbxfeVFy/3rZFRGC7ViMP7RvoH+xY2zzPV2nBcaXb3QomhEilUrEKFncNiN5HDMOI+2sQb29vQojhSo7OQ5nhGxAX3S13z64ehM/1UP7T33fAzVs1dM1HH33kmDabzZ9//rmIhbk9EQIxPT29T58+MpmMENKrV6/09PSWLVs6Hm3dunVQUBAhJDw83Gg0ZmdnazSaRYsWEULUanV2dnZQUFCbNm0caUgIGTRoUEVFBSFEq9U6ZrIs6+HhUXnOg2NZlmEYs9ksYptKpdJkMonbplwuNxgMIjYokUikUmkjSk6pS/pJpdKr1yyt2/E6rUBIhclkuHVDJ5NJeN6xtqtHm06nEwShhoIJISLWLO4a8PT0NBgMFotFlNYYhuE4zmQyidIaIUSlUtlWL+uhJEXFRCIryMqkPH9Lpgguzc/nrYL1f11T8/cEz/O5ubliFfYoECEQBUGgfx3RoJRW+cqqMvqQTCZLSEiw/fic53lBEC5evFjl27VNmza2iaKiosqvQggRN2gEQWBZVvQ2LRaLuG1KpVJxG2QYRhCEN3xV/7h5a2dU99n7//NixhkdbzV5ekZu23icZf4v+sl/Bfo7XpTjqn5OzGZzDYEolUoFQRCxZnHXAM/zVqtVrAYZhqGUittBFouF53lL96eC8te/fOygzGLhWFZvEba2bnvoWt6c4EDHy9nGPazspZdeckyXlZW98MILIhbm9kQIxPbt22/cuLFPnz6EkH379r388suEEKvVeseFIyMjly5dmpiYKJVK58yZk5SUhPHanMWTYb5vGmJt0pjt0I5YLGaW9aK0Dc9bKf3x7sfsod4IHkr5yLGE542CwBDSlmVbCcLU2rrGNtgXIUQQhJMnT545c+bhV+o+RAjErl27Xrx4cdq0aYIgxMXFRUdH8zyvVCq/+OKLfv36VVm4ZcuWffr0mTFjhslkevLJJ2NjYzMyMh68Brhv9vOVHGff0mCYqpsc4FyVeqSGk8sOlbcZn3jiiW3btj2cstwTrWHHx+kq7zJzHOft7a1Wq0Vsn+M4lmWNRqOIbapUKr1eL+IRJUKIUqkU9+CpTCaTy+VlZWV1XF6hUCiVyspziouLa/jkKJVKQRB0Ot0DVfn3BkVcA+L2EcMwUqlUxEOcAQEBarW6+tmSO5LL5Xl5eZXnfP31146uKSwsNBgMCxcurP5EX1/fwMC7nqp+ZDWU6xABQBRt2rRxHLDq0qVLly5dnFuPa0EgAriJ6nvHer1+586d/fv3d0o9rgiBCOAmCgsLCSGXL1/OzMzs0aMHy7JHjx7t3r27s+tyJQhEADcxduxYQsiUKVO+/fZb28UbBoNhwYIFzq7LlWD4LwC3olarbT90IYTI5XLbbxygjrCFCOBWOnXqNHv27Oeff55hmH379jVp0sTZFbkSBCKAW5k+ffqWLVu2b99OKe3cufOzzz7r7IpcCQIRwK1wHBcaGlpUVEQpDQkJqf6zS6gBjiECuJVVq1atWbOmcePGwcHBq1ev/uGHH5xdkSvBtweAW9m3b9/KlSttAxT169fvtddee/XVV51dlMvAFiKAWxEEofKvKinG6bgX2EIEcCtPP/30jBkz4uPjBUHYvXt39QFWoAYIRAC3MmbMmNatW6elpVFKx4wZ061bN2dX5EoQiABu5datWzk5ORMmTLh8+XJ6erpWq60yUhHUAMcQAdzK3LlzLRaLRqOZNWvW+fPn58+f7+yKXAkCEcCtlJSUjBkzJiUlJT4+fubMmTk5Oc6uyJUgEAHcCsuyarU6NTU1Jibm5MmTIt778FGAQARwKyNHjhw5cqRMJmvbtu2RI0dmzJjh7IpcCU6qALiVxMTEhIQE2+WHU6ZMcXY5LgZbiABu5datWz///DMh5PLly1u3bhX3bjxuD4EI4FZwlvlBIBAB3ArOMj8IBCKAW8FZ5geBQARwKzjL/CBwlhnAreAs84NAIAK4lfT09CpzwsPDjx492rt3b6fU41oQiABuZcOGDVXmTJo0af369QjEukAgAriVXr16aTSaynOOHTuGW03VEQIRwK1cvnx5165dPXv2FATh0KFDkZGRuBNp3SEQAdzKyZMnv/nmG19fX0LIyJEj58yZM2vWLGcX5TJw2Q2AWykrK/P29rZNe3t7FxQUOLce14ItRAC30q1bt9mzZz///POEkM2bN0dFRTm7IleCQARwK1OmTNmxY8eOHTusVmtUVNQLL7zg7IpcCQIRwK2kpaWFhoaGhoba/uu4LLFz587OK8plIBAB3Mr27dvvOB+BWBcIRAC38q9//SsrK+v06dN6vb5Tp044hnhPcJYZwK1s3LgxOTlZEIQ9e/YsX768+g9XoAYIRAC3smXLli+/IMxprQAACeRJREFU/HLYsGGNGzdOTk7+/fffnV2RK0EgArgVk8kkk8ls0yzLchwOi90DBCKAW4mLi3vnnXesVmtRUdG8efP69Onj7IpcCb49ANzKhAkTDh06RAiJjo5u1apVfHy8sytyJQhEALdCKe3ZsyfB6LD3BbvMAAB2CEQAADsEIgCAHQIRAMAOgQgAYIdABACwc34gpqWlJScn2/51di0A8EhzfiACADQQ9X1htiAIK1asOHLkiFKpjIqKev311+u5ABfyg7q0IiP99TNH5UTw8PXX939R8PIqKym5uXs7Y7FUKL1aJz3vJZVUfopBEGblF+Sbzd4s+2FQYLAEF94/XNRqla//iSkqMPPCh60j21aU9zNpmynkxqf68H4BiwuLj+r0LKFvNfKPUsidXSzUrr7/YK5fv56fn79y5UpCyOTJk5OSkqovU1hYaDKZKKUKhcIxk2EYQgjLsiIWwzAMwzDitkkpFaXNMzr91ZKSRVlndfHPDpR7bT5+UL5nh+nF4bf+2MH1jm/TOOTS6ZMnD+9/Oj6h8rO+ul34jLdXosrrotE093bhimahd2z8XlcmpfSOLdSwPKVUxBUremti9bt0/25KyeyXX8vJvbb2wK78rj3i/BpvDfZ/fM+O/5cw0EDIr+Fh5VZ+1NUbWyLC6t4swzDV1/kd1XExqKP6DsSwsLDp06efPn06Ozu7pKTEZDJVX+bf//53Wloay7K7d++uPJ9S6uPjI3pJHh4eIrZGKVUqlQ/eznWD6XkJy0plfl2iO9zIr3i8jX/6GQ8fH2oxd2/TlhDS+YnuJT99X2WFXMq7/a8moR4s040QXWFxDavrnlamxWKpMkelUtXwp2h7yDHmiihEbE2sPiKEWAoLaVT0GaMxunkEPUSbhTdX6axXvX3aSaVXBPJccJCPj8qHkCYFxYynlzdX1whWqVR1LaBa18CDqO9AzMzMXLJkSXx8fHR09NmzZ++4zOeff26bKCoqcszkOM7b21utVotYDMdxLMsajUYR21SpVHq9/o5Bf0/aCfxCs7W7yViwedPtkDDVqWOmoMblxcW8h+e2fXu7tGl36cDe0tBmxcXFlZ/VTcItzM4ZH+C3p1wTIghVHnWQyWRyubysrKyOxSgUConkb/vmJSUlgiDcbXmlUikIgk6nq2P7tVIqlVqtVqzWxOojQogkrLn00L7BiQMvH021CiTj2FFjRLsO1y8bBaETQ5deuxFmMl01mwt0OnNZ6Z07o5qAgICSkhKe5+uysFyOPXEx1XcgpqWldevWbeDAgYWFhbm5uVartZ4LcBWPSSWjGwf/q2vcuBOp3+Zk8uEtjL3jCSERif2NB1OyL5wrb9b8qSdiqjxrtJ/P98UlE2/ktVfI5zRu5IzCHy3mrt0Zg+HVbb/lc9IXYp5ury3fk3Xa1y/AGP9sZ4V8kNV7Rt6tQI79okmwsyuFOqnvQIyLi1u2bNn06dODgoKSkpLWrl07YMCAeq7BVcR4KGI6tCMd2jGVto8kMllkfOLdnkIJGevvO9bft75qfORRau7Vl/ZL8jIY1vw1z7HHEe+ljPcSZ98c6kd9B2JwcPDcuXOrzIyMjHT8CwDgLLgOEQDADoEIAGCHQAQAsEMgAgDYIRABAOwQiAAAdghEAAA7BCIAgB0CEQDADoEIAGCHQAQAsEMgAgDYIRABAOwQiAAAdghEAAA7BCIAgB0CEQDADoEIAGCHQAQAsEMgAgDYIRABAOwQiAAAdghEAAA7BCIAgB0CEQDADoEIAGCHQAQAsEMgAgDYIRABAOwQiAAAfxFcRHZ2dmJiorOrqN0bb7yxb98+Z1dRi927d0+cOPHhtf/5558vXbr04bX/gMaMGXPw4EFnV3FXXbt2LSkpcXYVjyhsIQIA2HHOLqCuPDw8oqKinF1F7Vq3bu3n5+fsKmrh7+/funXrh9d+s2bNOK7hfrTatm3r4+Pj7CruqmvXrg157bk3KgiCs2sAAGgQsMsMAGDnMoFYXFz81ltvObuKu6pS3v79+ydOnDhx4sQ9e/Y4sSqbWmsTvdqG2VkNs4/qv3egBq5xqGLTpk179+6VSCTOLuTOqpRXUlKyevXqL774gmGYN998MyoqKiAgoMHWxrKsuNU2zM5qmH1U/70DNXONLcTHHnssKSnJ2VXcVZXyTp482aJFC5VK5eXl1a1bt+PHjzfk2kSvtmF2VsPso/rvHaiZawRi586dG/Ip5irlFRcXN23a1DYdGBioVqudVBchdahN9GobZmc1zD6q/96BmrlGILocSqljuqGdx69eW0Ou9uFpmO8aveNcCETx+fv737hxwzatVqv9/f2dW09l1WtryNU+PA3zXaN3nA6BKL4uXbpcunRJp9MZDIZjx45FR0c7u6L/qV5bQ6724WmY7xq943SucZbZtfj6+o4aNer9998XBGHIkCGBgYHOruh/7lhbg6324WmYfYTecTr8UgUAwA67zAAAdghEAAA7BCIAgB0CEQDADoH4KLJarff0m4d7XR7ARSEQHy2pqalDhw6NjIxcsWIFIeTTTz8NDw9v3br1hx9+SAjhef6tt96KiIiIiYkZOnToDz/8UGV5WwsDBw4cO3bsU0899fbbb7/zzjsDBw5MSkoyGo3l5eX9+/dv2rRpy5YtU1JSbMtXeQmAhgzXIT5ydu3aderUqfDw8JSUlF9++eXEiRMSiWTo0KFr1qxhWfbChQtZWVkFBQWtW7e2jTvgWN7RQmpqam5urtVq9ff337Rp06JFiwYPHrx3795r1675+vreuHFjz549W7du7dOnT/WXGDFihPPeOkAtEIiPnP/f3h2yKgyFYQA+zokwq8lgcWA0LbigYWIxDqZFJoLoHzAKYrQoWAVZEZNgNmiwLfgHNIqC4QRFgxzODY4pV7nh3qv3wt4nnXA4377yMr6xTVXVa7rN53NKaT6fJ4RsNhvbto/HY7lcFkUxEomkUqlP+13JZDIYDBJCwuGwpmmEkGg0SilVVbXdbjcajVwu1+12n5ZAIMJ/hkD0nFAodF1IklStVuv1OiGEMcY5r1QqguBMUdyP9Ln7XX6//+k6kUgsl8vRaNRsNiVJGo/HjyVe1hbAL8AM0bs0TRsOh4fD4XK5ZLPZyWSSTqcty2KM7ff72Wx2v5lzvl6vGWNfHNhqtTqdTq1WGwwG0+mUc/5Y4sU9AfwI7hC9S1EU0zQVRTmfz4Zh6LrOGLNtOx6Py7Ks6/r9r+lOp5Msy7vd7ulRgiCIolgsFguFgmVZgUCg1+v5fL7HEu9qDuA78C4z3CwWi9VqVSqVGGOZTKbf78disb++KID3QSDCDaXUNM3tdksIMQzjOvsD8A4EIgCAAw9VAAAcCEQAAAcCEQDAgUAEAHAgEAEAHB9qPHAVZ69gggAAAABJRU5ErkJggg==" alt="plot of chunk unnamed-chunk-9" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>for the easy task, training on same is just as good as all or other
subsets. rpart has much lower test error than featureless, in all
three train subsets.</li>
<li>for the impossible task, the least test error is using rpart with same train subsets; featureless with same train subsets is next best; training on all is substantially worse (for both featureless and rpart); training on other is even worse (patterns in the two people are completely different).</li>
<li>in a real data task, training on other will most likely not be quite as bad as in the impossible task above, but also not as good as in the easy task.</li>
</ul>
<h3 id="interactive-visualization-of-data-test-error-and-splits_1">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">inst &lt;- reg.bench.score$resampling[[1]]$instance
rect.expand &lt;- 0.2
grid.dt &lt;- data.table(x=seq(-abs.x, abs.x, l=101), y=0)
grid.task &lt;- mlr3::TaskRegr$new(&quot;grid&quot;, grid.dt, target=&quot;y&quot;)
pred.dt.list &lt;- list()
point.dt.list &lt;- list()
for(score.i in 1:nrow(reg.bench.score)){
  reg.bench.row &lt;- reg.bench.score[score.i]
  task.dt &lt;- data.table(
    reg.bench.row$task[[1]]$data(),
    reg.bench.row$resampling[[1]]$instance$id.dt)
  names(task.dt)[1] &lt;- &quot;y&quot;
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=reg.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ]
  point.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(task_id, iteration)],
    i.points)
  i.learner &lt;- reg.bench.row$learner[[1]]
  pred.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(
      task_id, iteration, algorithm
    )],
    as.data.table(
      i.learner$predict(grid.task)
    )[, .(x=grid.dt$x, y=response)]
  )
}
(pred.dt &lt;- rbindlist(pred.dt.list))
#&gt;          task_id iteration   algorithm     x        y
#&gt;           &lt;char&gt;     &lt;int&gt;      &lt;char&gt; &lt;num&gt;    &lt;num&gt;
#&gt;    1:       easy         1       rpart -2.00 3.557968
#&gt;    2:       easy         1       rpart -1.96 3.557968
#&gt;    3:       easy         1       rpart -1.92 3.557968
#&gt;    4:       easy         1       rpart -1.88 3.557968
#&gt;    5:       easy         1       rpart -1.84 3.557968
#&gt;   ---                                                
#&gt; 7268: impossible        18 featureless  1.84 7.204232
#&gt; 7269: impossible        18 featureless  1.88 7.204232
#&gt; 7270: impossible        18 featureless  1.92 7.204232
#&gt; 7271: impossible        18 featureless  1.96 7.204232
#&gt; 7272: impossible        18 featureless  2.00 7.204232
(point.dt &lt;- rbindlist(point.dt.list))
#&gt;           task_id iteration set.name row_id           y          x  fold person
#&gt;            &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;       &lt;num&gt;      &lt;num&gt; &lt;int&gt;  &lt;int&gt;
#&gt;     1:       easy         1     test      1  1.32996609 -0.9379653     1      1
#&gt;     2:       easy         1    train      2  0.24307692 -0.5115044     3      1
#&gt;     3:       easy         1     test      3 -0.23314657  0.2914135     1      1
#&gt;     4:       easy         1    train      4  1.73677545  1.6328312     2      1
#&gt;     5:       easy         1     test      5 -0.06356159 -1.1932723     1      1
#&gt;    ---                                                                         
#&gt; 21596: impossible        18    train    296  5.18094849  0.7257701     1      2
#&gt; 21597: impossible        18    train    297  9.60431191 -1.6033236     1      2
#&gt; 21598: impossible        18     test    298  7.51198770 -1.5243898     3      2
#&gt; 21599: impossible        18    train    299 11.03539747 -1.7982414     1      2
#&gt; 21600: impossible        18     test    300 10.71968480  1.7170157     3      2
#&gt;        subset display_row
#&gt;         &lt;int&gt;       &lt;int&gt;
#&gt;     1:      1           1
#&gt;     2:      1         101
#&gt;     3:      1           2
#&gt;     4:      1          51
#&gt;     5:      1           3
#&gt;    ---                   
#&gt; 21596:      2         198
#&gt; 21597:      2         199
#&gt; 21598:      2         299
#&gt; 21599:      2         200
#&gt; 21600:      2         300
set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
make_person_subset &lt;- function(DT){
  DT[, &quot;person/subset&quot; := person]
}
make_person_subset(point.dt)
make_person_subset(reg.bench.score)

if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Train/predict on subsets, regression&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      geom_point(aes(
        x, y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        shape=21,
        data=point.dt)+
      scale_color_manual(values=algo.colors)+
      geom_line(aes(
        x, y, color=algorithm, subset=paste(algorithm, iteration)),
        showSelected=&quot;iteration&quot;,
        data=pred.dt)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;)+
      scale_y_continuous(
        breaks=seq(-100, 100, by=2)),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400)+
      scale_y_log10(
        &quot;Mean squared error on test set&quot;)+
      scale_fill_manual(values=algo.colors)+
      scale_x_discrete(
        &quot;People/subsets in train set&quot;)+
      geom_point(aes(
        train.subsets, regr.mse, fill=algorithm),
        shape=1,
        size=5,
        stroke=2,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=reg.bench.score)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        scales=&quot;free&quot;),
    diagram=ggplot()+
      ggtitle(&quot;Select train/test split&quot;)+
      theme_bw()+
      theme_animint(height=300)+
      facet_grid(
        . ~ train.subsets,
        scales=&quot;free&quot;,
        space=&quot;free&quot;)+
      scale_size_manual(values=c(subset=3, fold=1))+
      scale_color_manual(values=c(subset=&quot;orange&quot;, fold=&quot;grey50&quot;))+
      geom_rect(aes(
        xmin=-Inf, xmax=Inf,
        color=rows,
        size=rows,
        ymin=display_row, ymax=display_end),
        fill=NA,
        data=inst$viz.rect.dt)+
      scale_fill_manual(values=set.colors)+
      geom_rect(aes(
        xmin=iteration-rect.expand, ymin=display_row,
        xmax=iteration+rect.expand, ymax=display_end,
        fill=set.name),
        clickSelects=&quot;iteration&quot;,
        data=inst$viz.set.dt)+
      geom_text(aes(
        ifelse(rows==&quot;subset&quot;, Inf, -Inf),
        (display_row+display_end)/2,
        hjust=ifelse(rows==&quot;subset&quot;, 1, 0),
        label=paste0(rows, &quot;=&quot;, ifelse(rows==&quot;subset&quot;, subset, fold))),
        data=data.table(train.name=&quot;same&quot;, inst$viz.rect.dt))+
      scale_x_continuous(
        &quot;Split number / cross-validation iteration&quot;)+
      scale_y_continuous(
        &quot;Row number&quot;),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/ResamplingSameOtherCV.Rmd&quot;)
  viz
}
</code></pre>
<script>
// Copyright (c) 2013, Michael Bostock
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.

// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.

// * The name Michael Bostock may not be used to endorse or promote products
//   derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d3 = function() {
  var π = Math.PI, ε = 1e-6, d3 = {
    version: "3.0.6"
  }, d3_radians = π / 180, d3_degrees = 180 / π, d3_document = document, d3_window = window;
  function d3_target(d) {
    return d.target;
  }
  function d3_source(d) {
    return d.source;
  }
  var d3_format_decimalPoint = ".", d3_format_thousandsSeparator = ",", d3_format_grouping = [ 3, 3 ];
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  try {
    d3_document.createElement("div").style.setProperty("opacity", 0, "");
  } catch (error) {
    var d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + "", priority);
    };
  }
  function d3_class(ctor, properties) {
    try {
      for (var key in properties) {
        Object.defineProperty(ctor.prototype, key, {
          value: properties[key],
          enumerable: false
        });
      }
    } catch (e) {
      ctor.prototype = properties;
    }
  }
  var d3_array = d3_arraySlice;
  function d3_arrayCopy(pseudoarray) {
    var i = -1, n = pseudoarray.length, array = [];
    while (++i < n) array.push(pseudoarray[i]);
    return array;
  }
  function d3_arraySlice(pseudoarray) {
    return Array.prototype.slice.call(pseudoarray);
  }
  try {
    d3_array(d3_document.documentElement.childNodes)[0].nodeType;
  } catch (e) {
    d3_array = d3_arrayCopy;
  }
  var d3_arraySubclass = [].__proto__ ? function(array, prototype) {
    array.__proto__ = prototype;
  } : function(array, prototype) {
    for (var property in prototype) array[property] = prototype[property];
  };
  d3.map = function(object) {
    var map = new d3_Map();
    for (var key in object) map.set(key, object[key]);
    return map;
  };
  function d3_Map() {}
  d3_class(d3_Map, {
    has: function(key) {
      return d3_map_prefix + key in this;
    },
    get: function(key) {
      return this[d3_map_prefix + key];
    },
    set: function(key, value) {
      return this[d3_map_prefix + key] = value;
    },
    remove: function(key) {
      key = d3_map_prefix + key;
      return key in this && delete this[key];
    },
    keys: function() {
      var keys = [];
      this.forEach(function(key) {
        keys.push(key);
      });
      return keys;
    },
    values: function() {
      var values = [];
      this.forEach(function(key, value) {
        values.push(value);
      });
      return values;
    },
    entries: function() {
      var entries = [];
      this.forEach(function(key, value) {
        entries.push({
          key: key,
          value: value
        });
      });
      return entries;
    },
    forEach: function(f) {
      for (var key in this) {
        if (key.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, key.substring(1), this[key]);
        }
      }
    }
  });
  var d3_map_prefix = "\0", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
  function d3_identity(d) {
    return d;
  }
  function d3_true() {
    return true;
  }
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return arguments.length ? target : value;
    };
  }
  d3.ascending = function(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  };
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.mean = function(array, f) {
    var n = array.length, a, m = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
    } else {
      while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
    }
    return j ? m : undefined;
  };
  d3.median = function(array, f) {
    if (arguments.length > 1) array = array.map(f);
    array = array.filter(d3_number);
    return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s / m;
      };
    }
  };
  function d3_number(x) {
    return x != null && !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (!isNaN(a = +array[i])) s += a;
    } else {
      while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.shuffle = function(array) {
    var m = array.length, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m], array[m] = array[i], array[i] = t;
    }
    return array;
  };
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.bisector = function(f) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (f.call(a, a[mid], mid) < x) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (x < f.call(a, a[mid], mid)) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  };
  var d3_bisector = d3.bisector(function(d) {
    return d;
  });
  d3.bisectLeft = d3_bisector.left;
  d3.bisect = d3.bisectRight = d3_bisector.right;
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, valuesByKey = new d3_Map(), values, o = {};
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      valuesByKey.forEach(function(keyValue, values) {
        o[keyValue] = map(values, depth);
      });
      return o;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var a = [], sortKey = sortKeys[depth++], key;
      for (key in map) {
        a.push({
          key: key,
          values: entries(map[key], depth)
        });
      }
      if (sortKey) a.sort(function(a, b) {
        return sortKey(a.key, b.key);
      });
      return a;
    }
    nest.map = function(array) {
      return map(array, 0);
    };
    nest.entries = function(array) {
      return entries(map(array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.permute = function(array, indexes) {
    var permutes = [], i = -1, n = indexes.length;
    while (++i < n) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.merge = function(arrays) {
    return Array.prototype.concat.apply([], arrays);
  };
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(Math.abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  d3.xhr = function(url, mimeType, callback) {
    var xhr = {}, dispatch = d3.dispatch("progress", "load", "error"), headers = {}, response = d3_identity, request = new (d3_window.XDomainRequest && /^(http(s)?:)?\/\//.test(url) ? XDomainRequest : XMLHttpRequest)();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var s = request.status;
      !s && request.responseText || s >= 200 && s < 300 || s === 304 ? dispatch.load.call(xhr, response.call(xhr, request)) : dispatch.error.call(xhr, request);
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
    mimeType = null;
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  };
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  d3.text = function() {
    return d3.xhr.apply(d3, arguments).response(d3_text);
  };
  function d3_text(request) {
    return request.responseText;
  }
  d3.json = function(url, callback) {
    return d3.xhr(url, "application/json", callback).response(d3_json);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3.xhr(url, "text/html", callback).response(d3_html);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = function() {
    return d3.xhr.apply(d3, arguments).response(d3_xml);
  };
  function d3_xml(request) {
    return request.responseXML;
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.substring(0, i);
        name = name.substring(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i > 0) {
      name = type.substring(i + 1);
      type = type.substring(0, i);
    }
    return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.format = function(specifier) {
    var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "", basePrefix = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, suffix = "", integer = false;
    if (precision) precision = +precision.substring(1);
    if (zfill || fill === "0" && align === "=") {
      zfill = fill = "0";
      align = "=";
      if (comma) width -= Math.floor((width - 1) / 4);
    }
    switch (type) {
     case "n":
      comma = true;
      type = "g";
      break;

     case "%":
      scale = 100;
      suffix = "%";
      type = "f";
      break;

     case "p":
      scale = 100;
      suffix = "%";
      type = "r";
      break;

     case "b":
     case "o":
     case "x":
     case "X":
      if (basePrefix) basePrefix = "0" + type.toLowerCase();

     case "c":
     case "d":
      integer = true;
      precision = 0;
      break;

     case "s":
      scale = -1;
      type = "r";
      break;
    }
    if (basePrefix === "#") basePrefix = "";
    if (type == "r" && !precision) type = "g";
    type = d3_format_types.get(type) || d3_format_typeDefault;
    var zcomma = zfill && comma;
    return function(value) {
      if (integer && value % 1) return "";
      var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
      if (scale < 0) {
        var prefix = d3.formatPrefix(value, precision);
        value = prefix.scale(value);
        suffix = prefix.symbol;
      } else {
        value *= scale;
      }
      value = type(value, precision);
      if (!zfill && comma) value = d3_format_group(value);
      var length = basePrefix.length + value.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
      if (zcomma) value = d3_format_group(padding + value);
      if (d3_format_decimalPoint) value.replace(".", d3_format_decimalPoint);
      negative += basePrefix;
      return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix;
    };
  };
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?([0-9]+)?(,)?(\.[0-9]+)?([a-zA-Z%])?/;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_format_group = d3_identity;
  if (d3_format_grouping) {
    var d3_format_groupingLength = d3_format_grouping.length;
    d3_format_group = function(value) {
      var i = value.lastIndexOf("."), f = i >= 0 ? "." + value.substring(i + 1) : (i = value.length, 
      ""), t = [], j = 0, g = d3_format_grouping[0];
      while (i > 0 && g > 0) {
        t.push(value.substring(i -= g, i + g));
        g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];
      }
      return t.reverse().join(d3_format_thousandsSeparator || "") + f;
    };
  }
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, Math.abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * π / 2);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / (2 * π) * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * π / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.event = null;
  function d3_eventCancel() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      g.setAttribute("transform", string);
      var t = g.transform.baseVal.consolidate();
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolate = function(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  };
  d3.interpolateNumber = function(a, b) {
    b -= a;
    return function(t) {
      return a + b * t;
    };
  };
  d3.interpolateRound = function(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  };
  d3.interpolateString = function(a, b) {
    var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;
    d3_interpolate_number.lastIndex = 0;
    for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
      if (m.index) s.push(b.substring(s0, s1 = m.index));
      q.push({
        i: s.length,
        x: m[0]
      });
      s.push(null);
      s0 = d3_interpolate_number.lastIndex;
    }
    if (s0 < b.length) s.push(b.substring(s0));
    for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
      o = q[i];
      if (o.x == m[0]) {
        if (o.i) {
          if (s[o.i + 1] == null) {
            s[o.i - 1] += o.x;
            s.splice(o.i, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          } else {
            s[o.i - 1] += o.x + s[o.i + 1];
            s.splice(o.i, 2);
            for (j = i + 1; j < n; ++j) q[j].i -= 2;
          }
        } else {
          if (s[o.i + 1] == null) {
            s[o.i] = o.x;
          } else {
            s[o.i] = o.x + s[o.i + 1];
            s.splice(o.i + 1, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          }
        }
        q.splice(i, 1);
        n--;
        i--;
      } else {
        o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
      }
    }
    while (i < n) {
      o = q.pop();
      if (s[o.i + 1] == null) {
        s[o.i] = o.x;
      } else {
        s[o.i] = o.x + s[o.i + 1];
        s.splice(o.i + 1, 1);
      }
      n--;
    }
    if (s.length === 1) {
      return s[0] == null ? q[0].x : function() {
        return b;
      };
    }
    return function(t) {
      for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateTransform = function(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3.interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3.interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3.interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3.interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3.interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3.interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateRgb = function(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  };
  d3.interpolateHsl = function(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var h0 = a.h, s0 = a.s, l0 = a.l, h1 = b.h - h0, s1 = b.s - s0, l1 = b.l - l0;
    if (h1 > 180) h1 -= 360; else if (h1 < -180) h1 += 360;
    return function(t) {
      return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t) + "";
    };
  };
  d3.interpolateLab = function(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  };
  d3.interpolateHcl = function(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  };
  d3.interpolateArray = function(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  };
  d3.interpolateObject = function(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolateByName(k)(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  };
  var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  function d3_interpolateByName(name) {
    return name == "transform" ? d3.interpolateTransform : d3.interpolate;
  }
  d3.interpolators = [ d3.interpolateObject, function(a, b) {
    return b instanceof Array && d3.interpolateArray(a, b);
  }, function(a, b) {
    return (typeof a === "string" || typeof b === "string") && d3.interpolateString(a + "", b + "");
  }, function(a, b) {
    return (typeof b === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) : b instanceof d3_Color) && d3.interpolateRgb(a, b);
  }, function(a, b) {
    return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b);
  } ];
  function d3_uninterpolateNumber(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return (x - a) * b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) * b));
    };
  }
  function d3_Color() {}
  d3_Color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.rgb = function(r, g, b) {
    return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);
  };
  function d3_rgb(r, g, b) {
    return new d3_Rgb(r, g, b);
  }
  function d3_Rgb(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return d3_rgb(Math.min(255, Math.floor(r / k)), Math.min(255, Math.floor(g / k)), Math.min(255, Math.floor(b / k)));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_rgb(Math.floor(k * this.r), Math.floor(k * this.g), Math.floor(k * this.b));
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, name;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);
    if (format != null && format.charAt(0) === "#") {
      if (format.length === 4) {
        r = format.charAt(1);
        r += r;
        g = format.charAt(2);
        g += g;
        b = format.charAt(3);
        b += b;
      } else if (format.length === 7) {
        r = format.substring(1, 3);
        g = format.substring(3, 5);
        b = format.substring(5, 7);
      }
      r = parseInt(r, 16);
      g = parseInt(g, 16);
      b = parseInt(b, 16);
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      s = h = 0;
    }
    return d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));
  });
  d3.hsl = function(h, s, l) {
    return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);
  };
  function d3_hsl(h, s, l) {
    return new d3_Hsl(h, s, l);
  }
  function d3_Hsl(h, s, l) {
    this.h = h;
    this.s = s;
    this.l = l;
  }
  var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = h % 360;
    if (h < 0) h += 360;
    s = s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = function(h, c, l) {
    return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);
  };
  function d3_hcl(h, c, l) {
    return new d3_Hcl(h, c, l);
  }
  function d3_Hcl(h, c, l) {
    this.h = h;
    this.c = c;
    this.l = l;
  }
  var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();
  d3_hclPrototype.brighter = function(k) {
    return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = function(l, a, b) {
    return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);
  };
  function d3_lab(l, a, b) {
    return new d3_Lab(l, a, b);
  }
  function d3_Lab(l, a, b) {
    this.l = l;
    this.a = a;
    this.b = b;
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_Lab.prototype = new d3_Color();
  d3_labPrototype.brighter = function(k) {
    return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return d3_hcl(Math.atan2(b, a) / π * 180, Math.sqrt(a * a + b * b), l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  function d3_selection(groups) {
    d3_arraySubclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectRoot = d3_document.documentElement, d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector, d3_selectMatches = function(n, s) {
    return d3_selectMatcher.call(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = function(s, n) {
      return Sizzle.uniqueSort(Sizzle(s, n));
    };
    d3_selectMatches = Sizzle.matchesSelector;
  }
  var d3_selectionPrototype = [];
  d3.selection = function() {
    return d3_selectionRoot;
  };
  d3.selection.prototype = d3_selectionPrototype;
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return function() {
      return d3_selectAll(selector, this);
    };
  }
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = name.trim().split(/^|\s+/g)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.className;
          if (value.baseVal != null) value = value.baseVal;
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classed(name, value) {
    name = name.trim().split(/\s+/).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.className, cb = c.baseVal != null, cv = cb ? c.baseVal : c;
      if (value) {
        re.lastIndex = 0;
        if (!re.test(cv)) {
          cv = d3_collapse(cv + " " + name);
          if (cb) c.baseVal = cv; else node.className = cv;
        }
      } else if (cv) {
        cv = d3_collapse(cv.replace(re, " "));
        if (cb) c.baseVal = cv; else node.className = cv;
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3.ns.qualify(name);
    function append() {
      return this.appendChild(d3_document.createElementNS(this.namespaceURI, name));
    }
    function appendNS() {
      return this.appendChild(d3_document.createElementNS(name.space, name.local));
    }
    return this.select(name.local ? appendNS : append);
  };
  d3_selectionPrototype.insert = function(name, before) {
    name = d3.ns.qualify(name);
    function insert() {
      return this.insertBefore(d3_document.createElementNS(this.namespaceURI, name), d3_select(before, this));
    }
    function insertNS() {
      return this.insertBefore(d3_document.createElementNS(name.space, name.local), d3_select(before, this));
    }
    return this.select(name.local ? insertNS : insert);
  };
  d3_selectionPrototype.remove = function() {
    return this.each(function() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    });
  };
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;
        for (i = -1; ++i < n; ) {
          keyValue = key.call(node = group[i], node.__data__, i);
          if (nodeByKeyValue.has(keyValue)) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues.push(keyValue);
        }
        for (i = -1; ++i < m; ) {
          keyValue = key.call(groupData, nodeData = groupData[i], i);
          if (node = nodeByKeyValue.get(keyValue)) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          } else if (!dataByKeyValue.has(keyValue)) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
          dataByKeyValue.set(keyValue, nodeData);
          nodeByKeyValue.remove(keyValue);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValues[i])) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3.ascending;
    return function(a, b) {
      return !a - !b || comparator(a.__data__, b.__data__);
    };
  }
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf(".");
    if (i > 0) type = type.substring(0, i);
    function onRemove() {
      var wrapper = this[name];
      if (wrapper) {
        this.removeEventListener(type, wrapper, wrapper.$);
        delete this[name];
      }
    }
    function onAdd() {
      var node = this, args = d3_array(arguments);
      onRemove.call(this);
      this.addEventListener(type, this[name] = wrapper, wrapper.$ = capture);
      wrapper._ = listener;
      function wrapper(e) {
        var o = d3.event;
        d3.event = e;
        args[0] = node.__data__;
        try {
          listener.apply(node, args);
        } finally {
          d3.event = o;
        }
      }
    }
    return listener ? onAdd : onRemove;
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.transition = function() {
    var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = Object.create(d3_transitionInherit);
    transition.time = Date.now();
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id);
  };
  var d3_selectionRoot = d3_selection([ [ d3_document ] ]);
  d3_selectionRoot[0].parentNode = d3_selectRoot;
  d3.select = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.select(selector) : d3_selection([ [ selector ] ]);
  };
  d3.selectAll = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.selectAll(selector) : d3_selection([ d3_array(selector) ]);
  };
  function d3_selection_enter(selection) {
    d3_arraySubclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_transition(groups, id) {
    d3_arraySubclass(groups, d3_transitionPrototype);
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit = {
    ease: d3_ease_cubicInOut,
    delay: 0,
    duration: 250
  };
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3.transition = function(selection) {
    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
  };
  d3.transition.prototype = d3_transitionPrototype;
  function d3_transitionNode(node, i, id, inherit) {
    var lock = node.__transition__ || (node.__transition__ = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        event: d3.dispatch("start", "end"),
        time: time,
        ease: inherit.ease,
        delay: inherit.delay,
        duration: inherit.duration
      };
      ++lock.count;
      d3.timer(function(elapsed) {
        var d = node.__data__, ease = transition.ease, event = transition.event, delay = transition.delay, duration = transition.duration, tweened = [];
        return delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time), 1;
        function start(elapsed) {
          if (lock.active > id) return stop();
          lock.active = id;
          event.start.call(node, d, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, d, i)) {
              tweened.push(value);
            }
          });
          if (!tick(elapsed)) d3.timer(tick, 0, time);
          return 1;
        }
        function tick(elapsed) {
          if (lock.active !== id) return stop();
          var t = (elapsed - delay) / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            stop();
            event.end.call(node, d, i);
            return 1;
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node.__transition__;
          return 1;
        }
      }, 0, time);
      return transition;
    }
  }
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnode, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, id, node.__transition__[id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node.__transition__[id];
          subnodes = selector.call(node, node.__data__, i);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            d3_transitionNode(subnode = subnodes[k], k, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.id, this.time).ease(this.ease());
  };
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = d3_interpolateByName(nameNS), name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    return d3_transition_tween(this, "attr." + nameNS, value, function(b) {
      function attrString() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      }
      function attrStringNS() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      }
      return b == null ? name.local ? attrNullNS : attrNull : (b += "", name.local ? attrStringNS : attrString);
    });
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    var interpolate = d3_interpolateByName(name);
    function styleNull() {
      this.style.removeProperty(name);
    }
    return d3_transition_tween(this, "style." + name, value, function(b) {
      function styleString() {
        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      }
      return b == null ? styleNull : (b += "", styleString);
    });
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    return this.tween("style." + name, function(d, i) {
      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    });
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    return this.each("end.transition", function() {
      var p;
      if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id;
    if (arguments.length < 1) return this.node().__transition__[id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node.__transition__[id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].delay = value.call(node, node.__data__, i, j) | 0;
    } : (value |= 0, function(node) {
      node.__transition__[id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j) | 0);
    } : (value = Math.max(1, value | 0), function(node) {
      node.__transition__[id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      d3_transitionInheritId = id;
      d3_selection_each(this, function(node, i, j) {
        d3_transitionInherit = node.__transition__[id];
        type.call(node, node.__data__, i, j);
      });
      d3_transitionInherit = inherit;
      d3_transitionInheritId = inheritId;
    } else {
      d3_selection_each(this, function(node) {
        node.__transition__[id].event.on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = Object.create(node.__transition__[id0]);
          transition.delay += transition.duration;
          d3_transitionNode(node, i, id1, transition);
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id1);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id;
    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node.__transition__[id].tween.remove(name);
    } : function(node) {
      node.__transition__[id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node.__transition__[id].tween.set(name, value);
    }));
  }
  var d3_timer_id = 0, d3_timer_byId = {}, d3_timer_queue = null, d3_timer_interval, d3_timer_timeout;
  d3.timer = function(callback, delay, then) {
    if (arguments.length < 3) {
      if (arguments.length < 2) delay = 0; else if (!isFinite(delay)) return;
      then = Date.now();
    }
    var timer = d3_timer_byId[callback.id];
    if (timer && timer.callback === callback) {
      timer.then = then;
      timer.delay = delay;
    } else d3_timer_byId[callback.id = ++d3_timer_id] = d3_timer_queue = {
      callback: callback,
      then: then,
      delay: delay,
      next: d3_timer_queue
    };
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    var delay = d3_timer_flush() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (!t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    d3_timer_flush();
  };
  function d3_timer_flush() {
    var t0 = null, t1 = d3_timer_queue, then = Infinity;
    while (t1) {
      if (t1.flush) {
        delete d3_timer_byId[t1.callback.id];
        t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
      } else {
        then = Math.min(then, t1.then + t1.delay);
        t1 = (t0 = t1).next;
      }
    }
    return then;
  }
  var d3_timer_frame = d3_window.requestAnimationFrame || d3_window.webkitRequestAnimationFrame || d3_window.mozRequestAnimationFrame || d3_window.oRequestAnimationFrame || d3_window.msRequestAnimationFrame || function(callback) {
    setTimeout(callback, 17);
  };
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
        svg = d3.select(d3_document.body).append("svg").style("position", "absolute").style("top", 0).style("left", 0);
        var ctm = svg[0][0].getScreenCTM();
        d3_mouse_bug44083 = !(ctm.f || ctm.e);
        svg.remove();
      }
      if (d3_mouse_bug44083) {
        point.x = e.pageX;
        point.y = e.pageY;
      } else {
        point.x = e.clientX;
        point.y = e.clientY;
      }
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  function d3_noop() {}
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    if (nice = nice(x1 - x0)) {
      domain[i0] = nice.floor(x0);
      domain[i1] = nice.ceil(x1);
    }
    return domain;
  }
  function d3_scale_niceDefault() {
    return Math;
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3.interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3.interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3.interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    scale.nice = function() {
      d3_scale_nice(domain, d3_scale_linearNice);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(dx) {
    dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
    return dx && {
      floor: function(x) {
        return Math.floor(x / dx) * dx;
      },
      ceil: function(x) {
        return Math.ceil(x / dx) * dx;
      }
    };
  }
  function d3_scale_linearTickRange(domain, m) {
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m) {
    return d3.format(",." + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + "f");
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear(), d3_scale_logp);
  };
  function d3_scale_log(linear, log) {
    var pow = log.pow;
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(pow);
      log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;
      pow = log.pow;
      linear.domain(x.map(log));
      return scale;
    };
    scale.nice = function() {
      linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(linear.domain()), ticks = [];
      if (extent.every(isFinite)) {
        var i = Math.floor(extent[0]), j = Math.ceil(extent[1]), u = pow(extent[0]), v = pow(extent[1]);
        if (log === d3_scale_logn) {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);
        } else {
          for (;i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (arguments.length < 2) format = d3_scale_logFormat;
      if (!arguments.length) return format;
      var k = Math.max(.1, n / scale.ticks().length), f = log === d3_scale_logn ? (e = -1e-12, 
      Math.floor) : (e = 1e-12, Math.ceil), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), log);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e");
  function d3_scale_logp(x) {
    return Math.log(x < 0 ? 0 : x) / Math.LN10;
  }
  function d3_scale_logn(x) {
    return -Math.log(x > 0 ? 0 : -x) / Math.LN10;
  }
  d3_scale_logp.pow = function(x) {
    return Math.pow(10, x);
  };
  d3_scale_logn.pow = function(x) {
    return -Math.pow(10, -x);
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1);
  };
  function d3_scale_pow(linear, exponent) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(powb);
      linear.domain(x.map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(scale.domain(), m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(scale.domain(), m);
    };
    scale.nice = function() {
      return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      var domain = scale.domain();
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      return scale.domain(domain);
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
      range = steps(start + Math.round(error / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf" ];
  var d3_category20 = [ "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5" ];
  var d3_category20b = [ "#393b79", "#5254a3", "#6b6ecf", "#9c9ede", "#637939", "#8ca252", "#b5cf6b", "#cedb9c", "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94", "#843c39", "#ad494a", "#d6616b", "#e7969c", "#7b4173", "#a55194", "#ce6dbd", "#de9ed6" ];
  var d3_category20c = [ "#3182bd", "#6baed6", "#9ecae1", "#c6dbef", "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2", "#31a354", "#74c476", "#a1d99b", "#c7e9c0", "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb", "#636363", "#969696", "#bdbdbd", "#d9d9d9" ];
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (isNaN(x = +x)) return NaN;
      return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.filter(function(d) {
        return !isNaN(d);
      }).sort(d3.ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function arc() {
      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, 
      a0 = a1, a1 = da), a1 - a0), df = da < π ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
      return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcOffset = -π / 2, d3_svg_arcMax = 2 * π - 1e-6;
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_line(projection) {
    var x = d3_svg_lineX, y = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  function d3_svg_lineX(d) {
    return d[0];
  }
  function d3_svg_lineY(d) {
    return d[1];
  }
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0 ];
    d3_svg_lineBasisBezier(path, px, py);
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    i = -1;
    while (++i < 2) {
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (Math.abs(d) < 1e-6) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] + d3_svg_arcOffset;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_svg_lineX, x1 = d3_svg_lineX, y0 = 0, y1 = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, tickMajorSize = 6, tickMinorSize = 6, tickEndSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_, tickSubdivide = 0;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain() : tickValues, tickFormat = tickFormat_ == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String : tickFormat_;
        var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide), subtick = g.selectAll(".tick.minor").data(subticks, String), subtickEnter = subtick.enter().insert("line", ".tick").attr("class", "tick minor").style("opacity", 1e-6), subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(), subtickUpdate = d3.transition(subtick).style("opacity", 1);
        var tick = g.selectAll(".tick.major").data(ticks, String), tickEnter = tick.enter().insert("g", "path").attr("class", "tick major").style("opacity", 1e-6), tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(), tickUpdate = d3.transition(tick).style("opacity", 1), tickTransform;
        var range = d3_scaleRange(scale), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        var scale1 = scale.copy(), scale0 = this.__chart__ || scale1;
        this.__chart__ = scale1;
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text");
        switch (orient) {
         case "bottom":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize);
            lineEnter.attr("y2", tickMajorSize);
            textEnter.attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", 0).attr("y2", tickMajorSize);
            textUpdate.attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            text.attr("dy", ".71em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
            break;
          }

         case "top":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", -tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize);
            lineEnter.attr("y2", -tickMajorSize);
            textEnter.attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", 0).attr("y2", -tickMajorSize);
            textUpdate.attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            text.attr("dy", "0em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
            break;
          }

         case "left":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", -tickMinorSize);
            subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", -tickMajorSize);
            textEnter.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", -tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "end");
            pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
            break;
          }

         case "right":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", tickMinorSize);
            subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", tickMajorSize);
            textEnter.attr("x", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "start");
            pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize);
            break;
          }
        }
        if (scale.ticks) {
          tickEnter.call(tickTransform, scale0);
          tickUpdate.call(tickTransform, scale1);
          tickExit.call(tickTransform, scale1);
          subtickEnter.call(tickTransform, scale0);
          subtickUpdate.call(tickTransform, scale1);
          subtickExit.call(tickTransform, scale1);
        } else {
          var dx = scale1.rangeBand() / 2, x = function(d) {
            return scale1(d) + dx;
          };
          tickEnter.call(tickTransform, x);
          tickUpdate.call(tickTransform, x);
        }
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x, y) {
      if (!arguments.length) return tickMajorSize;
      var n = arguments.length - 1;
      tickMajorSize = +x;
      tickMinorSize = n > 1 ? +y : tickMajorSize;
      tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function(x) {
      if (!arguments.length) return tickSubdivide;
      tickSubdivide = +x;
      return axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x) {
    selection.attr("transform", function(d) {
      return "translate(" + x(d) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y) {
    selection.attr("transform", function(d) {
      return "translate(0," + y(d) + ")";
    });
  }
  function d3_svg_axisSubdivide(scale, ticks, m) {
    subticks = [];
    if (m && ticks.length > 1) {
      var extent = d3_scaleExtent(scale.domain()), subticks, i = -1, n = ticks.length, d = (ticks[1] - ticks[0]) / ++m, j, v;
      while (++i < n) {
        for (j = m; --j > 0; ) {
          if ((v = +ticks[i] - j * d) >= extent[0]) {
            subticks.push(v);
          }
        }
      }
      for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1]; ) {
        subticks.push(v);
      }
    }
    return subticks;
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, resizes = d3_svg_brushResizes[0], extent = [ [ 0, 0 ], [ 0, 0 ] ], extentDomain;
    function brush(g) {
      g.each(function() {
        var g = d3.select(this), bg = g.selectAll(".background").data([ 0 ]), fg = g.selectAll(".extent").data([ 0 ]), tz = g.selectAll(".resize").data(resizes, String), e;
        g.style("pointer-events", "all").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        bg.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        fg.enter().append("rect").attr("class", "extent").style("cursor", "move");
        tz.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        tz.style("display", brush.empty() ? "none" : null);
        tz.exit().remove();
        if (x) {
          e = d3_scaleRange(x);
          bg.attr("x", e[0]).attr("width", e[1] - e[0]);
          redrawX(g);
        }
        if (y) {
          e = d3_scaleRange(y);
          bg.attr("y", e[0]).attr("height", e[1] - e[0]);
          redrawY(g);
        }
        redraw(g);
      });
    }
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", extent[0][0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", extent[0][1]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), center, origin = mouse(), offset;
      var w = d3.select(d3_window).on("mousemove.brush", brushmove).on("mouseup.brush", brushend).on("touchmove.brush", brushmove).on("touchend.brush", brushend).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (dragging) {
        origin[0] = extent[0][0] - origin[0];
        origin[1] = extent[0][1] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1] ];
        origin[0] = extent[ex][0];
        origin[1] = extent[ey][1];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      d3_eventCancel();
      function mouse() {
        var touches = d3.event.changedTouches;
        return touches ? d3.touches(target, touches)[0] : d3.mouse(target);
      }
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= extent[1][0];
            origin[1] -= extent[1][1];
            dragging = 2;
          }
          d3_eventCancel();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += extent[1][0];
          origin[1] += extent[1][1];
          dragging = 0;
          d3_eventCancel();
        }
      }
      function brushmove() {
        var point = mouse(), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2 ];
            origin[0] = extent[+(point[0] < center[0])][0];
            origin[1] = extent[+(point[1] < center[1])][1];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], size = extent[1][i] - extent[0][i], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = Math.max(r0, Math.min(r1, point[i]));
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0][i] !== min || extent[1][i] !== max) {
          extentDomain = null;
          extent[0][i] = min;
          extent[1][i] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        event_({
          type: "brushend"
        });
        d3_eventCancel();
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        z = extentDomain || extent;
        if (x) {
          x0 = z[0][0], x1 = z[1][0];
          if (!extentDomain) {
            x0 = extent[0][0], x1 = extent[1][0];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          y0 = z[0][1], y1 = z[1][1];
          if (!extentDomain) {
            y0 = extent[0][1], y1 = extent[1][1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      extentDomain = [ [ 0, 0 ], [ 0, 0 ] ];
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        extentDomain[0][0] = x0, extentDomain[1][0] = x1;
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        extentDomain[0][1] = y0, extentDomain[1][1] = y1;
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;
      }
      return brush;
    };
    brush.clear = function() {
      extentDomain = null;
      extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;
      return brush;
    };
    brush.empty = function() {
      return x && extent[0][0] === extent[1][0] || y && extent[0][1] === extent[1][1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  d3.behavior = {};
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null;
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", mousedown);
    }
    function mousedown() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, touchId = d3.event.touches ? d3.event.changedTouches[0].identifier : null, offset, origin_ = point(), moved = 0;
      var w = d3.select(d3_window).on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", dragmove).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", dragend, true);
      if (origin) {
        offset = origin.apply(target, arguments);
        offset = [ offset.x - origin_[0], offset.y - origin_[1] ];
      } else {
        offset = [ 0, 0 ];
      }
      if (touchId == null) d3_eventCancel();
      event_({
        type: "dragstart"
      });
      function point() {
        var p = target.parentNode;
        return touchId != null ? d3.touches(p).filter(function(p) {
          return p.identifier === touchId;
        })[0] : d3.mouse(p);
      }
      function dragmove() {
        if (!target.parentNode) return dragend();
        var p = point(), dx = p[0] - origin_[0], dy = p[1] - origin_[1];
        moved |= dx | dy;
        origin_ = p;
        d3_eventCancel();
        event_({
          type: "drag",
          x: p[0] + offset[0],
          y: p[1] + offset[1],
          dx: dx,
          dy: dy
        });
      }
      function dragend() {
        event_({
          type: "dragend"
        });
        if (moved) {
          d3_eventCancel();
          if (d3.event.target === eventTarget) w.on("click.drag", click, true);
        }
        w.on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", null).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", null);
      }
      function click() {
        d3_eventCancel();
        w.on("click.drag", null);
      }
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  d3.behavior.zoom = function() {
    var translate = [ 0, 0 ], translate0, scale = 1, scale0, scaleExtent = d3_behavior_zoomInfinity, event = d3_eventDispatch(zoom, "zoom"), x0, x1, y0, y1, touchtime;
    function zoom() {
      this.on("mousedown.zoom", mousedown).on("mousemove.zoom", mousemove).on(d3_behavior_zoomWheel + ".zoom", mousewheel).on("dblclick.zoom", dblclick).on("touchstart.zoom", touchstart).on("touchmove.zoom", touchmove).on("touchend.zoom", touchstart);
    }
    zoom.translate = function(x) {
      if (!arguments.length) return translate;
      translate = x.map(Number);
      rescale();
      return zoom;
    };
    zoom.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(x) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      translate = [ 0, 0 ];
      scale = 1;
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      translate = [ 0, 0 ];
      scale = 1;
      return zoom;
    };
    function location(p) {
      return [ (p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale ];
    }
    function point(l) {
      return [ l[0] * scale + translate[0], l[1] * scale + translate[1] ];
    }
    function scaleTo(s) {
      scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      translate[0] += p[0] - l[0];
      translate[1] += p[1] - l[1];
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - translate[0]) / scale;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - translate[1]) / scale;
      }).map(y0.invert));
    }
    function dispatch(event) {
      rescale();
      d3.event.preventDefault();
      event({
        type: "zoom",
        scale: scale,
        translate: translate
      });
    }
    function mousedown() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, moved = 0, w = d3.select(d3_window).on("mousemove.zoom", mousemove).on("mouseup.zoom", mouseup), l = location(d3.mouse(target));
      d3_window.focus();
      d3_eventCancel();
      function mousemove() {
        moved = 1;
        translateTo(d3.mouse(target), l);
        dispatch(event_);
      }
      function mouseup() {
        if (moved) d3_eventCancel();
        w.on("mousemove.zoom", null).on("mouseup.zoom", null);
        if (moved && d3.event.target === eventTarget) w.on("click.zoom", click, true);
      }
      function click() {
        d3_eventCancel();
        w.on("click.zoom", null);
      }
    }
    function mousewheel() {
      if (!translate0) translate0 = location(d3.mouse(this));
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);
      translateTo(d3.mouse(this), translate0);
      dispatch(event.of(this, arguments));
    }
    function mousemove() {
      translate0 = null;
    }
    function dblclick() {
      var p = d3.mouse(this), l = location(p), k = Math.log(scale) / Math.LN2;
      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
      translateTo(p, l);
      dispatch(event.of(this, arguments));
    }
    function touchstart() {
      var touches = d3.touches(this), now = Date.now();
      scale0 = scale;
      translate0 = {};
      touches.forEach(function(t) {
        translate0[t.identifier] = location(t);
      });
      d3_eventCancel();
      if (touches.length === 1) {
        if (now - touchtime < 500) {
          var p = touches[0], l = location(touches[0]);
          scaleTo(scale * 2);
          translateTo(p, l);
          dispatch(event.of(this, arguments));
        }
        touchtime = now;
      }
    }
    function touchmove() {
      var touches = d3.touches(this), p0 = touches[0], l0 = translate0[p0.identifier];
      if (p1 = touches[1]) {
        var p1, l1 = translate0[p1.identifier];
        p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
        l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
        scaleTo(d3.event.scale * scale0);
      }
      translateTo(p0, l0);
      touchtime = null;
      dispatch(event.of(this, arguments));
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ];
  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in document ? (d3_behavior_zoomDelta = function() {
    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
  }, "wheel") : "onmousewheel" in document ? (d3_behavior_zoomDelta = function() {
    return d3.event.wheelDelta;
  }, "mousewheel") : (d3_behavior_zoomDelta = function() {
    return -d3.event.detail;
  }, "MozMousePixelScroll");
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (2 * π - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, gravity = .1, theta = .8, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dn = 1 / Math.sqrt(dx * dx + dy * dy);
          if ((x2 - x1) * dn < theta) {
            var k = quad.charge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
            return true;
          }
          if (quad.point && isFinite(dn)) {
            var k = quad.pointCharge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return theta;
      theta = +x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, j, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        var neighbors = neighbor(i), j = -1, m = neighbors.length, x;
        while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;
        return Math.random() * size;
      }
      function neighbor() {
        if (!neighbors) {
          neighbors = [];
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        return neighbors[i];
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1;
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = 2 * π;
    function pie(data) {
      var values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      });
      var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
      var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - startAngle) / d3.sum(values);
      var index = d3.range(data.length);
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      var arcs = [];
      index.forEach(function(i) {
        var d;
        arcs[i] = {
          data: data[i],
          value: d = values[i],
          startAngle: a,
          endAngle: a += d * k
        };
      });
      return arcs;
    }
    pie.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return pie;
    };
    pie.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return pie;
    };
    pie.startAngle = function(x) {
      if (!arguments.length) return startAngle;
      startAngle = x;
      return pie;
    };
    pie.endAngle = function(x) {
      if (!arguments.length) return endAngle;
      endAngle = x;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var n = series.length, m = series[0].length, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function recurse(node, depth, nodes) {
      var childs = children.call(hierarchy, node, depth);
      node.depth = depth;
      nodes.push(node);
      if (childs && (n = childs.length)) {
        var i = -1, n, c = node.children = [], v = 0, j = depth + 1, d;
        while (++i < n) {
          d = recurse(childs[i], j, nodes);
          d.parent = node;
          c.push(d);
          v += d.value;
        }
        if (sort) c.sort(sort);
        if (value) node.value = v;
      } else if (value) {
        node.value = +value.call(hierarchy, node, depth) || 0;
      }
      return node;
    }
    function revalue(node, depth) {
      var children = node.children, v = 0;
      if (children && (n = children.length)) {
        var i = -1, n, j = depth + 1;
        while (++i < n) v += revalue(children[i], j);
      } else if (value) {
        v = +value.call(hierarchy, node, depth) || 0;
      }
      if (value) node.value = v;
      return v;
    }
    function hierarchy(d) {
      var nodes = [];
      recurse(d, 0, nodes);
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      revalue(root, 0);
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ];
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      root.x = 0;
      root.y = 0;
      d3_layout_treeVisitAfter(root, function(d) {
        d.r = Math.sqrt(d.value);
      });
      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
      var w = size[0], h = size[1], k = Math.max(2 * root.r / w, 2 * root.r / h);
      if (padding > 0) {
        var dr = padding * k / 2;
        d3_layout_treeVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
        d3_layout_treeVisitAfter(root, function(d) {
          d.r -= dr;
        });
        k = Math.max(2 * root.r / w, 2 * root.r / h);
      }
      d3_layout_packTransform(root, w / 2, h / 2, 1 / k);
      return nodes;
    }
    pack.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return dr * dr - dx * dx - dy * dy > .001;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_treeVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      function firstWalk(node, previousSibling) {
        var children = node.children, layout = node._tree;
        if (children && (n = children.length)) {
          var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
          while (++i < n) {
            child = children[i];
            firstWalk(child, previousChild);
            ancestor = apportion(child, previousChild, ancestor);
            previousChild = child;
          }
          d3_layout_treeShift(node);
          var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
            layout.mod = layout.prelim - midpoint;
          } else {
            layout.prelim = midpoint;
          }
        } else {
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          }
        }
      }
      function secondWalk(node, x) {
        node.x = node._tree.prelim + x;
        var children = node.children;
        if (children && (n = children.length)) {
          var i = -1, n;
          x += node._tree.mod;
          while (++i < n) {
            secondWalk(children[i], x);
          }
        }
      }
      function apportion(node, previousSibling, ancestor) {
        if (previousSibling) {
          var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
            vom = d3_layout_treeLeft(vom);
            vop = d3_layout_treeRight(vop);
            vop._tree.ancestor = node;
            shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
            if (shift > 0) {
              d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim._tree.mod;
            sip += vip._tree.mod;
            som += vom._tree.mod;
            sop += vop._tree.mod;
          }
          if (vim && !d3_layout_treeRight(vop)) {
            vop._tree.thread = vim;
            vop._tree.mod += sim - sop;
          }
          if (vip && !d3_layout_treeLeft(vom)) {
            vom._tree.thread = vip;
            vom._tree.mod += sip - som;
            ancestor = node;
          }
        }
        return ancestor;
      }
      d3_layout_treeVisitAfter(root, function(node, previousSibling) {
        node._tree = {
          ancestor: node,
          prelim: 0,
          mod: 0,
          change: 0,
          shift: 0,
          number: previousSibling ? previousSibling._tree.number + 1 : 0
        };
      });
      firstWalk(root);
      secondWalk(root, -root._tree.prelim);
      var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost), right = d3_layout_treeSearch(root, d3_layout_treeRightmost), deep = d3_layout_treeSearch(root, d3_layout_treeDeepest), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2, y1 = deep.depth || 1;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = node.depth / y1 * size[1];
        delete node._tree;
      });
      return nodes;
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(node) {
    var children = node.children;
    return children && children.length ? children[0] : node._tree.thread;
  }
  function d3_layout_treeRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? children[n - 1] : node._tree.thread;
  }
  function d3_layout_treeSearch(node, compare) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child, n, i = -1;
      while (++i < n) {
        if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
          node = child;
        }
      }
    }
    return node;
  }
  function d3_layout_treeRightmost(a, b) {
    return a.x - b.x;
  }
  function d3_layout_treeLeftmost(a, b) {
    return b.x - a.x;
  }
  function d3_layout_treeDeepest(a, b) {
    return a.depth - b.depth;
  }
  function d3_layout_treeVisitAfter(node, callback) {
    function visit(node, previousSibling) {
      var children = node.children;
      if (children && (n = children.length)) {
        var child, previousChild = null, i = -1, n;
        while (++i < n) {
          child = children[i];
          visit(child, previousChild);
          previousChild = child;
        }
      }
      callback(node, previousSibling);
    }
    visit(node, null);
  }
  function d3_layout_treeShift(node) {
    var shift = 0, change = 0, children = node.children, i = children.length, child;
    while (--i >= 0) {
      child = children[i]._tree;
      child.prelim += shift;
      child.mod += shift;
      shift += child.shift + (change += child.change);
    }
  }
  function d3_layout_treeMove(ancestor, node, shift) {
    ancestor = ancestor._tree;
    node = node._tree;
    var change = shift / (node.number - ancestor.number);
    ancestor.change += change;
    node.change -= change;
    node.shift += shift;
    node.prelim += shift;
    node.mod += shift;
  }
  function d3_layout_treeAncestor(vim, node, ancestor) {
    return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  function d3_dsv(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, callback) {
      return d3.xhr(url, mimeType, callback).response(response);
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    dsv.parse = function(text) {
      var o;
      return dsv.parseRows(text, function(row) {
        if (o) return o(row);
        o = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.substring(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.substring(j, I - k);
        }
        return text.substring(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && !(a = f(a, n++))) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  }
  d3.csv = d3_dsv(",", "text/csv");
  d3.tsv = d3_dsv("	", "text/tab-separated-values");
  d3.geo = {};
  d3.geo.stream = function(object, listener) {
    if (d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      var coordinate = object.coordinates;
      listener.point(coordinate[0], coordinate[1]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length, coordinate;
      while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), Math.asin(Math.max(-1, Math.min(1, cartesian[2]))) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, maxDepth = 16;
    function resample(stream) {
      var λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = polygonLineStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function polygonLineStart() {
        var λ00, φ00, x00, y00, a00, b00, c00;
        lineStart();
        resample.point = function(λ, φ) {
          linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resample.point = linePoint;
        };
        resample.lineEnd = function() {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
          resample.lineEnd = lineEnd;
          lineEnd();
        };
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = Math.abs(Math.abs(c) - 1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || Math.abs((dx * dx2 + dy * dy2) / d2 - .5) > .3) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 60 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 20 ]).parallels([ 8, 18 ]);
    var puertoRico = d3.geo.albers().rotate([ 60, 0 ]).center([ 0, 10 ]).parallels([ 8, 18 ]);
    function albersUsa(coordinates) {
      return projection(coordinates)(coordinates);
    }
    function projection(point) {
      var lon = point[0], lat = point[1];
      return lat > 50 ? alaska : lon < -140 ? hawaii : lat < 21 ? puertoRico : lower48;
    }
    albersUsa.scale = function(x) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(x);
      alaska.scale(x * .6);
      hawaii.scale(x);
      puertoRico.scale(x * 1.5);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(x) {
      if (!arguments.length) return lower48.translate();
      var dz = lower48.scale(), dx = x[0], dy = x[1];
      lower48.translate(x);
      alaska.translate([ dx - .4 * dz, dy + .17 * dz ]);
      hawaii.translate([ dx - .19 * dz, dy + .2 * dz ]);
      puertoRico.translate([ dx + .58 * dz, dy + .43 * dz ]);
      return albersUsa;
    };
    return albersUsa.scale(lower48.scale());
  };
  function d3_geo_albers(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function albers(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    albers.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, Math.asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return albers;
  }
  (d3.geo.albers = function() {
    var φ0 = 29.5 * d3_radians, φ1 = 45.5 * d3_radians, m = d3_geo_projectionMutator(d3_geo_albers), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 * d3_degrees, φ1 * d3_degrees ];
      return m(φ0 = _[0] * d3_radians, φ1 = _[1] * d3_radians);
    };
    return p.rotate([ 98, 0 ]).center([ 0, 38 ]).scale(1e3);
  }).raw = d3_geo_albers;
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  d3.geo.bounds = d3_geo_bounds(d3_identity);
  function d3_geo_bounds(projectStream) {
    var x0, y0, x1, y1;
    var bound = {
      point: boundPoint,
      lineStart: d3_noop,
      lineEnd: d3_noop,
      polygonStart: function() {
        bound.lineEnd = boundPolygonLineEnd;
      },
      polygonEnd: function() {
        bound.point = boundPoint;
      }
    };
    function boundPoint(x, y) {
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }
    function boundPolygonLineEnd() {
      bound.point = bound.lineEnd = d3_noop;
    }
    return function(feature) {
      y1 = x1 = -(x0 = y0 = Infinity);
      d3.geo.stream(feature, projectStream(bound));
      return [ [ x0, y0 ], [ x1, y1 ] ];
    };
  }
  d3.geo.centroid = function(object) {
    d3_geo_centroidDimension = d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var m;
    if (d3_geo_centroidW && Math.abs(m = Math.sqrt(d3_geo_centroidX * d3_geo_centroidX + d3_geo_centroidY * d3_geo_centroidY + d3_geo_centroidZ * d3_geo_centroidZ)) > ε) {
      return [ Math.atan2(d3_geo_centroidY, d3_geo_centroidX) * d3_degrees, Math.asin(Math.max(-1, Math.min(1, d3_geo_centroidZ / m))) * d3_degrees ];
    }
  };
  var d3_geo_centroidDimension, d3_geo_centroidW, d3_geo_centroidX, d3_geo_centroidY, d3_geo_centroidZ;
  var d3_geo_centroid = {
    sphere: function() {
      if (d3_geo_centroidDimension < 2) {
        d3_geo_centroidDimension = 2;
        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      }
    },
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      if (d3_geo_centroidDimension < 2) {
        d3_geo_centroidDimension = 2;
        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      }
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    if (d3_geo_centroidDimension) return;
    ++d3_geo_centroidW;
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidX += (cosφ * Math.cos(λ) - d3_geo_centroidX) / d3_geo_centroidW;
    d3_geo_centroidY += (cosφ * Math.sin(λ) - d3_geo_centroidY) / d3_geo_centroidW;
    d3_geo_centroidZ += (Math.sin(φ) - d3_geo_centroidZ) / d3_geo_centroidW;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00;
    d3_geo_centroidDimension = 1;
    d3_geo_centroidLineStart();
    d3_geo_centroidDimension = 2;
    var linePoint = d3_geo_centroid.point;
    d3_geo_centroid.point = function(λ, φ) {
      linePoint(λ00 = λ, φ00 = φ);
    };
    d3_geo_centroid.lineEnd = function() {
      d3_geo_centroid.point(λ00, φ00);
      d3_geo_centroidLineEnd();
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
    };
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    if (d3_geo_centroidDimension > 1) return;
    if (d3_geo_centroidDimension < 1) {
      d3_geo_centroidDimension = 1;
      d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    }
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW += w;
      d3_geo_centroidX += w * (x0 + (x0 = x));
      d3_geo_centroidY += w * (y0 + (y0 = y));
      d3_geo_centroidZ += w * (z0 + (z0 = z));
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radians, precision) {
    var cr = Math.cos(radians), sr = Math.sin(radians);
    return function(from, to, direction, listener) {
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * 2 * π;
      } else {
        from = radians + direction * 2 * π;
        to = radians;
      }
      var point;
      for (var step = direction * precision, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = Math.acos(Math.max(-1, Math.min(1, -a[1])));
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate) {
    return function(listener) {
      var line = clipLine(listener);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          invisible = false;
          invisibleArea = visibleArea = 0;
          segments = [];
          listener.polygonStart();
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          if (segments.length) {
            d3_geo_clipPolygon(segments, interpolate, listener);
          } else if (visibleArea < -ε || invisible && invisibleArea < -ε) {
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          listener.polygonEnd();
          segments = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        if (pointVisible(λ, φ)) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        line.point(λ, φ);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments, visibleArea, invisibleArea, invisible;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), ring;
      function pointRing(λ, φ) {
        ringListener.point(λ, φ);
        ring.push([ λ, φ ]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        if (!n) {
          invisible = true;
          invisibleArea += d3_geo_clipAreaRing(ring, -1);
          ring = null;
          return;
        }
        ring = null;
        if (clean & 1) {
          segment = ringSegments[0];
          visibleArea += d3_geo_clipAreaRing(segment, 1);
          var n = segment.length - 1, i = -1, point;
          listener.lineStart();
          while (++i < n) listener.point((point = segment[i])[0], point[1]);
          listener.lineEnd();
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipPolygon(segments, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      var n = segment.length;
      if (n <= 1) return;
      var p0 = segment[0], p1 = segment[n - 1], a = {
        point: p0,
        points: segment,
        other: null,
        visited: false,
        entry: true,
        subject: true
      }, b = {
        point: p0,
        points: [ p0 ],
        other: a,
        visited: false,
        entry: false,
        subject: false
      };
      a.other = b;
      subject.push(a);
      clip.push(b);
      a = {
        point: p1,
        points: [ p1 ],
        other: null,
        visited: false,
        entry: false,
        subject: true
      };
      b = {
        point: p1,
        points: [ p1 ],
        other: a,
        visited: false,
        entry: true,
        subject: false
      };
      a.other = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(d3_geo_clipSort);
    d3_geo_clipLinkCircular(subject);
    d3_geo_clipLinkCircular(clip);
    if (!subject.length) return;
    var start = subject[0], current, points, point;
    while (1) {
      current = start;
      while (current.visited) if ((current = current.next) === start) return;
      points = current.points;
      listener.lineStart();
      do {
        current.visited = current.other.visited = true;
        if (current.entry) {
          if (current.subject) {
            for (var i = 0; i < points.length; i++) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.point, current.next.point, 1, listener);
          }
          current = current.next;
        } else {
          if (current.subject) {
            points = current.prev.points;
            for (var i = points.length; --i >= 0; ) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.point, current.prev.point, -1, listener);
          }
          current = current.prev;
        }
        current = current.other;
        points = current.points;
      } while (!current.visited);
      listener.lineEnd();
    }
  }
  function d3_geo_clipLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.next = b = array[i];
      b.prev = a;
      a = b;
    }
    a.next = b = array[0];
    b.prev = a;
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.point)[0] < 0 ? a[1] - π / 2 - ε : π / 2 - a[1]) - ((b = b.point)[0] < 0 ? b[1] - π / 2 - ε : π / 2 - b[1]);
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      }
    };
  }
  function d3_geo_clipAreaRing(ring, invisible) {
    if (!(n = ring.length)) return 0;
    var n, i = 0, area = 0, p = ring[0], λ = p[0], φ = p[1], cosφ = Math.cos(φ), x0 = Math.atan2(invisible * Math.sin(λ) * cosφ, Math.sin(φ)), y0 = 1 - invisible * Math.cos(λ) * cosφ, x1 = x0, x, y;
    while (++i < n) {
      p = ring[i];
      cosφ = Math.cos(φ = p[1]);
      x = Math.atan2(invisible * Math.sin(λ = p[0]) * cosφ, Math.sin(φ));
      y = 1 - invisible * Math.cos(λ) * cosφ;
      if (Math.abs(y0 - 2) < ε && Math.abs(y - 2) < ε) continue;
      if (Math.abs(y) < ε || Math.abs(y0) < ε) {} else if (Math.abs(Math.abs(x - x0) - π) < ε) {
        if (y + y0 > 2) area += 4 * (x - x0);
      } else if (Math.abs(y0 - 2) < ε) area += 4 * (x - x1); else area += ((3 * π + x - x0) % (2 * π) - π) * (y0 + y);
      x1 = x0, x0 = x, y0 = y;
    }
    return area;
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = Math.abs(λ1 - λ0);
        if (Math.abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? π / 2 : -π / 2);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (Math.abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (Math.abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return Math.abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * π / 2;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (Math.abs(from[0] - to[0]) > ε) {
      var s = (from[0] < to[0] ? 1 : -1) * π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_clipCircle(degrees) {
    var radians = degrees * d3_radians, cr = Math.cos(radians), interpolate = d3_geo_circleInterpolate(radians, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ);
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v0 = v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) listener.point(point1[0], point1[1]);
          point0 = point1;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b) {
      var pa = d3_geo_cartesian(a, 0), pb = d3_geo_cartesian(b, 0);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t = Math.sqrt(w * w - uu * (d3_geo_cartesianDot(A, A) - 1)), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      return d3_geo_spherical(q);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular).scale(250 / π);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  d3.geo.graticule = function() {
    var x1, x0, y1, y0, dx = 22.5, dy = dx, x, y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(x0 / dx) * dx, x1, dx).map(x).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ x(x0).concat(y(y1).slice(1), x(x1).reverse().slice(1), y(y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, precision);
      y = d3_geo_graticuleY(x0, x1, precision);
      return graticule;
    };
    return graticule.extent([ [ -180 + ε, -90 + ε ], [ 180 - ε, 90 - ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))), k = 1 / Math.sin(d);
    function interpolate(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) / d3_radians, Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_radians ];
    }
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_, precision = 6 * d3_radians, interpolate;
    function greatArc() {
      var p0 = source_ || source.apply(this, arguments), p1 = target_ || target.apply(this, arguments), i = interpolate || d3.geo.interpolate(p0, p1), t = 0, dt = precision / i.distance, coordinates = [ p0 ];
      while ((t += dt) < 1) coordinates.push(i(t));
      coordinates.push(p1);
      return {
        type: "LineString",
        coordinates: coordinates
      };
    }
    greatArc.distance = function() {
      return (interpolate || d3.geo.interpolate(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments))).distance;
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      interpolate = source_ && target_ ? d3.geo.interpolate(source_, target_) : null;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      interpolate = source_ && target_ ? d3.geo.interpolate(source_, target_) : null;
      return greatArc;
    };
    greatArc.precision = function(_) {
      if (!arguments.length) return precision / d3_radians;
      precision = _ * d3_radians;
      return greatArc;
    };
    return greatArc;
  };
  function d3_geo_mercator(λ, φ) {
    return [ λ / (2 * π), Math.max(-.5, Math.min(+.5, Math.log(Math.tan(π / 4 + φ / 2)) / (2 * π))) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ 2 * π * x, 2 * Math.atan(Math.exp(2 * π * y)) - π / 2 ];
  };
  (d3.geo.mercator = function() {
    return d3_geo_projection(d3_geo_mercator).scale(500);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream;
    function path(object) {
      if (object) d3.geo.stream(object, projectStream(contextStream.pointRadius(typeof pointRadius === "function" ? +pointRadius.apply(this, arguments) : pointRadius)));
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidDimension = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ ? [ d3_geo_centroidX / d3_geo_centroidZ, d3_geo_centroidY / d3_geo_centroidZ ] : undefined;
    };
    path.bounds = function(object) {
      return d3_geo_bounds(projectStream)(object);
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return path;
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      return path;
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : +_;
      return path;
    };
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + +2 * radius + "z";
  }
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(λ, φ) {
      return project([ λ * d3_degrees, φ * d3_degrees ]);
    });
    return function(stream) {
      stream = resample(stream);
      return {
        point: function(λ, φ) {
          stream.point(λ * d3_radians, φ * d3_radians);
        },
        sphere: function() {
          stream.sphere();
        },
        lineStart: function() {
          stream.lineStart();
        },
        lineEnd: function() {
          stream.lineEnd();
        },
        polygonStart: function() {
          stream.polygonStart();
        },
        polygonEnd: function() {
          stream.polygonEnd();
        }
      };
    };
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x, y);
      context.arc(x, y, pointRadius, 0, 2 * π);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += Math.abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    if (d3_geo_centroidDimension) return;
    d3_geo_centroidX += x;
    d3_geo_centroidY += y;
    ++d3_geo_centroidZ;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    if (d3_geo_centroidDimension !== 1) {
      if (d3_geo_centroidDimension < 1) {
        d3_geo_centroidDimension = 1;
        d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      } else return;
    }
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      x0 = x, y0 = y;
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX += z * (x0 + x) / 2;
      d3_geo_centroidY += z * (y0 + y) / 2;
      d3_geo_centroidZ += z;
      x0 = x, y0 = y;
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    if (d3_geo_centroidDimension < 2) {
      d3_geo_centroidDimension = 2;
      d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    }
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      var z = y0 * x - x0 * y;
      d3_geo_centroidX += z * (x0 + x);
      d3_geo_centroidY += z * (y0 + y);
      d3_geo_centroidZ += z * 3;
      x0 = x, y0 = y;
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingU, d3_geo_areaRingV;
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingU = 1, d3_geo_areaRingV = 0;
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * Math.atan2(d3_geo_areaRingV, d3_geo_areaRingU);
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u0 = d3_geo_areaRingU, v0 = d3_geo_areaRingV, u = cosφ0 * cosφ + k * Math.cos(dλ), v = k * Math.sin(dλ);
      d3_geo_areaRingU = u0 * u - v0 * v;
      d3_geo_areaRingV = v0 * u + u0 * v;
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, clip = d3_geo_clipAntimeridian, clipAngle = null;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(stream) {
      return d3_geo_projectionRadiansRotate(rotate, clip(projectResample(stream)));
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      clip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle(clipAngle = +_);
      return projection;
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadiansRotate(rotate, stream) {
    return {
      point: function(x, y) {
        y = rotate(x * d3_radians, y * d3_radians), x = y[0];
        stream.point(x > π ? x - 2 * π : x < -π ? x + 2 * π : x, y[1]);
      },
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_equirectangular;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - 2 * π : λ < -π ? λ + 2 * π : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδγ + y * sinδγ))) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδφ - x * sinδφ))) ];
    };
    return rotation;
  }
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  d3.geom = {};
  d3.geom.hull = function(vertices) {
    if (vertices.length < 3) return [];
    var len = vertices.length, plen = len - 1, points = [], stack = [], i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;
    for (i = 1; i < len; ++i) {
      if (vertices[i][1] < vertices[h][1]) {
        h = i;
      } else if (vertices[i][1] == vertices[h][1]) {
        h = vertices[i][0] < vertices[h][0] ? i : h;
      }
    }
    for (i = 0; i < len; ++i) {
      if (i === h) continue;
      y1 = vertices[i][1] - vertices[h][1];
      x1 = vertices[i][0] - vertices[h][0];
      points.push({
        angle: Math.atan2(y1, x1),
        index: i
      });
    }
    points.sort(function(a, b) {
      return a.angle - b.angle;
    });
    a = points[0].angle;
    v = points[0].index;
    u = 0;
    for (i = 1; i < plen; ++i) {
      j = points[i].index;
      if (a == points[i].angle) {
        x1 = vertices[v][0] - vertices[h][0];
        y1 = vertices[v][1] - vertices[h][1];
        x2 = vertices[j][0] - vertices[h][0];
        y2 = vertices[j][1] - vertices[h][1];
        if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {
          points[i].index = -1;
        } else {
          points[u].index = -1;
          a = points[i].angle;
          u = i;
          v = j;
        }
      } else {
        a = points[i].angle;
        u = i;
        v = j;
      }
    }
    stack.push(h);
    for (i = 0, j = 0; i < 2; ++j) {
      if (points[j].index !== -1) {
        stack.push(points[j].index);
        i++;
      }
    }
    sp = stack.length;
    for (;j < plen; ++j) {
      if (points[j].index === -1) continue;
      while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {
        --sp;
      }
      stack[sp++] = points[j].index;
    }
    var poly = [];
    for (i = 0; i < sp; ++i) {
      poly.push(vertices[stack[i]]);
    }
    return poly;
  };
  function d3_geom_hullCCW(i1, i2, i3, v) {
    var t, a, b, c, d, e, f;
    t = v[i1];
    a = t[0];
    b = t[1];
    t = v[i2];
    c = t[0];
    d = t[1];
    t = v[i3];
    e = t[0];
    f = t[1];
    return (f - b) * (c - a) - (d - b) * (e - a) > 0;
  }
  d3.geom.polygon = function(coordinates) {
    coordinates.area = function() {
      var i = 0, n = coordinates.length, area = coordinates[n - 1][1] * coordinates[0][0] - coordinates[n - 1][0] * coordinates[0][1];
      while (++i < n) {
        area += coordinates[i - 1][1] * coordinates[i][0] - coordinates[i - 1][0] * coordinates[i][1];
      }
      return area * .5;
    };
    coordinates.centroid = function(k) {
      var i = -1, n = coordinates.length, x = 0, y = 0, a, b = coordinates[n - 1], c;
      if (!arguments.length) k = -1 / (6 * coordinates.area());
      while (++i < n) {
        a = b;
        b = coordinates[i];
        c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }
      return [ x * k, y * k ];
    };
    coordinates.clip = function(subject) {
      var input, i = -1, n = coordinates.length, j, m, a = coordinates[n - 1], b, c, d;
      while (++i < n) {
        input = subject.slice();
        subject.length = 0;
        b = coordinates[i];
        c = input[(m = input.length) - 1];
        j = -1;
        while (++j < m) {
          d = input[j];
          if (d3_geom_polygonInside(d, a, b)) {
            if (!d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            subject.push(d);
          } else if (d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          c = d;
        }
        a = b;
      }
      return subject;
    };
    return coordinates;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  d3.geom.voronoi = function(vertices) {
    var polygons = vertices.map(function() {
      return [];
    }), Z = 1e6;
    d3_voronoi_tessellate(vertices, function(e) {
      var s1, s2, x1, x2, y1, y2;
      if (e.a === 1 && e.b >= 0) {
        s1 = e.ep.r;
        s2 = e.ep.l;
      } else {
        s1 = e.ep.l;
        s2 = e.ep.r;
      }
      if (e.a === 1) {
        y1 = s1 ? s1.y : -Z;
        x1 = e.c - e.b * y1;
        y2 = s2 ? s2.y : Z;
        x2 = e.c - e.b * y2;
      } else {
        x1 = s1 ? s1.x : -Z;
        y1 = e.c - e.a * x1;
        x2 = s2 ? s2.x : Z;
        y2 = e.c - e.a * x2;
      }
      var v1 = [ x1, y1 ], v2 = [ x2, y2 ];
      polygons[e.region.l.index].push(v1, v2);
      polygons[e.region.r.index].push(v1, v2);
    });
    polygons = polygons.map(function(polygon, i) {
      var cx = vertices[i][0], cy = vertices[i][1], angle = polygon.map(function(v) {
        return Math.atan2(v[0] - cx, v[1] - cy);
      }), order = d3.range(polygon.length).sort(function(a, b) {
        return angle[a] - angle[b];
      });
      return order.filter(function(d, i) {
        return !i || angle[d] - angle[order[i - 1]] > ε;
      }).map(function(d) {
        return polygon[d];
      });
    });
    polygons.forEach(function(polygon, i) {
      var n = polygon.length;
      if (!n) return polygon.push([ -Z, -Z ], [ -Z, Z ], [ Z, Z ], [ Z, -Z ]);
      if (n > 2) return;
      var p0 = vertices[i], p1 = polygon[0], p2 = polygon[1], x0 = p0[0], y0 = p0[1], x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], dx = Math.abs(x2 - x1), dy = y2 - y1;
      if (Math.abs(dy) < ε) {
        var y = y0 < y1 ? -Z : Z;
        polygon.push([ -Z, y ], [ Z, y ]);
      } else if (dx < ε) {
        var x = x0 < x1 ? -Z : Z;
        polygon.push([ x, -Z ], [ x, Z ]);
      } else {
        var y = (x2 - x1) * (y1 - y0) < (x1 - x0) * (y2 - y1) ? Z : -Z, z = Math.abs(dy) - dx;
        if (Math.abs(z) < ε) {
          polygon.push([ dy < 0 ? y : -y, y ]);
        } else {
          if (z > 0) y *= -1;
          polygon.push([ -Z, y ], [ Z, y ]);
        }
      }
    });
    return polygons;
  };
  var d3_voronoi_opposite = {
    l: "r",
    r: "l"
  };
  function d3_voronoi_tessellate(vertices, callback) {
    var Sites = {
      list: vertices.map(function(v, i) {
        return {
          index: i,
          x: v[0],
          y: v[1]
        };
      }).sort(function(a, b) {
        return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0;
      }),
      bottomSite: null
    };
    var EdgeList = {
      list: [],
      leftEnd: null,
      rightEnd: null,
      init: function() {
        EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.leftEnd.r = EdgeList.rightEnd;
        EdgeList.rightEnd.l = EdgeList.leftEnd;
        EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);
      },
      createHalfEdge: function(edge, side) {
        return {
          edge: edge,
          side: side,
          vertex: null,
          l: null,
          r: null
        };
      },
      insert: function(lb, he) {
        he.l = lb;
        he.r = lb.r;
        lb.r.l = he;
        lb.r = he;
      },
      leftBound: function(p) {
        var he = EdgeList.leftEnd;
        do {
          he = he.r;
        } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
        he = he.l;
        return he;
      },
      del: function(he) {
        he.l.r = he.r;
        he.r.l = he.l;
        he.edge = null;
      },
      right: function(he) {
        return he.r;
      },
      left: function(he) {
        return he.l;
      },
      leftRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[he.side];
      },
      rightRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[d3_voronoi_opposite[he.side]];
      }
    };
    var Geom = {
      bisect: function(s1, s2) {
        var newEdge = {
          region: {
            l: s1,
            r: s2
          },
          ep: {
            l: null,
            r: null
          }
        };
        var dx = s2.x - s1.x, dy = s2.y - s1.y, adx = dx > 0 ? dx : -dx, ady = dy > 0 ? dy : -dy;
        newEdge.c = s1.x * dx + s1.y * dy + (dx * dx + dy * dy) * .5;
        if (adx > ady) {
          newEdge.a = 1;
          newEdge.b = dy / dx;
          newEdge.c /= dx;
        } else {
          newEdge.b = 1;
          newEdge.a = dx / dy;
          newEdge.c /= dy;
        }
        return newEdge;
      },
      intersect: function(el1, el2) {
        var e1 = el1.edge, e2 = el2.edge;
        if (!e1 || !e2 || e1.region.r == e2.region.r) {
          return null;
        }
        var d = e1.a * e2.b - e1.b * e2.a;
        if (Math.abs(d) < 1e-10) {
          return null;
        }
        var xint = (e1.c * e2.b - e2.c * e1.b) / d, yint = (e2.c * e1.a - e1.c * e2.a) / d, e1r = e1.region.r, e2r = e2.region.r, el, e;
        if (e1r.y < e2r.y || e1r.y == e2r.y && e1r.x < e2r.x) {
          el = el1;
          e = e1;
        } else {
          el = el2;
          e = e2;
        }
        var rightOfSite = xint >= e.region.r.x;
        if (rightOfSite && el.side === "l" || !rightOfSite && el.side === "r") {
          return null;
        }
        return {
          x: xint,
          y: yint
        };
      },
      rightOf: function(he, p) {
        var e = he.edge, topsite = e.region.r, rightOfSite = p.x > topsite.x;
        if (rightOfSite && he.side === "l") {
          return 1;
        }
        if (!rightOfSite && he.side === "r") {
          return 0;
        }
        if (e.a === 1) {
          var dyp = p.y - topsite.y, dxp = p.x - topsite.x, fast = 0, above = 0;
          if (!rightOfSite && e.b < 0 || rightOfSite && e.b >= 0) {
            above = fast = dyp >= e.b * dxp;
          } else {
            above = p.x + p.y * e.b > e.c;
            if (e.b < 0) {
              above = !above;
            }
            if (!above) {
              fast = 1;
            }
          }
          if (!fast) {
            var dxs = topsite.x - e.region.l.x;
            above = e.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b);
            if (e.b < 0) {
              above = !above;
            }
          }
        } else {
          var yl = e.c - e.a * p.x, t1 = p.y - yl, t2 = p.x - topsite.x, t3 = yl - topsite.y;
          above = t1 * t1 > t2 * t2 + t3 * t3;
        }
        return he.side === "l" ? above : !above;
      },
      endPoint: function(edge, side, site) {
        edge.ep[side] = site;
        if (!edge.ep[d3_voronoi_opposite[side]]) return;
        callback(edge);
      },
      distance: function(s, t) {
        var dx = s.x - t.x, dy = s.y - t.y;
        return Math.sqrt(dx * dx + dy * dy);
      }
    };
    var EventQueue = {
      list: [],
      insert: function(he, site, offset) {
        he.vertex = site;
        he.ystar = site.y + offset;
        for (var i = 0, list = EventQueue.list, l = list.length; i < l; i++) {
          var next = list[i];
          if (he.ystar > next.ystar || he.ystar == next.ystar && site.x > next.vertex.x) {
            continue;
          } else {
            break;
          }
        }
        list.splice(i, 0, he);
      },
      del: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l && ls[i] != he; ++i) {}
        ls.splice(i, 1);
      },
      empty: function() {
        return EventQueue.list.length === 0;
      },
      nextEvent: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l; ++i) {
          if (ls[i] == he) return ls[i + 1];
        }
        return null;
      },
      min: function() {
        var elem = EventQueue.list[0];
        return {
          x: elem.vertex.x,
          y: elem.ystar
        };
      },
      extractMin: function() {
        return EventQueue.list.shift();
      }
    };
    EdgeList.init();
    Sites.bottomSite = Sites.list.shift();
    var newSite = Sites.list.shift(), newIntStar;
    var lbnd, rbnd, llbnd, rrbnd, bisector;
    var bot, top, temp, p, v;
    var e, pm;
    while (true) {
      if (!EventQueue.empty()) {
        newIntStar = EventQueue.min();
      }
      if (newSite && (EventQueue.empty() || newSite.y < newIntStar.y || newSite.y == newIntStar.y && newSite.x < newIntStar.x)) {
        lbnd = EdgeList.leftBound(newSite);
        rbnd = EdgeList.right(lbnd);
        bot = EdgeList.rightRegion(lbnd);
        e = Geom.bisect(bot, newSite);
        bisector = EdgeList.createHalfEdge(e, "l");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(lbnd, bisector);
        if (p) {
          EventQueue.del(lbnd);
          EventQueue.insert(lbnd, p, Geom.distance(p, newSite));
        }
        lbnd = bisector;
        bisector = EdgeList.createHalfEdge(e, "r");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(bisector, rbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, newSite));
        }
        newSite = Sites.list.shift();
      } else if (!EventQueue.empty()) {
        lbnd = EventQueue.extractMin();
        llbnd = EdgeList.left(lbnd);
        rbnd = EdgeList.right(lbnd);
        rrbnd = EdgeList.right(rbnd);
        bot = EdgeList.leftRegion(lbnd);
        top = EdgeList.rightRegion(rbnd);
        v = lbnd.vertex;
        Geom.endPoint(lbnd.edge, lbnd.side, v);
        Geom.endPoint(rbnd.edge, rbnd.side, v);
        EdgeList.del(lbnd);
        EventQueue.del(rbnd);
        EdgeList.del(rbnd);
        pm = "l";
        if (bot.y > top.y) {
          temp = bot;
          bot = top;
          top = temp;
          pm = "r";
        }
        e = Geom.bisect(bot, top);
        bisector = EdgeList.createHalfEdge(e, pm);
        EdgeList.insert(llbnd, bisector);
        Geom.endPoint(e, d3_voronoi_opposite[pm], v);
        p = Geom.intersect(llbnd, bisector);
        if (p) {
          EventQueue.del(llbnd);
          EventQueue.insert(llbnd, p, Geom.distance(p, bot));
        }
        p = Geom.intersect(bisector, rrbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, bot));
        }
      } else {
        break;
      }
    }
    for (lbnd = EdgeList.right(EdgeList.leftEnd); lbnd != EdgeList.rightEnd; lbnd = EdgeList.right(lbnd)) {
      callback(lbnd.edge);
    }
  }
  d3.geom.delaunay = function(vertices) {
    var edges = vertices.map(function() {
      return [];
    }), triangles = [];
    d3_voronoi_tessellate(vertices, function(e) {
      edges[e.region.l.index].push(vertices[e.region.r.index]);
    });
    edges.forEach(function(edge, i) {
      var v = vertices[i], cx = v[0], cy = v[1];
      edge.forEach(function(v) {
        v.angle = Math.atan2(v[0] - cx, v[1] - cy);
      });
      edge.sort(function(a, b) {
        return a.angle - b.angle;
      });
      for (var j = 0, m = edge.length - 1; j < m; j++) {
        triangles.push([ v, edge[j], edge[j + 1] ]);
      }
    });
    return triangles;
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var p, i = -1, n = points.length;
    if (arguments.length < 5) {
      if (arguments.length === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      } else {
        x1 = y1 = Infinity;
        x2 = y2 = -Infinity;
        while (++i < n) {
          p = points[i];
          if (p.x < x1) x1 = p.x;
          if (p.y < y1) y1 = p.y;
          if (p.x > x2) x2 = p.x;
          if (p.y > y2) y2 = p.y;
        }
      }
    }
    var dx = x2 - x1, dy = y2 - y1;
    if (dx > dy) y2 = y1 + dx; else x2 = x1 + dy;
    function insert(n, p, x1, y1, x2, y2) {
      if (isNaN(p.x) || isNaN(p.y)) return;
      if (n.leaf) {
        var v = n.point;
        if (v) {
          if (Math.abs(v.x - p.x) + Math.abs(v.y - p.y) < .01) {
            insertChild(n, p, x1, y1, x2, y2);
          } else {
            n.point = null;
            insertChild(n, v, x1, y1, x2, y2);
            insertChild(n, p, x1, y1, x2, y2);
          }
        } else {
          n.point = p;
        }
      } else {
        insertChild(n, p, x1, y1, x2, y2);
      }
    }
    function insertChild(n, p, x1, y1, x2, y2) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = p.x >= sx, bottom = p.y >= sy, i = (bottom << 1) + right;
      n.leaf = false;
      n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
      if (right) x1 = sx; else x2 = sx;
      if (bottom) y1 = sy; else y2 = sy;
      insert(n, p, x1, y1, x2, y2);
    }
    var root = d3_geom_quadtreeNode();
    root.add = function(p) {
      insert(root, p, x1, y1, x2, y2);
    };
    root.visit = function(f) {
      d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);
    };
    points.forEach(root.add);
    return root;
  };
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  d3.time = {};
  var d3_time = Date, d3_time_daySymbols = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
  function d3_time_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_time_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  var d3_time_formatDateTime = "%a %b %e %X %Y", d3_time_formatDate = "%m/%d/%Y", d3_time_formatTime = "%H:%M:%S";
  var d3_time_days = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], d3_time_dayAbbreviations = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], d3_time_months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], d3_time_monthAbbreviations = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
  d3.time.format = function(template) {
    var n = template.length;
    function format(date) {
      var string = [], i = -1, j = 0, c, p, f;
      while (++i < n) {
        if (template.charCodeAt(i) === 37) {
          string.push(template.substring(j, i));
          if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
          if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(template.substring(j, i));
      return string.join("");
    }
    format.parse = function(string) {
      var d = {
        y: 1900,
        m: 0,
        d: 1,
        H: 0,
        M: 0,
        S: 0,
        L: 0
      }, i = d3_time_parse(d, template, string, 0);
      if (i != string.length) return null;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      var date = new d3_time();
      date.setFullYear(d.y, d.m, d.d);
      date.setHours(d.H, d.M, d.S, d.L);
      return date;
    };
    format.toString = function() {
      return template;
    };
    return format;
  };
  function d3_time_parse(date, template, string, j) {
    var c, p, i = 0, n = template.length, m = string.length;
    while (i < n) {
      if (j >= m) return -1;
      c = template.charCodeAt(i++);
      if (c === 37) {
        p = d3_time_parsers[template.charAt(i++)];
        if (!p || (j = p(date, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_formatPad(value, fill, width) {
    value += "";
    var length = value.length;
    return length < width ? new Array(width - length + 1).join(fill) + value : value;
  }
  var d3_time_dayRe = d3_time_formatRe(d3_time_days), d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations), d3_time_monthRe = d3_time_formatRe(d3_time_months), d3_time_monthLookup = d3_time_formatLookup(d3_time_months), d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations), d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations);
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  };
  var d3_time_formats = {
    a: function(d) {
      return d3_time_dayAbbreviations[d.getDay()];
    },
    A: function(d) {
      return d3_time_days[d.getDay()];
    },
    b: function(d) {
      return d3_time_monthAbbreviations[d.getMonth()];
    },
    B: function(d) {
      return d3_time_months[d.getMonth()];
    },
    c: d3.time.format(d3_time_formatDateTime),
    d: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    e: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    H: function(d, p) {
      return d3_time_formatPad(d.getHours(), p, 2);
    },
    I: function(d, p) {
      return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
    },
    j: function(d, p) {
      return d3_time_formatPad(1 + d3.time.dayOfYear(d), p, 3);
    },
    L: function(d, p) {
      return d3_time_formatPad(d.getMilliseconds(), p, 3);
    },
    m: function(d, p) {
      return d3_time_formatPad(d.getMonth() + 1, p, 2);
    },
    M: function(d, p) {
      return d3_time_formatPad(d.getMinutes(), p, 2);
    },
    p: function(d) {
      return d.getHours() >= 12 ? "PM" : "AM";
    },
    S: function(d, p) {
      return d3_time_formatPad(d.getSeconds(), p, 2);
    },
    U: function(d, p) {
      return d3_time_formatPad(d3.time.sundayOfYear(d), p, 2);
    },
    w: function(d) {
      return d.getDay();
    },
    W: function(d, p) {
      return d3_time_formatPad(d3.time.mondayOfYear(d), p, 2);
    },
    x: d3.time.format(d3_time_formatDate),
    X: d3.time.format(d3_time_formatTime),
    y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 100, p, 2);
    },
    Y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
    },
    Z: d3_time_zone,
    "%": function() {
      return "%";
    }
  };
  var d3_time_parsers = {
    a: d3_time_parseWeekdayAbbrev,
    A: d3_time_parseWeekday,
    b: d3_time_parseMonthAbbrev,
    B: d3_time_parseMonth,
    c: d3_time_parseLocaleFull,
    d: d3_time_parseDay,
    e: d3_time_parseDay,
    H: d3_time_parseHour24,
    I: d3_time_parseHour24,
    L: d3_time_parseMilliseconds,
    m: d3_time_parseMonthNumber,
    M: d3_time_parseMinutes,
    p: d3_time_parseAmPm,
    S: d3_time_parseSeconds,
    x: d3_time_parseLocaleDate,
    X: d3_time_parseLocaleTime,
    y: d3_time_parseYear,
    Y: d3_time_parseFullYear
  };
  function d3_time_parseWeekdayAbbrev(date, string, i) {
    d3_time_dayAbbrevRe.lastIndex = 0;
    var n = d3_time_dayAbbrevRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseWeekday(date, string, i) {
    d3_time_dayRe.lastIndex = 0;
    var n = d3_time_dayRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseMonthAbbrev(date, string, i) {
    d3_time_monthAbbrevRe.lastIndex = 0;
    var n = d3_time_monthAbbrevRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseMonth(date, string, i) {
    d3_time_monthRe.lastIndex = 0;
    var n = d3_time_monthRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseLocaleFull(date, string, i) {
    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
  }
  function d3_time_parseLocaleDate(date, string, i) {
    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
  }
  function d3_time_parseLocaleTime(date, string, i) {
    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 4));
    return n ? (date.y = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i += n[0].length) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.m = n[0] - 1, i += n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.d = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.H = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.M = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.S = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 3));
    return n ? (date.L = +n[0], i += n[0].length) : -1;
  }
  var d3_time_numberRe = /^\s*\d+/;
  function d3_time_parseAmPm(date, string, i) {
    var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
    return n == null ? -1 : (date.p = n, i);
  }
  var d3_time_amPmLookup = d3.map({
    am: 0,
    pm: 1
  });
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = ~~(Math.abs(z) / 60), zm = Math.abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  d3.time.format.utc = function(template) {
    var local = d3.time.format(template);
    function format(date) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time();
        utc._ = date;
        return local(utc);
      } finally {
        d3_time = Date;
      }
    }
    format.parse = function(string) {
      try {
        d3_time = d3_time_utc;
        var date = local.parse(string);
        return date && date._;
      } finally {
        d3_time = Date;
      }
    };
    format.toString = local.toString;
    return format;
  };
  var d3_time_formatIso = d3.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_time(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_time(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_time = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_time = Date;
      }
    };
  }
  d3.time.second = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3.time.seconds = d3.time.second.range;
  d3.time.seconds.utc = d3.time.second.utc.range;
  d3.time.minute = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3.time.minutes = d3.time.minute.range;
  d3.time.minutes.utc = d3.time.minute.utc.range;
  d3.time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3.time.hours = d3.time.hour.range;
  d3.time.hours.utc = d3.time.hour.utc.range;
  d3.time.day = d3_time_interval(function(date) {
    var day = new d3_time(1970, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3.time.days = d3.time.day.range;
  d3.time.days.utc = d3.time.day.utc.range;
  d3.time.dayOfYear = function(date) {
    var year = d3.time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  d3_time_daySymbols.forEach(function(day, i) {
    day = day.toLowerCase();
    i = 7 - i;
    var interval = d3.time[day] = d3_time_interval(function(date) {
      (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3.time[day + "s"] = interval.range;
    d3.time[day + "s"].utc = interval.utc.range;
    d3.time[day + "OfYear"] = function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3.time.week = d3.time.sunday;
  d3.time.weeks = d3.time.sunday.range;
  d3.time.weeks.utc = d3.time.sunday.utc.range;
  d3.time.weekOfYear = d3.time.sundayOfYear;
  d3.time.month = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3.time.months = d3.time.month.range;
  d3.time.months.utc = d3.time.month.utc.range;
  d3.time.year = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3.time.years = d3.time.year.range;
  d3.time.years.utc = d3.time.year.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_nice(scale.domain(), function() {
        return m;
      }));
    };
    scale.ticks = function(m, k) {
      var extent = d3_time_scaleExtent(scale.domain());
      if (typeof m !== "function") {
        var span = extent[1] - extent[0], target = span / m, i = d3.bisect(d3_time_scaleSteps, target);
        if (i == d3_time_scaleSteps.length) return methods.year(extent, m);
        if (!i) return linear.ticks(m).map(d3_time_scaleDate);
        if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;
        m = methods[i];
        k = m[1];
        m = m[0].range;
      }
      return m(extent[0], new Date(+extent[1] + 1), k);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_time_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  function d3_time_scaleFormat(formats) {
    return function(date) {
      var i = formats.length - 1, f = formats[i];
      while (!f[1](date)) f = formats[--i];
      return f[0](date);
    };
  }
  function d3_time_scaleSetYear(y) {
    var d = new Date(y, 0, 1);
    d.setFullYear(y);
    return d;
  }
  function d3_time_scaleGetYear(d) {
    var y = d.getFullYear(), d0 = d3_time_scaleSetYear(y), d1 = d3_time_scaleSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3.time.second, 1 ], [ d3.time.second, 5 ], [ d3.time.second, 15 ], [ d3.time.second, 30 ], [ d3.time.minute, 1 ], [ d3.time.minute, 5 ], [ d3.time.minute, 15 ], [ d3.time.minute, 30 ], [ d3.time.hour, 1 ], [ d3.time.hour, 3 ], [ d3.time.hour, 6 ], [ d3.time.hour, 12 ], [ d3.time.day, 1 ], [ d3.time.day, 2 ], [ d3.time.week, 1 ], [ d3.time.month, 1 ], [ d3.time.month, 3 ], [ d3.time.year, 1 ] ];
  var d3_time_scaleLocalFormats = [ [ d3.time.format("%Y"), d3_true ], [ d3.time.format("%B"), function(d) {
    return d.getMonth();
  } ], [ d3.time.format("%b %d"), function(d) {
    return d.getDate() != 1;
  } ], [ d3.time.format("%a %d"), function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ d3.time.format("%I %p"), function(d) {
    return d.getHours();
  } ], [ d3.time.format("%I:%M"), function(d) {
    return d.getMinutes();
  } ], [ d3.time.format(":%S"), function(d) {
    return d.getSeconds();
  } ], [ d3.time.format(".%L"), function(d) {
    return d.getMilliseconds();
  } ] ];
  var d3_time_scaleLinear = d3.scale.linear(), d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);
  d3_time_scaleLocalMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);
  };
  d3.time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUTCFormats = [ [ d3.time.format.utc("%Y"), d3_true ], [ d3.time.format.utc("%B"), function(d) {
    return d.getUTCMonth();
  } ], [ d3.time.format.utc("%b %d"), function(d) {
    return d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%a %d"), function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%I %p"), function(d) {
    return d.getUTCHours();
  } ], [ d3.time.format.utc("%I:%M"), function(d) {
    return d.getUTCMinutes();
  } ], [ d3.time.format.utc(":%S"), function(d) {
    return d.getUTCSeconds();
  } ], [ d3.time.format.utc(".%L"), function(d) {
    return d.getUTCMilliseconds();
  } ] ];
  var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);
  function d3_time_scaleUTCSetYear(y) {
    var d = new Date(Date.UTC(y, 0, 1));
    d.setUTCFullYear(y);
    return d;
  }
  function d3_time_scaleUTCGetYear(d) {
    var y = d.getUTCFullYear(), d0 = d3_time_scaleUTCSetYear(y), d1 = d3_time_scaleUTCSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  d3_time_scaleUTCMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);
  };
  d3.time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
  };
  return d3;
}();
</script>
<script>
// Define functions to render linked interactive plots using d3.
// Another script should define e.g.
// <script>
//   var plot = new animint("#plot","path/to/plot.json");
// </script>
// Constructor for animint Object.
var animint = function (to_select, json_file) {

  var default_axis_px = 16;

   function wait_until_then(timeout, condFun, readyFun) {
    var args=arguments
    function checkFun() {
      if(condFun()) {
        readyFun(args[3],args[4]);
      } else{
        setTimeout(checkFun, timeout);
      }
    }
    checkFun();
  }

  function convert_R_types(resp_array, types){
    return resp_array.map(function (d) {
      for (var v_name in d) {
      	if(!is_interactive_aes(v_name)){
          var r_type = types[v_name];
          if (r_type == "integer") {
            d[v_name] = parseInt(d[v_name]);
          } else if (r_type == "numeric") {
            d[v_name] = parseFloat(d[v_name]);
          } else if (r_type == "factor" || r_type == "rgb" 
		     || r_type == "linetype" || r_type == "label" 
		     || r_type == "character") {
            // keep it as a character
          } else if (r_type == "character" & v_name == "outliers") {
            d[v_name] = parseFloat(d[v_name].split(" @ "));
          } 
      	}
      }
      return d;
    });
  }

  // replacing periods in variable with an underscore this makes sure
  // that selector doesn't confuse . in name with css selectors
  function safe_name(unsafe_name){
    return unsafe_name.replace(/[ .]/g, '_');
  }
  function legend_class_name(selector_name){
    return safe_name(selector_name) + "_variable";
  }

  function is_interactive_aes(v_name){
    if(v_name.indexOf("clickSelects") > -1){
      return true;
    }
    if(v_name.indexOf("showSelected") > -1){
      return true;
    }
    return false;
  }

  var linetypesize2dasharray = function (lt, size) {
    var isInt = function(n) {
      return typeof n === 'number' && parseFloat(n) == parseInt(n, 10) && !isNaN(n);
    };
    if(isInt(lt)){ // R integer line types.
      if(lt == 1){
        return null;
      }
      var o = {
        0: size * 0 + "," + size * 10,
        2: size * 4 + "," + size * 4,
        3: size + "," + size * 2,
        4: size + "," + size * 2 + "," + size * 4 + "," + size * 2,
        5: size * 8 + "," + size * 4,
        6: size * 2 + "," + size * 2 + "," + size * 6 + "," + size * 2
      };
    } else { // R defined line types
      if(lt == "solid" || lt === null){
        return null;
      }
      var o = {
        "blank": size * 0 + "," + size * 10,
        "none": size * 0 + "," + size * 10,
        "dashed": size * 4 + "," + size * 4,
        "dotted": size + "," + size * 2,
        "dotdash": size + "," + size * 2 + "," + size * 4 + "," + size * 2,
        "longdash": size * 8 + "," + size * 4,
        "twodash": size * 2 + "," + size * 2 + "," + size * 6 + "," + size * 2,
        "22": size * 2 + "," + size * 2,
        "42": size * 4 + "," + size * 2,
        "44": size * 4 + "," + size * 4,"13": size + "," + size * 3,
        "1343": size + "," + size * 3 + "," + size * 4 + "," + size * 3,
        "73": size * 7 + "," + size * 3,
        "2262": size * 2 + "," + size * 2 + "," + size * 6 + "," + size * 2,
        "12223242": size + "," + size * 2 + "," + size * 2 + "," + size * 2 + "," + size * 3 + "," + size * 2 + "," + size * 4 + "," + size * 2,
        "F282": size * 15 + "," + size * 2 + "," + size * 8 + "," + size * 2,
        "F4448444": size * 15 + "," + size * 4 + "," + size * 4 + "," + size * 4 + "," + size * 8 + "," + size * 4 + "," + size * 4 + "," + size * 4,
        "224282F2": size * 2 + "," + size * 2 + "," + size * 4 + "," + size * 2 + "," + size * 8 + "," + size * 2 + "," + size * 16 + "," + size * 2,
        "F1": size * 16 + "," + size
      };
    }

    if (lt in o){
      return o[lt];
    } else{ // manually specified line types
      str = lt.split("");
      strnum = str.map(function (d) {
        return size * parseInt(d, 16);
      });
      return strnum;
    }
  };

  var isArray = function(o) {
    return Object.prototype.toString.call(o) === '[object Array]';
  };

  // create a dummy element, apply the appropriate classes,
  // and then measure the element
  // Inspired from http://jsfiddle.net/uzddx/2/
  var measureText = function(pText, pFontSize, pAngle, pStyle) {
    if (!pText || pText.length === 0) return {height: 0, width: 0};
    if (pAngle === null || isNaN(pAngle)) pAngle = 0;

    var container = element.append('svg');
    // do we need to set the class so that styling is applied?
    //.attr('class', classname);

    container.append('text')
      .attr({x: -1000, y: -1000})
      .attr("transform", "rotate(" + pAngle + ")")
      .attr("style", pStyle)
      .attr("font-size", pFontSize)
      .text(pText);

    var bbox = container.node().getBBox();
    container.remove();

    return {height: bbox.height, width: bbox.width};
  };

  var nest_by_group = d3.nest().key(function(d){ return d.group; });
  var dirs = json_file.split("/");
  dirs.pop(); //if a directory path exists, remove the JSON file from dirs
  var element = d3.select(to_select);
  this.element = element;
  var viz_id = element.attr("id");
  var Widgets = {};
  this.Widgets = Widgets;
  var Selectors = {};
  this.Selectors = Selectors;
  var Plots = {};
  this.Plots = Plots;
  var Geoms = {};
  this.Geoms = Geoms;
  // SVGs must be stored separately from Geoms since they are
  // initialized first, with the Plots.
  var SVGs = {};
  this.SVGs = SVGs;
  var Animation = {};
  this.Animation = Animation;
  var all_geom_names = {};
  this.all_geom_names = all_geom_names;

  //creating an array to contain the selectize widgets
  var selectized_array = [];
  var data_object_geoms = {
    "line":true,
    "path":true,
    "ribbon":true,
    "polygon":true
  };
  var css = document.createElement('style');
  css.type = 'text/css';
  var styles = [".axis path{fill: none;stroke: black;shape-rendering: crispEdges;}",
            ".axis line{fill: none;stroke: black;shape-rendering: crispEdges;}",
            ".axis text {font-family: sans-serif;font-size: 11px;}"];

  var add_geom = function (g_name, g_info) {
    // Determine if data will be an object or an array.
    if(g_info.geom in data_object_geoms){
      g_info.data_is_object = true;
    }else{
      g_info.data_is_object = false;
    }
    // Add a row to the loading table.
    g_info.tr = Widgets["loading"].append("tr");
    g_info.tr.append("td").text(g_name);
    g_info.tr.append("td").attr("class", "chunk");
    g_info.tr.append("td").attr("class", "downloaded").text(0);
    g_info.tr.append("td").text(g_info.total);
    g_info.tr.append("td").attr("class", "status").text("initialized");

    // load chunk tsv
    g_info.data = {};
    g_info.download_status = {};
    Geoms[g_name] = g_info;
    // Determine whether common chunk tsv exists
    // If yes, load it
    if(g_info.hasOwnProperty("columns") && g_info.columns.common){
      var common_tsv = get_tsv(g_info, "_common");
      g_info.common_tsv = common_tsv;
      var common_path = getTSVpath(common_tsv);
      d3.tsv(common_path, function (error, response) {
        var converted = convert_R_types(response, g_info.types);
        g_info.data[common_tsv] = nest_by_group.map(converted);
      });
    } else {
      g_info.common_tsv = null;
    }
    // Save this geom and load it!
    update_geom(g_name, null);
  };
  var add_plot = function (p_name, p_info) {
    // Each plot may have one or more legends. To make space for the
    // legends, we put each plot in a table with one row and two
    // columns: tdLeft and tdRight.
    var plot_table = element.append("table").style("display", "inline-block");
    var plot_tr = plot_table.append("tr");
    var tdLeft = plot_tr.append("td");
    var tdRight = plot_tr.append("td").attr("class", p_name+"_legend");
    if(viz_id === null){
      p_info.plot_id = p_name;
    }else{
      p_info.plot_id = viz_id + "_" + p_name;
    }
    var svg = tdLeft.append("svg")
      .attr("id", p_info.plot_id)
      .attr("height", p_info.options.height)
      .attr("width", p_info.options.width);

    // divvy up width/height based on the panel layout
    var nrows = Math.max.apply(null, p_info.layout.ROW);
    var ncols = Math.max.apply(null, p_info.layout.COL);
    var panel_names = p_info.layout.PANEL;
    var npanels = Math.max.apply(null, panel_names);

    // Note axis names are "shared" across panels (just like the title)
    var xtitlepadding = 5 + measureText(p_info["xtitle"], default_axis_px).height;
    var ytitlepadding = 5 + measureText(p_info["ytitle"], default_axis_px).height;

    // 'margins' are fixed across panels and do not
    // include title/axis/label padding (since these are not
    // fixed across panels). They do, however, account for
    // spacing between panels
    var text_height_pixels = measureText("foo", 11).height;
    var margin = {
      left: 0,
      right: text_height_pixels * p_info.panel_margin_lines,
      top: text_height_pixels * p_info.panel_margin_lines,
      bottom: 0
    };
    var plotdim = {
      width: 0,
      height: 0,
      xstart: 0,
      xend: 0,
      ystart: 0,
      yend: 0,
      graph: {
	width: 0,
	height: 0
      },
      margin: margin,
      xlab: {
	x: 0,
	y: 0
      },
      ylab: {
	x: 0,
	y: 0
      },
      title: {
	x: 0,
	y: 0
      }
    };

    // Draw the title
    var titlepadding = measureText(p_info.title, p_info.title_size).height;
    // why are we giving the title padding if it is undefined?
    if (p_info.title === undefined) titlepadding = 0;
    plotdim.title.x = p_info.options.width / 2;
    plotdim.title.y = titlepadding;
    svg.append("text")
      .text(p_info.title)
      .attr("class", "plottitle")
      .attr("font-family", "sans-serif")
      .attr("font-size", p_info.title_size)
      .attr("transform", "translate(" + plotdim.title.x + "," + 
        plotdim.title.y + ")")
      .style("text-anchor", "middle");

    // grab max text size over axis labels and facet strip labels
    var axispaddingy = 5;
    if(p_info.hasOwnProperty("ylabs") && p_info.ylabs.length){
      axispaddingy += Math.max.apply(null, p_info.ylabs.map(function(entry){
	// + 5 to give a little extra space to avoid bad axis labels
	// in shiny.
	return measureText(entry, p_info.ysize).width + 5;
      }));
    }
    var axispaddingx = 10 + 20;
    if(p_info.hasOwnProperty("xlabs") && p_info.xlabs.length){
      // TODO: throw warning if text height is large portion of plot height?
      axispaddingx += Math.max.apply(null, p_info.xlabs.map(function(entry){
	     return measureText(entry, p_info.xsize, p_info.xangle).height;
      }));
      // TODO: carefully calculating this gets complicated with rotating xlabs
      //margin.right += 5;
    }
    plotdim.margin = margin;
    
    var strip_heights = p_info.strips.top.map(function(entry){ 
      return measureText(entry, p_info.strip_text_xsize).height;
    });
    var strip_widths = p_info.strips.right.map(function(entry){ 
      return measureText(entry, p_info.strip_text_ysize).height; 
    });

    // compute the number of x/y axes, max strip height per row, and
    // max strip width per columns, for calculating height/width of
    // graphing region.
    var row_strip_heights = [];
    var col_strip_widths = [];
    var n_xaxes = 0;
    var n_yaxes = 0;
    var current_row, current_col;
    for (var layout_i = 0; layout_i < npanels; layout_i++) {
      current_row = p_info.layout.ROW[layout_i] - 1;
      current_col = p_info.layout.COL[layout_i] - 1;
      if(row_strip_heights[current_row] === undefined){
	row_strip_heights[current_row] = [];
      }
      if(col_strip_widths[current_col] === undefined){
	col_strip_widths[current_col] = [];
      }
      row_strip_heights[current_row].push(strip_heights[layout_i]);
      col_strip_widths[current_col].push(strip_widths[layout_i]);
      if (p_info.layout.COL[layout_i] == 1) {
	n_xaxes += p_info.layout.AXIS_X[layout_i];
      }
      if (p_info.layout.ROW[layout_i] == 1) {
	n_yaxes += p_info.layout.AXIS_Y[layout_i];
      }
    }
    function cumsum_array(array_of_arrays){
      var cumsum = [], max_value, cumsum_value = 0;
      for(var i=0; i<array_of_arrays.length; i++){
	cumsum_value += d3.max(array_of_arrays[i]);
	cumsum[i] = cumsum_value;
      }
      return cumsum;
    }
    var cum_height_per_row = cumsum_array(row_strip_heights);
    var cum_width_per_col = cumsum_array(col_strip_widths);
    var strip_width = d3.max(cum_width_per_col);
    var strip_height = d3.max(cum_height_per_row);

    // the *entire graph* height/width
    var graph_width = p_info.options.width - 
        ncols * (margin.left + margin.right) -
	strip_width -
        n_yaxes * axispaddingy - ytitlepadding;
    var graph_height = p_info.options.height - 
        nrows * (margin.top + margin.bottom) -
	strip_height -
        titlepadding - n_xaxes * axispaddingx - xtitlepadding;

    // Impose the pixelated aspect ratio of the graph upon the width/height
    // proportions calculated by the compiler. This has to be done on the
    // rendering side since the precomputed proportions apply to the *graph*
    // and the graph size depends upon results of measureText()
    if (p_info.layout.coord_fixed[0]) {
      var aspect = (graph_height / nrows) / (graph_width / ncols);
    } else {
      var aspect = 1;
    }
    var wp = p_info.layout.width_proportion.map(function(x){
      return x * Math.min(1, aspect);
    })
    var hp = p_info.layout.height_proportion.map(function(x){
      return x * Math.min(1, 1/aspect);
    })

    // track the proportion of the graph that should be 'blank'
    // this is mainly used to implement coord_fixed()
    var graph_height_blank = 1;
    var graph_width_blank = 1;
    for (var layout_i = 0; layout_i < npanels; layout_i++) {
      if (p_info.layout.COL[layout_i] == 1) graph_height_blank -= hp[layout_i];
      if (p_info.layout.ROW[layout_i] == 1) graph_width_blank -= wp[layout_i];
    }
    // cumulative portion of the graph used
    var graph_width_cum = (graph_width_blank / 2) * graph_width;
    var graph_height_cum = (graph_height_blank / 2) * graph_height;

    // Bind plot data to this plot's SVG element
    svg.plot = p_info;
    Plots[p_name] = p_info;
    p_info.geoms.forEach(function (g_name) {
      var layer_g_element = svg.append("g").attr("class", g_name);
      panel_names.forEach(function(PANEL){
        layer_g_element.append("g").attr("class", "PANEL" + PANEL);
      });
      SVGs[g_name] = svg;
    });

    // create a grouping for strip labels (even if there are none).
    var topStrip = svg.append("g")
      .attr("class", "topStrip")
    ;
    var rightStrip = svg.append("g")
      .attr("class", "rightStrip")
    ;

    // this will hold x/y scales for each panel
    // eventually we inject this into Plots[p_name]
    var scales = {};
    n_xaxes = 0;
    n_yaxes = 0;
    // Draw a plot outline for every panel
    for (var layout_i = 0; layout_i < npanels; layout_i++) {
      var panel_i = layout_i + 1;
      var axis  = p_info["axis" + panel_i];

      //forces values to be in an array
      var xaxisvals = [];
      var xaxislabs = [];
      var yaxisvals = [];
      var yaxislabs = [];
      var outbreaks, outlabs;

      //function to write labels and breaks to their respective arrays
      var axislabs = function(breaks, labs, axis){
        if(axis=="x"){
          outbreaks = xaxisvals;
          outlabs = xaxislabs;
        } else {
          outbreaks = yaxisvals;
          outlabs = yaxislabs;
        } // set appropriate variable names
        if (isArray(breaks)) {
          breaks.forEach(function (d) {
            outbreaks.push(d);
          })
        } else {
          //breaks can be an object!
          for (key in breaks) {
            outbreaks.push(breaks[key]);
          }
        }
        if (labs){
          labs.forEach(function (d) {
            outlabs.push(d);
            // push each label provided into the array
          });
        } else {
          outbreaks.forEach(function (d) {
            outlabs.push("");
            // push a blank string to the array for each axis tick
            // if the specified label is null
          });
        }
      };

      if(axis["xticks"]){
	axislabs(axis.x, axis.xlab, "x");
      }
      if(axis["yticks"]){
	axislabs(axis.y, axis.ylab, "y");
      }

      // compute the current panel height/width
      plotdim.graph.height = graph_height * hp[layout_i];
      plotdim.graph.width = graph_width * wp[layout_i];

      current_row = p_info.layout.ROW[layout_i];
      current_col = p_info.layout.COL[layout_i];
      var draw_x = p_info.layout.AXIS_X[layout_i];
      var draw_y = p_info.layout.AXIS_Y[layout_i];
      // panels are drawn using a "typewriter approach" (left to right
      // & top to bottom) if the carriage is returned (ie, there is a
      // new row), change some parameters:
      var new_row = current_col <= p_info.layout.COL[layout_i - 1]
      if (new_row) {
	n_yaxes = 0;
	graph_width_cum = (graph_width_blank / 2) * graph_width;
	graph_height_cum += graph_height * hp[layout_i-1];
      }
      n_xaxes += draw_x;
      n_yaxes += draw_y;

      // calculate panel specific locations to be used in placing
      // axes, labels, etc.
      plotdim.xstart =  current_col * plotdim.margin.left +
        (current_col - 1) * plotdim.margin.right +
        graph_width_cum + n_yaxes * axispaddingy + ytitlepadding;
      // room for right strips should be distributed evenly across
      // panels to preserve aspect ratio
      plotdim.xend = plotdim.xstart + plotdim.graph.width;
      // total height of strips drawn thus far
      var strip_h = cum_height_per_row[current_row-1];
      plotdim.ystart = current_row * plotdim.margin.top +
        (current_row - 1) * plotdim.margin.bottom +
        graph_height_cum + titlepadding + strip_h;
      // room for xaxis title should be distributed evenly across
      // panels to preserve aspect ratio
      plotdim.yend = plotdim.ystart + plotdim.graph.height;
      // always add to the width (note it may have been reset earlier)
      graph_width_cum = graph_width_cum + plotdim.graph.width;

      // get the x position of the y-axis title (and add padding) when
      // rendering the first plot.
      if (layout_i === 0) {
	var ytitle_x = (plotdim.xstart - axispaddingy - ytitlepadding / 2);
	var xtitle_left = plotdim.xstart;
	var ytitle_top = plotdim.ystart;
      }
      // get the y position of the x-axis title when drawing the last
      // panel.
      if (layout_i === (npanels - 1)) {
	var xtitle_y = (plotdim.yend + axispaddingx);
	var xtitle_right = plotdim.xend;
	var ytitle_bottom = plotdim.yend;
      }

      var draw_strip = function(strip, side) {
        if (strip == "") {
          return(null);
        }
        var x, y, rotate, stripElement, strip_text_xy;
        if (side == "right") {
          x = plotdim.xend;
          y = (plotdim.ystart + plotdim.yend) / 2;
          rotate = 90;
	  stripElement = rightStrip;
          strip_text_xy = "y";
        }else{ //top
	  x = (plotdim.xstart + plotdim.xend) / 2;
          y = plotdim.ystart;
	  rotate = 0;
	  stripElement = topStrip;
          strip_text_xy = "x";
	}
	var trans_text = "translate(" + x + "," + y + ")";
	var rot_text = "rotate(" + rotate + ")";
        var strip_text_size = "strip_text_"+strip_text_xy+"size";
	stripElement
          .selectAll("." + side + "Strips")
          .data(strip)
          .enter()
          .append("text")
          .style("text-anchor", "middle")
          .style("font-size", p_info[strip_text_size])
          .text(function(d) { return d; })
        // NOTE: there could be multiple strips per panel
        // TODO: is there a better way to manage spacing?
          .attr("transform", trans_text + rot_text)
	;
      }
      draw_strip([p_info.strips.top[layout_i]], "top");
      draw_strip([p_info.strips.right[layout_i]], "right");

      // for each of the x and y axes, there is a "real" and fake
      // version. The real version will be used for plotting the
      // data, and the fake version is just for the display of the
      // axes.
      scales[panel_i] = {};
      scales[panel_i].x = d3.scale.linear()
        .domain(axis.xrange)
        .range([plotdim.xstart, plotdim.xend]);
      scales[panel_i].y = d3.scale.linear()
        .domain(axis.yrange)
        .range([plotdim.yend, plotdim.ystart]);
      if(draw_x){
        var xaxis = d3.svg.axis()
          .scale(scales[panel_i].x)
          .tickValues(xaxisvals)
          .tickFormat(function (d) {
            return xaxislabs[xaxisvals.indexOf(d)].toString();
          })
          .orient("bottom")
	;
  var axis_panel = "xaxis" + "_" + panel_i;
	var xaxis_g = svg.append("g")
          .attr("class", "xaxis axis " + axis_panel)
          .attr("transform", "translate(0," + plotdim.yend + ")")
          .call(xaxis);
	if(axis["xline"] == false){
	  var axis_path = xaxis_g.select("path.domain");
	  axis_path.remove();
	}
	xaxis_g.selectAll("text")
	  .style("text-anchor", p_info.xanchor)
	  .style("font-size", p_info.xsize)
	  .attr("transform", "rotate(" + p_info.xangle + " 0 9)");
      }
      if(draw_y){
	var yaxis = d3.svg.axis()
          .scale(scales[panel_i].y)
          .tickValues(yaxisvals)
          .tickFormat(function (d) {
            return yaxislabs[yaxisvals.indexOf(d)].toString();
          })
          .orient("left");
  var axis_panel = "yaxis" + "_" + panel_i;
	var yaxis_g = svg.append("g")
          .attr("class", "yaxis axis " + axis_panel)
          .attr("transform", "translate(" + (plotdim.xstart) + ",0)")
          .call(yaxis);
	if(axis["yline"] == false){
	  var axis_path = yaxis_g.select("path.domain");
	  axis_path.remove();
	}
  yaxis_g.selectAll(".tick text")
    .style("font-size", p_info.ysize);
      }

      if(!axis.xline) {
    	styles.push("#"+p_name+" #xaxis"+" path{stroke:none;}");
      }
      if(!axis.xticks) {
    	styles.push("#"+p_name+" #xaxis .tick"+" line{stroke:none;}");
      }
      if(!axis.yline) {
    	styles.push("#"+p_name+" #yaxis"+" path{stroke:none;}");
      }
      if(!axis.yticks) {
    	styles.push("#"+p_name+" #yaxis .tick"+" line{stroke:none;}");
      }
      
      // creating g element for background, grid lines, and border
      // uses insert to draw it right before plot title
      var background = svg.insert("g", ".plottitle")
        .attr("class", "background bgr" + panel_i);
      
      // drawing background
      if(Object.keys(p_info.panel_background).length > 1) {
        background.append("rect")
          .attr("x", plotdim.xstart)
          .attr("y", plotdim.ystart)
          .attr("width", plotdim.xend - plotdim.xstart)
          .attr("height", plotdim.yend - plotdim.ystart)
          .attr("class", "background_rect")
          .style("fill", p_info.panel_background.fill)
          .style("stroke", p_info.panel_background.colour)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(p_info.panel_background.linetype,
                                          p_info.panel_background.size);
          });
      }
      
      // drawing the grid lines
      ["grid_minor", "grid_major"].forEach(function(grid_class){
	var grid_background = p_info[grid_class];
        // if grid lines are defined
        if(grid_background.hasOwnProperty("size")) {
          var grid = background.append("g")
              .attr("class", grid_class);
	  ["x","y"].forEach(function(scale_var){
	    var const_var;
	    if(scale_var == "x"){
	      const_var = "y";
	    }else{
	      const_var = "x";
	    }
            grid.append("g")
              .attr("class", scale_var)
              .selectAll("line")
              .data(grid_background.loc[scale_var][layout_i])
              .enter()
              .append("line")
              .attr(const_var + "1", plotdim[const_var + "start"])
              .attr(const_var + "2", plotdim[const_var + "end"])
              .attr(scale_var + "1", function(d) {
		return scales[panel_i][scale_var](d);
	      })
              .attr(scale_var + "2", function(d) {
		return scales[panel_i][scale_var](d);
	      })
              .style("stroke", grid_background.colour)
              .style("stroke-linecap", grid_background.lineend)
              .style("stroke-width", grid_background.size)
              .style("stroke-dasharray", linetypesize2dasharray(
		grid_background.linetype, grid_background.size))
	    ;
	  });
	}
      });
      
      // drawing border
      // uses insert to draw it right before the #plottitle
      if(Object.keys(p_info.panel_border).length > 1) {
        background.append("rect")
          .attr("x", plotdim.xstart)
          .attr("y", plotdim.ystart)
          .attr("width", plotdim.xend - plotdim.xstart)
          .attr("height", plotdim.yend - plotdim.ystart)
          .attr("class", "border_rect")
          .style("fill", p_info.panel_border.fill)
          .style("stroke", p_info.panel_border.colour)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(p_info.panel_border.linetype,
                                          p_info.panel_border.size);
          });
      }

    } //end of for(layout_i
    // After drawing all backgrounds, we can draw the axis labels.
    if(p_info["ytitle"]){
      svg.append("text")
	.text(p_info["ytitle"])
	.attr("class", "ytitle")
	.style("text-anchor", "middle")
	.style("font-size", default_axis_px + "px")
	.attr("transform", "translate(" + 
	      ytitle_x +
	      "," +
	      (ytitle_top + ytitle_bottom)/2 + 
	      ")rotate(270)")
      ;
    }
    if(p_info["xtitle"]){
      svg.append("text")
	.text(p_info["xtitle"])
	.attr("class", "xtitle")
	.style("text-anchor", "middle")
	.style("font-size", default_axis_px + "px")
	.attr("transform", "translate(" + 
	      (xtitle_left + xtitle_right)/2 +
	      "," + 
	      xtitle_y + 
	      ")")
      ;
    }
    Plots[p_name].scales = scales;
  }; //end of add_plot()

  function update_legend_opacity(v_name){
    var s_info = Selectors[v_name];
    s_info.legend_tds.style("opacity", s_info.legend_update_fun);
  }

  var add_selector = function (s_name, s_info) {
    Selectors[s_name] = s_info;
    if(s_info.type == "multiple"){
      if(!isArray(s_info.selected)){
        s_info.selected = [s_info.selected];
      }
      // legend_update_fun is evaluated in the context of the
      // td.legend_entry_label.
      s_info.legend_update_fun = function(d){
	var i_value = s_info.selected.indexOf(this.textContent);
	if(i_value == -1){
	  return 0.5;
	}else{
	  return 1;
	}
      }
    }else{
      s_info.legend_update_fun = function(d){
	if(this.textContent == s_info.selected){
	  return 1;
	}else{
	  return 0.5;
	}
      }
    }
    s_info.legend_tds = 
      element.selectAll("tr."+legend_class_name(s_name)+" td.legend_entry_label")
    ;
    update_legend_opacity(s_name);
  }; //end of add_selector()

  function get_tsv(g_info, chunk_id){
    return g_info.classed + "_chunk" + chunk_id + ".tsv";
  }
  function getTSVpath(tsv_name){
    return dirs.concat(tsv_name).join("/");
  }
  
  /**
   * copy common chunk tsv to varied chunk tsv, returning an array of
   * objects.
  */
  function copy_chunk(g_info, varied_chunk) {
    var varied_by_group = nest_by_group.map(varied_chunk);
    var common_by_group = g_info.data[g_info.common_tsv];
    var new_varied_chunk = [];
    for(group_id in varied_by_group){
      var varied_one_group = varied_by_group[group_id];
      var common_one_group = common_by_group[group_id];
      var common_i = 0;
      for(var varied_i=0; varied_i < varied_one_group.length; varied_i++){
	// there are two cases: each group of varied data is of length
	// 1, or of length of the common data.
	if(common_one_group.length == varied_one_group.length){
	  common_i = varied_i;
	}
	var varied_obj = varied_one_group[varied_i];
	var common_obj = common_one_group[common_i];
	for(col in common_obj){
	  if(col != "group"){
	    varied_obj[col] = common_obj[col];
	  }
	}
	new_varied_chunk.push(varied_obj);
      }
    }
    return new_varied_chunk;
  }

  // update_geom is called from add_geom and update_selector. It
  // downloads data if necessary, and then calls draw_geom.
  var update_geom = function (g_name, selector_name) {
    var g_info = Geoms[g_name];
    // First apply chunk_order selector variables.
    var chunk_id = g_info.chunks;
    g_info.chunk_order.forEach(function (v_name) {
      if(chunk_id == null){
        return; // no data in a higher up chunk var.
      }
      var value = Selectors[v_name].selected;
      if(chunk_id.hasOwnProperty(value)){
	       chunk_id = chunk_id[value];
      }else{
	       chunk_id = null; // no data to show in this subset.
      }
    });
    if(chunk_id == null){
      draw_panels(g_info, [], selector_name); //draw nothing.
      return;
    }
    var tsv_name = get_tsv(g_info, chunk_id);
    // get the data if it has not yet been downloaded.
    g_info.tr.select("td.chunk").text(tsv_name);
    if(g_info.data.hasOwnProperty(tsv_name)){
      draw_panels(g_info, g_info.data[tsv_name], selector_name);
    }else{
      g_info.tr.select("td.status").text("downloading");
      var svg = SVGs[g_name];
      var loading = svg.append("text")
        .attr("class", "loading"+tsv_name)
	      .text("Downloading "+tsv_name+"...")
	      .attr("font-size", 9)
	      //.attr("x", svg.attr("width")/2)
        .attr("y", 10)
        .style("fill", "red");
      download_chunk(g_info, tsv_name, function(chunk){
      	loading.remove();
	draw_panels(g_info, chunk, selector_name);
      });
    }
  };
  var draw_panels = function(g_info, chunk, selector_name) {
    // derive the plot name from the geometry name
    var g_names = g_info.classed.split("_");
    var p_name = g_names[g_names.length - 1];
    var panels = Plots[p_name].layout.PANEL;
    panels.forEach(function(panel) {
      draw_geom(g_info, chunk, selector_name, panel);
    });
  };

  function download_next(g_name){
    var g_info = Geoms[g_name];
    var selector_value = Animation.sequence[g_info.seq_i];
    var chunk_id = g_info.chunks[selector_value];
    var tsv_name = get_tsv(g_info, chunk_id);
    g_info.seq_count += 1;
    if(Animation.sequence.length == g_info.seq_count){
      Animation.done_geoms[g_name] = 1;
      return;
    }
    g_info.seq_i += 1;
    if(g_info.seq_i == Animation.sequence.length){
      g_info.seq_i = 0;
    }
    if(typeof(chunk_id) == "string"){
      download_chunk(g_info, tsv_name, function(chunk){
	download_next(g_name);
      })
    }else{
      download_next(g_name);
    }
  }

  // download_chunk is called from update_geom and download_next.
  function download_chunk(g_info, tsv_name, funAfter){
    if(g_info.download_status.hasOwnProperty(tsv_name)){
      var chunk;
      if(g_info.data_is_object){
	chunk = {};
      }else{
	chunk = [];
      }
      funAfter(chunk);
      return; // do not download twice.
    }
    g_info.download_status[tsv_name] = "downloading";
    // prefix tsv file with appropriate path
    var tsv_file = getTSVpath(tsv_name);
    d3.tsv(tsv_file, function (error, response) {
      // First convert to correct types.
      g_info.download_status[tsv_name] = "processing";
      response = convert_R_types(response, g_info.types);
      wait_until_then(500, function(){
	if(g_info.common_tsv) {
          return g_info.data.hasOwnProperty(g_info.common_tsv);
	}else{
	  return true;
	}
      }, function(){
	if(g_info.common_tsv) {
          // copy data from common tsv to varied tsv
          response = copy_chunk(g_info, response);
	}
	var nest = d3.nest();
	g_info.nest_order.forEach(function (v_name) {
          nest.key(function (d) {
            return d[v_name];
          });
	});
	var chunk = nest.map(response);
	g_info.data[tsv_name] = chunk;
	g_info.tr.select("td.downloaded").text(d3.keys(g_info.data).length);
	g_info.download_status[tsv_name] = "saved";
	funAfter(chunk);
      });
    });
  }//download_chunk.

  // update_geom is responsible for obtaining a chunk of downloaded
  // data, and then calling draw_geom to actually draw it.
  var draw_geom = function(g_info, chunk, selector_name, PANEL){
    g_info.tr.select("td.status").text("displayed");
    var svg = SVGs[g_info.classed];
    // derive the plot name from the geometry name
    var g_names = g_info.classed.split("_");
    var p_name = g_names[g_names.length - 1];
    var scales = Plots[p_name].scales[PANEL];
    var selected_arrays = [ [] ]; //double array necessary.
    var has_clickSelects = g_info.aes.hasOwnProperty("clickSelects");
    var has_clickSelects_variable =
      g_info.aes.hasOwnProperty("clickSelects.variable");
    g_info.subset_order.forEach(function (aes_name) {
      var selected, values;
      var new_arrays = [];
      if(0 < aes_name.indexOf(".variable")){ 
	selected_arrays.forEach(function(old_array){
	  var some_data = chunk;
	  old_array.forEach(function(value){
            if(some_data.hasOwnProperty(value)) {
              some_data = some_data[value];
            } else {
              some_data = {};
            }
	  })
	  values = d3.keys(some_data);
	  values.forEach(function(s_name){
	    var selected = Selectors[s_name].selected;
	    var new_array = old_array.concat(s_name).concat(selected);
	    new_arrays.push(new_array);
	  })
	})
      }else{//not .variable aes:
	if(aes_name == "PANEL"){
	  selected = PANEL;
	}else{
          var s_name = g_info.aes[aes_name];
          selected = Selectors[s_name].selected;
	}
	if(isArray(selected)){ 
	  values = selected; //multiple selection.
	}else{
	  values = [selected]; //single selection.
	}
	values.forEach(function(value){
	  selected_arrays.forEach(function(old_array){
	    var new_array = old_array.concat(value);
	    new_arrays.push(new_array);
	  })
	})
      }
      selected_arrays = new_arrays;
    });
    // data can be either an array[] if it will be directly involved
    // in a data-bind, or an object{} if it will be involved in a
    // data-bind by group (e.g. geom_line).
    var data;
    if(g_info.data_is_object){
      data = {};
    }else{
      data = [];
    }
    selected_arrays.forEach(function(value_array){
      var some_data = chunk;
      value_array.forEach(function(value){
        if (some_data.hasOwnProperty(value)) {
          some_data = some_data[value];
        } else {
	  if(g_info.data_is_object){
	    some_data = {};
	  }else{
            some_data = [];
	  }
        }
      });
      if(g_info.data_is_object){
	if(isArray(some_data) && some_data.length){
	  data["0"] = some_data;
	}else{
	  for(k in some_data){
            data[k] = some_data[k];
          }
	}
      }else{//some_data is an array.
        data = data.concat(some_data);
      }
    });
    var aes = g_info.aes;
    var toXY = function (xy, a) {
      return function (d) {
        return scales[xy](d[a]);
      };
    };
    var layer_g_element = svg.select("g." + g_info.classed);
    var panel_g_element = layer_g_element.select("g.PANEL" + PANEL);
    var elements = panel_g_element.selectAll(".geom");

    // helper functions so we can write code that works for both
    // grouped and ungrouped geoms. get_one_row returns one row of
    // data (not one group), in both cases.
    var get_fun = function(fun){
      return function(input){
	var d = get_one_row(input);
	return fun(d);
      };
    };
    var get_attr = function(attr_name){
      return get_fun(function(d){
	return d[attr_name];
      });
    };

    var size = 2;
    var get_size;
    if(aes.hasOwnProperty("size")){
      get_size = get_attr("size");
    }else{
      get_size = function(d){
	return size;
      };
    }
    var get_style_on_stroke_width = get_size;
    
    // stroke_width for geom_point
    var stroke_width = 1;  // by default ggplot2 has 0.5, animint has 1
    var get_stroke_width;
    if(aes.hasOwnProperty("stroke")){
      get_stroke_width = get_attr("stroke");
    }else{
      get_stroke_width = function(d){
	return stroke_width;
      };
    }
    
    var linetype = "solid";
    var get_linetype;
    if(aes.hasOwnProperty("linetype")){
      get_linetype = get_attr("linetype");
    }else{
      get_linetype = function(d){
	return linetype;
      };
    }
    var get_dasharray = function(d){
      var lt = get_linetype(d);
      return linetypesize2dasharray(lt, get_size(d));
    };

    var alpha = 1, alpha_off = 0.5;
    var get_alpha;
    var get_alpha_off = function (d) {
      return alpha_off;
    };
    if(aes.hasOwnProperty("alpha")){
      get_alpha = get_attr("alpha");
      get_alpha_off = get_attr("alpha");
    } else {
      get_alpha = function(d){
	return alpha;
      };
    }
    
    var colour = "black", colour_off;
    var get_colour;
    var get_colour_off = function (d) {
      return colour_off;
    };
    if(aes.hasOwnProperty("colour")){
      get_colour = get_attr("colour");
      get_colour_off = get_colour;
    }else{
      get_colour = function (d) {
	return colour;
      };
    }
    var get_colour_off_default = get_colour;

    var fill = "black", fill_off = "black";
    var get_fill = function (d) {
      return fill;
    };
    var get_fill_off = function (d) {
      return fill_off;
    };
    
    var angle = 0;
    var get_angle;
    if(aes.hasOwnProperty("angle")){
      get_angle = get_attr("angle");
    }else{
      get_angle = function(d){
	return angle;
      };
    }
    var get_rotate = function(d){
      // x and y are the coordinates to rotate around, we choose the center 
      // point of the text because otherwise it will rotate around (0,0) of its 
      // coordinate system, which is the top left of the plot
      x = scales["x"](d["x"]);
      y = scales["y"](d["y"]);
      var angle = get_angle(d);
      // ggplot expects angles to be in degrees CCW, SVG uses degrees CW, so 
      // we negate the angle.
      return `rotate(${-angle}, ${x}, ${y})`;
    };
    
    // For aes(hjust) the compiler should make an "anchor" column.
    var text_anchor = "middle";
    var get_text_anchor;
    if(g_info.aes.hasOwnProperty("hjust")) {
      get_text_anchor = function(d){
	return d["anchor"];
      }
    }else{
      get_text_anchor = function(d){
	return text_anchor;
      }
    }

    var eActions, eAppend;
    var key_fun = null;
    if(g_info.aes.hasOwnProperty("key")){
      key_fun = function(d){
        return d.key;
      };
    }
    var get_one_row;//different for grouped and ungrouped geoms.
    var data_to_bind;
    g_info.style_list = [
      "opacity","stroke","stroke-width","stroke-dasharray","fill"];
    var line_style_list = [
      "opacity","stroke","stroke-width","stroke-dasharray"];
    var fill_comes_from="fill", fill_off_comes_from="fill_off";
    if(g_info.data_is_object) {

      // Lines, paths, polygons, and ribbons are a bit special. For
      // every unique value of the group variable, we take the
      // corresponding data rows and make 1 path. The tricky part is
      // that to use d3 I do a data-bind of some "fake" data which are
      // just group ids, which is the kv variable in the code below

      // // case of only 1 line and no groups.
      // if(!aes.hasOwnProperty("group")){
      //     kv = [{"key":0,"value":0}];
      //     data = {0:data};
      // }else{
      //     // we need to use a path for each group.
      //     var kv = d3.entries(d3.keys(data));
      //     kv = kv.map(function(d){
      // 	d[aes.group] = d.value;
      // 	return d;
      //     });
      // }

      // For an example consider breakpointError$error which is
      // defined using this R code

      // geom_line(aes(segments, error, group=bases.per.probe,
      //    clickSelects=bases.per.probe), data=only.error, lwd=4)

      // Inside update_geom the variables take the following values
      // (pseudo-Javascript code)

      // var kv = [{"key":"0","value":"133","bases.per.probe":"133"},
      //           {"key":"1","value":"2667","bases.per.probe":"2667"}];
      // var data = {"133":[array of 20 points used to draw the line for group 133],
      //             "2667":[array of 20 points used to draw the line for group 2667]};

      // I do elements.data(kv) so that when I set the d attribute of
      // each path, I need to select the correct group before
      // returning anything.

      // e.attr("d",function(group_info){
      //     var one_group = data[group_info.value];
      //     return lineThing(one_group);
      // })

      // To make color work I think you just have to select the group
      // and take the color of the first element, e.g.

      // .style("stroke",function(group_info){
      //     var one_group = data[group_info.value];
      //     var one_row = one_group[0];
      //     return get_color(one_row);
      // }

      // In order to get d3 lines to play nice, bind fake "data" (group
      // id's) -- the kv variable. Then each separate object is plotted
      // using path (case of only 1 thing and no groups).

      // we need to use a path for each group.
      var keyed_data = {}, one_group, group_id, k;
      for(group_id in data){
	one_group = data[group_id];
	one_row = one_group[0];
	if(one_row.hasOwnProperty("key")){
	  k = one_row.key;
	}else{
	  k = group_id;
	}
	keyed_data[k] = one_group;
      }
      var kv_array = d3.entries(d3.keys(keyed_data));
      var kv = kv_array.map(function (d) {
        //d[aes.group] = d.value;

        // Need to store the clickSelects value that will
        // be passed to the selector when we click on this
        // item.
        d.clickSelects = keyed_data[d.value][0].clickSelects;
        return d;
      });

      // line, path, and polygon use d3.svg.line(),
      // ribbon uses d3.svg.area()
      // we have to define lineThing accordingly.
      if (g_info.geom == "ribbon") {
        var lineThing = d3.svg.area()
          .x(toXY("x", "x"))
          .y(toXY("y", "ymax"))
          .y0(toXY("y", "ymin"));
      } else {
        var lineThing = d3.svg.line()
          .x(toXY("x", "x"))
          .y(toXY("y", "y"));
      }
      if(["line","path"].includes(g_info.geom)){
	fill = "none";
	fill_off = "none";
      }
      // select the correct group before returning anything.
      key_fun = function(group_info){
	return group_info.value;
      };
      data_to_bind = kv;
      get_one_row = function(group_info) {
        var one_group = keyed_data[group_info.value];
        var one_row = one_group[0];
	return one_row;
      };
      eActions = function (e) {
        e.attr("d", function (d) {
          var one_group = keyed_data[d.value];
          // filter NaN since they make the whole line disappear!
	  var no_na = one_group.filter(function(d){
            if(g_info.geom == "ribbon"){
              return !isNaN(d.x) && !isNaN(d.ymin) && !isNaN(d.ymax);
            }else{
              return !isNaN(d.x) && !isNaN(d.y);
            }
          });
          return lineThing(no_na);
        })
      };
      eAppend = "path";
    }else{
      get_one_row = function(d){
	return d;
      }
      data_to_bind = data;
      if (g_info.geom == "segment") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("x1", function (d) {
            return scales.x(d["x"]);
          })
            .attr("x2", function (d) {
              return scales.x(d["xend"]);
            })
            .attr("y1", function (d) {
              return scales.y(d["y"]);
            })
            .attr("y2", function (d) {
              return scales.y(d["yend"]);
            })
	};
	eAppend = "line";
      }
      if (g_info.geom == "linerange") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("x1", function (d) {
            return scales.x(d["x"]);
          })
            .attr("x2", function (d) {
              return scales.x(d["x"]);
            })
            .attr("y1", function (d) {
              return scales.y(d["ymax"]);
            })
            .attr("y2", function (d) {
              return scales.y(d["ymin"]);
            })
	  ;
	};
	eAppend = "line";
      }
      if (g_info.geom == "vline") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("x1", toXY("x", "xintercept"))
            .attr("x2", toXY("x", "xintercept"))
            .attr("y1", scales.y.range()[0])
            .attr("y2", scales.y.range()[1])
	  ;
	};
	eAppend = "line";
      }
      if (g_info.geom == "hline") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("y1", toXY("y", "yintercept"))
            .attr("y2", toXY("y", "yintercept"))
            .attr("x1", scales.x.range()[0])
            .attr("x2", scales.x.range()[1])
	  ;
	};
	eAppend = "line";
      }
      if (g_info.geom == "text") {
	size = 12;//default
	get_colour = function(d){
	  return "none";
	};
	get_colour_off = function(d) {
	  return "none";
	};
	fill_comes_from = "colour";
	fill_off_comes_from = "colour_off";
	g_info.style_list = [
	  "opacity","fill"];
	eActions = function (e) {
          e.attr("x", toXY("x", "x"))
            .attr("y", toXY("y", "y"))
            .attr("font-size", get_size)
            .style("text-anchor", get_text_anchor)
            .attr("transform", get_rotate)
            .text(function (d) {
              return d.label;
            })
	  ;
	};
	eAppend = "text";
      }
      if (g_info.geom == "point") {
	// point is special because it takes SVG fill from ggplot
	// colour, if fill is not specified.
	if(!(
	  g_info.params.hasOwnProperty("fill") ||
	    aes.hasOwnProperty("fill")
	)){
	  fill_comes_from = "colour";
	}
	if(!g_info.params.hasOwnProperty("fill_off")){
	  fill_off_comes_from = "colour_off";
	}
	get_style_on_stroke_width = get_stroke_width;//not size.
	eActions = function (e) {
          e.attr("cx", toXY("x", "x"))
            .attr("cy", toXY("y", "y"))
            .attr("r", get_size)
	  ;
	};
	eAppend = "circle";
      }
      var rect_geoms = ["tallrect","widerect","rect"];
      if(rect_geoms.includes(g_info.geom)){
	eAppend = "rect";
	if (g_info.geom == "tallrect") {
	  eActions = function (e) {
            e.attr("x", toXY("x", "xmin"))
              .attr("width", function (d) {
		return scales.x(d["xmax"]) - scales.x(d["xmin"]);
              })
              .attr("y", scales.y.range()[1])
              .attr("height", scales.y.range()[0] - scales.y.range()[1])
	    ;
	  };
	}
	if (g_info.geom == "widerect") {
	  eActions = function (e) {
            e.attr("y", toXY("y", "ymax"))
              .attr("height", function (d) {
		return scales.y(d["ymin"]) - scales.y(d["ymax"]);
              })
              .attr("x", scales.x.range()[0])
              .attr("width", scales.x.range()[1] - scales.x.range()[0])
	    ;
	  };
	}
	if (g_info.geom == "rect") {
	  alpha_off = alpha;
	  colour_off = "transparent";
	  get_colour_off_default = get_colour_off;
	  eActions = function (e) {
            e.attr("x", toXY("x", "xmin"))
              .attr("width", function (d) {
		return Math.abs(scales.x(d.xmax) - scales.x(d.xmin));
              })
              .attr("y", toXY("y", "ymax"))
              .attr("height", function (d) {
		return Math.abs(scales.y(d.ymin) - scales.y(d.ymax));
              })
	    ;
	  };
	}
      }
    }
    // set params after geom-specific code, because each geom may have
    // a different default.
    if (g_info.params.hasOwnProperty("stroke")) {
      stroke_width = g_info.params.stroke;
    }
    if (g_info.params.hasOwnProperty("linetype")) {
      linetype = g_info.params.linetype;
    }
    if(g_info.params.hasOwnProperty("alpha")){
      alpha = g_info.params.alpha;
      alpha_off = alpha - 0.5
    }
    if(g_info.params.hasOwnProperty("alpha_off")){
      alpha_off = g_info.params.alpha_off;
    }
    if(g_info.params.hasOwnProperty("anchor")){
      text_anchor = g_info.params["anchor"];
    }
    if(g_info.params.hasOwnProperty("colour")){
      colour = g_info.params.colour;
    }
    if(g_info.params.hasOwnProperty("colour_off")){
      colour_off = g_info.params.colour_off;
    }else{
      get_colour_off = get_colour_off_default;
    }
    if (g_info.params.hasOwnProperty("angle")) {
      angle = g_info.params["angle"];
    }
    if (g_info.params.hasOwnProperty(fill_comes_from)) {
      fill = g_info.params[fill_comes_from];
    }
    if (g_info.params.hasOwnProperty(fill_off_comes_from)) {
      fill_off = g_info.params[fill_off_comes_from];
    }else{
      fill_off = fill;
    }
    if(aes.hasOwnProperty(fill_comes_from)){
      get_fill = get_attr(fill_comes_from);
      get_fill_off = get_attr(fill_comes_from);
    };
    if (g_info.params.hasOwnProperty("size")) {
      size = g_info.params.size;
    }
    var styleActions = function(e){
      g_info.style_list.forEach(function(s){
	e.style(s, function(d) {
	  var style_on_fun = style_on_funs[s];
	  return style_on_fun(d);
	});
      });
    };
    var style_on_funs = {
      "opacity": get_alpha,
      "stroke": get_colour,
      "fill": get_fill,
      "stroke-width": get_style_on_stroke_width,
      "stroke-dasharray": get_dasharray
    };
    var style_off_funs = {
      "opacity": get_alpha_off,
      "stroke": get_colour_off,
      "fill": get_fill_off
    };
    // TODO cleanup.
    var select_style_default = ["opacity","stroke","fill"];
    g_info.select_style = select_style_default.filter(
      X => g_info.style_list.includes(X));
    var over_fun = function(e){
      g_info.select_style.forEach(function(s){
        e.style(s, function (d) {
          return style_on_funs[s](d);
        });
      });
    };
    var out_fun = function(e){
      g_info.select_style.forEach(function(s){
        e.style(s, function (d) {
          var select_on = style_on_funs[s](d);
          var select_off = style_off_funs[s](d);
          if(has_clickSelects){
            return ifSelectedElse(
	      d.clickSelects,
	      g_info.aes.clickSelects,
              select_on, select_off);
          }else if(has_clickSelects_variable){
            return ifSelectedElse(
	      d["clickSelects.value"],
              d["clickSelects.variable"],
              select_on, select_off);
          }
        });
      });
    };
    elements = elements.data(data_to_bind, key_fun);
    elements.exit().remove();
    var enter = elements.enter();
    if(g_info.aes.hasOwnProperty("href")){
      enter = enter.append("svg:a")
        .append("svg:"+eAppend);
    }else{
      enter = enter.append(eAppend)
	.attr("class", "geom");
    }
    var moreActions = function(e){};
    if (has_clickSelects || has_clickSelects_variable) {
      moreActions = out_fun;
      elements.call(out_fun)
        .on("mouseover", function (d) {
          d3.select(this).call(over_fun);
        })
        .on("mouseout", function (d) {
          d3.select(this).call(out_fun);
        })
      ;
      if(has_clickSelects){
	elements.on("click", function (d) {
            var s_name = g_info.aes.clickSelects;
            update_selector(s_name, d.clickSelects);
	});
      }else{
	elements.on("click", function(d){
	  var s_name = d["clickSelects.variable"];
	  var s_value = d["clickSelects.value"];
	  update_selector(s_name, s_value);
	});
      }
    }
    // Set attributes of only the entering elements. This is needed to
    // prevent things from flying around from the upper left when they
    // enter the plot.
    var doActions = function(e) {
      eActions(e);
      styleActions(e);
      moreActions(e)
    };
    doActions(enter);  // DO NOT DELETE!
    var has_tooltip = g_info.aes.hasOwnProperty("tooltip");
    if(has_clickSelects || has_tooltip || has_clickSelects_variable){
      var text_fun;
      if(has_tooltip){
        text_fun = function(d){
	  return d.tooltip;
	};
      }else if(has_clickSelects){
	text_fun = function(d){
          var v_name = g_info.aes.clickSelects;
          return v_name + " " + d.clickSelects;
	};
      }else{ //clickSelects_variable
	text_fun = function(d){
	  return d["clickSelects.variable"] + " " + d["clickSelects.value"];
	};
      }
      // if elements have an existing title, remove it.
      elements.selectAll("title").remove();
      elements.append("svg:title")
        .text(get_fun(text_fun))
      ;
    }
    if(Selectors.hasOwnProperty(selector_name)){
      var milliseconds = Selectors[selector_name].duration;
      elements = elements.transition().duration(milliseconds);
    }
    if(g_info.aes.hasOwnProperty("id")){
      elements.attr("id", get_attr("id"));
    }
    if(g_info.aes.hasOwnProperty("href")){
      // elements are <a>, children are e.g. <circle>
      var linked_geoms = elements.select(eAppend);
      doActions(linked_geoms);
      elements.attr("xlink:href", get_attr("href"))
        .attr("target", "_blank")
        .attr("class", "geom");
    }else{
      // elements are e.g. <circle>
      doActions(elements); // Set the attributes of all elements (enter/exit/stay)
    }
  };
  
  var value_tostring = function(selected_values) {
      //function that is helpful to change the format of the string
      var selector_url="#"
      for (var selc_var in selected_values){
          if(selected_values.hasOwnProperty(selc_var)){
              var values_str=selected_values[selc_var].join();
              var sub_url=selc_var.concat("=","{",values_str,"}");
              selector_url=selector_url.concat(sub_url);
          }
      }
      var url_nohash=window.location.href.match(/(^[^#]*)/)[0];
      selector_url=url_nohash.concat(selector_url);
      return  selector_url;
 };
  
  var get_values=function(){
      // function that is useful to get the selected values
      var selected_values={}
      for(var s_name in Selectors){
          var s_info=Selectors[s_name];
          var initial_selections = [];
          if(s_info.type==="single"){
              initial_selections=[s_info.selected];
          }
          else{
          for(var i in s_info.selected) {
            initial_selections[i] =  s_info.selected[i];
          }
          }
          selected_values[s_name]=initial_selections;    
      }
      return selected_values;
  };
  
  // update scales for the plots that have update_axes option in
  // theme_animint
  function update_scales(p_name, axes, v_name, value){
    // Get pre-computed domain
    var axis_domains = Plots[p_name]["axis_domains"];
    if(!isArray(axes)){
      axes = [axes];
    }
    if(axis_domains != null){
      axes.forEach(function(xyaxis){
        // For Each PANEL, update the axes
        Plots[p_name].layout.PANEL.forEach(function(panel_i, i){
          // Determine whether this panel has a scale or not
          // If not we just update the scales according to the common
          // scale and skip the updating of axis
          var draw_axes = Plots[p_name].layout["AXIS_"+ xyaxis.toUpperCase()][i];
          if(draw_axes){
            var use_panel = panel_i;
          }else{
            var use_panel = Plots[p_name].layout.PANEL[0];
          }
          // We update the current selection of the plot every time
          // and use it to index the correct domain
          var curr_select = axis_domains[xyaxis].curr_select;
          if(axis_domains[xyaxis].selectors.indexOf(v_name) > -1){
            curr_select[v_name] = value;
            var str = use_panel+".";
            for(selec in curr_select){
              str = str + curr_select[selec] + "_";
            }
            str = str.substring(0, str.length - 1); // Strip off trailing underscore
            var use_domain = axis_domains[xyaxis]["domains"][str];
          }
          if(use_domain != null){
            Plots[p_name]["scales"][panel_i][xyaxis].domain(use_domain);
            var scales = Plots[p_name]["scales"][panel_i][xyaxis];
            // major and minor grid lines as calculated in the compiler
            var grid_vals = Plots[p_name]["axis_domains"][xyaxis]["grids"][str];

            // Once scales are updated, update the axis ticks if needed
            if(draw_axes){
              // Tick values are same as major grid lines
              update_axes(p_name, xyaxis, panel_i, grid_vals[1]);
            }
            // Update major and minor grid lines
            update_grids(p_name, xyaxis, panel_i, grid_vals, scales);
          }
        });
      });
    }
  }

  // Update the axis ticks etc. once plot is zoomed in/out
  // currently called from update_scales.
  function update_axes(p_name, axes, panel_i, tick_vals){
    var orientation;
    if(axes == "x"){
      orientation = "bottom";
    }else{
      orientation = "left";
    }
    if(!isArray(tick_vals)){
      tick_vals = [tick_vals];
    }
    var xyaxis = d3.svg.axis()
          .scale(Plots[p_name]["scales"][panel_i][axes])
          .orient(orientation)
          .tickValues(tick_vals);
    // update existing axis
    var xyaxis_g = element.select("#plot_"+p_name).select("."+axes+"axis_"+panel_i)
          .transition()
          .duration(1000)
          .call(xyaxis);
  }

  // Update major/minor grids once axes ticks have been updated
  function update_grids(p_name, axes, panel_i, grid_vals, scales){
    // Select panel to update
    var bgr = element.select("#plot_"+p_name).select(".bgr"+panel_i);
    // Update major and minor grid lines
    ["minor", "major"].forEach(function(grid_class, j){
      var lines = bgr.select(".grid_"+grid_class).select("."+axes);
      var xy1, xy2;
      if(axes == "x"){
        xy1 = lines.select("line").attr("y1");
        xy2 = lines.select("line").attr("y2");
      }else{
        xy1 = lines.select("line").attr("x1");
        xy2 = lines.select("line").attr("x2");
      }
      
      // Get default values for grid lines like colour, stroke etc.
      var grid_background = Plots[p_name]["grid_"+grid_class];
      var col = grid_background.colour;
      var lt = grid_background.linetype;
      var size = grid_background.size;
      var cap = grid_background.lineend;

      // Remove old lines
      lines.selectAll("line")
        .remove();

      if(!isArray(grid_vals[j])){
        grid_vals[j] = [grid_vals[j]];
      }

      if(axes == "x"){
        lines.selectAll("line")
          .data(grid_vals[j])
          .enter()
          .append("line")
          .attr("y1", xy1)
          .attr("y2", xy2)
          .attr("x1", function(d) { return scales(d); })
          .attr("x2", function(d) { return scales(d); })
          .style("stroke", col)
          .style("stroke-linecap", cap)
          .style("stroke-width", size)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(lt, size);
          });
      }else{
        lines.selectAll("line")
          .data(grid_vals[j])
          .enter()
          .append("line")
          .attr("x1", xy1)
          .attr("x2", xy2)
          .attr("y1", function(d) { return scales(d); })
          .attr("y2", function(d) { return scales(d); })
          .style("stroke", col)
          .style("stroke-linecap", cap)
          .style("stroke-width", size)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(lt, size);
          });
      }
    });
  }

  var update_selector = function (v_name, value) {
    if(!Selectors.hasOwnProperty(v_name)){
      return;
    }
    value = value + "";
    var s_info = Selectors[v_name];
    if(s_info.type == "single"){
      // value is the new selection.
      s_info.selected = value;
    }else{
      // value should be added or removed from the selection.
      var i_value = s_info.selected.indexOf(value);
      if(i_value == -1){
        // not found, add to selection.
	s_info.selected.push(value);
      }else{
	// found, remove from selection.
	s_info.selected.splice(i_value, 1);
      }
    }
    // update_selector_url()
    // if there are levels, then there is a selectize widget which
    // should be updated.
    if(isArray(s_info.levels)){
      // the jquery ids
      if(s_info.type == "single") {
	var selected_ids = v_name.concat("___", value);
      } else {
	var selected_ids = [];
	for(i in s_info.selected) {
          selected_ids[i] = v_name.concat("___", s_info.selected[i]);
	}
      }
      // from
      // https://github.com/brianreavis/selectize.js/blob/master/docs/api.md:
      // setValue(value, silent) If "silent" is truthy, no change
      // event will be fired on the original input.
      selectized_array[v_name].setValue(selected_ids, true);
    }

    // For each updated geom, check if the axes of the plot need to be
    // updated and update them
    s_info.update.forEach(function(g_name){
      var plot_name = g_name.split("_").pop();
      var axes = Plots[plot_name]["options"]["update_axes"];
      if(axes != null){
        update_scales(plot_name, axes, v_name, value);
      }
    });

    update_legend_opacity(v_name);
    s_info.update.forEach(function(g_name){
      update_geom(g_name, v_name);
    });
  };

  var ifSelectedElse = function (s_value, s_name, selected, not_selected) {
    var is_selected;
    var s_info = Selectors[s_name];
    if(s_info.type == "single"){
      is_selected = s_value == s_info.selected;
    }else{
      is_selected = s_info.selected.indexOf(s_value) != -1;
    }
    if(is_selected){
      return selected;
    } else {
      return not_selected;
    }
  };
  
  function update_next_animation(){
    var values = d3.values(Animation.done_geoms);
    if(d3.sum(values) == values.length){
      // If the values in done_geoms are all 1, then we have loaded
      // all of the animation-related chunks, and we can start
      // playing the animation.
      var v_name = Animation.variable;
      var cur = Selectors[v_name].selected;
      var next = Animation.next[cur];
      update_selector(v_name, next);
    }
  }

  // The main idea of how legends work:

  // 1. In getLegend in animint.R I export the legend entries as a
  // list of rows that can be used in a data() bind in D3.

  // 2. Here in add_legend I create a <table> for every legend, and
  // then I bind the legend entries to <tr>, <td>, and <svg> elements.
  var add_legend = function(p_name, p_info){
    // case of multiple legends, d3 reads legend structure in as an array
    var tdRight = element.select("td."+p_name+"_legend");
    var legendkeys = d3.keys(p_info.legend);
    for(var i=0; i<legendkeys.length; i++){
      var legend_key = legendkeys[i];
      var l_info = p_info.legend[legend_key];
      // the table that contains one row for each legend element.
      var legend_table = tdRight.append("table")
	.attr("class", "legend")
      ;
      var legend_class = legend_class_name(l_info["class"]);
      var legend_id = p_info.plot_id + "_" + legend_class;
      // the legend table with breaks/value/label .
      // TODO: variable and value should be set in the compiler! What
      // if label is different from the data value?
      for(var entry_i=0; entry_i < l_info.entries.length; entry_i++){
	var entry = l_info.entries[entry_i];
	entry.variable = l_info.selector;
	entry.value = entry.label;
	entry.id = safe_name(legend_id + "_" + entry["label"]);
  	entry.text_size = l_info.text_size;
      }
      var legend_rows = legend_table.selectAll("tr")
        .data(l_info.entries)
        .enter()
        .append("tr")
      // in a good data viz there should not be more than one legend
      // that shows the same thing, so there should be no duplicate
      // id.
        .attr("id", function(d) { return d["id"]; })
	.attr("class", legend_class)
      ;
      if(l_info.selector != null){
	legend_rows
	  .on("click", function(d) { 
            update_selector(d.variable, d.value);
	  })
	  .attr("title", function(d) {
            return "Toggle " + d.value;
	  })
	  .attr("style", "cursor:pointer")
	;
      }
      var first_tr = legend_table.insert("tr", "tr");
      var first_th = first_tr.append("th")
	.attr("align", "left")
	.attr("colspan", 2)
        .text(l_info.title)
        .attr("class", legend_class)
        .style("font-size", l_info.title_size)
      ;
      var legend_svgs = legend_rows.append("td")
        .append("svg")
  	    .attr("id", function(d){return d["id"]+"_svg";})
  	    .attr("height", 14)
  	    .attr("width", 20);
      var pointscale = d3.scale.linear().domain([0,7]).range([1,4]);
      // scale points so they are visible in the legend. (does not
      // affect plot scaling)
      var linescale = d3.scale.linear().domain([0,6]).range([1,4]);
      // scale lines so they are visible in the legend. (does not
      // affect plot scaling)
      if(l_info.geoms.indexOf("polygon")>-1){
        // aesthetics that would draw a rect
        legend_svgs.append("rect")
          .attr("x", 2)
	        .attr("y", 2)
	        .attr("width", 10)
	        .attr("height", 10)
          .style("stroke-width", function(d){return d["polygonsize"]||1;})
          .style("stroke-dasharray", function(d){
            return linetypesize2dasharray(d["polygonlinetype"], d["size"]||2);
          })
          .style("stroke", function(d){return d["polygoncolour"] || "#000000";})
          .style("fill", function(d){return d["polygonfill"] || "#FFFFFF";})
          .style("opacity", function(d){return d["polygonalpha"]||1;});
      }
      if(l_info.geoms.indexOf("text")>-1){
        // aesthetics that would draw a rect
        legend_svgs.append("text")
	        .attr("x", 10)
	        .attr("y", 14)
          	.style("fill", function(d){return d["textcolour"]||1;})
	        .style("text-anchor", "middle")
          	.attr("font-size", function(d){return d["textsize"]||1;})
	        .text("a");
      }
      if(l_info.geoms.indexOf("path")>-1){
        // aesthetics that would draw a line
        legend_svgs.append("line")
          .attr("x1", 1).attr("x2", 19).attr("y1", 7).attr("y2", 7)
          .style("stroke-width", function(d){
            return linescale(d["pathsize"])||2;
          })
          .style("stroke-dasharray", function(d){
            return linetypesize2dasharray(d["pathlinetype"], d["pathsize"] || 2);
          })
          .style("stroke", function(d){return d["pathcolour"] || "#000000";})
          .style("opacity", function(d){return d["pathalpha"]||1;});
      }
      if(l_info.geoms.indexOf("point")>-1){
        // aesthetics that would draw a point
        legend_svgs.append("circle")
          .attr("cx", 10)
          .attr("cy", 7)
          .attr("r", function(d){return pointscale(d["pointsize"])||4;})
          .style("stroke", function(d){return d["pointcolour"] || "#000000";})
          .style("fill", function(d){
            return d["pointfill"] || d["pointcolour"] || "#000000";
          })
          .style("opacity", function(d){return d["pointalpha"]||1;});
      }
      legend_rows.append("td")
	.attr("align", "left") // TODO: right for numbers?
	.attr("class", "legend_entry_label")
	.attr("id", function(d){ return d["id"]+"_label"; })
  	.style("font-size", function(d){ return d["text_size"]})
	.text(function(d){ return d["label"];});
    }
  }

  // Download the main description of the interactive plot.
  d3.json(json_file, function (error, response) {
    if(response.hasOwnProperty("title")){
      // This selects the title of the web page, outside of wherever
      // the animint is defined, usually a <div> -- so it is OK to use
      // global d3.select here.
      d3.select("title").text(response.title);
    }
    // Add plots.
    for (var p_name in response.plots) {
      add_plot(p_name, response.plots[p_name]);
      add_legend(p_name, response.plots[p_name]);
      // Append style sheet to document head.
      css.appendChild(document.createTextNode(styles.join(" ")));
      document.head.appendChild(css);
    }
    // Then add selectors and start downloading the first data subset.
    for (var s_name in response.selectors) {
      add_selector(s_name, response.selectors[s_name]);
    }
    
    // Update the scales/axes of the plots if needed
    // We do this so that the plots zoom in initially after loading
    for (var p_name in response.plots) {
      if(response.plots[p_name].axis_domains !== null){
        for(var xy in response.plots[p_name].axis_domains){
          var selectors = response.plots[p_name].axis_domains[xy].selectors;
          if(!isArray(selectors)){
            selectors = [selectors];
          }
          update_scales(p_name, xy, selectors[0],
            response.selectors[selectors[0]].selected);
        }
      }
    }

    ////////////////////////////////////////////
    // Widgets at bottom of page
    ////////////////////////////////////////////
    element.append("br");
    if(response.hasOwnProperty("source")){
      element.append("a")
	.attr("id","a_source_href")
	.attr("href", response.source)
	.text("source");
    }
    // loading table.
    var show_hide_table = element.append("button")
      .text("Show download status table");
    show_hide_table
      .on("click", function(){
        if(this.textContent == "Show download status table"){
          loading.style("display", "");
          show_hide_table.text("Hide download status table");
        }else{
          loading.style("display", "none");
          show_hide_table.text("Show download status table");
        }
      });
    var loading = element.append("table")
      .style("display", "none");
    Widgets["loading"] = loading;
    var tr = loading.append("tr");
    tr.append("th").text("geom");
    tr.append("th").attr("class", "chunk").text("selected chunk");
    tr.append("th").attr("class", "downloaded").text("downloaded");
    tr.append("th").attr("class", "total").text("total");
    tr.append("th").attr("class", "status").text("status");
    
    // Add geoms and construct nest operators.
    for (var g_name in response.geoms) {
      add_geom(g_name, response.geoms[g_name]);
    }
    
    // Animation control widgets.
    var show_message = "Show animation controls";
    // add a button to view the animation widgets
    var show_hide_animation_controls = element.append("button")
      .text(show_message)
      .attr("id", viz_id + "_show_hide_animation_controls")
      .on("click", function(){
        if(this.textContent == show_message){
          time_table.style("display", "");
          show_hide_animation_controls.text("Hide animation controls");
        }else{
          time_table.style("display", "none");
          show_hide_animation_controls.text(show_message);
        }
      })
    ;
    // table of the animint widgets
    var time_table = element.append("table")
      .style("display", "none");
    var first_tr = time_table.append("tr");
    var first_th = first_tr.append("th");
    // if there's a time variable, add a button to pause the animint
    if(response.time){
      Animation.next = {};
      Animation.ms = response.time.ms;
      Animation.variable = response.time.variable;
      Animation.sequence = response.time.sequence;
      Widgets["play_pause"] = first_th.append("button")
	.text("Play")
        .attr("id", "play_pause")
	.on("click", function(){
          if(this.textContent == "Play"){
            Animation.play();
          }else{
            Animation.pause(false);
          }
        })
      ;
    }
    first_tr.append("th").text("milliseconds");
    if(response.time){
      var second_tr = time_table.append("tr");
      second_tr.append("td").text("updates");
      second_tr.append("td").append("input")
	.attr("id", "updates_ms")
	.attr("type", "text")
	.attr("value", Animation.ms)
	.on("change", function(){
          Animation.pause(false);
          Animation.ms = this.value;
          Animation.play();
        })
      ;
    }
    for(s_name in Selectors){
      var s_info = Selectors[s_name];
      if(!s_info.hasOwnProperty("duration")){
        s_info.duration = 0;
      }
    }
    var selector_array = d3.keys(Selectors);
    var duration_rows = time_table.selectAll("tr.duration")
      .data(selector_array)
      .enter()
      .append("tr");
    duration_rows
      .append("td")
      .text(function(s_name){return s_name;});
    var duration_tds = duration_rows.append("td");
    var duration_inputs = duration_tds
      .append("input")
      .attr("id", function(s_name){
        return viz_id + "_duration_ms_" + s_name;
      })
      .attr("type", "text")
      .on("change", function(s_name){
        Selectors[s_name].duration = this.value;
      })
      .attr("value", function(s_name){
        return Selectors[s_name].duration;
      });
    // selector widgets
    var toggle_message = "Show selection menus";
    var show_or_hide_fun = function(){
      if(this.textContent == toggle_message){
        selector_table.style("display", "");
        show_hide_selector_widgets.text("Hide selection menus");
        d3.select(".urltable").style("display","")
      }else{
        selector_table.style("display", "none");
        show_hide_selector_widgets.text(toggle_message);
        d3.select(".urltable").style("display","none")
      }
    }
    var show_hide_selector_widgets = element.append("button")
      .text(toggle_message)
      .attr("class", "show_hide_selector_widgets")
      .on("click", show_or_hide_fun)
    ;
    // adding a table for selector widgets
    var selector_table = element.append("table")
      .style("display", "none")
      .attr("class", "table_selector_widgets")
    ;
    var selector_first_tr = selector_table.append("tr");
    selector_first_tr
      .append("th")
      .text("Variable")
    ;
    selector_first_tr
      .append("th")
      .text("Selected value(s)")
    ;
      
     // looping through and adding a row for each selector
    for(s_name in Selectors) {
      var s_info = Selectors[s_name];
      // for .variable .value selectors, levels is undefined and we do
      // not want to make a selectize widget.

      // TODO: why does it take so long to initialize the selectize
      // widget when there are many (>1000) values?
      if(isArray(s_info.levels)){
	// If there were no geoms that specified clickSelects for this
	// selector, then there is no way to select it other than the
	// selectize widgets (and possibly legends). So in this case
	// we show the selectize widgets by default.
	var selector_widgets_hidden = 
	  show_hide_selector_widgets.text() == toggle_message;
	var has_no_clickSelects = 
	  !Selectors[s_name].hasOwnProperty("clickSelects")
	var has_no_legend = 
	  !Selectors[s_name].hasOwnProperty("legend")
	if(selector_widgets_hidden && has_no_clickSelects && has_no_legend){
	  var node = show_hide_selector_widgets.node();
	  show_or_hide_fun.apply(node);
	}
	// removing "." from name so it can be used in ids
	var s_name_id = legend_class_name(s_name);

	// adding a row for each selector
	var selector_widget_row = selector_table
          .append("tr")
          .attr("class", function() { return s_name_id + "_selector_widget"; })
	;
	selector_widget_row.append("td").text(s_name);
	// adding the selector
	var selector_widget_select = selector_widget_row
          .append("td")
          .append("select")
          .attr("class", function() { return s_name_id + "_input"; })
          .attr("placeholder", function() { return "Toggle " + s_name; });
	// adding an option for each level of the variable
	selector_widget_select.selectAll("option")
          .data(s_info.levels)
          .enter()
          .append("option")
          .attr("value", function(d) { return d; })
          .text(function(d) { return d; });
	// making sure that the first option is blank
	selector_widget_select
          .insert("option")
          .attr("value", "")
          .text(function() { return "Toggle " + s_name; });
	
	// calling selectize
	var selectize_selector = to_select + ' .' + s_name_id + "_input";
	if(s_info.type == "single") {
          // setting up array of selector and options
          var selector_values = [];
          for(i in s_info.levels) {
            selector_values[i] = {
              id: s_name.concat("___", s_info.levels[i]), 
              text: s_info.levels[i]
            };
          }
          // the id of the first selector
          var selected_id = s_name.concat("___", s_info.selected);

          // if single selection, only allow one item
          var $temp = $(selectize_selector)
            .selectize({
              create: false, 
              valueField: 'id',
              labelField: 'text',
              searchField: ['text'],
              options: selector_values, 
              items: [selected_id],
              maxItems: 1, 
              allowEmptyOption: true,
              onChange: function(value) {
		// extracting the name and the level to update
		var selector_name = value.split("___")[0];
		var selected_level = value.split("___")[1];
		// updating the selector
		update_selector(selector_name, selected_level);
              }
            })
          ;
	} else { // multiple selection:
          // setting up array of selector and options
          var selector_values = [];
          if(typeof s_info.levels == "object") {
            for(i in s_info.levels) {
              selector_values[i] = {
		id: s_name.concat("___", s_info.levels[i]), 
		text: s_info.levels[i]
              };
            }
          } else {
            selector_values[0] = {
              id: s_name.concat("___", s_info.levels), 
              text: s_info.levels
            };
          }
          // setting up an array to contain the initally selected elements
          var initial_selections = [];
          for(i in s_info.selected) {
            initial_selections[i] = s_name.concat("___", s_info.selected[i]);
          }
          
          // construct the selectize
          var $temp = $(selectize_selector)
            .selectize({
              create: false, 
              valueField: 'id',
              labelField: 'text',
              searchField: ['text'],
              options: selector_values, 
              items: initial_selections,
              maxItems: s_info.levels.length, 
              allowEmptyOption: true,
              onChange: function(value) { 
		// if nothing is selected, remove what is currently selected
		if(value == null) {
                  // extracting the selector ids from the options
                  var the_ids = Object.keys($(this)[0].options);
                  // the name of the appropriate selector
                  var selector_name = the_ids[0].split("___")[0];
                  // the previously selected elements
                  var old_selections = Selectors[selector_name].selected;
                  // updating the selector for each of the old selections
                  old_selections.forEach(function(element) {
                    update_selector(selector_name, element);
                  });
		} else { // value is not null:
                  // grabbing the name of the selector from the selected value
                  var selector_name = value[0].split("___")[0];
                  // identifying the levels that should be selected
                  var specified_levels = [];
                  for(i in value) {
                    specified_levels[i] = value[i].split("___")[1];
                  }
                  // the previously selected entries
                  old_selections = Selectors[selector_name].selected;
                  
                  // the levels that need to have selections turned on
                  specified_levels
                    .filter(function(n) {
                      return old_selections.indexOf(n) == -1;
                    })
                    .forEach(function(element) {
                      update_selector(selector_name, element);
                    })
                  ;
                  // the levels that need to be turned off
                  // - same approach
                  old_selections
                    .filter(function(n) {
                      return specified_levels.indexOf(n) == -1;
                    })
                    .forEach(function(element) {
                      update_selector(selector_name, element);
                    })
                  ;
		}//value==null
              }//onChange
            })//selectize
          ;
	}//single or multiple selection.
	selectized_array[s_name] = $temp[0].selectize;
      }//levels, is.variable.value
    } // close for loop through selector widgets
    // If this is an animation, then start downloading all the rest of
    // the data, and start the animation.
    if (response.time) {
      var i, prev, cur;
      for (var i = 0; i < Animation.sequence.length; i++) {
        if (i == 0) {
          prev = Animation.sequence[Animation.sequence.length-1];
        } else {
          prev = Animation.sequence[i - 1];
        }
        cur = Animation.sequence[i];
        Animation.next[prev] = cur;
      }
      Animation.timer = null;
      Animation.play = function(){
	if(Animation.timer == null){ // only play if not already playing.
    	  // as shown on http://bl.ocks.org/mbostock/3808234
    	  Animation.timer = setInterval(update_next_animation, Animation.ms);
    	  Widgets["play_pause"].text("Pause");
	}
      };
      Animation.play_after_visible = false;
      Animation.pause = function(play_after_visible){
        Animation.play_after_visible = play_after_visible;
        clearInterval(Animation.timer);
	Animation.timer = null;
        Widgets["play_pause"].text("Play");
      };
      var s_info = Selectors[Animation.variable];
      Animation.done_geoms = {};
      s_info.update.forEach(function(g_name){
        var g_info = Geoms[g_name];
        if(g_info.chunk_order.length == 1 &&
	   g_info.chunk_order[0] == Animation.variable){
	  g_info.seq_i = Animation.sequence.indexOf(s_info.selected);
	  g_info.seq_count = 0;
	  Animation.done_geoms[g_name] = 0;
	  download_next(g_name);
	}
      });
      Animation.play();
      all_geom_names = d3.keys(response.geoms);

      // This code starts/stops the animation timer when the page is
      // hidden, inspired by
      // http://stackoverflow.com/questions/1060008
      function onchange (evt) {
        if(document.visibilityState == "visible"){
          if(Animation.play_after_visible){
            Animation.play();
          }
        }else{
          if(Widgets["play_pause"].text() == "Pause"){
            Animation.pause(true);
          }
        }
      };
      document.addEventListener("visibilitychange", onchange);
    }
    // update_selector_url()
    var check_func=function(){
      var status_array = $('.status').map(function(){
        return $.trim($(this).text());
      }).get();
      status_array=status_array.slice(1)
      return status_array.every(function(elem){ return elem === "displayed"});           
    }
    if(window.location.hash) {
      var fragment=window.location.hash;
      fragment=fragment.slice(1);
      fragment=decodeURI(fragment)
      var frag_array=fragment.split(/(.*?})/);
      frag_array=frag_array.filter(function(x){ return x!=""})
      frag_array.forEach(function(selector_string){ 
        var selector_hash=selector_string.split("=");
        var selector_nam=selector_hash[0];
        var selector_values=selector_hash[1];
        var re = /\{(.*?)\}/;
        selector_values = re.exec(selector_values)[1];
        var array_values = selector_values.split(',');
	if(Selectors.hasOwnProperty(selector_nam)){
          var s_info = Selectors[selector_nam]
          if(s_info.type=="single"){//TODO fix
            array_values.forEach(function(element) {
              wait_until_then(100, check_func, update_selector,selector_nam,element)
              if(response.time)Animation.pause(true)
            });   
          }else{
            var old_selections = Selectors[selector_nam].selected;
            // the levels that need to have selections turned on
            array_values
              .filter(function(n) {
		return old_selections.indexOf(n) == -1;
              })
              .forEach(function(element) {
		wait_until_then(100, check_func, update_selector,selector_nam,element)
		if(response.time){
                  Animation.pause(true)
		}
              });
            old_selections
              .filter(function(n) {
		return array_values.indexOf(n) == -1;
              })
              .forEach(function(element) {
		wait_until_then(100, check_func, update_selector,selector_nam,element)
		if(response.time){
                  Animation.pause(true)
		}
              });     
          }//if(single) else multiple selection
	}//if(Selectors.hasOwnProperty(selector_nam))
      })//frag_array.forEach
    }//if(window.location.hash)
  });
};


</script>
<script>
/*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l="1.11.3",m=function(a,b){return new m.fn.init(a,b)},n=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,o=/^-ms-/,p=/-([\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:"jQuery"+(l+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===m.type(a)},isArray:Array.isArray||function(a){return"array"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,"ms-").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(n,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function r(a){var b="length"in a&&a.length,c=m.type(a);return"function"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);m.find=s,m.expr=s.selectors,m.expr[":"]=m.expr.pseudos,m.unique=s.uniqueSort,m.text=s.getText,m.isXMLDoc=s.isXML,m.contains=s.contains;var t=m.expr.match.needsContext,u=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,v=/^.[^:#\[\.,]*$/;function w(a,b,c){if(m.isFunction(b))return m.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return m.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(v.test(b))return m.filter(b,a,c);b=m.filter(b,a)}return m.grep(a,function(a){return m.inArray(a,b)>=0!==c})}m.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?m.find.matchesSelector(d,a)?[d]:[]:m.find.matches(a,m.grep(b,function(a){return 1===a.nodeType}))},m.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(m(a).filter(function(){for(b=0;e>b;b++)if(m.contains(d[b],this))return!0}));for(b=0;e>b;b++)m.find(a,d[b],c);return c=this.pushStack(e>1?m.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(w(this,a||[],!1))},not:function(a){return this.pushStack(w(this,a||[],!0))},is:function(a){return!!w(this,"string"==typeof a&&t.test(a)?m(a):a||[],!1).length}});var x,y=a.document,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=m.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||x).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof m?b[0]:b,m.merge(this,m.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:y,!0)),u.test(c[1])&&m.isPlainObject(b))for(c in b)m.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=y.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return x.find(a);this.length=1,this[0]=d}return this.context=y,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):m.isFunction(a)?"undefined"!=typeof x.ready?x.ready(a):a(m):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),m.makeArray(a,this))};A.prototype=m.fn,x=m(y);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};m.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!m(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),m.fn.extend({has:function(a){var b,c=m(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(m.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=t.test(a)||"string"!=typeof a?m(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&m.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?m.unique(f):f)},index:function(a){return a?"string"==typeof a?m.inArray(this[0],m(a)):m.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(m.unique(m.merge(this.get(),m(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}m.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return m.dir(a,"parentNode")},parentsUntil:function(a,b,c){return m.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return m.dir(a,"nextSibling")},prevAll:function(a){return m.dir(a,"previousSibling")},nextUntil:function(a,b,c){return m.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return m.dir(a,"previousSibling",c)},siblings:function(a){return m.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return m.sibling(a.firstChild)},contents:function(a){return m.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:m.merge([],a.childNodes)}},function(a,b){m.fn[a]=function(c,d){var e=m.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=m.filter(d,e)),this.length>1&&(C[a]||(e=m.unique(e)),B.test(a)&&(e=e.reverse())),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return m.each(a.match(E)||[],function(a,c){b[c]=!0}),b}m.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):m.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){m.each(b,function(b,c){var d=m.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&m.each(arguments,function(a,c){var d;while((d=m.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?m.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},m.extend({Deferred:function(a){var b=[["resolve","done",m.Callbacks("once memory"),"resolved"],["reject","fail",m.Callbacks("once memory"),"rejected"],["notify","progress",m.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return m.Deferred(function(c){m.each(b,function(b,f){var g=m.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&m.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?m.extend(a,d):d}},e={};return d.pipe=d.then,m.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&m.isFunction(a.promise)?e:0,g=1===f?a:m.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&m.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;m.fn.ready=function(a){return m.ready.promise().done(a),this},m.extend({isReady:!1,readyWait:1,holdReady:function(a){a?m.readyWait++:m.ready(!0)},ready:function(a){if(a===!0?!--m.readyWait:!m.isReady){if(!y.body)return setTimeout(m.ready);m.isReady=!0,a!==!0&&--m.readyWait>0||(H.resolveWith(y,[m]),m.fn.triggerHandler&&(m(y).triggerHandler("ready"),m(y).off("ready")))}}});function I(){y.addEventListener?(y.removeEventListener("DOMContentLoaded",J,!1),a.removeEventListener("load",J,!1)):(y.detachEvent("onreadystatechange",J),a.detachEvent("onload",J))}function J(){(y.addEventListener||"load"===event.type||"complete"===y.readyState)&&(I(),m.ready())}m.ready.promise=function(b){if(!H)if(H=m.Deferred(),"complete"===y.readyState)setTimeout(m.ready);else if(y.addEventListener)y.addEventListener("DOMContentLoaded",J,!1),a.addEventListener("load",J,!1);else{y.attachEvent("onreadystatechange",J),a.attachEvent("onload",J);var c=!1;try{c=null==a.frameElement&&y.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!m.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}I(),m.ready()}}()}return H.promise(b)};var K="undefined",L;for(L in m(k))break;k.ownLast="0"!==L,k.inlineBlockNeedsLayout=!1,m(function(){var a,b,c,d;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",k.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(d))}),function(){var a=y.createElement("div");if(null==k.deleteExpando){k.deleteExpando=!0;try{delete a.test}catch(b){k.deleteExpando=!1}}a=null}(),m.acceptData=function(a){var b=m.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var M=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,N=/([A-Z])/g;function O(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(N,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:M.test(c)?m.parseJSON(c):c}catch(e){}m.data(a,b,c)}else c=void 0}return c}function P(a){var b;for(b in a)if(("data"!==b||!m.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;

return!0}function Q(a,b,d,e){if(m.acceptData(a)){var f,g,h=m.expando,i=a.nodeType,j=i?m.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||m.guid++:h),j[k]||(j[k]=i?{}:{toJSON:m.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=m.extend(j[k],b):j[k].data=m.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[m.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[m.camelCase(b)])):f=g,f}}function R(a,b,c){if(m.acceptData(a)){var d,e,f=a.nodeType,g=f?m.cache:a,h=f?a[m.expando]:m.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){m.isArray(b)?b=b.concat(m.map(b,m.camelCase)):b in d?b=[b]:(b=m.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!P(d):!m.isEmptyObject(d))return}(c||(delete g[h].data,P(g[h])))&&(f?m.cleanData([a],!0):k.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}m.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?m.cache[a[m.expando]]:a[m.expando],!!a&&!P(a)},data:function(a,b,c){return Q(a,b,c)},removeData:function(a,b){return R(a,b)},_data:function(a,b,c){return Q(a,b,c,!0)},_removeData:function(a,b){return R(a,b,!0)}}),m.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=m.data(f),1===f.nodeType&&!m._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=m.camelCase(d.slice(5)),O(f,d,e[d])));m._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){m.data(this,a)}):arguments.length>1?this.each(function(){m.data(this,a,b)}):f?O(f,a,m.data(f,a)):void 0},removeData:function(a){return this.each(function(){m.removeData(this,a)})}}),m.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=m._data(a,b),c&&(!d||m.isArray(c)?d=m._data(a,b,m.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=m.queue(a,b),d=c.length,e=c.shift(),f=m._queueHooks(a,b),g=function(){m.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return m._data(a,c)||m._data(a,c,{empty:m.Callbacks("once memory").add(function(){m._removeData(a,b+"queue"),m._removeData(a,c)})})}}),m.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?m.queue(this[0],a):void 0===b?this:this.each(function(){var c=m.queue(this,a,b);m._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&m.dequeue(this,a)})},dequeue:function(a){return this.each(function(){m.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=m.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=m._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=["Top","Right","Bottom","Left"],U=function(a,b){return a=b||a,"none"===m.css(a,"display")||!m.contains(a.ownerDocument,a)},V=m.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===m.type(c)){e=!0;for(h in c)m.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,m.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(m(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},W=/^(?:checkbox|radio)$/i;!function(){var a=y.createElement("input"),b=y.createElement("div"),c=y.createDocumentFragment();if(b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",k.leadingWhitespace=3===b.firstChild.nodeType,k.tbody=!b.getElementsByTagName("tbody").length,k.htmlSerialize=!!b.getElementsByTagName("link").length,k.html5Clone="<:nav></:nav>"!==y.createElement("nav").cloneNode(!0).outerHTML,a.type="checkbox",a.checked=!0,c.appendChild(a),k.appendChecked=a.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,c.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,k.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){k.noCloneEvent=!1}),b.cloneNode(!0).click()),null==k.deleteExpando){k.deleteExpando=!0;try{delete b.test}catch(d){k.deleteExpando=!1}}}(),function(){var b,c,d=y.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(k[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),k[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var X=/^(?:input|select|textarea)$/i,Y=/^key/,Z=/^(?:mouse|pointer|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=/^([^.]*)(?:\.(.+)|)$/;function aa(){return!0}function ba(){return!1}function ca(){try{return y.activeElement}catch(a){}}m.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=m.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof m===K||a&&m.event.triggered===a.type?void 0:m.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(E)||[""],h=b.length;while(h--)f=_.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=m.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=m.event.special[o]||{},l=m.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&m.expr.match.needsContext.test(e),namespace:p.join(".")},i),(n=g[o])||(n=g[o]=[],n.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?n.splice(n.delegateCount++,0,l):n.push(l),m.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m.hasData(a)&&m._data(a);if(r&&(k=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=_.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=m.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,n=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=n.length;while(f--)g=n[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(n.splice(f,1),g.selector&&n.delegateCount--,l.remove&&l.remove.call(a,g));i&&!n.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||m.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)m.event.remove(a,o+b[j],c,d,!0);m.isEmptyObject(k)&&(delete r.handle,m._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,o=[d||y],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||y,3!==d.nodeType&&8!==d.nodeType&&!$.test(p+m.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[m.expando]?b:new m.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:m.makeArray(c,[b]),k=m.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!m.isWindow(d)){for(i=k.delegateType||p,$.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||y)&&o.push(l.defaultView||l.parentWindow||a)}n=0;while((h=o[n++])&&!b.isPropagationStopped())b.type=n>1?i:k.bindType||p,f=(m._data(h,"events")||{})[b.type]&&m._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&m.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&m.acceptData(d)&&g&&d[p]&&!m.isWindow(d)){l=d[g],l&&(d[g]=null),m.event.triggered=p;try{d[p]()}catch(r){}m.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=m.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(m._data(this,"events")||{})[a.type]||[],k=m.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=m.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((m.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?m(c,this).index(i)>=0:m.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[m.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=Z.test(e)?this.mouseHooks:Y.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new m.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||y),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||y,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ca()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ca()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return m.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return m.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=m.extend(new m.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?m.event.trigger(e,null,b):m.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},m.removeEvent=y.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===K&&(a[d]=null),a.detachEvent(d,c))},m.Event=function(a,b){return this instanceof m.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?aa:ba):this.type=a,b&&m.extend(this,b),this.timeStamp=a&&a.timeStamp||m.now(),void(this[m.expando]=!0)):new m.Event(a,b)},m.Event.prototype={isDefaultPrevented:ba,isPropagationStopped:ba,isImmediatePropagationStopped:ba,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=aa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=aa,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=aa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},m.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){m.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!m.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.submitBubbles||(m.event.special.submit={setup:function(){return m.nodeName(this,"form")?!1:void m.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=m.nodeName(b,"input")||m.nodeName(b,"button")?b.form:void 0;c&&!m._data(c,"submitBubbles")&&(m.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),m._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&m.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return m.nodeName(this,"form")?!1:void m.event.remove(this,"._submit")}}),k.changeBubbles||(m.event.special.change={setup:function(){return X.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(m.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),m.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),m.event.simulate("change",this,a,!0)})),!1):void m.event.add(this,"beforeactivate._change",function(a){var b=a.target;X.test(b.nodeName)&&!m._data(b,"changeBubbles")&&(m.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||m.event.simulate("change",this.parentNode,a,!0)}),m._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return m.event.remove(this,"._change"),!X.test(this.nodeName)}}),k.focusinBubbles||m.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){m.event.simulate(b,a.target,m.event.fix(a),!0)};m.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=m._data(d,b);e||d.addEventListener(a,c,!0),m._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=m._data(d,b)-1;e?m._data(d,b,e):(d.removeEventListener(a,c,!0),m._removeData(d,b))}}}),m.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=ba;else if(!d)return this;return 1===e&&(g=d,d=function(a){return m().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=m.guid++)),this.each(function(){m.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,m(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=ba),this.each(function(){m.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){m.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?m.event.trigger(a,b,c,!0):void 0}});function da(a){var b=ea.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var ea="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",fa=/ jQuery\d+="(?:null|\d+)"/g,ga=new RegExp("<(?:"+ea+")[\\s/>]","i"),ha=/^\s+/,ia=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ja=/<([\w:]+)/,ka=/<tbody/i,la=/<|&#?\w+;/,ma=/<(?:script|style|link)/i,na=/checked\s*(?:[^=]|=\s*.checked.)/i,oa=/^$|\/(?:java|ecma)script/i,pa=/^true\/(.*)/,qa=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ra={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:k.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},sa=da(y),ta=sa.appendChild(y.createElement("div"));ra.optgroup=ra.option,ra.tbody=ra.tfoot=ra.colgroup=ra.caption=ra.thead,ra.th=ra.td;function ua(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==K?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==K?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||m.nodeName(d,b)?f.push(d):m.merge(f,ua(d,b));return void 0===b||b&&m.nodeName(a,b)?m.merge([a],f):f}function va(a){W.test(a.type)&&(a.defaultChecked=a.checked)}function wa(a,b){return m.nodeName(a,"table")&&m.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function xa(a){return a.type=(null!==m.find.attr(a,"type"))+"/"+a.type,a}function ya(a){var b=pa.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function za(a,b){for(var c,d=0;null!=(c=a[d]);d++)m._data(c,"globalEval",!b||m._data(b[d],"globalEval"))}function Aa(a,b){if(1===b.nodeType&&m.hasData(a)){var c,d,e,f=m._data(a),g=m._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)m.event.add(b,c,h[c][d])}g.data&&(g.data=m.extend({},g.data))}}function Ba(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!k.noCloneEvent&&b[m.expando]){e=m._data(b);for(d in e.events)m.removeEvent(b,d,e.handle);b.removeAttribute(m.expando)}"script"===c&&b.text!==a.text?(xa(b).text=a.text,ya(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),k.html5Clone&&a.innerHTML&&!m.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&W.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}m.extend({clone:function(a,b,c){var d,e,f,g,h,i=m.contains(a.ownerDocument,a);if(k.html5Clone||m.isXMLDoc(a)||!ga.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(ta.innerHTML=a.outerHTML,ta.removeChild(f=ta.firstChild)),!(k.noCloneEvent&&k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||m.isXMLDoc(a)))for(d=ua(f),h=ua(a),g=0;null!=(e=h[g]);++g)d[g]&&Ba(e,d[g]);if(b)if(c)for(h=h||ua(a),d=d||ua(f),g=0;null!=(e=h[g]);g++)Aa(e,d[g]);else Aa(a,f);return d=ua(f,"script"),d.length>0&&za(d,!i&&ua(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,l,n=a.length,o=da(b),p=[],q=0;n>q;q++)if(f=a[q],f||0===f)if("object"===m.type(f))m.merge(p,f.nodeType?[f]:f);else if(la.test(f)){h=h||o.appendChild(b.createElement("div")),i=(ja.exec(f)||["",""])[1].toLowerCase(),l=ra[i]||ra._default,h.innerHTML=l[1]+f.replace(ia,"<$1></$2>")+l[2],e=l[0];while(e--)h=h.lastChild;if(!k.leadingWhitespace&&ha.test(f)&&p.push(b.createTextNode(ha.exec(f)[0])),!k.tbody){f="table"!==i||ka.test(f)?"<table>"!==l[1]||ka.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)m.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}m.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),k.appendChecked||m.grep(ua(p,"input"),va),q=0;while(f=p[q++])if((!d||-1===m.inArray(f,d))&&(g=m.contains(f.ownerDocument,f),h=ua(o.appendChild(f),"script"),g&&za(h),c)){e=0;while(f=h[e++])oa.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=m.expando,j=m.cache,l=k.deleteExpando,n=m.event.special;null!=(d=a[h]);h++)if((b||m.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)n[e]?m.event.remove(d,e):m.removeEvent(d,e,g.handle);j[f]&&(delete j[f],l?delete d[i]:typeof d.removeAttribute!==K?d.removeAttribute(i):d[i]=null,c.push(f))}}}),m.fn.extend({text:function(a){return V(this,function(a){return void 0===a?m.text(this):this.empty().append((this[0]&&this[0].ownerDocument||y).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?m.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||m.cleanData(ua(c)),c.parentNode&&(b&&m.contains(c.ownerDocument,c)&&za(ua(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&m.cleanData(ua(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&m.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return m.clone(this,a,b)})},html:function(a){return V(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(fa,""):void 0;if(!("string"!=typeof a||ma.test(a)||!k.htmlSerialize&&ga.test(a)||!k.leadingWhitespace&&ha.test(a)||ra[(ja.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(ia,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(m.cleanData(ua(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,m.cleanData(ua(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,n=this,o=l-1,p=a[0],q=m.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&na.test(p))return this.each(function(c){var d=n.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(i=m.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=m.map(ua(i,"script"),xa),f=g.length;l>j;j++)d=i,j!==o&&(d=m.clone(d,!0,!0),f&&m.merge(g,ua(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,m.map(g,ya),j=0;f>j;j++)d=g[j],oa.test(d.type||"")&&!m._data(d,"globalEval")&&m.contains(h,d)&&(d.src?m._evalUrl&&m._evalUrl(d.src):m.globalEval((d.text||d.textContent||d.innerHTML||"").replace(qa,"")));i=c=null}return this}}),m.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){m.fn[a]=function(a){for(var c,d=0,e=[],g=m(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),m(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Ca,Da={};function Ea(b,c){var d,e=m(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:m.css(e[0],"display");return e.detach(),f}function Fa(a){var b=y,c=Da[a];return c||(c=Ea(a,b),"none"!==c&&c||(Ca=(Ca||m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ca[0].contentWindow||Ca[0].contentDocument).document,b.write(),b.close(),c=Ea(a,b),Ca.detach()),Da[a]=c),c}!function(){var a;k.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,d;return c=y.getElementsByTagName("body")[0],c&&c.style?(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(y.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(d),a):void 0}}();var Ga=/^margin/,Ha=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ia,Ja,Ka=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ia=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||m.contains(a.ownerDocument,a)||(g=m.style(a,b)),Ha.test(g)&&Ga.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):y.documentElement.currentStyle&&(Ia=function(a){return a.currentStyle},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ha.test(g)&&!Ka.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function La(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h;if(b=y.createElement("div"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=d&&d.style){c.cssText="float:left;opacity:.5",k.opacity="0.5"===c.opacity,k.cssFloat=!!c.cssFloat,b.style.backgroundClip="content-box",b.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===b.style.backgroundClip,k.boxSizing=""===c.boxSizing||""===c.MozBoxSizing||""===c.WebkitBoxSizing,m.extend(k,{reliableHiddenOffsets:function(){return null==g&&i(),g},boxSizingReliable:function(){return null==f&&i(),f},pixelPosition:function(){return null==e&&i(),e},reliableMarginRight:function(){return null==h&&i(),h}});function i(){var b,c,d,i;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),b.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",e=f=!1,h=!0,a.getComputedStyle&&(e="1%"!==(a.getComputedStyle(b,null)||{}).top,f="4px"===(a.getComputedStyle(b,null)||{width:"4px"}).width,i=b.appendChild(y.createElement("div")),i.style.cssText=b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",i.style.marginRight=i.style.width="0",b.style.width="1px",h=!parseFloat((a.getComputedStyle(i,null)||{}).marginRight),b.removeChild(i)),b.innerHTML="<table><tr><td></td><td>t</td></tr></table>",i=b.getElementsByTagName("td"),i[0].style.cssText="margin:0;border:0;padding:0;display:none",g=0===i[0].offsetHeight,g&&(i[0].style.display="",i[1].style.display="none",g=0===i[0].offsetHeight),c.removeChild(d))}}}(),m.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Ma=/alpha\([^)]*\)/i,Na=/opacity\s*=\s*([^)]*)/,Oa=/^(none|table(?!-c[ea]).+)/,Pa=new RegExp("^("+S+")(.*)$","i"),Qa=new RegExp("^([+-])=("+S+")","i"),Ra={position:"absolute",visibility:"hidden",display:"block"},Sa={letterSpacing:"0",fontWeight:"400"},Ta=["Webkit","O","Moz","ms"];function Ua(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ta.length;while(e--)if(b=Ta[e]+c,b in a)return b;return d}function Va(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=m._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&U(d)&&(f[g]=m._data(d,"olddisplay",Fa(d.nodeName)))):(e=U(d),(c&&"none"!==c||!e)&&m._data(d,"olddisplay",e?c:m.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Wa(a,b,c){var d=Pa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Xa(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=m.css(a,c+T[f],!0,e)),d?("content"===c&&(g-=m.css(a,"padding"+T[f],!0,e)),"margin"!==c&&(g-=m.css(a,"border"+T[f]+"Width",!0,e))):(g+=m.css(a,"padding"+T[f],!0,e),"padding"!==c&&(g+=m.css(a,"border"+T[f]+"Width",!0,e)));return g}function Ya(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ia(a),g=k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Ja(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ha.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Xa(a,b,c||(g?"border":"content"),d,f)+"px"}m.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Ja(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":k.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=m.camelCase(b),i=a.style;if(b=m.cssProps[h]||(m.cssProps[h]=Ua(i,h)),g=m.cssHooks[b]||m.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Qa.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(m.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||m.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=m.camelCase(b);return b=m.cssProps[h]||(m.cssProps[h]=Ua(a.style,h)),g=m.cssHooks[b]||m.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Ja(a,b,d)),"normal"===f&&b in Sa&&(f=Sa[b]),""===c||c?(e=parseFloat(f),c===!0||m.isNumeric(e)?e||0:f):f}}),m.each(["height","width"],function(a,b){m.cssHooks[b]={get:function(a,c,d){return c?Oa.test(m.css(a,"display"))&&0===a.offsetWidth?m.swap(a,Ra,function(){return Ya(a,b,d)}):Ya(a,b,d):void 0},set:function(a,c,d){var e=d&&Ia(a);return Wa(a,c,d?Xa(a,b,d,k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,e),e):0)}}}),k.opacity||(m.cssHooks.opacity={get:function(a,b){return Na.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=m.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===m.trim(f.replace(Ma,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Ma.test(f)?f.replace(Ma,e):f+" "+e)}}),m.cssHooks.marginRight=La(k.reliableMarginRight,function(a,b){return b?m.swap(a,{display:"inline-block"},Ja,[a,"marginRight"]):void 0}),m.each({margin:"",padding:"",border:"Width"},function(a,b){m.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+T[d]+b]=f[d]||f[d-2]||f[0];return e}},Ga.test(a)||(m.cssHooks[a+b].set=Wa)}),m.fn.extend({css:function(a,b){return V(this,function(a,b,c){var d,e,f={},g=0;if(m.isArray(b)){for(d=Ia(a),e=b.length;e>g;g++)f[b[g]]=m.css(a,b[g],!1,d);return f}return void 0!==c?m.style(a,b,c):m.css(a,b)},a,b,arguments.length>1)},show:function(){return Va(this,!0)},hide:function(){return Va(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){U(this)?m(this).show():m(this).hide()})}});function Za(a,b,c,d,e){
return new Za.prototype.init(a,b,c,d,e)}m.Tween=Za,Za.prototype={constructor:Za,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(m.cssNumber[c]?"":"px")},cur:function(){var a=Za.propHooks[this.prop];return a&&a.get?a.get(this):Za.propHooks._default.get(this)},run:function(a){var b,c=Za.propHooks[this.prop];return this.options.duration?this.pos=b=m.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Za.propHooks._default.set(this),this}},Za.prototype.init.prototype=Za.prototype,Za.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=m.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){m.fx.step[a.prop]?m.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[m.cssProps[a.prop]]||m.cssHooks[a.prop])?m.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Za.propHooks.scrollTop=Za.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},m.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},m.fx=Za.prototype.init,m.fx.step={};var $a,_a,ab=/^(?:toggle|show|hide)$/,bb=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),cb=/queueHooks$/,db=[ib],eb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=bb.exec(b),f=e&&e[3]||(m.cssNumber[a]?"":"px"),g=(m.cssNumber[a]||"px"!==f&&+d)&&bb.exec(m.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,m.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function fb(){return setTimeout(function(){$a=void 0}),$a=m.now()}function gb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=T[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function hb(a,b,c){for(var d,e=(eb[b]||[]).concat(eb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,l,n=this,o={},p=a.style,q=a.nodeType&&U(a),r=m._data(a,"fxshow");c.queue||(h=m._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,n.always(function(){n.always(function(){h.unqueued--,m.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=m.css(a,"display"),l="none"===j?m._data(a,"olddisplay")||Fa(a.nodeName):j,"inline"===l&&"none"===m.css(a,"float")&&(k.inlineBlockNeedsLayout&&"inline"!==Fa(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",k.shrinkWrapBlocks()||n.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],ab.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||m.style(a,d)}else j=void 0;if(m.isEmptyObject(o))"inline"===("none"===j?Fa(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=m._data(a,"fxshow",{}),f&&(r.hidden=!q),q?m(a).show():n.done(function(){m(a).hide()}),n.done(function(){var b;m._removeData(a,"fxshow");for(b in o)m.style(a,b,o[b])});for(d in o)g=hb(q?r[d]:0,d,n),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=m.camelCase(c),e=b[d],f=a[c],m.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=m.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=db.length,h=m.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=$a||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:m.extend({},b),opts:m.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:$a||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=m.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);g>f;f++)if(d=db[f].call(j,a,k,j.opts))return d;return m.map(k,hb,j),m.isFunction(j.opts.start)&&j.opts.start.call(a,j),m.fx.timer(m.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}m.Animation=m.extend(kb,{tweener:function(a,b){m.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],eb[c]=eb[c]||[],eb[c].unshift(b)},prefilter:function(a,b){b?db.unshift(a):db.push(a)}}),m.speed=function(a,b,c){var d=a&&"object"==typeof a?m.extend({},a):{complete:c||!c&&b||m.isFunction(a)&&a,duration:a,easing:c&&b||b&&!m.isFunction(b)&&b};return d.duration=m.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in m.fx.speeds?m.fx.speeds[d.duration]:m.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){m.isFunction(d.old)&&d.old.call(this),d.queue&&m.dequeue(this,d.queue)},d},m.fn.extend({fadeTo:function(a,b,c,d){return this.filter(U).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=m.isEmptyObject(a),f=m.speed(b,c,d),g=function(){var b=kb(this,m.extend({},a),f);(e||m._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=m.timers,g=m._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&cb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&m.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=m._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=m.timers,g=d?d.length:0;for(c.finish=!0,m.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),m.each(["toggle","show","hide"],function(a,b){var c=m.fn[b];m.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),m.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){m.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),m.timers=[],m.fx.tick=function(){var a,b=m.timers,c=0;for($a=m.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||m.fx.stop(),$a=void 0},m.fx.timer=function(a){m.timers.push(a),a()?m.fx.start():m.timers.pop()},m.fx.interval=13,m.fx.start=function(){_a||(_a=setInterval(m.fx.tick,m.fx.interval))},m.fx.stop=function(){clearInterval(_a),_a=null},m.fx.speeds={slow:600,fast:200,_default:400},m.fn.delay=function(a,b){return a=m.fx?m.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e;b=y.createElement("div"),b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=y.createElement("select"),e=c.appendChild(y.createElement("option")),a=b.getElementsByTagName("input")[0],d.style.cssText="top:1px",k.getSetAttribute="t"!==b.className,k.style=/top/.test(d.getAttribute("style")),k.hrefNormalized="/a"===d.getAttribute("href"),k.checkOn=!!a.value,k.optSelected=e.selected,k.enctype=!!y.createElement("form").enctype,c.disabled=!0,k.optDisabled=!e.disabled,a=y.createElement("input"),a.setAttribute("value",""),k.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),k.radioValue="t"===a.value}();var lb=/\r/g;m.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=m.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,m(this).val()):a,null==e?e="":"number"==typeof e?e+="":m.isArray(e)&&(e=m.map(e,function(a){return null==a?"":a+""})),b=m.valHooks[this.type]||m.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=m.valHooks[e.type]||m.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(lb,""):null==c?"":c)}}}),m.extend({valHooks:{option:{get:function(a){var b=m.find.attr(a,"value");return null!=b?b:m.trim(m.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&m.nodeName(c.parentNode,"optgroup"))){if(b=m(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=m.makeArray(b),g=e.length;while(g--)if(d=e[g],m.inArray(m.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),m.each(["radio","checkbox"],function(){m.valHooks[this]={set:function(a,b){return m.isArray(b)?a.checked=m.inArray(m(a).val(),b)>=0:void 0}},k.checkOn||(m.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var mb,nb,ob=m.expr.attrHandle,pb=/^(?:checked|selected)$/i,qb=k.getSetAttribute,rb=k.input;m.fn.extend({attr:function(a,b){return V(this,m.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){m.removeAttr(this,a)})}}),m.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===K?m.prop(a,b,c):(1===f&&m.isXMLDoc(a)||(b=b.toLowerCase(),d=m.attrHooks[b]||(m.expr.match.bool.test(b)?nb:mb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=m.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void m.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=m.propFix[c]||c,m.expr.match.bool.test(c)?rb&&qb||!pb.test(c)?a[d]=!1:a[m.camelCase("default-"+c)]=a[d]=!1:m.attr(a,c,""),a.removeAttribute(qb?c:d)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&m.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),nb={set:function(a,b,c){return b===!1?m.removeAttr(a,c):rb&&qb||!pb.test(c)?a.setAttribute(!qb&&m.propFix[c]||c,c):a[m.camelCase("default-"+c)]=a[c]=!0,c}},m.each(m.expr.match.bool.source.match(/\w+/g),function(a,b){var c=ob[b]||m.find.attr;ob[b]=rb&&qb||!pb.test(b)?function(a,b,d){var e,f;return d||(f=ob[b],ob[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,ob[b]=f),e}:function(a,b,c){return c?void 0:a[m.camelCase("default-"+b)]?b.toLowerCase():null}}),rb&&qb||(m.attrHooks.value={set:function(a,b,c){return m.nodeName(a,"input")?void(a.defaultValue=b):mb&&mb.set(a,b,c)}}),qb||(mb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},ob.id=ob.name=ob.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},m.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:mb.set},m.attrHooks.contenteditable={set:function(a,b,c){mb.set(a,""===b?!1:b,c)}},m.each(["width","height"],function(a,b){m.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),k.style||(m.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var sb=/^(?:input|select|textarea|button|object)$/i,tb=/^(?:a|area)$/i;m.fn.extend({prop:function(a,b){return V(this,m.prop,a,b,arguments.length>1)},removeProp:function(a){return a=m.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),m.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!m.isXMLDoc(a),f&&(b=m.propFix[b]||b,e=m.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=m.find.attr(a,"tabindex");return b?parseInt(b,10):sb.test(a.nodeName)||tb.test(a.nodeName)&&a.href?0:-1}}}}),k.hrefNormalized||m.each(["href","src"],function(a,b){m.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),k.optSelected||(m.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),m.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){m.propFix[this.toLowerCase()]=this}),k.enctype||(m.propFix.enctype="encoding");var ub=/[\t\r\n\f]/g;m.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=m.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?m.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(m.isFunction(a)?function(c){m(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=m(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===K||"boolean"===c)&&(this.className&&m._data(this,"__className__",this.className),this.className=this.className||a===!1?"":m._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ub," ").indexOf(b)>=0)return!0;return!1}}),m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){m.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),m.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var vb=m.now(),wb=/\?/,xb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;m.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=m.trim(b+"");return e&&!m.trim(e.replace(xb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():m.error("Invalid JSON: "+b)},m.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||m.error("Invalid XML: "+b),c};var yb,zb,Ab=/#.*$/,Bb=/([?&])_=[^&]*/,Cb=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Db=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Eb=/^(?:GET|HEAD)$/,Fb=/^\/\//,Gb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Hb={},Ib={},Jb="*/".concat("*");try{zb=location.href}catch(Kb){zb=y.createElement("a"),zb.href="",zb=zb.href}yb=Gb.exec(zb.toLowerCase())||[];function Lb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(m.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Mb(a,b,c,d){var e={},f=a===Ib;function g(h){var i;return e[h]=!0,m.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Nb(a,b){var c,d,e=m.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&m.extend(!0,a,c),a}function Ob(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Pb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}m.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:zb,type:"GET",isLocal:Db.test(yb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Jb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":m.parseJSON,"text xml":m.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Nb(Nb(a,m.ajaxSettings),b):Nb(m.ajaxSettings,a)},ajaxPrefilter:Lb(Hb),ajaxTransport:Lb(Ib),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=m.ajaxSetup({},b),l=k.context||k,n=k.context&&(l.nodeType||l.jquery)?m(l):m.event,o=m.Deferred(),p=m.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Cb.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||zb)+"").replace(Ab,"").replace(Fb,yb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=m.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(c=Gb.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===yb[1]&&c[2]===yb[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(yb[3]||("http:"===yb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=m.param(k.data,k.traditional)),Mb(Hb,k,b,v),2===t)return v;h=m.event&&k.global,h&&0===m.active++&&m.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Eb.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(wb.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Bb.test(e)?e.replace(Bb,"$1_="+vb++):e+(wb.test(e)?"&":"?")+"_="+vb++)),k.ifModified&&(m.lastModified[e]&&v.setRequestHeader("If-Modified-Since",m.lastModified[e]),m.etag[e]&&v.setRequestHeader("If-None-Match",m.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Jb+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Mb(Ib,k,b,v)){v.readyState=1,h&&n.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Ob(k,v,c)),u=Pb(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(m.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(m.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&n.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(n.trigger("ajaxComplete",[v,k]),--m.active||m.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return m.get(a,b,c,"json")},getScript:function(a,b){return m.get(a,void 0,b,"script")}}),m.each(["get","post"],function(a,b){m[b]=function(a,c,d,e){return m.isFunction(c)&&(e=e||d,d=c,c=void 0),m.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),m._evalUrl=function(a){return m.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},m.fn.extend({wrapAll:function(a){if(m.isFunction(a))return this.each(function(b){m(this).wrapAll(a.call(this,b))});if(this[0]){var b=m(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(m.isFunction(a)?function(b){m(this).wrapInner(a.call(this,b))}:function(){var b=m(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=m.isFunction(a);return this.each(function(c){m(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){m.nodeName(this,"body")||m(this).replaceWith(this.childNodes)}).end()}}),m.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!k.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||m.css(a,"display"))},m.expr.filters.visible=function(a){return!m.expr.filters.hidden(a)};var Qb=/%20/g,Rb=/\[\]$/,Sb=/\r?\n/g,Tb=/^(?:submit|button|image|reset|file)$/i,Ub=/^(?:input|select|textarea|keygen)/i;function Vb(a,b,c,d){var e;if(m.isArray(b))m.each(b,function(b,e){c||Rb.test(a)?d(a,e):Vb(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==m.type(b))d(a,b);else for(e in b)Vb(a+"["+e+"]",b[e],c,d)}m.param=function(a,b){var c,d=[],e=function(a,b){b=m.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=m.ajaxSettings&&m.ajaxSettings.traditional),m.isArray(a)||a.jquery&&!m.isPlainObject(a))m.each(a,function(){e(this.name,this.value)});else for(c in a)Vb(c,a[c],b,e);return d.join("&").replace(Qb,"+")},m.fn.extend({serialize:function(){return m.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=m.prop(this,"elements");return a?m.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!m(this).is(":disabled")&&Ub.test(this.nodeName)&&!Tb.test(a)&&(this.checked||!W.test(a))}).map(function(a,b){var c=m(this).val();return null==c?null:m.isArray(c)?m.map(c,function(a){return{name:b.name,value:a.replace(Sb,"\r\n")}}):{name:b.name,value:c.replace(Sb,"\r\n")}}).get()}}),m.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&Zb()||$b()}:Zb;var Wb=0,Xb={},Yb=m.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Xb)Xb[a](void 0,!0)}),k.cors=!!Yb&&"withCredentials"in Yb,Yb=k.ajax=!!Yb,Yb&&m.ajaxTransport(function(a){if(!a.crossDomain||k.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Wb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Xb[g],b=void 0,f.onreadystatechange=m.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Xb[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function Zb(){try{return new a.XMLHttpRequest}catch(b){}}function $b(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}m.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return m.globalEval(a),a}}}),m.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),m.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=y.head||m("head")[0]||y.documentElement;return{send:function(d,e){b=y.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var _b=[],ac=/(=)\?(?=&|$)|\?\?/;m.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=_b.pop()||m.expando+"_"+vb++;return this[a]=!0,a}}),m.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(ac.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&ac.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=m.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(ac,"$1"+e):b.jsonp!==!1&&(b.url+=(wb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||m.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,_b.push(e)),g&&m.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),m.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||y;var d=u.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=m.buildFragment([a],b,e),e&&e.length&&m(e).remove(),m.merge([],d.childNodes))};var bc=m.fn.load;m.fn.load=function(a,b,c){if("string"!=typeof a&&bc)return bc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=m.trim(a.slice(h,a.length)),a=a.slice(0,h)),m.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&m.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?m("<div>").append(m.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},m.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){m.fn[b]=function(a){return this.on(b,a)}}),m.expr.filters.animated=function(a){return m.grep(m.timers,function(b){return a===b.elem}).length};var cc=a.document.documentElement;function dc(a){return m.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}m.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=m.css(a,"position"),l=m(a),n={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=m.css(a,"top"),i=m.css(a,"left"),j=("absolute"===k||"fixed"===k)&&m.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),m.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(n.top=b.top-h.top+g),null!=b.left&&(n.left=b.left-h.left+e),"using"in b?b.using.call(a,n):l.css(n)}},m.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){m.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,m.contains(b,e)?(typeof e.getBoundingClientRect!==K&&(d=e.getBoundingClientRect()),c=dc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===m.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),m.nodeName(a[0],"html")||(c=a.offset()),c.top+=m.css(a[0],"borderTopWidth",!0),c.left+=m.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-m.css(d,"marginTop",!0),left:b.left-c.left-m.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||cc;while(a&&!m.nodeName(a,"html")&&"static"===m.css(a,"position"))a=a.offsetParent;return a||cc})}}),m.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);m.fn[a]=function(d){return V(this,function(a,d,e){var f=dc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?m(f).scrollLeft():e,c?e:m(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),m.each(["top","left"],function(a,b){m.cssHooks[b]=La(k.pixelPosition,function(a,c){return c?(c=Ja(a,b),Ha.test(c)?m(a).position()[b]+"px":c):void 0})}),m.each({Height:"height",Width:"width"},function(a,b){m.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){m.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return V(this,function(b,c,d){var e;return m.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?m.css(b,c,g):m.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),m.fn.size=function(){return this.length},m.fn.andSelf=m.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return m});var ec=a.jQuery,fc=a.$;return m.noConflict=function(b){return a.$===m&&(a.$=fc),b&&a.jQuery===m&&(a.jQuery=ec),m},typeof b===K&&(a.jQuery=a.$=m),m});
</script>
<script>
/*! selectize.js - v0.12.1 | https://github.com/brianreavis/selectize.js | Apache License (v2) */
!function(a,b){"function"==typeof define&&define.amd?define("sifter",b):"object"==typeof exports?module.exports=b():a.Sifter=b()}(this,function(){var a=function(a,b){this.items=a,this.settings=b||{diacritics:!0}};a.prototype.tokenize=function(a){if(a=d(String(a||"").toLowerCase()),!a||!a.length)return[];var b,c,f,h,i=[],j=a.split(/ +/);for(b=0,c=j.length;c>b;b++){if(f=e(j[b]),this.settings.diacritics)for(h in g)g.hasOwnProperty(h)&&(f=f.replace(new RegExp(h,"g"),g[h]));i.push({string:j[b],regex:new RegExp(f,"i")})}return i},a.prototype.iterator=function(a,b){var c;c=f(a)?Array.prototype.forEach||function(a){for(var b=0,c=this.length;c>b;b++)a(this[b],b,this)}:function(a){for(var b in this)this.hasOwnProperty(b)&&a(this[b],b,this)},c.apply(a,[b])},a.prototype.getScoreFunction=function(a,b){var c,d,e,f;c=this,a=c.prepareSearch(a,b),e=a.tokens,d=a.options.fields,f=e.length;var g=function(a,b){var c,d;return a?(a=String(a||""),d=a.search(b.regex),-1===d?0:(c=b.string.length/a.length,0===d&&(c+=.5),c)):0},h=function(){var a=d.length;return a?1===a?function(a,b){return g(b[d[0]],a)}:function(b,c){for(var e=0,f=0;a>e;e++)f+=g(c[d[e]],b);return f/a}:function(){return 0}}();return f?1===f?function(a){return h(e[0],a)}:"and"===a.options.conjunction?function(a){for(var b,c=0,d=0;f>c;c++){if(b=h(e[c],a),0>=b)return 0;d+=b}return d/f}:function(a){for(var b=0,c=0;f>b;b++)c+=h(e[b],a);return c/f}:function(){return 0}},a.prototype.getSortFunction=function(a,c){var d,e,f,g,h,i,j,k,l,m,n;if(f=this,a=f.prepareSearch(a,c),n=!a.query&&c.sort_empty||c.sort,l=function(a,b){return"$score"===a?b.score:f.items[b.id][a]},h=[],n)for(d=0,e=n.length;e>d;d++)(a.query||"$score"!==n[d].field)&&h.push(n[d]);if(a.query){for(m=!0,d=0,e=h.length;e>d;d++)if("$score"===h[d].field){m=!1;break}m&&h.unshift({field:"$score",direction:"desc"})}else for(d=0,e=h.length;e>d;d++)if("$score"===h[d].field){h.splice(d,1);break}for(k=[],d=0,e=h.length;e>d;d++)k.push("desc"===h[d].direction?-1:1);return i=h.length,i?1===i?(g=h[0].field,j=k[0],function(a,c){return j*b(l(g,a),l(g,c))}):function(a,c){var d,e,f;for(d=0;i>d;d++)if(f=h[d].field,e=k[d]*b(l(f,a),l(f,c)))return e;return 0}:null},a.prototype.prepareSearch=function(a,b){if("object"==typeof a)return a;b=c({},b);var d=b.fields,e=b.sort,g=b.sort_empty;return d&&!f(d)&&(b.fields=[d]),e&&!f(e)&&(b.sort=[e]),g&&!f(g)&&(b.sort_empty=[g]),{options:b,query:String(a||"").toLowerCase(),tokens:this.tokenize(a),total:0,items:[]}},a.prototype.search=function(a,b){var c,d,e,f,g=this;return d=this.prepareSearch(a,b),b=d.options,a=d.query,f=b.score||g.getScoreFunction(d),a.length?g.iterator(g.items,function(a,e){c=f(a),(b.filter===!1||c>0)&&d.items.push({score:c,id:e})}):g.iterator(g.items,function(a,b){d.items.push({score:1,id:b})}),e=g.getSortFunction(d,b),e&&d.items.sort(e),d.total=d.items.length,"number"==typeof b.limit&&(d.items=d.items.slice(0,b.limit)),d};var b=function(a,b){return"number"==typeof a&&"number"==typeof b?a>b?1:b>a?-1:0:(a=h(String(a||"")),b=h(String(b||"")),a>b?1:b>a?-1:0)},c=function(a){var b,c,d,e;for(b=1,c=arguments.length;c>b;b++)if(e=arguments[b])for(d in e)e.hasOwnProperty(d)&&(a[d]=e[d]);return a},d=function(a){return(a+"").replace(/^\s+|\s+$|/g,"")},e=function(a){return(a+"").replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")},f=Array.isArray||$&&$.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},g={a:"[aÀÁÂÃÄÅàáâãäåĀāąĄ]",c:"[cÇçćĆčČ]",d:"[dđĐďĎ]",e:"[eÈÉÊËèéêëěĚĒēęĘ]",i:"[iÌÍÎÏìíîïĪī]",l:"[lłŁ]",n:"[nÑñňŇńŃ]",o:"[oÒÓÔÕÕÖØòóôõöøŌō]",r:"[rřŘ]",s:"[sŠšśŚ]",t:"[tťŤ]",u:"[uÙÚÛÜùúûüůŮŪū]",y:"[yŸÿýÝ]",z:"[zŽžżŻźŹ]"},h=function(){var a,b,c,d,e="",f={};for(c in g)if(g.hasOwnProperty(c))for(d=g[c].substring(2,g[c].length-1),e+=d,a=0,b=d.length;b>a;a++)f[d.charAt(a)]=c;var h=new RegExp("["+e+"]","g");return function(a){return a.replace(h,function(a){return f[a]}).toLowerCase()}}();return a}),function(a,b){"function"==typeof define&&define.amd?define("microplugin",b):"object"==typeof exports?module.exports=b():a.MicroPlugin=b()}(this,function(){var a={};a.mixin=function(a){a.plugins={},a.prototype.initializePlugins=function(a){var c,d,e,f=this,g=[];if(f.plugins={names:[],settings:{},requested:{},loaded:{}},b.isArray(a))for(c=0,d=a.length;d>c;c++)"string"==typeof a[c]?g.push(a[c]):(f.plugins.settings[a[c].name]=a[c].options,g.push(a[c].name));else if(a)for(e in a)a.hasOwnProperty(e)&&(f.plugins.settings[e]=a[e],g.push(e));for(;g.length;)f.require(g.shift())},a.prototype.loadPlugin=function(b){var c=this,d=c.plugins,e=a.plugins[b];if(!a.plugins.hasOwnProperty(b))throw new Error('Unable to find "'+b+'" plugin');d.requested[b]=!0,d.loaded[b]=e.fn.apply(c,[c.plugins.settings[b]||{}]),d.names.push(b)},a.prototype.require=function(a){var b=this,c=b.plugins;if(!b.plugins.loaded.hasOwnProperty(a)){if(c.requested[a])throw new Error('Plugin has circular dependency ("'+a+'")');b.loadPlugin(a)}return c.loaded[a]},a.define=function(b,c){a.plugins[b]={name:b,fn:c}}};var b={isArray:Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)}};return a}),function(a,b){"function"==typeof define&&define.amd?define("selectize",["jquery","sifter","microplugin"],b):"object"==typeof exports?module.exports=b(require("jquery"),require("sifter"),require("microplugin")):a.Selectize=b(a.jQuery,a.Sifter,a.MicroPlugin)}(this,function(a,b,c){"use strict";var d=function(a,b){if("string"!=typeof b||b.length){var c="string"==typeof b?new RegExp(b,"i"):b,d=function(a){var b=0;if(3===a.nodeType){var e=a.data.search(c);if(e>=0&&a.data.length>0){var f=a.data.match(c),g=document.createElement("span");g.className="highlight";var h=a.splitText(e),i=(h.splitText(f[0].length),h.cloneNode(!0));g.appendChild(i),h.parentNode.replaceChild(g,h),b=1}}else if(1===a.nodeType&&a.childNodes&&!/(script|style)/i.test(a.tagName))for(var j=0;j<a.childNodes.length;++j)j+=d(a.childNodes[j]);return b};return a.each(function(){d(this)})}},e=function(){};e.prototype={on:function(a,b){this._events=this._events||{},this._events[a]=this._events[a]||[],this._events[a].push(b)},off:function(a,b){var c=arguments.length;return 0===c?delete this._events:1===c?delete this._events[a]:(this._events=this._events||{},void(a in this._events!=!1&&this._events[a].splice(this._events[a].indexOf(b),1)))},trigger:function(a){if(this._events=this._events||{},a in this._events!=!1)for(var b=0;b<this._events[a].length;b++)this._events[a][b].apply(this,Array.prototype.slice.call(arguments,1))}},e.mixin=function(a){for(var b=["on","off","trigger"],c=0;c<b.length;c++)a.prototype[b[c]]=e.prototype[b[c]]};var f=/Mac/.test(navigator.userAgent),g=65,h=13,i=27,j=37,k=38,l=80,m=39,n=40,o=78,p=8,q=46,r=16,s=f?91:17,t=f?18:17,u=9,v=1,w=2,x=!/android/i.test(window.navigator.userAgent)&&!!document.createElement("form").validity,y=function(a){return"undefined"!=typeof a},z=function(a){return"undefined"==typeof a||null===a?null:"boolean"==typeof a?a?"1":"0":a+""},A=function(a){return(a+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")},B=function(a){return(a+"").replace(/\$/g,"$$$$")},C={};C.before=function(a,b,c){var d=a[b];a[b]=function(){return c.apply(a,arguments),d.apply(a,arguments)}},C.after=function(a,b,c){var d=a[b];a[b]=function(){var b=d.apply(a,arguments);return c.apply(a,arguments),b}};var D=function(a){var b=!1;return function(){b||(b=!0,a.apply(this,arguments))}},E=function(a,b){var c;return function(){var d=this,e=arguments;window.clearTimeout(c),c=window.setTimeout(function(){a.apply(d,e)},b)}},F=function(a,b,c){var d,e=a.trigger,f={};a.trigger=function(){var c=arguments[0];return-1===b.indexOf(c)?e.apply(a,arguments):void(f[c]=arguments)},c.apply(a,[]),a.trigger=e;for(d in f)f.hasOwnProperty(d)&&e.apply(a,f[d])},G=function(a,b,c,d){a.on(b,c,function(b){for(var c=b.target;c&&c.parentNode!==a[0];)c=c.parentNode;return b.currentTarget=c,d.apply(this,[b])})},H=function(a){var b={};if("selectionStart"in a)b.start=a.selectionStart,b.length=a.selectionEnd-b.start;else if(document.selection){a.focus();var c=document.selection.createRange(),d=document.selection.createRange().text.length;c.moveStart("character",-a.value.length),b.start=c.text.length-d,b.length=d}return b},I=function(a,b,c){var d,e,f={};if(c)for(d=0,e=c.length;e>d;d++)f[c[d]]=a.css(c[d]);else f=a.css();b.css(f)},J=function(b,c){if(!b)return 0;var d=a("<test>").css({position:"absolute",top:-99999,left:-99999,width:"auto",padding:0,whiteSpace:"pre"}).text(b).appendTo("body");I(c,d,["letterSpacing","fontSize","fontFamily","fontWeight","textTransform"]);var e=d.width();return d.remove(),e},K=function(a){var b=null,c=function(c,d){var e,f,g,h,i,j,k,l;c=c||window.event||{},d=d||{},c.metaKey||c.altKey||(d.force||a.data("grow")!==!1)&&(e=a.val(),c.type&&"keydown"===c.type.toLowerCase()&&(f=c.keyCode,g=f>=97&&122>=f||f>=65&&90>=f||f>=48&&57>=f||32===f,f===q||f===p?(l=H(a[0]),l.length?e=e.substring(0,l.start)+e.substring(l.start+l.length):f===p&&l.start?e=e.substring(0,l.start-1)+e.substring(l.start+1):f===q&&"undefined"!=typeof l.start&&(e=e.substring(0,l.start)+e.substring(l.start+1))):g&&(j=c.shiftKey,k=String.fromCharCode(c.keyCode),k=j?k.toUpperCase():k.toLowerCase(),e+=k)),h=a.attr("placeholder"),!e&&h&&(e=h),i=J(e,a)+4,i!==b&&(b=i,a.width(i),a.triggerHandler("resize")))};a.on("keydown keyup update blur",c),c()},L=function(c,d){var e,f,g,h,i=this;h=c[0],h.selectize=i;var j=window.getComputedStyle&&window.getComputedStyle(h,null);if(g=j?j.getPropertyValue("direction"):h.currentStyle&&h.currentStyle.direction,g=g||c.parents("[dir]:first").attr("dir")||"",a.extend(i,{order:0,settings:d,$input:c,tabIndex:c.attr("tabindex")||"",tagType:"select"===h.tagName.toLowerCase()?v:w,rtl:/rtl/i.test(g),eventNS:".selectize"+ ++L.count,highlightedValue:null,isOpen:!1,isDisabled:!1,isRequired:c.is("[required]"),isInvalid:!1,isLocked:!1,isFocused:!1,isInputHidden:!1,isSetup:!1,isShiftDown:!1,isCmdDown:!1,isCtrlDown:!1,ignoreFocus:!1,ignoreBlur:!1,ignoreHover:!1,hasOptions:!1,currentResults:null,lastValue:"",caretPos:0,loading:0,loadedSearches:{},$activeOption:null,$activeItems:[],optgroups:{},options:{},userOptions:{},items:[],renderCache:{},onSearchChange:null===d.loadThrottle?i.onSearchChange:E(i.onSearchChange,d.loadThrottle)}),i.sifter=new b(this.options,{diacritics:d.diacritics}),i.settings.options){for(e=0,f=i.settings.options.length;f>e;e++)i.registerOption(i.settings.options[e]);delete i.settings.options}if(i.settings.optgroups){for(e=0,f=i.settings.optgroups.length;f>e;e++)i.registerOptionGroup(i.settings.optgroups[e]);delete i.settings.optgroups}i.settings.mode=i.settings.mode||(1===i.settings.maxItems?"single":"multi"),"boolean"!=typeof i.settings.hideSelected&&(i.settings.hideSelected="multi"===i.settings.mode),i.initializePlugins(i.settings.plugins),i.setupCallbacks(),i.setupTemplates(),i.setup()};return e.mixin(L),c.mixin(L),a.extend(L.prototype,{setup:function(){var b,c,d,e,g,h,i,j,k,l=this,m=l.settings,n=l.eventNS,o=a(window),p=a(document),q=l.$input;if(i=l.settings.mode,j=q.attr("class")||"",b=a("<div>").addClass(m.wrapperClass).addClass(j).addClass(i),c=a("<div>").addClass(m.inputClass).addClass("items").appendTo(b),d=a('<input type="text" autocomplete="off" />').appendTo(c).attr("tabindex",q.is(":disabled")?"-1":l.tabIndex),h=a(m.dropdownParent||b),e=a("<div>").addClass(m.dropdownClass).addClass(i).hide().appendTo(h),g=a("<div>").addClass(m.dropdownContentClass).appendTo(e),l.settings.copyClassesToDropdown&&e.addClass(j),b.css({width:q[0].style.width}),l.plugins.names.length&&(k="plugin-"+l.plugins.names.join(" plugin-"),b.addClass(k),e.addClass(k)),(null===m.maxItems||m.maxItems>1)&&l.tagType===v&&q.attr("multiple","multiple"),l.settings.placeholder&&d.attr("placeholder",m.placeholder),!l.settings.splitOn&&l.settings.delimiter){var u=l.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");l.settings.splitOn=new RegExp("\\s*"+u+"+\\s*")}q.attr("autocorrect")&&d.attr("autocorrect",q.attr("autocorrect")),q.attr("autocapitalize")&&d.attr("autocapitalize",q.attr("autocapitalize")),l.$wrapper=b,l.$control=c,l.$control_input=d,l.$dropdown=e,l.$dropdown_content=g,e.on("mouseenter","[data-selectable]",function(){return l.onOptionHover.apply(l,arguments)}),e.on("mousedown click","[data-selectable]",function(){return l.onOptionSelect.apply(l,arguments)}),G(c,"mousedown","*:not(input)",function(){return l.onItemSelect.apply(l,arguments)}),K(d),c.on({mousedown:function(){return l.onMouseDown.apply(l,arguments)},click:function(){return l.onClick.apply(l,arguments)}}),d.on({mousedown:function(a){a.stopPropagation()},keydown:function(){return l.onKeyDown.apply(l,arguments)},keyup:function(){return l.onKeyUp.apply(l,arguments)},keypress:function(){return l.onKeyPress.apply(l,arguments)},resize:function(){l.positionDropdown.apply(l,[])},blur:function(){return l.onBlur.apply(l,arguments)},focus:function(){return l.ignoreBlur=!1,l.onFocus.apply(l,arguments)},paste:function(){return l.onPaste.apply(l,arguments)}}),p.on("keydown"+n,function(a){l.isCmdDown=a[f?"metaKey":"ctrlKey"],l.isCtrlDown=a[f?"altKey":"ctrlKey"],l.isShiftDown=a.shiftKey}),p.on("keyup"+n,function(a){a.keyCode===t&&(l.isCtrlDown=!1),a.keyCode===r&&(l.isShiftDown=!1),a.keyCode===s&&(l.isCmdDown=!1)}),p.on("mousedown"+n,function(a){if(l.isFocused){if(a.target===l.$dropdown[0]||a.target.parentNode===l.$dropdown[0])return!1;l.$control.has(a.target).length||a.target===l.$control[0]||l.blur(a.target)}}),o.on(["scroll"+n,"resize"+n].join(" "),function(){l.isOpen&&l.positionDropdown.apply(l,arguments)}),o.on("mousemove"+n,function(){l.ignoreHover=!1}),this.revertSettings={$children:q.children().detach(),tabindex:q.attr("tabindex")},q.attr("tabindex",-1).hide().after(l.$wrapper),a.isArray(m.items)&&(l.setValue(m.items),delete m.items),x&&q.on("invalid"+n,function(a){a.preventDefault(),l.isInvalid=!0,l.refreshState()}),l.updateOriginalInput(),l.refreshItems(),l.refreshState(),l.updatePlaceholder(),l.isSetup=!0,q.is(":disabled")&&l.disable(),l.on("change",this.onChange),q.data("selectize",l),q.addClass("selectized"),l.trigger("initialize"),m.preload===!0&&l.onSearchChange("")},setupTemplates:function(){var b=this,c=b.settings.labelField,d=b.settings.optgroupLabelField,e={optgroup:function(a){return'<div class="optgroup">'+a.html+"</div>"},optgroup_header:function(a,b){return'<div class="optgroup-header">'+b(a[d])+"</div>"},option:function(a,b){return'<div class="option">'+b(a[c])+"</div>"},item:function(a,b){return'<div class="item">'+b(a[c])+"</div>"},option_create:function(a,b){return'<div class="create">Add <strong>'+b(a.input)+"</strong>&hellip;</div>"}};b.settings.render=a.extend({},e,b.settings.render)},setupCallbacks:function(){var a,b,c={initialize:"onInitialize",change:"onChange",item_add:"onItemAdd",item_remove:"onItemRemove",clear:"onClear",option_add:"onOptionAdd",option_remove:"onOptionRemove",option_clear:"onOptionClear",optgroup_add:"onOptionGroupAdd",optgroup_remove:"onOptionGroupRemove",optgroup_clear:"onOptionGroupClear",dropdown_open:"onDropdownOpen",dropdown_close:"onDropdownClose",type:"onType",load:"onLoad",focus:"onFocus",blur:"onBlur"};for(a in c)c.hasOwnProperty(a)&&(b=this.settings[c[a]],b&&this.on(a,b))},onClick:function(a){var b=this;b.isFocused||(b.focus(),a.preventDefault())},onMouseDown:function(b){{var c=this,d=b.isDefaultPrevented();a(b.target)}if(c.isFocused){if(b.target!==c.$control_input[0])return"single"===c.settings.mode?c.isOpen?c.close():c.open():d||c.setActiveItem(null),!1}else d||window.setTimeout(function(){c.focus()},0)},onChange:function(){this.$input.trigger("change")},onPaste:function(b){var c=this;c.isFull()||c.isInputHidden||c.isLocked?b.preventDefault():c.settings.splitOn&&setTimeout(function(){for(var b=a.trim(c.$control_input.val()||"").split(c.settings.splitOn),d=0,e=b.length;e>d;d++)c.createItem(b[d])},0)},onKeyPress:function(a){if(this.isLocked)return a&&a.preventDefault();var b=String.fromCharCode(a.keyCode||a.which);return this.settings.create&&"multi"===this.settings.mode&&b===this.settings.delimiter?(this.createItem(),a.preventDefault(),!1):void 0},onKeyDown:function(a){var b=(a.target===this.$control_input[0],this);if(b.isLocked)return void(a.keyCode!==u&&a.preventDefault());switch(a.keyCode){case g:if(b.isCmdDown)return void b.selectAll();break;case i:return void(b.isOpen&&(a.preventDefault(),a.stopPropagation(),b.close()));case o:if(!a.ctrlKey||a.altKey)break;case n:if(!b.isOpen&&b.hasOptions)b.open();else if(b.$activeOption){b.ignoreHover=!0;var c=b.getAdjacentOption(b.$activeOption,1);c.length&&b.setActiveOption(c,!0,!0)}return void a.preventDefault();case l:if(!a.ctrlKey||a.altKey)break;case k:if(b.$activeOption){b.ignoreHover=!0;var d=b.getAdjacentOption(b.$activeOption,-1);d.length&&b.setActiveOption(d,!0,!0)}return void a.preventDefault();case h:return void(b.isOpen&&b.$activeOption&&(b.onOptionSelect({currentTarget:b.$activeOption}),a.preventDefault()));case j:return void b.advanceSelection(-1,a);case m:return void b.advanceSelection(1,a);case u:return b.settings.selectOnTab&&b.isOpen&&b.$activeOption&&(b.onOptionSelect({currentTarget:b.$activeOption}),b.isFull()||a.preventDefault()),void(b.settings.create&&b.createItem()&&a.preventDefault());case p:case q:return void b.deleteSelection(a)}return!b.isFull()&&!b.isInputHidden||(f?a.metaKey:a.ctrlKey)?void 0:void a.preventDefault()},onKeyUp:function(a){var b=this;if(b.isLocked)return a&&a.preventDefault();var c=b.$control_input.val()||"";b.lastValue!==c&&(b.lastValue=c,b.onSearchChange(c),b.refreshOptions(),b.trigger("type",c))},onSearchChange:function(a){var b=this,c=b.settings.load;c&&(b.loadedSearches.hasOwnProperty(a)||(b.loadedSearches[a]=!0,b.load(function(d){c.apply(b,[a,d])})))},onFocus:function(a){var b=this,c=b.isFocused;return b.isDisabled?(b.blur(),a&&a.preventDefault(),!1):void(b.ignoreFocus||(b.isFocused=!0,"focus"===b.settings.preload&&b.onSearchChange(""),c||b.trigger("focus"),b.$activeItems.length||(b.showInput(),b.setActiveItem(null),b.refreshOptions(!!b.settings.openOnFocus)),b.refreshState()))},onBlur:function(a,b){var c=this;if(c.isFocused&&(c.isFocused=!1,!c.ignoreFocus)){if(!c.ignoreBlur&&document.activeElement===c.$dropdown_content[0])return c.ignoreBlur=!0,void c.onFocus(a);var d=function(){c.close(),c.setTextboxValue(""),c.setActiveItem(null),c.setActiveOption(null),c.setCaret(c.items.length),c.refreshState(),(b||document.body).focus(),c.ignoreFocus=!1,c.trigger("blur")};c.ignoreFocus=!0,c.settings.create&&c.settings.createOnBlur?c.createItem(null,!1,d):d()}},onOptionHover:function(a){this.ignoreHover||this.setActiveOption(a.currentTarget,!1)},onOptionSelect:function(b){var c,d,e=this;b.preventDefault&&(b.preventDefault(),b.stopPropagation()),d=a(b.currentTarget),d.hasClass("create")?e.createItem(null,function(){e.settings.closeAfterSelect&&e.close()}):(c=d.attr("data-value"),"undefined"!=typeof c&&(e.lastQuery=null,e.setTextboxValue(""),e.addItem(c),e.settings.closeAfterSelect?e.close():!e.settings.hideSelected&&b.type&&/mouse/.test(b.type)&&e.setActiveOption(e.getOption(c))))},onItemSelect:function(a){var b=this;b.isLocked||"multi"===b.settings.mode&&(a.preventDefault(),b.setActiveItem(a.currentTarget,a))},load:function(a){var b=this,c=b.$wrapper.addClass(b.settings.loadingClass);b.loading++,a.apply(b,[function(a){b.loading=Math.max(b.loading-1,0),a&&a.length&&(b.addOption(a),b.refreshOptions(b.isFocused&&!b.isInputHidden)),b.loading||c.removeClass(b.settings.loadingClass),b.trigger("load",a)}])},setTextboxValue:function(a){var b=this.$control_input,c=b.val()!==a;c&&(b.val(a).triggerHandler("update"),this.lastValue=a)},getValue:function(){return this.tagType===v&&this.$input.attr("multiple")?this.items:this.items.join(this.settings.delimiter)},setValue:function(a,b){var c=b?[]:["change"];F(this,c,function(){this.clear(b),this.addItems(a,b)})},setActiveItem:function(b,c){var d,e,f,g,h,i,j,k,l=this;if("single"!==l.settings.mode){if(b=a(b),!b.length)return a(l.$activeItems).removeClass("active"),l.$activeItems=[],void(l.isFocused&&l.showInput());if(d=c&&c.type.toLowerCase(),"mousedown"===d&&l.isShiftDown&&l.$activeItems.length){for(k=l.$control.children(".active:last"),g=Array.prototype.indexOf.apply(l.$control[0].childNodes,[k[0]]),h=Array.prototype.indexOf.apply(l.$control[0].childNodes,[b[0]]),g>h&&(j=g,g=h,h=j),e=g;h>=e;e++)i=l.$control[0].childNodes[e],-1===l.$activeItems.indexOf(i)&&(a(i).addClass("active"),l.$activeItems.push(i));c.preventDefault()}else"mousedown"===d&&l.isCtrlDown||"keydown"===d&&this.isShiftDown?b.hasClass("active")?(f=l.$activeItems.indexOf(b[0]),l.$activeItems.splice(f,1),b.removeClass("active")):l.$activeItems.push(b.addClass("active")[0]):(a(l.$activeItems).removeClass("active"),l.$activeItems=[b.addClass("active")[0]]);l.hideInput(),this.isFocused||l.focus()}},setActiveOption:function(b,c,d){var e,f,g,h,i,j=this;j.$activeOption&&j.$activeOption.removeClass("active"),j.$activeOption=null,b=a(b),b.length&&(j.$activeOption=b.addClass("active"),(c||!y(c))&&(e=j.$dropdown_content.height(),f=j.$activeOption.outerHeight(!0),c=j.$dropdown_content.scrollTop()||0,g=j.$activeOption.offset().top-j.$dropdown_content.offset().top+c,h=g,i=g-e+f,g+f>e+c?j.$dropdown_content.stop().animate({scrollTop:i},d?j.settings.scrollDuration:0):c>g&&j.$dropdown_content.stop().animate({scrollTop:h},d?j.settings.scrollDuration:0)))},selectAll:function(){var a=this;"single"!==a.settings.mode&&(a.$activeItems=Array.prototype.slice.apply(a.$control.children(":not(input)").addClass("active")),a.$activeItems.length&&(a.hideInput(),a.close()),a.focus())},hideInput:function(){var a=this;a.setTextboxValue(""),a.$control_input.css({opacity:0,position:"absolute",left:a.rtl?1e4:-1e4}),a.isInputHidden=!0},showInput:function(){this.$control_input.css({opacity:1,position:"relative",left:0}),this.isInputHidden=!1},focus:function(){var a=this;a.isDisabled||(a.ignoreFocus=!0,a.$control_input[0].focus(),window.setTimeout(function(){a.ignoreFocus=!1,a.onFocus()},0))},blur:function(a){this.$control_input[0].blur(),this.onBlur(null,a)},getScoreFunction:function(a){return this.sifter.getScoreFunction(a,this.getSearchOptions())},getSearchOptions:function(){var a=this.settings,b=a.sortField;return"string"==typeof b&&(b=[{field:b}]),{fields:a.searchField,conjunction:a.searchConjunction,sort:b}},search:function(b){var c,d,e,f=this,g=f.settings,h=this.getSearchOptions();if(g.score&&(e=f.settings.score.apply(this,[b]),"function"!=typeof e))throw new Error('Selectize "score" setting must be a function that returns a function');if(b!==f.lastQuery?(f.lastQuery=b,d=f.sifter.search(b,a.extend(h,{score:e})),f.currentResults=d):d=a.extend(!0,{},f.currentResults),g.hideSelected)for(c=d.items.length-1;c>=0;c--)-1!==f.items.indexOf(z(d.items[c].id))&&d.items.splice(c,1);return d},refreshOptions:function(b){var c,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s;"undefined"==typeof b&&(b=!0);var t=this,u=a.trim(t.$control_input.val()),v=t.search(u),w=t.$dropdown_content,x=t.$activeOption&&z(t.$activeOption.attr("data-value"));for(g=v.items.length,"number"==typeof t.settings.maxOptions&&(g=Math.min(g,t.settings.maxOptions)),h={},i=[],c=0;g>c;c++)for(j=t.options[v.items[c].id],k=t.render("option",j),l=j[t.settings.optgroupField]||"",m=a.isArray(l)?l:[l],e=0,f=m&&m.length;f>e;e++)l=m[e],t.optgroups.hasOwnProperty(l)||(l=""),h.hasOwnProperty(l)||(h[l]=[],i.push(l)),h[l].push(k);for(this.settings.lockOptgroupOrder&&i.sort(function(a,b){var c=t.optgroups[a].$order||0,d=t.optgroups[b].$order||0;return c-d}),n=[],c=0,g=i.length;g>c;c++)l=i[c],t.optgroups.hasOwnProperty(l)&&h[l].length?(o=t.render("optgroup_header",t.optgroups[l])||"",o+=h[l].join(""),n.push(t.render("optgroup",a.extend({},t.optgroups[l],{html:o})))):n.push(h[l].join(""));if(w.html(n.join("")),t.settings.highlight&&v.query.length&&v.tokens.length)for(c=0,g=v.tokens.length;g>c;c++)d(w,v.tokens[c].regex);if(!t.settings.hideSelected)for(c=0,g=t.items.length;g>c;c++)t.getOption(t.items[c]).addClass("selected");p=t.canCreate(u),p&&(w.prepend(t.render("option_create",{input:u})),s=a(w[0].childNodes[0])),t.hasOptions=v.items.length>0||p,t.hasOptions?(v.items.length>0?(r=x&&t.getOption(x),r&&r.length?q=r:"single"===t.settings.mode&&t.items.length&&(q=t.getOption(t.items[0])),q&&q.length||(q=s&&!t.settings.addPrecedence?t.getAdjacentOption(s,1):w.find("[data-selectable]:first"))):q=s,t.setActiveOption(q),b&&!t.isOpen&&t.open()):(t.setActiveOption(null),b&&t.isOpen&&t.close())},addOption:function(b){var c,d,e,f=this;if(a.isArray(b))for(c=0,d=b.length;d>c;c++)f.addOption(b[c]);else(e=f.registerOption(b))&&(f.userOptions[e]=!0,f.lastQuery=null,f.trigger("option_add",e,b))},registerOption:function(a){var b=z(a[this.settings.valueField]);return!b||this.options.hasOwnProperty(b)?!1:(a.$order=a.$order||++this.order,this.options[b]=a,b)},registerOptionGroup:function(a){var b=z(a[this.settings.optgroupValueField]);return b?(a.$order=a.$order||++this.order,this.optgroups[b]=a,b):!1},addOptionGroup:function(a,b){b[this.settings.optgroupValueField]=a,(a=this.registerOptionGroup(b))&&this.trigger("optgroup_add",a,b)},removeOptionGroup:function(a){this.optgroups.hasOwnProperty(a)&&(delete this.optgroups[a],this.renderCache={},this.trigger("optgroup_remove",a))},clearOptionGroups:function(){this.optgroups={},this.renderCache={},this.trigger("optgroup_clear")},updateOption:function(b,c){var d,e,f,g,h,i,j,k=this;if(b=z(b),f=z(c[k.settings.valueField]),null!==b&&k.options.hasOwnProperty(b)){if("string"!=typeof f)throw new Error("Value must be set in option data");j=k.options[b].$order,f!==b&&(delete k.options[b],g=k.items.indexOf(b),-1!==g&&k.items.splice(g,1,f)),c.$order=c.$order||j,k.options[f]=c,h=k.renderCache.item,i=k.renderCache.option,h&&(delete h[b],delete h[f]),i&&(delete i[b],delete i[f]),-1!==k.items.indexOf(f)&&(d=k.getItem(b),e=a(k.render("item",c)),d.hasClass("active")&&e.addClass("active"),d.replaceWith(e)),k.lastQuery=null,k.isOpen&&k.refreshOptions(!1)}},removeOption:function(a,b){var c=this;a=z(a);var d=c.renderCache.item,e=c.renderCache.option;d&&delete d[a],e&&delete e[a],delete c.userOptions[a],delete c.options[a],c.lastQuery=null,c.trigger("option_remove",a),c.removeItem(a,b)},clearOptions:function(){var a=this;a.loadedSearches={},a.userOptions={},a.renderCache={},a.options=a.sifter.items={},a.lastQuery=null,a.trigger("option_clear"),a.clear()},getOption:function(a){return this.getElementWithValue(a,this.$dropdown_content.find("[data-selectable]"))},getAdjacentOption:function(b,c){var d=this.$dropdown.find("[data-selectable]"),e=d.index(b)+c;return e>=0&&e<d.length?d.eq(e):a()},getElementWithValue:function(b,c){if(b=z(b),"undefined"!=typeof b&&null!==b)for(var d=0,e=c.length;e>d;d++)if(c[d].getAttribute("data-value")===b)return a(c[d]);return a()},getItem:function(a){return this.getElementWithValue(a,this.$control.children())},addItems:function(b,c){for(var d=a.isArray(b)?b:[b],e=0,f=d.length;f>e;e++)this.isPending=f-1>e,this.addItem(d[e],c)},addItem:function(b,c){var d=c?[]:["change"];F(this,d,function(){var d,e,f,g,h,i=this,j=i.settings.mode;return b=z(b),-1!==i.items.indexOf(b)?void("single"===j&&i.close()):void(i.options.hasOwnProperty(b)&&("single"===j&&i.clear(c),"multi"===j&&i.isFull()||(d=a(i.render("item",i.options[b])),h=i.isFull(),i.items.splice(i.caretPos,0,b),i.insertAtCaret(d),(!i.isPending||!h&&i.isFull())&&i.refreshState(),i.isSetup&&(f=i.$dropdown_content.find("[data-selectable]"),i.isPending||(e=i.getOption(b),g=i.getAdjacentOption(e,1).attr("data-value"),i.refreshOptions(i.isFocused&&"single"!==j),g&&i.setActiveOption(i.getOption(g))),!f.length||i.isFull()?i.close():i.positionDropdown(),i.updatePlaceholder(),i.trigger("item_add",b,d),i.updateOriginalInput({silent:c})))))})},removeItem:function(a,b){var c,d,e,f=this;c="object"==typeof a?a:f.getItem(a),a=z(c.attr("data-value")),d=f.items.indexOf(a),-1!==d&&(c.remove(),c.hasClass("active")&&(e=f.$activeItems.indexOf(c[0]),f.$activeItems.splice(e,1)),f.items.splice(d,1),f.lastQuery=null,!f.settings.persist&&f.userOptions.hasOwnProperty(a)&&f.removeOption(a,b),d<f.caretPos&&f.setCaret(f.caretPos-1),f.refreshState(),f.updatePlaceholder(),f.updateOriginalInput({silent:b}),f.positionDropdown(),f.trigger("item_remove",a,c))},createItem:function(b,c){var d=this,e=d.caretPos;b=b||a.trim(d.$control_input.val()||"");var f=arguments[arguments.length-1];if("function"!=typeof f&&(f=function(){}),"boolean"!=typeof c&&(c=!0),!d.canCreate(b))return f(),!1;d.lock();var g="function"==typeof d.settings.create?this.settings.create:function(a){var b={};return b[d.settings.labelField]=a,b[d.settings.valueField]=a,b},h=D(function(a){if(d.unlock(),!a||"object"!=typeof a)return f();var b=z(a[d.settings.valueField]);return"string"!=typeof b?f():(d.setTextboxValue(""),d.addOption(a),d.setCaret(e),d.addItem(b),d.refreshOptions(c&&"single"!==d.settings.mode),void f(a))}),i=g.apply(this,[b,h]);return"undefined"!=typeof i&&h(i),!0},refreshItems:function(){this.lastQuery=null,this.isSetup&&this.addItem(this.items),this.refreshState(),this.updateOriginalInput()},refreshState:function(){var a,b=this;b.isRequired&&(b.items.length&&(b.isInvalid=!1),b.$control_input.prop("required",a)),b.refreshClasses()},refreshClasses:function(){var b=this,c=b.isFull(),d=b.isLocked;b.$wrapper.toggleClass("rtl",b.rtl),b.$control.toggleClass("focus",b.isFocused).toggleClass("disabled",b.isDisabled).toggleClass("required",b.isRequired).toggleClass("invalid",b.isInvalid).toggleClass("locked",d).toggleClass("full",c).toggleClass("not-full",!c).toggleClass("input-active",b.isFocused&&!b.isInputHidden).toggleClass("dropdown-active",b.isOpen).toggleClass("has-options",!a.isEmptyObject(b.options)).toggleClass("has-items",b.items.length>0),b.$control_input.data("grow",!c&&!d)},isFull:function(){return null!==this.settings.maxItems&&this.items.length>=this.settings.maxItems},updateOriginalInput:function(a){var b,c,d,e,f=this;if(a=a||{},f.tagType===v){for(d=[],b=0,c=f.items.length;c>b;b++)e=f.options[f.items[b]][f.settings.labelField]||"",d.push('<option value="'+A(f.items[b])+'" selected="selected">'+A(e)+"</option>");d.length||this.$input.attr("multiple")||d.push('<option value="" selected="selected"></option>'),f.$input.html(d.join(""))}else f.$input.val(f.getValue()),f.$input.attr("value",f.$input.val());f.isSetup&&(a.silent||f.trigger("change",f.$input.val()))},updatePlaceholder:function(){if(this.settings.placeholder){var a=this.$control_input;this.items.length?a.removeAttr("placeholder"):a.attr("placeholder",this.settings.placeholder),a.triggerHandler("update",{force:!0})}},open:function(){var a=this;a.isLocked||a.isOpen||"multi"===a.settings.mode&&a.isFull()||(a.focus(),a.isOpen=!0,a.refreshState(),a.$dropdown.css({visibility:"hidden",display:"block"}),a.positionDropdown(),a.$dropdown.css({visibility:"visible"}),a.trigger("dropdown_open",a.$dropdown))},close:function(){var a=this,b=a.isOpen;"single"===a.settings.mode&&a.items.length&&a.hideInput(),a.isOpen=!1,a.$dropdown.hide(),a.setActiveOption(null),a.refreshState(),b&&a.trigger("dropdown_close",a.$dropdown)},positionDropdown:function(){var a=this.$control,b="body"===this.settings.dropdownParent?a.offset():a.position();b.top+=a.outerHeight(!0),this.$dropdown.css({width:a.outerWidth(),top:b.top,left:b.left})},clear:function(a){var b=this;b.items.length&&(b.$control.children(":not(input)").remove(),b.items=[],b.lastQuery=null,b.setCaret(0),b.setActiveItem(null),b.updatePlaceholder(),b.updateOriginalInput({silent:a}),b.refreshState(),b.showInput(),b.trigger("clear"))},insertAtCaret:function(b){var c=Math.min(this.caretPos,this.items.length);0===c?this.$control.prepend(b):a(this.$control[0].childNodes[c]).before(b),this.setCaret(c+1)},deleteSelection:function(b){var c,d,e,f,g,h,i,j,k,l=this;if(e=b&&b.keyCode===p?-1:1,f=H(l.$control_input[0]),l.$activeOption&&!l.settings.hideSelected&&(i=l.getAdjacentOption(l.$activeOption,-1).attr("data-value")),g=[],l.$activeItems.length){for(k=l.$control.children(".active:"+(e>0?"last":"first")),h=l.$control.children(":not(input)").index(k),e>0&&h++,c=0,d=l.$activeItems.length;d>c;c++)g.push(a(l.$activeItems[c]).attr("data-value"));
b&&(b.preventDefault(),b.stopPropagation())}else(l.isFocused||"single"===l.settings.mode)&&l.items.length&&(0>e&&0===f.start&&0===f.length?g.push(l.items[l.caretPos-1]):e>0&&f.start===l.$control_input.val().length&&g.push(l.items[l.caretPos]));if(!g.length||"function"==typeof l.settings.onDelete&&l.settings.onDelete.apply(l,[g])===!1)return!1;for("undefined"!=typeof h&&l.setCaret(h);g.length;)l.removeItem(g.pop());return l.showInput(),l.positionDropdown(),l.refreshOptions(!0),i&&(j=l.getOption(i),j.length&&l.setActiveOption(j)),!0},advanceSelection:function(a,b){var c,d,e,f,g,h,i=this;0!==a&&(i.rtl&&(a*=-1),c=a>0?"last":"first",d=H(i.$control_input[0]),i.isFocused&&!i.isInputHidden?(f=i.$control_input.val().length,g=0>a?0===d.start&&0===d.length:d.start===f,g&&!f&&i.advanceCaret(a,b)):(h=i.$control.children(".active:"+c),h.length&&(e=i.$control.children(":not(input)").index(h),i.setActiveItem(null),i.setCaret(a>0?e+1:e))))},advanceCaret:function(a,b){var c,d,e=this;0!==a&&(c=a>0?"next":"prev",e.isShiftDown?(d=e.$control_input[c](),d.length&&(e.hideInput(),e.setActiveItem(d),b&&b.preventDefault())):e.setCaret(e.caretPos+a))},setCaret:function(b){var c=this;if(b="single"===c.settings.mode?c.items.length:Math.max(0,Math.min(c.items.length,b)),!c.isPending){var d,e,f,g;for(f=c.$control.children(":not(input)"),d=0,e=f.length;e>d;d++)g=a(f[d]).detach(),b>d?c.$control_input.before(g):c.$control.append(g)}c.caretPos=b},lock:function(){this.close(),this.isLocked=!0,this.refreshState()},unlock:function(){this.isLocked=!1,this.refreshState()},disable:function(){var a=this;a.$input.prop("disabled",!0),a.$control_input.prop("disabled",!0).prop("tabindex",-1),a.isDisabled=!0,a.lock()},enable:function(){var a=this;a.$input.prop("disabled",!1),a.$control_input.prop("disabled",!1).prop("tabindex",a.tabIndex),a.isDisabled=!1,a.unlock()},destroy:function(){var b=this,c=b.eventNS,d=b.revertSettings;b.trigger("destroy"),b.off(),b.$wrapper.remove(),b.$dropdown.remove(),b.$input.html("").append(d.$children).removeAttr("tabindex").removeClass("selectized").attr({tabindex:d.tabindex}).show(),b.$control_input.removeData("grow"),b.$input.removeData("selectize"),a(window).off(c),a(document).off(c),a(document.body).off(c),delete b.$input[0].selectize},render:function(a,b){var c,d,e="",f=!1,g=this,h=/^[\t \r\n]*<([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?)/i;return("option"===a||"item"===a)&&(c=z(b[g.settings.valueField]),f=!!c),f&&(y(g.renderCache[a])||(g.renderCache[a]={}),g.renderCache[a].hasOwnProperty(c))?g.renderCache[a][c]:(e=g.settings.render[a].apply(this,[b,A]),("option"===a||"option_create"===a)&&(e=e.replace(h,"<$1 data-selectable")),"optgroup"===a&&(d=b[g.settings.optgroupValueField]||"",e=e.replace(h,'<$1 data-group="'+B(A(d))+'"')),("option"===a||"item"===a)&&(e=e.replace(h,'<$1 data-value="'+B(A(c||""))+'"')),f&&(g.renderCache[a][c]=e),e)},clearCache:function(a){var b=this;"undefined"==typeof a?b.renderCache={}:delete b.renderCache[a]},canCreate:function(a){var b=this;if(!b.settings.create)return!1;var c=b.settings.createFilter;return!(!a.length||"function"==typeof c&&!c.apply(b,[a])||"string"==typeof c&&!new RegExp(c).test(a)||c instanceof RegExp&&!c.test(a))}}),L.count=0,L.defaults={options:[],optgroups:[],plugins:[],delimiter:",",splitOn:null,persist:!0,diacritics:!0,create:!1,createOnBlur:!1,createFilter:null,highlight:!0,openOnFocus:!0,maxOptions:1e3,maxItems:null,hideSelected:null,addPrecedence:!1,selectOnTab:!1,preload:!1,allowEmptyOption:!1,closeAfterSelect:!1,scrollDuration:60,loadThrottle:300,loadingClass:"loading",dataAttr:"data-data",optgroupField:"optgroup",valueField:"value",labelField:"text",optgroupLabelField:"label",optgroupValueField:"value",lockOptgroupOrder:!1,sortField:"$order",searchField:["text"],searchConjunction:"and",mode:null,wrapperClass:"selectize-control",inputClass:"selectize-input",dropdownClass:"selectize-dropdown",dropdownContentClass:"selectize-dropdown-content",dropdownParent:null,copyClassesToDropdown:!0,render:{}},a.fn.selectize=function(b){var c=a.fn.selectize.defaults,d=a.extend({},c,b),e=d.dataAttr,f=d.labelField,g=d.valueField,h=d.optgroupField,i=d.optgroupLabelField,j=d.optgroupValueField,k=function(b,c){var h,i,j,k,l=b.attr(e);if(l)for(c.options=JSON.parse(l),h=0,i=c.options.length;i>h;h++)c.items.push(c.options[h][g]);else{var m=a.trim(b.val()||"");if(!d.allowEmptyOption&&!m.length)return;for(j=m.split(d.delimiter),h=0,i=j.length;i>h;h++)k={},k[f]=j[h],k[g]=j[h],c.options.push(k);c.items=j}},l=function(b,c){var k,l,m,n,o=c.options,p={},q=function(a){var b=e&&a.attr(e);return"string"==typeof b&&b.length?JSON.parse(b):null},r=function(b,e){b=a(b);var i=z(b.attr("value"));if(i||d.allowEmptyOption)if(p.hasOwnProperty(i)){if(e){var j=p[i][h];j?a.isArray(j)?j.push(e):p[i][h]=[j,e]:p[i][h]=e}}else{var k=q(b)||{};k[f]=k[f]||b.text(),k[g]=k[g]||i,k[h]=k[h]||e,p[i]=k,o.push(k),b.is(":selected")&&c.items.push(i)}},s=function(b){var d,e,f,g,h;for(b=a(b),f=b.attr("label"),f&&(g=q(b)||{},g[i]=f,g[j]=f,c.optgroups.push(g)),h=a("option",b),d=0,e=h.length;e>d;d++)r(h[d],f)};for(c.maxItems=b.attr("multiple")?null:1,n=b.children(),k=0,l=n.length;l>k;k++)m=n[k].tagName.toLowerCase(),"optgroup"===m?s(n[k]):"option"===m&&r(n[k])};return this.each(function(){if(!this.selectize){var e,f=a(this),g=this.tagName.toLowerCase(),h=f.attr("placeholder")||f.attr("data-placeholder");h||d.allowEmptyOption||(h=f.children('option[value=""]').text());var i={placeholder:h,options:[],optgroups:[],items:[]};"select"===g?l(f,i):k(f,i),e=new L(f,a.extend(!0,{},c,i,b))}})},a.fn.selectize.defaults=L.defaults,a.fn.selectize.support={validity:x},L.define("drag_drop",function(){if(!a.fn.sortable)throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');if("multi"===this.settings.mode){var b=this;b.lock=function(){var a=b.lock;return function(){var c=b.$control.data("sortable");return c&&c.disable(),a.apply(b,arguments)}}(),b.unlock=function(){var a=b.unlock;return function(){var c=b.$control.data("sortable");return c&&c.enable(),a.apply(b,arguments)}}(),b.setup=function(){var c=b.setup;return function(){c.apply(this,arguments);var d=b.$control.sortable({items:"[data-value]",forcePlaceholderSize:!0,disabled:b.isLocked,start:function(a,b){b.placeholder.css("width",b.helper.css("width")),d.css({overflow:"visible"})},stop:function(){d.css({overflow:"hidden"});var c=b.$activeItems?b.$activeItems.slice():null,e=[];d.children("[data-value]").each(function(){e.push(a(this).attr("data-value"))}),b.setValue(e),b.setActiveItem(c)}})}}()}}),L.define("dropdown_header",function(b){var c=this;b=a.extend({title:"Untitled",headerClass:"selectize-dropdown-header",titleRowClass:"selectize-dropdown-header-title",labelClass:"selectize-dropdown-header-label",closeClass:"selectize-dropdown-header-close",html:function(a){return'<div class="'+a.headerClass+'"><div class="'+a.titleRowClass+'"><span class="'+a.labelClass+'">'+a.title+'</span><a href="javascript:void(0)" class="'+a.closeClass+'">&times;</a></div></div>'}},b),c.setup=function(){var d=c.setup;return function(){d.apply(c,arguments),c.$dropdown_header=a(b.html(b)),c.$dropdown.prepend(c.$dropdown_header)}}()}),L.define("optgroup_columns",function(b){var c=this;b=a.extend({equalizeWidth:!0,equalizeHeight:!0},b),this.getAdjacentOption=function(b,c){var d=b.closest("[data-group]").find("[data-selectable]"),e=d.index(b)+c;return e>=0&&e<d.length?d.eq(e):a()},this.onKeyDown=function(){var a=c.onKeyDown;return function(b){var d,e,f,g;return!this.isOpen||b.keyCode!==j&&b.keyCode!==m?a.apply(this,arguments):(c.ignoreHover=!0,g=this.$activeOption.closest("[data-group]"),d=g.find("[data-selectable]").index(this.$activeOption),g=b.keyCode===j?g.prev("[data-group]"):g.next("[data-group]"),f=g.find("[data-selectable]"),e=f.eq(Math.min(f.length-1,d)),void(e.length&&this.setActiveOption(e)))}}();var d=function(){var a,b=d.width,c=document;return"undefined"==typeof b&&(a=c.createElement("div"),a.innerHTML='<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>',a=a.firstChild,c.body.appendChild(a),b=d.width=a.offsetWidth-a.clientWidth,c.body.removeChild(a)),b},e=function(){var e,f,g,h,i,j,k;if(k=a("[data-group]",c.$dropdown_content),f=k.length,f&&c.$dropdown_content.width()){if(b.equalizeHeight){for(g=0,e=0;f>e;e++)g=Math.max(g,k.eq(e).height());k.css({height:g})}b.equalizeWidth&&(j=c.$dropdown_content.innerWidth()-d(),h=Math.round(j/f),k.css({width:h}),f>1&&(i=j-h*(f-1),k.eq(f-1).css({width:i})))}};(b.equalizeHeight||b.equalizeWidth)&&(C.after(this,"positionDropdown",e),C.after(this,"refreshOptions",e))}),L.define("remove_button",function(b){if("single"!==this.settings.mode){b=a.extend({label:"&times;",title:"Remove",className:"remove",append:!0},b);var c=this,d='<a href="javascript:void(0)" class="'+b.className+'" tabindex="-1" title="'+A(b.title)+'">'+b.label+"</a>",e=function(a,b){var c=a.search(/(<\/[^>]+>\s*)$/);return a.substring(0,c)+b+a.substring(c)};this.setup=function(){var f=c.setup;return function(){if(b.append){var g=c.settings.render.item;c.settings.render.item=function(){return e(g.apply(this,arguments),d)}}f.apply(this,arguments),this.$control.on("click","."+b.className,function(b){if(b.preventDefault(),!c.isLocked){var d=a(b.currentTarget).parent();c.setActiveItem(d),c.deleteSelection()&&c.setCaret(c.items.length)}})}}()}}),L.define("restore_on_backspace",function(a){var b=this;a.text=a.text||function(a){return a[this.settings.labelField]},this.onKeyDown=function(){var c=b.onKeyDown;return function(b){var d,e;return b.keyCode===p&&""===this.$control_input.val()&&!this.$activeItems.length&&(d=this.caretPos-1,d>=0&&d<this.items.length)?(e=this.options[this.items[d]],this.deleteSelection(b)&&(this.setTextboxValue(a.text.apply(this,[e])),this.refreshOptions(!0)),void b.preventDefault()):c.apply(this,arguments)}}()}),L});
</script>
<link rel="stylesheet" type="text/css" href="SimulationsAnimintRegression/vendor/selectize.css" />
<p></p>
<div id='SimulationsAnimintRegression'></div>
<script>var SimulationsAnimintRegression = new animint("#SimulationsAnimintRegression", "SimulationsAnimintRegression/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-13-train-predict-subsets-regression&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-13-train-predict-subsets-regression/">https://tdhock.github.io/2023-12-13-train-predict-subsets-regression/</a></p>
<h2 id="simulated-classification-problems_1">Simulated classification problems</h2>
<p>The previous section investigated a simulated regression problem, whereas in this section we simulate a binary classification problem.
Assume there is a data set with some rows from one person, some rows
from another,</p>
<pre><code class="language-r">N &lt;- 200
library(data.table)
(full.dt &lt;- data.table(
  label=factor(rep(c(&quot;spam&quot;,&quot;not spam&quot;), l=N)),
  person=rep(1:2, each=0.5*N)
)[, signal := ifelse(label==&quot;not spam&quot;, 0, 3)][])
#&gt;         label person signal
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;
#&gt;   1:     spam      1      3
#&gt;   2: not spam      1      0
#&gt;   3:     spam      1      3
#&gt;   4: not spam      1      0
#&gt;   5:     spam      1      3
#&gt;  ---                       
#&gt; 196: not spam      2      0
#&gt; 197:     spam      2      3
#&gt; 198: not spam      2      0
#&gt; 199:     spam      2      3
#&gt; 200: not spam      2      0
</code></pre>
<p>Above each row has an person ID between 1 and 2.
We can imagine a spam filtering system, that has training data for multiple people (here just two).
Each row in the table above represents a message which has been labeled as spam or not, by one of the two people.
Can we train on one person, and accurately predict on the other person?
To do that we will need some features, which we generate/simulate below:</p>
<pre><code class="language-r">set.seed(1)
n.people &lt;- length(unique(full.dt$person))
for(person.i in 1:n.people){
  use.signal.vec &lt;- list(
    easy=rep(if(person.i==1)TRUE else FALSE, N),
    impossible=full.dt$person==person.i)
  for(task_id in names(use.signal.vec)){
    use.signal &lt;- use.signal.vec[[task_id]]
    full.dt[
    , paste0(&quot;x&quot;,person.i,&quot;_&quot;,task_id) := ifelse(
      use.signal, signal, 0
    )+rnorm(N)][]
  }
}
full.dt
#&gt;         label person signal    x1_easy x1_impossible    x2_easy x2_impossible
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;      &lt;num&gt;         &lt;num&gt;      &lt;num&gt;         &lt;num&gt;
#&gt;   1:     spam      1      3  2.3735462     3.4094018  1.0744410    -0.3410670
#&gt;   2: not spam      1      0  0.1836433     1.6888733  1.8956548     1.5024245
#&gt;   3:     spam      1      3  2.1643714     4.5865884 -0.6029973     0.5283077
#&gt;   4: not spam      1      0  1.5952808    -0.3309078 -0.3908678     0.5421914
#&gt;   5:     spam      1      3  3.3295078     0.7147645 -0.4162220    -0.1366734
#&gt;  ---                                                                         
#&gt; 196: not spam      2      0 -1.0479844    -0.9243128  0.7682782    -1.0293917
#&gt; 197:     spam      2      3  4.4411577     1.5929138 -0.8161606     2.9890743
#&gt; 198: not spam      2      0 -1.0158475     0.0450106 -0.4361069    -1.2249912
#&gt; 199:     spam      2      3  3.4119747    -0.7151284  0.9047050     0.4038886
#&gt; 200: not spam      2      0 -0.3810761     0.8652231 -0.7630863     1.1691226
</code></pre>
<p>In the table above, there are two sets of two features:</p>
<ul>
<li>For easy features, one is correlated with the label (<code>x1_easy</code>), and
one is random noise (<code>x2_easy</code>), so the algorithm just needs to
learn to ignore the noise feature, and concentrate on the signal
feature. That should be possible given data from either person (same
signal in each person).</li>
<li>Each impossible feature is correlated with the label (when feature
number same as person number), or is just noise (when person number
different from feature number). So if the algorithm has access to
the correct person (same as test, say person 2), then it needs to
learn to use the corresponding feature <code>x2_impossible</code>. But if
the algorithm does not have access to that person, then the best it
can do is same as featureless (predict most frequent class label in
train data).</li>
</ul>
<h3 id="static-visualization-of-simulated-data_2">Static visualization of simulated data</h3>
<p>Below we reshape the data to a table which is more suitable for visualization:</p>
<pre><code class="language-r">(scatter.dt &lt;- nc::capture_melt_multiple(
  full.dt,
  column=&quot;x[12]&quot;,
  &quot;_&quot;,
  task_id=&quot;easy|impossible&quot;))
#&gt;         label person signal    task_id         x1         x2
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;     &lt;char&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;   1:     spam      1      3       easy  2.3735462  1.0744410
#&gt;   2: not spam      1      0       easy  0.1836433  1.8956548
#&gt;   3:     spam      1      3       easy  2.1643714 -0.6029973
#&gt;   4: not spam      1      0       easy  1.5952808 -0.3908678
#&gt;   5:     spam      1      3       easy  3.3295078 -0.4162220
#&gt;  ---                                                        
#&gt; 396: not spam      2      0 impossible -0.9243128 -1.0293917
#&gt; 397:     spam      2      3 impossible  1.5929138  2.9890743
#&gt; 398: not spam      2      0 impossible  0.0450106 -1.2249912
#&gt; 399:     spam      2      3 impossible -0.7151284  0.4038886
#&gt; 400: not spam      2      0 impossible  0.8652231  1.1691226
</code></pre>
<p>Below we visualize the pattern for each person and feature type:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x1, x2, color=label),
      shape=1,
      data=scatter.dt)+
    facet_grid(
      task_id ~ person,
      labeller=label_both)
}
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAIAAABHLKd9AAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nOydd2BUVfbHz339zUwyk2TSJhUSQHovglIEFLCwFhALa9ldcO3uT91i2RXXsrq7sq67dtdKExQiIgiiFJFiIALSA4T0ZDKZ/t68dn9/TAxDGjOYkAD389dkcua+M+++95377j33HIQxBgKBQCAAUJ3tAIFAIHQViCASCARCA0QQCQQCoQEiiAQCgdAAc9aO5HQ6z9qxCD8TURTNZnPkO6T7ziEEQbBYLJ3txTnJ2RNEl8t11o5F+JkkJCQ0EcT6+noSkHCuYLVaiSCeGeSRmUAgEBoggkggEAgNEEEkEAiEBoggEggEQgNEEDsNp9N59913d7YXhDNh4cKFt9xyy4wZM+bPn6/reme7Q2g3iCBGha7rPp+vHRtctGjRI488oqpqO7ZJaI327b5Dhw4tXbr0jTfeePfdd48dO7Zq1ar2apnQ6Zy9sJsuyGeffXb8+HGn0+n1erOysu6//36GYZYsWbJ8+XKGYS677LLbb7997969y5YtKykpmTRp0vTp05955pkjR45wHPd///d/gwcPBoB333137dq1CKHLL7/8l7/85d69e1esWGG328vLy2ma/v3vfw8AU6dOXbZsWWJiYuOh8/Lypk+f/vnnn3falz/36azuczqd06dPD4clXXzxxVVVVZ14EgjtywUtiACwdevWt99+WxCEF154YdWqVVlZWevXr3/99ddpmp43b966devS0tJ27NjxxhtvOByOgoKCuLi4JUuWFBYWfvvtt4MHD962bduOHTvefvttAHjooYd69+4tiuKmTZuWLl1qsVgee+yxwsLC0aNHv//++1arNfK4w4cPT0tLI4L4M+mU7hs9evTo0aMBwOl0rl69+pFHHum0709oby70R+ZRo0YJggAAEyZM2Llz565du3w+31NPPfXkk09WVVUdOHAAAPr16+dwOACgb9++u3fvfuedd0RRvPfeewGgqKjoiiuuEARBEITJkycXFRUBQJ8+fcJhsQ6HQ1EUhFBWVhZN0535Pc9TOrH7Pvvss3vvvffOO+/s27fvWf7WhI7jQh8hGoYRfhGeGhcE4eqrr541a1bjO/v37+d5PmyTl5f35ptvrl+//t133xUEYd68eRhjhFD4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" alt="plot of chunk unnamed-chunk-13" /></p>
<p>In the plot above, it is apparent that</p>
<ul>
<li>for easy features (left), the two label classes differ in x1 values
for both people. So it should be possible/easy to train on person 1, and
predict accurately on person 2.</li>
<li>for impossible features (right), the two people have different label
patterns. For person 1, the two label classes differ in x1 values,
whereas for person 2, the two label classes differ in x2 values. So
it should be impossible to train on person 1, and predict accurately
on person 2.</li>
</ul>
<h3 id="benchmark-computing-test-error_2">Benchmark: computing test error</h3>
<p>We use the code below to create a list of classification tasks, for
use in the mlr3 framework.</p>
<pre><code class="language-r">class.task.list &lt;- list()
for(task_id in c(&quot;easy&quot;,&quot;impossible&quot;)){
  feature.names &lt;- grep(task_id, names(full.dt), value=TRUE)
  task.col.names &lt;- c(feature.names, &quot;label&quot;, &quot;person&quot;)
  task.dt &lt;- full.dt[, task.col.names, with=FALSE]
  this.task &lt;- mlr3::TaskClassif$new(
    task_id, task.dt, target=&quot;label&quot;)
  this.task$col_roles$subset &lt;- &quot;person&quot;
  this.task$col_roles$stratum &lt;- c(&quot;person&quot;,&quot;label&quot;)
  this.task$col_roles$feature &lt;- setdiff(names(task.dt), this.task$col_roles$stratum)
  class.task.list[[task_id]] &lt;- this.task
}
class.task.list
#&gt; $easy
#&gt; &lt;TaskClassif:easy&gt; (200 x 3)
#&gt; * Target: label
#&gt; * Properties: twoclass, strata
#&gt; * Features (2):
#&gt;   - dbl (2): x1_easy, x2_easy
#&gt; * Strata: person, label
#&gt; 
#&gt; $impossible
#&gt; &lt;TaskClassif:impossible&gt; (200 x 3)
#&gt; * Target: label
#&gt; * Properties: twoclass, strata
#&gt; * Features (2):
#&gt;   - dbl (2): x1_impossible, x2_impossible
#&gt; * Strata: person, label
</code></pre>
<p>Note in the code above that person is assigned roles subset and
stratum, whereas label is assigned roles target and stratum.  When
adapting the code above to real data, the important part is the
<code>mlr3::TaskClassif</code> line which tells mlr3 what data set to use, and
what columns should be used for target/subset/stratum.</p>
<p>The code below is used to define a K-fold cross-validation experiment,</p>
<pre><code class="language-r">(class_same_other &lt;- mlr3resampling::ResamplingSameOtherCV$new())
#&gt; &lt;ResamplingSameOtherCV&gt; : Same versus Other Cross-Validation
#&gt; * Iterations:
#&gt; * Instantiated: FALSE
#&gt; * Parameters:
#&gt; List of 1
#&gt;  $ folds: int 3
</code></pre>
<p>The code below is used to define the learning algorithms to test,</p>
<pre><code class="language-r">(class.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerClassifRpart$new(),
  mlr3::LearnerClassifFeatureless$new()))
#&gt; [[1]]
#&gt; &lt;LearnerClassifRpart:classif.rpart&gt;: Classification Tree
#&gt; * Model: -
#&gt; * Parameters: xval=0
#&gt; * Packages: mlr3, rpart
#&gt; * Predict Types:  [response], prob
#&gt; * Feature Types: logical, integer, numeric, factor, ordered
#&gt; * Properties: importance, missings, multiclass, selected_features,
#&gt;   twoclass, weights
#&gt; 
#&gt; [[2]]
#&gt; &lt;LearnerClassifFeatureless:classif.featureless&gt;: Featureless Classification Learner
#&gt; * Model: -
#&gt; * Parameters: method=mode
#&gt; * Packages: mlr3
#&gt; * Predict Types:  [response], prob
#&gt; * Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt;   POSIXct
#&gt; * Properties: featureless, importance, missings, multiclass,
#&gt;   selected_features, twoclass
</code></pre>
<p>The code below defines the grid of tasks, learners, and resamplings.</p>
<pre><code class="language-r">(class.bench.grid &lt;- mlr3::benchmark_grid(
  class.task.list,
  class.learner.list,
  class_same_other))
#&gt;          task             learner    resampling
#&gt;        &lt;char&gt;              &lt;char&gt;        &lt;char&gt;
#&gt; 1:       easy       classif.rpart same_other_cv
#&gt; 2:       easy classif.featureless same_other_cv
#&gt; 3: impossible       classif.rpart same_other_cv
#&gt; 4: impossible classif.featureless same_other_cv
</code></pre>
<p>The code below runs the benchmark experiment grid. Note that each
iteration can be parallelized by declaring a future plan.</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(class.bench.result &lt;- mlr3::benchmark(
  class.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 72 rows with 4 resampling runs
#&gt;  nr    task_id          learner_id resampling_id iters warnings errors
#&gt;   1       easy       classif.rpart same_other_cv    18        0      0
#&gt;   2       easy classif.featureless same_other_cv    18        0      0
#&gt;   3 impossible       classif.rpart same_other_cv    18        0      0
#&gt;   4 impossible classif.featureless same_other_cv    18        0      0
</code></pre>
<p>Below we compute scores (test error) for each resampling iteration,
and show the first row of the result.</p>
<pre><code class="language-r">class.bench.score &lt;- mlr3resampling::score(class.bench.result)
class.bench.score[1]
#&gt;    train.subsets test.fold test.subset person iteration                  test
#&gt;           &lt;char&gt;     &lt;int&gt;       &lt;int&gt;  &lt;int&gt;     &lt;int&gt;                &lt;list&gt;
#&gt; 1:           all         1           1      1         1  1, 2, 8,11,12,18,...
#&gt;                    train                                uhash    nr
#&gt;                   &lt;list&gt;                               &lt;char&gt; &lt;int&gt;
#&gt; 1:  3, 4, 5, 6, 9,10,... feb4f442-9d38-4b1b-82a6-451c8f71e02b     1
#&gt;                  task task_id                             learner    learner_id
#&gt;                &lt;list&gt;  &lt;char&gt;                              &lt;list&gt;        &lt;char&gt;
#&gt; 1: &lt;TaskClassif:easy&gt;    easy &lt;LearnerClassifRpart:classif.rpart&gt; classif.rpart
#&gt;                 resampling resampling_id          prediction classif.ce
#&gt;                     &lt;list&gt;        &lt;char&gt;              &lt;list&gt;      &lt;num&gt;
#&gt; 1: &lt;ResamplingSameOtherCV&gt; same_other_cv &lt;PredictionClassif&gt; 0.08823529
#&gt;    algorithm
#&gt;       &lt;char&gt;
#&gt; 1:     rpart
</code></pre>
<p>Finally we plot the test error values below.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      classif.ce, train.subsets, color=algorithm),
      shape=1,
      data=class.bench.score)+
    facet_grid(
      person ~ task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAIAAABHLKd9AAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nOzdZ3wU5f428PuemW3Z3WTTCyW00CUJhN5LEAJIO6gUBduh+UeD5dgeFMtB4SgooigiWJB2aHJQehMElGIgkEAQAqRBGkm2787M82LHNaTubkKWhOv7gs8wue+Z38zOXjtld4aKokgAAIAQxtsFAADcKxCIAAASBCIAgASBCAAg4bxdQFXy8vK8XQIQQohKpVKr1aXH4KW5RyiVSo1G4+0qGo57OhALCgq8XQIQQoi/v3+ZQCwsLMT3E+4Ffn5+CMRahENmAAAJAhEAQIJABACQIBABACT3eyAWFxdPnTrVxca7du1avnx51W0OHDgwY8aM0mPWrl27adMmD+triLy4zsu3vEscM9q+ffs333xTevzp06ffeeedOigAPHNPX2Wuj7p3796+fXtvV3F/cX2d19mr45jRb7/9Vgfzglp0vwfi4sWLb926tWTJkueee27p0qWHDx/WarVdunSZPXu20Wh87733Ll++LJfLX3jhhdjYWGevb775Jj09/Y033mBZtswEr1y5snHjxnnz5n3yyScnTpzw9/dv3Lhx27ZtzWbz8OHDN23aFBAQ4Gy8YcOGrVu3chw3aNCgadOmiaJYbQ2LFi2KjY0dMmQIz/OTJ09evny5Tqero5VVS7y4zh0tJ0yYsG7dOl9f34yMjPbt21NKb9y4Ybfb33nnnZ07d6anp+fl5RUXFzdp0mTOnDkcx61evXrPnj2U0qFDhz7++OMGg6FMkeXHOGYUFxeXkZExZ86cW7duxcbGJiYmOmsu89Lf/bUOLrnfD5kTExNDQkKef/759PT0jIyM9evXf/XVV8ePH8/IyNi3b59Wq92wYUNiYuLRo0edXTZs2HDp0qUK35lOO3bsyMnJ+f777//973+fO3eOEKJQKL799ls/Pz9nmzNnzuzfv/+LL75Yvnx5amrq3r17Xalh4MCBBw4cIIScPn26devW9S4NiVfXuVNycnJiYuLChQu3bNkSExPz7rvvKhSK06dPE0KOHz/+6quvLl682G63//TTTydOnPj9999Xrlz51VdfHTt27Pfffy9fZGVlE0KSkpLefvvtNWvWFBYW/vjjj46R5V/62livUAvu90B0at68+WuvvXby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" alt="plot of chunk unnamed-chunk-20" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>for the easy task, training on same is just as good as all or other
subsets.</li>
<li>for the impossible task, we must train on same subset for minimal
test error; training on all is almost as good, because the pattern
in person 1 is orthogonal to person 2; training on other is just as
bad as featureless, because patterns are different.</li>
<li>in a real data task, training on other will most likely not be quite as bad as in the impossible task above, but also not as good as in the easy task.</li>
</ul>
<h3 id="interactive-visualization-of-data-test-error-and-splits_2">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">inst &lt;- class.bench.score$resampling[[1]]$instance
rect.expand &lt;- 0.2
grid.value.dt &lt;- scatter.dt[
, lapply(.SD, function(x)do.call(seq, c(as.list(range(x)), l=21)))
, .SDcols=c(&quot;x1&quot;,&quot;x2&quot;)]
grid.class.dt &lt;- data.table(
  label=full.dt$label[1],
  do.call(
    CJ, grid.value.dt
  )
)
class.pred.dt.list &lt;- list()
class.point.dt.list &lt;- list()
for(score.i in 1:nrow(class.bench.score)){
  class.bench.row &lt;- class.bench.score[score.i]
  task.dt &lt;- data.table(
    class.bench.row$task[[1]]$data(),
    class.bench.row$resampling[[1]]$instance$id.dt)
  names(task.dt)[2:3] &lt;- c(&quot;x1&quot;,&quot;x2&quot;)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=class.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ][]
  class.point.dt.list[[score.i]] &lt;- data.table(
    class.bench.row[, .(task_id, iteration)],
    i.points)
  if(class.bench.row$algorithm!=&quot;featureless&quot;){
    i.learner &lt;- class.bench.row$learner[[1]]
    i.learner$predict_type &lt;- &quot;prob&quot;
    i.task &lt;- class.bench.row$task[[1]]
    setnames(grid.class.dt, names(i.task$data()))
    grid.class.task &lt;- mlr3::TaskClassif$new(
      &quot;grid&quot;, grid.class.dt, target=&quot;label&quot;)
    pred.grid &lt;- as.data.table(
      i.learner$predict(grid.class.task)
    )[, data.table(grid.class.dt, prob.spam)]
    names(pred.grid)[2:3] &lt;- c(&quot;x1&quot;,&quot;x2&quot;)
    pred.wide &lt;- dcast(pred.grid, x1 ~ x2, value.var=&quot;prob.spam&quot;)
    prob.mat &lt;- as.matrix(pred.wide[,-1])
    contour.list &lt;- contourLines(
      grid.value.dt$x1, grid.value.dt$x2, prob.mat, levels=0.5)
    class.pred.dt.list[[score.i]] &lt;- data.table(
      class.bench.row[, .(
        task_id, iteration, algorithm
      )],
      data.table(contour.i=seq_along(contour.list))[, {
        do.call(data.table, contour.list[[contour.i]])[, .(level, x1=x, x2=y)]
      }, by=contour.i]
    )
  }
}
(class.pred.dt &lt;- rbindlist(class.pred.dt.list))
#&gt;         task_id iteration algorithm contour.i level       x1        x2
#&gt;          &lt;char&gt;     &lt;int&gt;    &lt;char&gt;     &lt;int&gt; &lt;num&gt;    &lt;num&gt;     &lt;num&gt;
#&gt;   1:       easy         1     rpart         1   0.5 1.856156 -3.008049
#&gt;   2:       easy         1     rpart         1   0.5 1.856156 -2.606579
#&gt;   3:       easy         1     rpart         1   0.5 1.856156 -2.205109
#&gt;   4:       easy         1     rpart         1   0.5 1.856156 -1.803639
#&gt;   5:       easy         1     rpart         1   0.5 1.856156 -1.402169
#&gt;  ---                                                                  
#&gt; 766: impossible        18     rpart         1   0.5 3.743510  1.225096
#&gt; 767: impossible        18     rpart         1   0.5 4.158037  1.225096
#&gt; 768: impossible        18     rpart         1   0.5 4.572564  1.225096
#&gt; 769: impossible        18     rpart         1   0.5 4.987091  1.225096
#&gt; 770: impossible        18     rpart         1   0.5 5.401618  1.225096
(class.point.dt &lt;- rbindlist(class.point.dt.list))
#&gt;           task_id iteration set.name row_id    label         x1         x2
#&gt;            &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;   &lt;fctr&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;     1:       easy         1     test      1     spam  2.3735462  1.0744410
#&gt;     2:       easy         1     test      2 not spam  0.1836433  1.8956548
#&gt;     3:       easy         1    train      3     spam  2.1643714 -0.6029973
#&gt;     4:       easy         1    train      4 not spam  1.5952808 -0.3908678
#&gt;     5:       easy         1    train      5     spam  3.3295078 -0.4162220
#&gt;    ---                                                                    
#&gt; 14396: impossible        18    train    196 not spam -0.9243128 -1.0293917
#&gt; 14397: impossible        18    train    197     spam  1.5929138  2.9890743
#&gt; 14398: impossible        18    train    198 not spam  0.0450106 -1.2249912
#&gt; 14399: impossible        18    train    199     spam -0.7151284  0.4038886
#&gt; 14400: impossible        18    train    200 not spam  0.8652231  1.1691226
#&gt;         fold person subset display_row
#&gt;        &lt;int&gt;  &lt;int&gt;  &lt;int&gt;       &lt;int&gt;
#&gt;     1:     1      1      1           1
#&gt;     2:     1      1      1           2
#&gt;     3:     2      1      1          35
#&gt;     4:     2      1      1          36
#&gt;     5:     2      1      1          37
#&gt;    ---                                
#&gt; 14396:     2      2      2         166
#&gt; 14397:     2      2      2         167
#&gt; 14398:     1      2      2         133
#&gt; 14399:     1      2      2         134
#&gt; 14400:     2      2      2         168

set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
make_person_subset &lt;- function(DT){
  DT[, &quot;person/subset&quot; := person]
}
make_person_subset(class.point.dt)
make_person_subset(class.bench.score)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Train/predict on subsets, classification&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      scale_color_manual(values=c(spam=&quot;black&quot;,&quot;not spam&quot;=&quot;white&quot;))+
      geom_point(aes(
        x1, x2, color=label, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        stroke=2,
        shape=21,
        data=class.point.dt)+
      geom_path(aes(
        x1, x2, 
        subset=paste(algorithm, iteration, contour.i)),
        showSelected=c(&quot;iteration&quot;,&quot;algorithm&quot;),
        color=algo.colors[[&quot;rpart&quot;]],
        data=class.pred.dt)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;)+
      scale_y_continuous(
        breaks=seq(-100, 100, by=2)),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      scale_y_continuous(
        &quot;Classification error on test set&quot;,
        breaks=seq(0, 1, by=0.25))+
      scale_fill_manual(values=algo.colors)+
      scale_x_discrete(
        &quot;People/subsets in train set&quot;)+
      geom_hline(aes(
        yintercept=yint),
        data=data.table(yint=0.5),
        color=&quot;grey50&quot;)+
      geom_point(aes(
        train.subsets, classif.ce, fill=algorithm),
        shape=1,
        size=5,
        stroke=2,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=class.bench.score)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both),
    diagram=ggplot()+
      ggtitle(&quot;Select train/test split&quot;)+
      theme_bw()+
      theme_animint(height=300)+
      facet_grid(
        . ~ train.subsets,
        scales=&quot;free&quot;,
        space=&quot;free&quot;)+
      scale_size_manual(values=c(subset=3, fold=1))+
      scale_color_manual(values=c(subset=&quot;orange&quot;, fold=&quot;grey50&quot;))+
      geom_rect(aes(
        xmin=-Inf, xmax=Inf,
        color=rows,
        size=rows,
        ymin=display_row, ymax=display_end),
        fill=NA,
        data=inst$viz.rect.dt)+
      scale_fill_manual(values=set.colors)+
      geom_rect(aes(
        xmin=iteration-rect.expand, ymin=display_row,
        xmax=iteration+rect.expand, ymax=display_end,
        fill=set.name),
        clickSelects=&quot;iteration&quot;,
        data=inst$viz.set.dt)+
      geom_text(aes(
        ifelse(rows==&quot;subset&quot;, Inf, -Inf),
        (display_row+display_end)/2,
        hjust=ifelse(rows==&quot;subset&quot;, 1, 0),
        label=paste0(rows, &quot;=&quot;, ifelse(rows==&quot;subset&quot;, subset, fold))),
        data=data.table(train.name=&quot;same&quot;, inst$viz.rect.dt))+
      scale_x_continuous(
        &quot;Split number / cross-validation iteration&quot;)+
      scale_y_continuous(
        &quot;Row number&quot;),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/ResamplingSameOtherCV.Rmd&quot;)
  viz
}
</code></pre>
<p></p>
<div id='SimulationsAnimintClassification'></div>
<script>var SimulationsAnimintClassification = new animint("#SimulationsAnimintClassification", "SimulationsAnimintClassification/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-13-train-predict-subsets-classification&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-13-train-predict-subsets-classification/">https://tdhock.github.io/2023-12-13-train-predict-subsets-classification/</a></p>
<h2 id="conclusion_1">Conclusion</h2>
<p>In this section we have shown how to use mlr3resampling for comparing
test error of models trained on same/all/other subsets.</p>
<h1 id="variable-size-train-resampler">Variable size train resampler</h1>
<p>The goal of this section is to explain how to
<code>ResamplingVariableSizeTrainCV</code>, which can be used to determine how
many train data are necessary to provide accurate predictions on a
given test set.</p>
<h2 id="simulated-regression-problems_2">Simulated regression problems</h2>
<p>The code below creates data for simulated regression problems. First
we define a vector of input values,</p>
<pre><code class="language-r">N &lt;- 300
abs.x &lt;- 10
set.seed(1)
x.vec &lt;- runif(N, -abs.x, abs.x)
str(x.vec)
#&gt;  num [1:300] -4.69 -2.56 1.46 8.16 -5.97 ...
</code></pre>
<p>Below we define a list of two true regression functions (tasks in mlr3
terminology) for our simulated data,</p>
<pre><code class="language-r">reg.pattern.list &lt;- list(
  sin=sin,
  constant=function(x)0)
</code></pre>
<p>The constant function represents a regression problem which can be
solved by always predicting the mean value of outputs (featureless is
the best possible learning algorithm). The sin function will be used
to generate data with a non-linear pattern that will need to be
learned. Below we use a for loop over these two functions/tasks, to
simulate the data which will be used as input to the learning
algorithms:</p>
<pre><code class="language-r">library(data.table)
reg.task.list &lt;- list()
reg.data.list &lt;- list()
for(task_id in names(reg.pattern.list)){
  f &lt;- reg.pattern.list[[task_id]]
  task.dt &lt;- data.table(
    x=x.vec,
    y = f(x.vec)+rnorm(N,sd=0.5))
  reg.data.list[[task_id]] &lt;- data.table(task_id, task.dt)
  reg.task.list[[task_id]] &lt;- mlr3::TaskRegr$new(
    task_id, task.dt, target=&quot;y&quot;
  )
}
(reg.data &lt;- rbindlist(reg.data.list))
#&gt;       task_id         x          y
#&gt;        &lt;char&gt;     &lt;num&gt;      &lt;num&gt;
#&gt;   1:      sin -4.689827  1.2248390
#&gt;   2:      sin -2.557522 -0.5607042
#&gt;   3:      sin  1.457067  0.8345056
#&gt;   4:      sin  8.164156  0.4875994
#&gt;   5:      sin -5.966361 -0.4321800
#&gt;  ---                              
#&gt; 596: constant  3.628850 -0.6728968
#&gt; 597: constant -8.016618  0.5168327
#&gt; 598: constant -7.621949 -0.4058882
#&gt; 599: constant -8.991207  0.9008627
#&gt; 600: constant  8.585078  0.8857710
</code></pre>
<p>In the table above, the input is x, and the output is y. Below we
visualize these data, with one task in each facet/panel:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x, y),
      data=reg.data)+
    facet_grid(task_id ~ ., labeller=label_both)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-24" /></p>
<p>In the plot above we can see two different simulated data sets
(constant and sin).  Note that the code above used the <code>animint2</code>
package, which provides interactive extensions to the static graphics
of the <code>ggplot2</code> package (see below section Interactive data viz).</p>
<h3 id="visualizing-instance-table">Visualizing instance table</h3>
<p>In the code below, we define a K-fold cross-validation experiment,
with K=3 folds.</p>
<pre><code class="language-r">reg_size_cv &lt;- mlr3resampling::ResamplingVariableSizeTrainCV$new()
reg_size_cv$param_set$values$train_sizes &lt;- 6
reg_size_cv
#&gt; &lt;ResamplingVariableSizeTrainCV&gt; : Cross-Validation with variable size train sets
#&gt; * Iterations:
#&gt; * Instantiated: FALSE
#&gt; * Parameters:
#&gt; List of 4
#&gt;  $ folds         : int 3
#&gt;  $ min_train_data: int 10
#&gt;  $ random_seeds  : int 3
#&gt;  $ train_sizes   : int 6
</code></pre>
<p>In the output above we can see the parameters of the resampling
object, all of which should be integer scalars:</p>
<ul>
<li><code>folds</code> is the number of cross-validation folds.</li>
<li><code>min_train_data</code> is the minimum number of train data to consider.</li>
<li><code>random_seeds</code> is the number of random seeds, each of which
determines a different random ordering of the train data. The random
ordering determines which data are included in small train set
sizes.</li>
<li><code>train_sizes</code> is the number of train set sizes, evenly spaced on a
log scale, from <code>min_train_data</code> to the max number of train data
(determined by <code>folds</code>).</li>
</ul>
<p>Below we instantiate the resampling on one of the tasks:</p>
<pre><code class="language-r">reg_size_cv$instantiate(reg.task.list[[&quot;sin&quot;]])
reg_size_cv$instance
#&gt; $iteration.dt
#&gt;     test.fold  seed small_stratum_size train_size_i train_size
#&gt;         &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt;  1:         1     1                 10            1         10
#&gt;  2:         1     1                 18            2         18
#&gt;  3:         1     1                 33            3         33
#&gt;  4:         1     1                 60            4         60
#&gt;  5:         1     1                110            5        110
#&gt;  6:         1     1                200            6        200
#&gt;  7:         1     2                 10            1         10
#&gt;  8:         1     2                 18            2         18
#&gt;  9:         1     2                 33            3         33
#&gt; 10:         1     2                 60            4         60
#&gt; 11:         1     2                110            5        110
#&gt; 12:         1     2                200            6        200
#&gt; 13:         1     3                 10            1         10
#&gt; 14:         1     3                 18            2         18
#&gt; 15:         1     3                 33            3         33
#&gt; 16:         1     3                 60            4         60
#&gt; 17:         1     3                110            5        110
#&gt; 18:         1     3                200            6        200
#&gt; 19:         2     1                 10            1         10
#&gt; 20:         2     1                 18            2         18
#&gt; 21:         2     1                 33            3         33
#&gt; 22:         2     1                 60            4         60
#&gt; 23:         2     1                110            5        110
#&gt; 24:         2     1                200            6        200
#&gt; 25:         2     2                 10            1         10
#&gt; 26:         2     2                 18            2         18
#&gt; 27:         2     2                 33            3         33
#&gt; 28:         2     2                 60            4         60
#&gt; 29:         2     2                110            5        110
#&gt; 30:         2     2                200            6        200
#&gt; 31:         2     3                 10            1         10
#&gt; 32:         2     3                 18            2         18
#&gt; 33:         2     3                 33            3         33
#&gt; 34:         2     3                 60            4         60
#&gt; 35:         2     3                110            5        110
#&gt; 36:         2     3                200            6        200
#&gt; 37:         3     1                 10            1         10
#&gt; 38:         3     1                 18            2         18
#&gt; 39:         3     1                 33            3         33
#&gt; 40:         3     1                 60            4         60
#&gt; 41:         3     1                110            5        110
#&gt; 42:         3     1                200            6        200
#&gt; 43:         3     2                 10            1         10
#&gt; 44:         3     2                 18            2         18
#&gt; 45:         3     2                 33            3         33
#&gt; 46:         3     2                 60            4         60
#&gt; 47:         3     2                110            5        110
#&gt; 48:         3     2                200            6        200
#&gt; 49:         3     3                 10            1         10
#&gt; 50:         3     3                 18            2         18
#&gt; 51:         3     3                 33            3         33
#&gt; 52:         3     3                 60            4         60
#&gt; 53:         3     3                110            5        110
#&gt; 54:         3     3                200            6        200
#&gt;     test.fold  seed small_stratum_size train_size_i train_size
#&gt;                           train                  test iteration train_min_size
#&gt;                          &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt;  1: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         1             10
#&gt;  2: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         2             18
#&gt;  3: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         3             33
#&gt;  4: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         4             60
#&gt;  5: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         5            110
#&gt;  6: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         6            200
#&gt;  7: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         7             10
#&gt;  8: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         8             18
#&gt;  9: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         9             33
#&gt; 10: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        10             60
#&gt; 11: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        11            110
#&gt; 12: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        12            200
#&gt; 13:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        13             10
#&gt; 14:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        14             18
#&gt; 15:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        15             33
#&gt; 16:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        16             60
#&gt; 17:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        17            110
#&gt; 18:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        18            200
#&gt; 19: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        19             10
#&gt; 20: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        20             18
#&gt; 21: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        21             33
#&gt; 22: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        22             60
#&gt; 23: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        23            110
#&gt; 24: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        24            200
#&gt; 25: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        25             10
#&gt; 26: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        26             18
#&gt; 27: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        27             33
#&gt; 28: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        28             60
#&gt; 29: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        29            110
#&gt; 30: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        30            200
#&gt; 31:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        31             10
#&gt; 32:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        32             18
#&gt; 33:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        33             33
#&gt; 34:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        34             60
#&gt; 35:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        35            110
#&gt; 36:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        36            200
#&gt; 37: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        37             10
#&gt; 38: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        38             18
#&gt; 39: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        39             33
#&gt; 40: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        40             60
#&gt; 41: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        41            110
#&gt; 42: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        42            200
#&gt; 43: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        43             10
#&gt; 44: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        44             18
#&gt; 45: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        45             33
#&gt; 46: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        46             60
#&gt; 47: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        47            110
#&gt; 48: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        48            200
#&gt; 49:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        49             10
#&gt; 50:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        50             18
#&gt; 51:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        51             33
#&gt; 52:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        52             60
#&gt; 53:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        53            110
#&gt; 54:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        54            200
#&gt;                           train                  test iteration train_min_size
#&gt; 
#&gt; $id.dt
#&gt;      row_id  fold
#&gt;       &lt;int&gt; &lt;int&gt;
#&gt;   1:      1     1
#&gt;   2:      2     3
#&gt;   3:      3     3
#&gt;   4:      4     2
#&gt;   5:      5     3
#&gt;  ---             
#&gt; 296:    296     2
#&gt; 297:    297     1
#&gt; 298:    298     1
#&gt; 299:    299     3
#&gt; 300:    300     2
</code></pre>
<p>Above we see the instance, which need not be examined by the user, but
for informational purposes, it contains the following data:</p>
<ul>
<li><code>iteration.dt</code> has one row for each train/test split,</li>
<li><code>id.dt</code> has one row for each data point.</li>
</ul>
<h3 id="benchmark-computing-test-error_3">Benchmark: computing test error</h3>
<p>In the code below, we define two learners to compare,</p>
<pre><code class="language-r">(reg.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerRegrRpart$new(),
  mlr3::LearnerRegrFeatureless$new()))
#&gt; [[1]]
#&gt; &lt;LearnerRegrRpart:regr.rpart&gt;: Regression Tree
#&gt; * Model: -
#&gt; * Parameters: xval=0
#&gt; * Packages: mlr3, rpart
#&gt; * Predict Types:  [response]
#&gt; * Feature Types: logical, integer, numeric, factor, ordered
#&gt; * Properties: importance, missings, selected_features, weights
#&gt; 
#&gt; [[2]]
#&gt; &lt;LearnerRegrFeatureless:regr.featureless&gt;: Featureless Regression Learner
#&gt; * Model: -
#&gt; * Parameters: robust=FALSE
#&gt; * Packages: mlr3, stats
#&gt; * Predict Types:  [response], se
#&gt; * Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt;   POSIXct
#&gt; * Properties: featureless, importance, missings, selected_features
</code></pre>
<p>The code above defines</p>
<ul>
<li><code>regr.rpart</code>: Regression Tree learning algorithm, which should be
able to learn the non-linear pattern in the sin data (if there are
enough data in the train set).</li>
<li><code>regr.featureless</code>: Featureless Regression learning algorithm, which
should be optimal for the constant data, and can be used as a
baseline in the sin data. When the rpart learner gets smaller
prediction error rates than featureless, then we know that it has
learned some non-trivial relationship between inputs and outputs.</li>
</ul>
<p>In the code below, we define the benchmark grid, which is all
combinations of tasks (constant and sin), learners (rpart and
featureless), and the one resampling method.</p>
<pre><code class="language-r">(reg.bench.grid &lt;- mlr3::benchmark_grid(
  reg.task.list,
  reg.learner.list,
  reg_size_cv))
#&gt;        task          learner             resampling
#&gt;      &lt;char&gt;           &lt;char&gt;                 &lt;char&gt;
#&gt; 1:      sin       regr.rpart variable_size_train_cv
#&gt; 2:      sin regr.featureless variable_size_train_cv
#&gt; 3: constant       regr.rpart variable_size_train_cv
#&gt; 4: constant regr.featureless variable_size_train_cv
</code></pre>
<p>In the code below, we execute the benchmark experiment (optionally in parallel
using the multisession future plan).</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(reg.bench.result &lt;- mlr3::benchmark(
  reg.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 216 rows with 4 resampling runs
#&gt;  nr  task_id       learner_id          resampling_id iters warnings errors
#&gt;   1      sin       regr.rpart variable_size_train_cv    54        0      0
#&gt;   2      sin regr.featureless variable_size_train_cv    54        0      0
#&gt;   3 constant       regr.rpart variable_size_train_cv    54        0      0
#&gt;   4 constant regr.featureless variable_size_train_cv    54        0      0
</code></pre>
<p>The code below computes the test error for each split, and visualizes
the information stored in the first row of the result:</p>
<pre><code class="language-r">reg.bench.score &lt;- mlr3resampling::score(reg.bench.result)
reg.bench.score[1]
#&gt;    test.fold  seed small_stratum_size train_size_i train_size
#&gt;        &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt; 1:         1     1                 10            1         10
#&gt;                          train                  test iteration train_min_size
#&gt;                         &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt; 1: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         1             10
#&gt;                                   uhash    nr           task task_id
#&gt;                                  &lt;char&gt; &lt;int&gt;         &lt;list&gt;  &lt;char&gt;
#&gt; 1: 50d4edb9-631c-4ece-b745-efbdeba0e44c     1 &lt;TaskRegr:sin&gt;     sin
#&gt;                          learner learner_id                      resampling
#&gt;                           &lt;list&gt;     &lt;char&gt;                          &lt;list&gt;
#&gt; 1: &lt;LearnerRegrRpart:regr.rpart&gt; regr.rpart &lt;ResamplingVariableSizeTrainCV&gt;
#&gt;             resampling_id       prediction  regr.mse algorithm
#&gt;                    &lt;char&gt;           &lt;list&gt;     &lt;num&gt;    &lt;char&gt;
#&gt; 1: variable_size_train_cv &lt;PredictionRegr&gt; 0.8008255     rpart
</code></pre>
<p>The output above contains all of the results related to a particular
train/test split. In particular for our purposes, the interesting
columns are:</p>
<ul>
<li><code>test.fold</code> is the cross-validation fold ID.</li>
<li><code>seed</code> is the random seed used to determine the train set order.</li>
<li><code>train_size</code> is the number of data in the train set.</li>
<li><code>train</code> and <code>test</code> are vectors of row numbers assigned to each set.</li>
<li><code>iteration</code> is an ID for the train/test split, for a particular
learning algorithm and task. It is the row number of <code>iteration.dt</code>
(see instance above), which has one row for each unique combination
of <code>test.fold</code>, <code>seed</code>, and <code>train_size</code>.</li>
<li><code>learner</code> is the mlr3 learner object, which can be used to compute
predictions on new data (including a grid of inputs, to show
predictions in the visualization below).</li>
<li><code>regr.mse</code> is the mean squared error on the test set.</li>
<li><code>algorithm</code> is the name of the learning algorithm (same as
<code>learner_id</code> but without <code>regr.</code> prefix).</li>
</ul>
<p>The code below visualizes the resulting test accuracy numbers.</p>
<pre><code class="language-r">train_size_vec &lt;- unique(reg.bench.score$train_size)
if(require(animint2)){
  ggplot()+
    scale_x_log10(
      breaks=train_size_vec)+
    scale_y_log10()+
    geom_line(aes(
      train_size, regr.mse,
      group=paste(algorithm, seed),
      color=algorithm),
      shape=1,
      data=reg.bench.score)+
    geom_point(aes(
      train_size, regr.mse, color=algorithm),
      shape=1,
      data=reg.bench.score)+
    facet_grid(
      test.fold~task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAIAAABHLKd9AAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nOydd5xU1dn4n3P7vdN3d7YXeu/gLlhAuhBLFLuiIhFMNIomrybmjb9oor6xJIoxGhVFNBJBVLAHC7YILL0vLLC97+xOv/38/hjcLFtmh52Vbef74cPn7p1zn/uce+Y+c8pzngdhjIFAIBAIAFR3K0AgEAg9BWIQCQQC4RTEIBIIBMIpiEEkEAiEUzDddeO6urruujUhOqIoWiyW5mdIY/VYBEGwWq3drUXfodsMosfj6a5bE6LjcrlaGMSGhgbijdAzcTgcxCB2IWTITCAQCKcgBpFAIBBOQQwigUAgnIIYRAKBQDhF3zGIPp/v5ptvjrHwp59++sILL0Qv8+WXX95+++3Nz6xdu3bDhg2d1C8GzqgKZ1S499KjmrX1tYQ+RretMvd88vLyRo0a1d1aELqYeJqVfCX6PH3HIP71r3+tqal5+umn77777mefffbrr7+22WyTJ0++4447QqHQI488UlhYyHHcr371q4kTJzZd9dprrxUVFf3v//4vTdMtBJ44cWL9+vUPPvjgypUrt23b5nK5MjMzR4wYIcvyggULNmzYkJCQ0FR41apVX3zxhWEYS5YsmT9/PgCsXr168+bNCKF58+bddNNNBw4c2LhxY1JSUnl5OU3T999/v2EYLbSKUoWDBw+2uLyp8IoVK87OE+4WurFZg8FgC/mRa6+66qoWbSEIwtl7IoQfk74zZL7nnnuSk5NXrFhRVFRUVlb21ltvvfzyy1u3bi0rK/v8889tNtu6devuueee7777rumSdevWHT16tM3XpokPP/ywqqrqjTfeePTRR/fv3w8APM+vWbPG4XA0lfnqq68OHz68Zs2aZ5999rnnnguHw9u2bcvPz1+1atXLL7/8/fff5+fnA8A333xzww03PPzww6qq7ty5s7VWUarQ+vKmwj/eI+0JdGOzticfWrXFj1BvQvfQdwxiEwMHDnzggQd27Njx+uuvNzQ0qKo6evToffv2vfLKK6Io3nnnnZFi33777WuvvZaXlxfltQGAvXv3XnbZZQzDuFyuCy+8EAAQQllZWc2v2rVr1/z582madrvda9eu5Thuz5498+fPFwRBEIS5c+fu2bMHAEaNGhXxoU1PT29P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cJSX2wzdg1b6vclPl04H0dcQdS5AenPs+vTkxyur19TUNXnLRJKrUpyzbZbp+cWzbNa/lFZWKSHGp+cXqqp6GvHwww8HD861XucH+gKKzoXJRRz7fmrSjPxiniBm2H4zBgwuKV7M87cWlybQ1NKS8jdTnedKz4izZMkSr9fbkLS8srLyj3/8IwC88cYbEZG/devW11577Z133mnXVevWrXv66ac3bdo0YsSII0eO7NixY8WKFe+//35EVIogukHUuWDpw3NrU52zCkoIgOm2pvPiMSbD1ozUuYWl232+dXWemc0anKekp6fff//9DS9XrFhx9913n0N9VFV1u92TJ08eMmTIOVQjTEJPmdeuXXv33XcrirJhw4azoJCOTgQZZODfSU26v6zyQ3cLmRqSGHpTZsqlBsNdxeW7fIHmDc5H7r///pycnHfffff111/ft29fB60hxviPf/yj0+ns3bv33Xff3bCUrGnavffem5mZOWTIkJkzZwaHnw899FBWVlZ2dvYjjzwCADt27Jg5c2bfvn1feeWVAwcO3HvvvbfffnthYeGSJUsAoK6u7oYbbujZs+eMGTN8Pt+OHTumTp26cOHCyy677L777lu2bNnUqVMnT54ccn05soQYIT744IN79uzJz89HCL344ou7d+9+8sknz45mOjoR4RIDtzbVOaeghENoksXU5F0WofVpSZPyCqfnF61MTpzSrMF5x/r167/44otx48Zt2bJl9+7d48aNmzFjxhlLO3ToUG5ubn5+PgD07t37tttuC55/7733Dh8+nJOTU1lZ2aNHj8mTJ3/++edffvnlgQMHAGDMmDGDBw82mUxffvnlTz/9lJGRsWPHDgB46aWXDhw48OKLL+7YsWPbtm25ubmpqakjR47cunWrw+HYsWNHcXGxqqoOh2PDhg3/+te/pk+fvnXr1smTJ0fgcwmPECPEd99997333nM6nSRJbtq0ad26dWdHLR2dCDLYwL+WnLCkpOzLem+LDdalJplJ4q6Ssn9UVGsYVIwl7XxNAfHxxx8///zzN9xwQ0JCwlNPPfXhhx92RNpFF1305ptvbt68+bHHHisvL29w+tmyZcvChQspikpMTBw5ciQAbN++ff78+QaDwWAwzJkzZ/v27QAwbNiwjIyMFiUPHTo0PT2dIIj+/fsH/bqGDh3KsqzBYIiOjh43bhwA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BpWVqINHAAD5/TeIN0JDrDRN4+TUhqtWr179008/TZw48YknnhAEwel0vvrqqxUVFcGM2QaDYc2aNf/73/9yc3OLi4snTpx45ZVXPvzww+PHjz969OiXX35pNBqfffbZ+fPnN1wbFFtXV9f45N69e5944glFUSZPnjxgwICG41tvvfUMnjSEQaypqUlKSho6dGiDWexgvkkdna4MjdB/nPGrXDXxNGUm0Dt17vtiHQvstlWu2k893qt+64TYx8BvzEiZdrJIBXxrlxknNsklU1NTs2fPnkGDBrU4CgsT6tut+HS2FCSKoCjk118CAPLWU99twzR9qp3Zosyc23DVTTfdlJSU9PXXX8+ePXvmzJlPPPHEunXrunXrtmzZsqFDh86aNauwsHDhwoU//vhjc3sdFxf3n//857HHHmt8bfCtF198sfHJw4cPz549e+rUqevWrdu4cWPD8Rk+adtv33fffffdd9+ZidbROR9x0vTjyU6Kog7X1F5+PL8nx06xmP4SF/NweeUVJiND/MbluBvLfJiePC2/yK9pS2Mc50rnxjSJnvjXv/61bNmyhrRdZ4Y87w8Nx0gUqfffUoePRqpK7v5OnjkP2szQdfz48Z9//nnLli0A0KdPn7i4uIcffnjNmjWHDx9u7rTYkC3x0ksvbX5tMJVRk5OLFi164IEHXn755cWLFzc+PrMnDWEQhw8f3nAcTDnZpMH27duDxnj69Onjx49v/NYtt9xSV3eqKu6jjz7ao0ePM1NRR+eckExTK5MTbi4qy2KSp1rNr7pq19TWNV8xzGaZj9KSr80vUjHcF9slbOKuXbv279+PEOrfv/+yZcsAoIMGsTGYZeWp15MHfgaCUKbd0LY1BIDs7Oy4uLibb755/fr12dnZzz777I033jhmzJgJEyYEc8phjCmKCmaT27Vr18SJEwEgGILd5NqioqLmJ7/55pvHH3/c4XAMGzZs6dKlDcdnVkmmHckX8/Pzs7KyGufFq62tXb169XPPPUcQxN13392vX7/o6OjgW8F0hLoPo855zSiT8c5o+01FpV9mpPwtLmZBYclMm9VMNvXNyGSZzzJSp+YVChj/LS76nKjawP/+97+ff/758ssvB4DVq1cfPnx4/vz5Eb6HyawOGxlm29tvv3327NkbN25MSUmZPn36Nddc88wzz6xatSojI+Ptt9+eOXPm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" alt="plot of chunk unnamed-chunk-31" /></p>
<p>Above we plot the test error for each fold and train set size.
There is a different panel for each task and test fold.
Each line represents a random seed (ordering of data in train set),
and each dot represents a specific train set size.
So the plot above shows that some variation in test error, for a given test fold,
is due to the random ordering of the train data.</p>
<p>Below we summarize each train set size, by taking the mean and standard deviation over each random seed.</p>
<pre><code class="language-r">reg.mean.dt &lt;- dcast(
  reg.bench.score,
  task_id + train_size + test.fold + algorithm ~ .,
  list(mean, sd),
  value.var=&quot;regr.mse&quot;)
if(require(animint2)){
  ggplot()+
    scale_x_log10(
      breaks=train_size_vec)+
    scale_y_log10()+
    geom_ribbon(aes(
      train_size,
      ymin=regr.mse_mean-regr.mse_sd,
      ymax=regr.mse_mean+regr.mse_sd,
      fill=algorithm),
      alpha=0.5,
      data=reg.mean.dt)+
    geom_line(aes(
      train_size, regr.mse_mean, color=algorithm),
      shape=1,
      data=reg.mean.dt)+
    facet_grid(
      test.fold~task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAIAAABHLKd9AAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nOydeXwUVdb371JrL+nsCQlhRxBUVqO4sEjY4igggw7IIjoDjjgMoILivCI84oLjCDjO+LgNi6io4Cu+LghIXJAlBEEJyIDKTgjZ02t1Vd33jwpt093pqqQ76XRyv3/kU125depU3+5f3/UcSAgBFAqFQgEAxdoBCoVCaSlQQaRQKJQ6qCBSKBRKHVQQKRQKpQ4mVjcuKyuL1a0p4RFF0Ww2+5+hldViEQTBYrHE2ovWQ8wEsaKiIla3poQnKSkpQBArKyvpaoSWic1mo4IYRWiXmUKhUOqggkihUCh1UEGkUCiUOqggUigUSh2tRxBramqmT59usPCWLVteeeWV8GV27Nhx//33+5955513Nm7c2Ej/DNCgR2hQ4filRVVr8LWUVkbMZplbPtddd12vXr1i7QUlykRSrfQj0eppPYL44osvlpaWrlix4q9//etLL7309ddfW63WAQMGzJ492+l0Llu27Pjx4xzHPfTQQ/369fNdtWbNmhMnTvztb3/DGAcY/OWXX95///0nnnhi1apVe/bsSUpKat++fc+ePd1u95gxYzZu3JicnOwr/MYbb3z55ZeKosyYMWPUqFEAgNWrV2/duhVCOHLkyGnTph06dOijjz5KTU09e/YsxnjhwoWKogR4FeYRiouLAy73FZ47d27zvMMxIYbV6nA4Auxr106cODGgLgRBaL53hNKUtJ4u87x589LT0+fOnXvixIkzZ85s2LDh9ddf371795kzZ7Zv3261Wt9777158+bt3LnTd8l777333//+N+TXxscnn3xSUlLy1ltvPf300z/++CMAgOf5tWvX2mw2X5mvvvrqyJEja9eufemll15++WWXy7Vnz57CwsI33njj9ddf37VrV2FhIQDgm2++ufvuu5cuXSpJUlFRUbBXYR4h+HJf4aZ7S1sCMazW+uyDoLpoguemxIbWI4g+OnfuvGjRon379q1bt66yslKSpN69e//www9vvvmmKIoPPvigVuzbb79ds2bNddddF+ZrAwA4ePDg2LFjGYZJSkoaOnQoAABCmJOT43/V/v37R40ahTFOS0t75513OI47cODAqFGjBEEQBGHEiBEHDhwAAPTq1UtbQ5uVlVWfV/U9QvDl0X3TWj7NX61hKqiN10UrphUKYnFx8bx5806ePHn99dd3794dANC1a9fXXnstNTV19erVTzzxhFYsLS3tX//615o1a6qrq8NYQwhBCH3HIcsoiuL7lyzLhBBCiO8qCKGqqgAAq9Xqf1VIr+p7hODL2xrNX61hKqiN10UrplUJoqIoAID9+/cPGjTozjvvTEpKOnnypCzLa9euff/992+//fZHH31037592i60Hj16dOzYMT8//7XXXgtj85prrvn4448VRamtrf3qq68AAISQc+fOaffS6Nu377Zt2xRFqampmTFjht1u79Onz9atWyVJ8ng8W7du7du3b7DlkF7V9whhnrfVE6tqDWmf0rppPYJoNpstFstzzz03fPjw48ePz5o169///ve4ceNWr149YsSIvXv3/uEPf5gzZ86cOXN8TQMAwN13371v377Dhw/XZzY/Pz8tLW3atGkLFy4cOXKk1Wr1eDx33323fwPklltu6dChwz333DNr1qw//elPiYmJgwYN6tu373333Xfffffl5uZed911/jYhhAihYK/CPELw5b7CUXsHWyQxrNYw9n1odRHdR6bEEBir373//ve/MbkvRZekpKS0tDT/M8eOHaPto5aJzWbLyMiItReth9az7CYSzp07t3nz5oCTeXl53bp1i4k/lKhAq5XSUGgLkRIIbSHGEbSFGF3o8AeFQqHUQQWRQqFQ6ohZl9nhcPi/RAhhjL1eb/irMMa6a00YhlFVVVv6F6EpjDGEsL5VLw01BQwslDFiCkLIMIyR90pV1fD1G9IUy7Icx/mfcTqd/naMO9CclYUQQghFq7KiVe8G3yuEkLZ8taGmGIapra0NbzwkwYkiKCCGkyoBixUwxgzDGPn+6Co4y7K6H2WDpjDGCCHdr6tBUxDq//wYMYUQYlnWoASHtxbSVPDzQgj9F50ghKJVWUbsGDcVxcqKlikIocHK0v31CllZhJDGZeMIThRBATEUxIAWIsdxoigGnAzGbDbrlmEYxu12626oMmJKFEWMcVS8MplMCKFoPSDLskac93g84b/VLMsyDBNgShTFgGIBLcSQVwVj5Fkwxh6Px+PxRG5KEAQjb4vBejfygCaTyel0hi+DMeZ53ojzXq83vG6GrHcaVyK60DFECoVCqYMKIoVCodRBBZFCoVDqoDtVKM3HC0X7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9GhpaWnPnj3z8/M//fTTLVu2/PDDDwCAYcOGXXfddRaLZcuWLfv37+/SpcvOnTsBAP/6179++OGHl19+eefOnTt27Dh27FjHjh0HDx68ffv2lJSUnTt3njlzRlGUlJSUTZs2LV++fMKECdu3b8/Pz4/C+2IMnRaix+Nxu909evTIyck5evQoHUOkxCkh24kcghNsCUc9nn2u3xZsx3sj8aOPPlq1atWkSZPatWv3/PPPf/jhh5FYu+qqq9atW7d169Zly5aVlJT4gudv27bt3nvvZRgmKytr8ODBAICCgoLp06ebTCaTyTRlypSCggIAwA033OALLx3AoEGDOnfujBDq16+fy+XSzvA8bzKZUlNThw8fDgDo0KGD7uqu6KIjiOPHj3/zzTf3XWLv3r3N4xaFEnVCaqIFo9/bEnY7nIfdv3XNnj5X0ox+RRlJkni+buW5tt47Emu7du0aOnTokSNHbr311n79+vnOK4qCLgVV0zZBEEJ8q8QhhNqayjAr0jMzMwPOYIxDHjcnOoLIcdwHH3zw4iVeeOGF5nGLQmkKFqSnBu9LSWHwOFvCVrvjpOT1nXzqTGNWO7cEhgwZsmDBAkVRysrKli5desstt0Ribdu2bbfddttDDz2UkZFx5MgR3xTrkCFD1qxZoyjKxYsXd+zYoZ1566233G63y+V66623hg4dGtKg3LJXgOoIYvfu3T/77DNJkpRLNI9bFErTEdxUbM8yt1otm6trS/2+rnHad77//vvHjh0LABg4cODw4cPvueeeSKxNnjz5+++/HzBgwPz582fPnv3kk09q56dOndq+ffsePXpMnTp1woQJiYmJv/vd74YOHdqnT58+ffqMHj065MBfYmJiYmLijBkzDN4dIRRhC7eh6Gzde+SRR/75z3/6b2E+ffp0VG5Mt+412hTduhcS/617RkwF690Bl3uX03V3oi1F4BFCmldhFuK0zK17JSUlW7dunTp16i+//HLo0KHhw4eH7LdGuHXv22+/PX78+D333KMoSl5e3uuvv946trHptBB37dpVXl5+2o/mcYtCaWqCla6vKPTSFmyrcbyJZcmSJbIs2+32xx9/vLi4eNmyZU1xl969e2/atOnaa6+9/vrr8/PzW4caAt1lN1dccUWsRjcplKYmeDnOEIvJUat+UFE5Oe03uYyvBduVlZUzZszYvHnziBEj7r333jvvvLMp7pKUlLR58+amsBxbdASxoqKiffv2gwYN8slihLP4FEqLIlgTR1ksm2pqP6moHm2Jy31ZGOOKioqdO3dOnz69qKiI4zj9ayiX0BHERx555JFHHgk4eeDAgb59+zaZSxRKsxKgiRiCO5IT3yyt+BGjq8W69Stx1EicMmXKlClTBg4c2KtXr3/+85/z58+PtUfxhI4g3njjjcEn169fTwWR0poI0EQBoTtSk966WJbBMulMXd8oXjRxzJgxo0eP1pYEPvjggxFaU1XV8/nHDbpEGHN7/Iat1ZlUoVDaCAFil8WxN5pNm6trJTXOIuIoilJbWxvF8F+kgUTxWZqfZl3jQ6G0ZALaiQNF4azk3WK335Zg9Z1s+e3E2bNn2+1236B/aWmpFvtLi79ACQ8VRArlNwI0cXSCZU1F9Q9uzzV+aVhauCa2tPBf8QXtMlMol7EgPXVRVt02Wx7C222WHXZHqXzZkumW3Hf+61//6t9vpWrYIKggUijhyGSYm0zi5uoa/8FE0II1ccyYMefPh8g72PzU1NQMHjz48OHD0TL4v//7vxs3boyWtZDoC+L69evnzp0ry/KmTZu0MzRMLKXV45/ieYBJTGOYz+2BewdD5juNORs3bszIyIi1FwAA8OOPPw4bNqxXr15hymzfvv25554L+S/dXZhNgc4Y4uLFiwsLC0+cOKElmdqzZ89zzz1XX4AzCqU14T+eODrBsrai+qDL3UcU/Mu0wPFEk8nk9Xp9YWlWrVo1Z84cQRDCXxUeWFUJDEwfE4xBgs33cvXq1fv37x89evSzzz7rdruzs7Nfe+21CxcuaBGzTSbT2rVr33zzzWPHjp05c2b06NG33nrrkiVL8vLyfvrppy1btpjN5hdffHH69Om+azWzVVVV/ieLioqeffZZWZbz8/P79+/vO77//vsb8aQ6gvjuu+8WFRWNHz9eSzLVvXv3+uScQmnF8BDeZrNsqKppx7K+lYkaLU0TA2LJVFRUFBYWDhw4MJKUmejkr8RApCvI82rva3wv77nnnvbt23/55ZeTJ0++6667nn322Q0bNlxxxRULFiwYNGjQH/7wh1OnTt1777379u0L1uuMjIyXXnpp2bJl/tdq/3r55Zf9Tx4+fHjy5Mnjxo3bsGHD5s2bfceNe9JIk0wVFBRo954wYUJeXp7/v/74xz9WVVVpx0899VTPnj0b5yKFEiv8G4mZDHOzybS5umZaUiKHLlt43KI08Z133vF/uXz58gULFvjCdjUOpU//Rl97/Pjx77//ftu2bQCAa665JiMjY8mSJWvXrj18+HBwKCZftMTc3Nzga7VOdMDJmTNnPv7446+88sqsWbP8jxvnrY4gakmmKisrn3/++fXr1weMHlZWVq5evXrlypUIoblz5/bt29cXKEyLvvXBBx80zi0KpQXS3ySc9no/tztuT7AE/KtFaeLu3bsPHjwIIezXr9+CBQsAABEKYiR07949IyPjvvvu27hxY/fu3V988cW777572LBhI0eO1GbDCSEMw2jR5Hbv3j169GgAgLYFO+BaLdpWwMmvvvrqmWeeSUlJueGGG+bPn+87blwmGZ1JlYcffvi5556bPHmylmRqzpw5/v8tKirq1q2bzWazWq25ubmFhYW+f50/f55l2X/84x8LFy7csmVLIzyjUFoCATI3OsFywSsf8MvB4qOFzDu/+eab69evb9euXWZm5urVq2O+HvuBBx7YuHHj2LFjCwoKunfvPnbs2BdffHHKlCldunR5++2327dv/+GHH1555ZVvvPHG+PHjc3JyfPkPgq8NeTI1NXX27Nn33Xff7bff7n/cOG91AsT6458zQWPDhg1ut3v69OkAgE2bNrlcrrvvvlv718GDBzdt2vTggw9KkrR06dJZs2b1798fAPDqq6/+8ssvCKHFixf7m0IIYYx93fP6YBhGNwQ5y7KKooQPjGrQFMYYQqhbrJlNQQhZltWNgIsxVlU1fP1qEYmDTfl/KAEAAQFc67sqAIOVpaqqbiR2g+8wQigqH6HgyvLPKHBB8q67WD4lLTlLEII/Zv7T0wAACCHHcboRcI1UVn31fvLkSf+XU6dOfeONN7QWltvtvu+++9avXx9szWCAWFVV3Z81LMyXmD82fvcy63SZt2/f/vHHH69YsWL8+PHbtm176aWXAiKS+z+5f3VqkcS14zFjxhQVFWmC2LNnz9TU1OAPLsMwRj7NBj/xiqLofuiNmDJYzEgZCCGEMCqmEEIsyxpxXpbl8N8xjHHw71BwBMzgAkZ+vYw8C8ZYluVoVVawq402FfCA/pKditHNVvPG8so/ZqQzJFAQl5w87VvXDRpSWbq/4iFNBVdWwIbi+NWmmKAjiLNmzXrllVd27drldruPHj06ZMgQf0FMSUnZs2ePdlxRUZGdne371/Hjx0VR1M5wHOerNi1jIQiVQgBj7EtyWB9GyvA8L0mSkQaUrikIYbS8QgghhKJiimEYQRCMOG8khQDHcQGmgqfOPB5PQAqB4KuCMfIsHMd5vV4jDShdUxpR8UoTEf9i85MT/XvEfXnujEf6fxWVv7OGiM6/9NQZX0cbYyyKohHnjaQQCK734PnZ4cOHz58/f8SIEYSQL774YuTIkbq3pvjQz8ucl5f3ySefjBs3LisrK+DXacCAAT///LPT6XS73Xv37h04cCAhpKSkRFXV8+fPr1y50u12ezyegoICGi6M0soYaTWX1jOYGFtmSosywwAAIABJREFUzJgxZcqUkpKS0tLSGTNmTJs2LdYexRM6LcQ+ffpMnz7966+//v777xcvXtyu3WUpHJOSkqZOnbpo0SJCyMSJE9PS0txu98yZM9euXXvTTTcdOXJk1qxZJpMpLy9P6y9TKPFLQNwHDsLxybZ1FyvaMUwGG/g9iuGk8/79+3me15ataC+1g8Z9BxFCYv7YBl0S1510HUFcv37922+/PX/+/MTERIxxwBInAMCwYcOGDRvmeykIgi/TwsyZM2fOnBlddymUGBKgiekse7PFtLnGPi3JxqNAFYiVJn7yySchzzdOEAkhugMaAfA8H7+aqCOIgiB07Njx0KFDhw4d6tq16549ezp16tQsjlEocUA/UTjrlbfUOm63Ba5MBAAsLy17rF1zbytetGjR559/fuDAAUJInz598vPzI8kTRwhZeupMgy5Z1j2OM/DpCOL48eNNJlNOTo72EiF01113Nb1XFEoLJTgp1UireV1l9fdOdz9TiP3Cz124+ExiYnN5BwAAq1atKi0tve222wghmzdvPn78+Lx585rTgbhGRxA5jqO7TSiUMHAQ3p5geaeyJosNMZgIAFhy8vSDFlOz+VNYWLhu3TqtVXjddddNmTKl2W7dCtCZZe7evftnn30mSZJyieZxi0JpsQSPDKYxzM1m0+Yau0cNveqzOTexJCYmulwu7bi2tjYpKanZbt0K0E8hcMcdd/h2KAMAtO2EFEpbJrjj3M8knJPlLbX2223WkJdo5ZthmiU3N3fWrFlDhw5VVXXHjh1XX321Nhc6adKkpr51K0BHEHft2lVeXm4yNV+Dn0KJU0ZYzesqqve73P3FeoMPNsPUc1ZW1h133KEdNy7AQXSpra21WkP/SAQU27t37759+yIJUxY5OoJ4xRVXRDJFRaG0Vhakp75YWe1/hoPwdpv1ncrq7FArE300tSYOHjzYt/BFWzQTYXTYRvPGG29ocV4zMzMdDgdC6Pz582+88UZNTY1/jNjVq1drxSRJOnbs2IQJE7p16xYTh4GuIFZUVLRv337QoEE+Wfzwww+b3isKJS5JY/Bgi+n/1tROT0oUglYm+mhSTRwzZsz69euzsrIAAGfOnJk2bdqOHTsitPnC+VLJQBQYG0YPZFwWMEKL8/rYY4916NDh4YcfXrVq1X/+859Bgwb5x4j1Fdu+ffu+fftiqIZAVxAfeeSRRx55pHlcoVDii8ez2z154lTAyb6icNYrf1pjvyMxXD+x6TRx48aNNltdHP+srKyoZGWanZEKDCy1hiSwkG/DjLZ5t1+/fps2bRo3blxAjFhfsZijI4g33nij71hRlICIDBRKGyd4dgUYG0wETaaJycnJvmOMsf/LRiMgY+k5g0RTi0IGANi7d29eXt53330XMkasr5jxaIRNRAPSkJ44cSIzM1O/HIXSttEGE791OM95dcKaLS8tayFhZZuaffv2/f73v//uu++mTZsWECPWV0YLFnvs2LEY+hmuhVhRUfHqq68++uij2ssuXbrY7fZm8YpCiRtCNhLTGDzEbPq4pnZGSrLujMby0rInOrRvIvdiyH333ec7fvzxxwcMGKAdDxkyZMiQIcHle/To4QsnGCvCtRBtNttbb73166+/ai8hhGZziOhvFAolmD6i0J5lP6muNdIJfPpcSbTu+89//vPrr7/2xcH87rvvYtvmii/CCSLGuHfv3v369cvPz594iWbzjEKJF+obChxhNVco8u5qQwnXn7twMSrOfPTRR59++ulTTz2lvTx27Nijjz767rvvRsV443jmmWd8zcMWjs6kypw5cwISS1EolGBCdpw5CMfZEjZUVRdB2Ivnewl8Ag7XBInKNAvLss8+++yTTz758ccf33bbbdOnT//9738/c+bMP/zhDxFabgvoCOLx48f9XyYmJv78889du8ZxeB8KpTlJY5mH2mf9VF1T7Pb8p6IqicG9ee5KgTfVM28brannOXPmPPDAA4MGDdL23epm1KgPCGGrHN+sD52se3fddddnn302ePBglmV37Njx+9///ueff/7d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LRBC6PyR1SkzQgj1JWzp0qXduPmGhoZHHnlk5syZ5sfq6uonn3zyjTfesNls5oM7GYdat27d008/vXHjRr/fb/38jnP+/PPP//rXv964cWMgEBg3blziHOtN+uSTTx5//PE1a9bU1dWVlZVltoNx+5U4x2LM9evXr1y5csOGDbW1taWlpYSQxBVTh8KD1dn9SpzTZQcLZagbb+isX7/++9///n333Wd+bGxsXLBgQXNzc2tr6+2333727NmMQ3366acLFy70+/2BQOCuu+46cOCAxTi7du26//77A4GA3+9fuHDhp59+mjjHYqhQKHTHHXecPHkyFArdf//9e/fuzWAH4/YrcY7FmIcPH7711lv9fr/f7//xj3+8adOmxBVTh8KD1dn9SpzTZQcLZaw7T5mHDh06e/bs6McU7710NpT5xJ/4BetxEl+wyfiVm5qamrFjxw4cOFCSpCeeeGLcuHEZ7GDcfiXOsRizoaGhvLzcbrfb7fbJkyefOXMmccXUofBgdXa/Eud02cFCGevOhFhaWhp71yzFey+dDTVixIiysrKKioqKioqLLrpozJgxFuMMHz784osvXrNmzZw5c4YOHTpixIjEORZD1dbWBoPBRYsWLViw4He/+x1jLIMdjNuvxDkWY06ZMuWWW24xl9+6deuUKVMSV0wdCg9WZ/crcU6XHSyUsZ51UyX1ey/Wffjhh0eOHHniiSeefPLJEydO7Nu3r1Orz5s3b9myZfv27du7d29Hc9IKBoNHjhx55JFHnnvuuTNnzmzatAlyt4OxrMf8xz/+UVVVVVFRYSadxBU71Tw8WBnoroOFLOpBCbGwsPD48ePmdGNjY2FhYcahampqvvrVrw4fPnzIkCHTpk2zfkKxa9euTz/9FADGjRv3ta997eOPP06cYzGUx+OZMGFCQUGBoiiTJ08+duxYDncwymJMzvmKFSvef//9p59++rLLLku6YqeahwcrA911sJB1PSghJr73knGowYMHv/vuu4FAIBAI7Nu378ILL7S4YuILNhm/cjNx4sR9+/aZbdi5c+fo0aNzuINRFmO+++67qqouXrzY7XZ3tGKnmocHKwPddbCQdT1oxOzE914yDjV9+vTPP//83nvv5Zxfeumls2bNsrhi4gs2uq536pWbqP79+8+dO/ehhx5SVfXyyy+/6qqrCCG52sEoiz/aRx999P777998883mx9mzZ992222JK1pvHh6sDHTXwULW4ZsqCCHUpgedMiOEUPfChIgQQm0wISKEUBtMiH1TQ0PDxRdfnHaxtWvXTp48ObNNZLMuQj0T3lTpmxoaGqZOnXrgwAHzo67rLS0ticNEer3exsbGIUOGZLCJbNZFqGfCHmLf9P3vf//YsWP33HPP9u3b586dO378+Oeff55z/oMf/GDQoEGXXHLJokWLOOf79+9/8MEHt2/fXlFRUVVVdcMNN8ydOzdp5evW1tbrr79+8ODBo0aNevPNNwHAXPfVV1+dOHHixIkThw8fHn3r7umnnzY/du9YSgh1WteMIYG6WH19/ZgxYzjn77zzjsvlOnLkCOf83//+96xZs8LhcDgcHjVq1CeffPLOO+/cdNNN77zzjqIojY2NnPNvfOMbr732WmLA3/zmN/Pnz+ecb9682Ry+xVzX/FbTtOnTp//5z3/mnG/dunXSpEkNDQ2tra3l5eWvvPJKV+00QtnCHmLfZ74YBwBjx459+eWXN2/e/Nhjj9XW1qqqGl3msssu83g8ADB8+PDY+bFB/vWvf/3sZz/Ly8tbuXJl3LdVVVWlpaVz5swBgOrq6qamprlz595www2ff/45DsSCepEe9KYKOkccDoc5sWPHjjvvvPP222+/7rrrtm3bFrtM2io048ePf++99/70pz8tXbrUbrdv2LAh+tXatWtramq2bNlifrTb7XfddddDDz0EALquc7xIjXoP7CH2WYllkrZs2XL99df/6Ec/6tev34EDByKRiPVojz766DPPPHP33Xe/8MILmzdvjqa5Dz/88JFHHlm7dm202PGMGTNeffVVr9cbiURmzpy5cePGnOwOQl0AE2Lf5Ha73W73woULY2d++9vffu+998rKyh544IF77rkn6R2Pjuq4z58/f9OmTUOHDr3iiit+9atfRceeWr58udfr/frXvz558uTJkyfruj558uQFCxZMnjx55MiRpaWlN9544znYP4TOCXzsBiGE2uA1RBTvs88+++1vfxs38zvf+Q4WBUZ9HvYQEUKoDV5DRAihNpgQEUKoDSZEhBBqgwkRIYTaYEJECKE2/x9e9viwQCeQPAAAAABJRU5ErkJggg==" alt="plot of chunk unnamed-chunk-32" /></p>
<p>The plot above shows a line for the mean,
and a ribbon for the standard deviation,
over the three random seeds.
It is clear from the plot above that</p>
<ul>
<li>in constant task, the featureless always has smaller or equal
prediction error rates than rpart, which indicates that rpart
sometimes overfits for large sample sizes.</li>
<li>in sin task, more than 30 samples are required for rpart to be more
accurate than featureless, which indicates it has learned a
non-trivial relationship between input and output.</li>
</ul>
<h3 id="interactive-data-viz">Interactive data viz</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">grid.dt &lt;- data.table(x=seq(-abs.x, abs.x, l=101), y=0)
grid.task &lt;- mlr3::TaskRegr$new(&quot;grid&quot;, grid.dt, target=&quot;y&quot;)
pred.dt.list &lt;- list()
point.dt.list &lt;- list()
for(score.i in 1:nrow(reg.bench.score)){
  reg.bench.row &lt;- reg.bench.score[score.i]
  task.dt &lt;- data.table(
    reg.bench.row$task[[1]]$data(),
    reg.bench.row$resampling[[1]]$instance$id.dt)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=reg.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ]
  point.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(task_id, iteration)],
    i.points)
  i.learner &lt;- reg.bench.row$learner[[1]]
  pred.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(
      task_id, iteration, algorithm
    )],
    as.data.table(
      i.learner$predict(grid.task)
    )[, .(x=grid.dt$x, y=response)]
  )
}
(pred.dt &lt;- rbindlist(pred.dt.list))
#&gt;         task_id iteration   algorithm     x           y
#&gt;          &lt;char&gt;     &lt;int&gt;      &lt;char&gt; &lt;num&gt;       &lt;num&gt;
#&gt;     1:      sin         1       rpart -10.0  0.25011658
#&gt;     2:      sin         1       rpart  -9.8  0.25011658
#&gt;     3:      sin         1       rpart  -9.6  0.25011658
#&gt;     4:      sin         1       rpart  -9.4  0.25011658
#&gt;     5:      sin         1       rpart  -9.2  0.25011658
#&gt;    ---                                                 
#&gt; 21812: constant        54 featureless   9.2 -0.03385654
#&gt; 21813: constant        54 featureless   9.4 -0.03385654
#&gt; 21814: constant        54 featureless   9.6 -0.03385654
#&gt; 21815: constant        54 featureless   9.8 -0.03385654
#&gt; 21816: constant        54 featureless  10.0 -0.03385654
(point.dt &lt;- rbindlist(point.dt.list))
#&gt;         task_id iteration set.name row_id          y         x  fold
#&gt;          &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;      &lt;num&gt;     &lt;num&gt; &lt;int&gt;
#&gt;     1:      sin         1     test      1  1.2248390 -4.689827     1
#&gt;     2:      sin         1   unused      2 -0.5607042 -2.557522     3
#&gt;     3:      sin         1   unused      3  0.8345056  1.457067     3
#&gt;     4:      sin         1   unused      4  0.4875994  8.164156     2
#&gt;     5:      sin         1   unused      5 -0.4321800 -5.966361     3
#&gt;    ---                                                              
#&gt; 64796: constant        54    train    296 -0.6728968  3.628850     2
#&gt; 64797: constant        54    train    297  0.5168327 -8.016618     1
#&gt; 64798: constant        54    train    298 -0.4058882 -7.621949     1
#&gt; 64799: constant        54     test    299  0.9008627 -8.991207     3
#&gt; 64800: constant        54    train    300  0.8857710  8.585078     2
set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Variable size train set, regression&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      geom_point(aes(
        x, y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        shape=21,
        data=point.dt)+
      scale_size_manual(values=c(
        featureless=3,
        rpart=2))+
      scale_color_manual(values=algo.colors)+
      geom_line(aes(
        x, y,
        color=algorithm,
        size=algorithm,
        group=paste(algorithm, iteration)),
        showSelected=&quot;iteration&quot;,
        data=pred.dt)+
      facet_grid(
        task_id ~ .,
        labeller=label_both),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(width=500)+
      theme(
        panel.margin=grid::unit(1, &quot;lines&quot;),
        legend.position=&quot;none&quot;)+
      scale_y_log10(
        &quot;Mean squared error on test set&quot;)+
      scale_color_manual(values=algo.colors)+
      scale_x_log10(
        &quot;Train set size&quot;,
        breaks=train_size_vec)+
      geom_line(aes(
        train_size, regr.mse,
        group=paste(algorithm, seed),
        color=algorithm),
        clickSelects=&quot;seed&quot;,
        alpha_off=0.2,
        showSelected=&quot;algorithm&quot;,
        size=4,
        data=reg.bench.score)+
      facet_grid(
        test.fold~task_id,
        labeller=label_both,
        scales=&quot;free&quot;)+
      geom_point(aes(
        train_size, regr.mse,
        color=algorithm),
        size=5,
        stroke=3,
        fill=&quot;black&quot;,
        fill_off=NA,
        showSelected=c(&quot;algorithm&quot;,&quot;seed&quot;),
        clickSelects=&quot;iteration&quot;,
        data=reg.bench.score),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Simulations.Rmd&quot;)
  viz
}
</code></pre>
<p></p>
<div id='ResamplingVariableSizeTrainCVAnimintRegression'></div>
<script>var ResamplingVariableSizeTrainCVAnimintRegression = new animint("#ResamplingVariableSizeTrainCVAnimintRegression", "ResamplingVariableSizeTrainCVAnimintRegression/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-26-train-sizes-regression&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-26-train-sizes-regression/">https://tdhock.github.io/2023-12-26-train-sizes-regression/</a></p>
<p>The interactive data viz consists of two plots:</p>
<ul>
<li>The first plot shows the data, with each point colored according to
the set it was assigned, in the currently selected
split/iteration. The red/blue lines additionally show the learned
prediction functions for the currently selected split/iteration.</li>
<li>The second plot shows the test error rates, as a function of train
set size. Clicking a line selects the corresponding random seed,
which makes the corresponding points on that line appear. Clicking a
point selects the corresponding iteration (seed, test fold, and train
set size).</li>
</ul>
<h2 id="simulated-classification-problems_2">Simulated classification problems</h2>
<p>Whereas in the section above, we focused on regression (output is a real number),
in this section we simulate a binary classification problem (output if a factor with two levels).</p>
<pre><code class="language-r">class.N &lt;- 300
class.abs.x &lt;- 1
rclass &lt;- function(){
  runif(class.N, -class.abs.x, class.abs.x)
}
library(data.table)
set.seed(1)
class.x.dt &lt;- data.table(x1=rclass(), x2=rclass())
class.fun.list &lt;- list(
  constant=function(...)0.5,
  xor=function(x1, x2)xor(x1&gt;0, x2&gt;0))
class.data.list &lt;- list()
class.task.list &lt;- list()
for(task_id in names(class.fun.list)){
  class.fun &lt;- class.fun.list[[task_id]]
  y &lt;- factor(ifelse(
    class.x.dt[, class.fun(x1, x2)+rnorm(class.N, sd=0.5)]&gt;0.5,
    &quot;spam&quot;, &quot;not&quot;))
  task.dt &lt;- data.table(class.x.dt, y)
  this.task &lt;- mlr3::TaskClassif$new(
    task_id, task.dt, target=&quot;y&quot;)
  this.task$col_roles$stratum &lt;- &quot;y&quot;
  class.task.list[[task_id]] &lt;- this.task
  class.data.list[[task_id]] &lt;- data.table(task_id, task.dt)
}
(class.data &lt;- rbindlist(class.data.list))
#&gt;       task_id         x1           x2      y
#&gt;        &lt;char&gt;      &lt;num&gt;        &lt;num&gt; &lt;fctr&gt;
#&gt;   1: constant -0.4689827  0.347424466   spam
#&gt;   2: constant -0.2557522 -0.810284289    not
#&gt;   3: constant  0.1457067 -0.014807758   spam
#&gt;   4: constant  0.8164156 -0.076896319    not
#&gt;   5: constant -0.5966361 -0.249566938   spam
#&gt;  ---                                        
#&gt; 596:      xor  0.3628850  0.297101895    not
#&gt; 597:      xor -0.8016618 -0.040328411    not
#&gt; 598:      xor -0.7621949 -0.009871789   spam
#&gt; 599:      xor -0.8991207 -0.240254817    not
#&gt; 600:      xor  0.8585078 -0.099029126   spam
</code></pre>
<p>The simulated data table above consists of two input features (<code>x1</code>
and <code>x2</code>) along with an output/label to predict (<code>y</code>). Below we count
the number of times each label appears in each task:</p>
<pre><code class="language-r">class.data[, .(count=.N), by=.(task_id, y)]
#&gt;     task_id      y count
#&gt;      &lt;char&gt; &lt;fctr&gt; &lt;int&gt;
#&gt; 1: constant   spam   143
#&gt; 2: constant    not   157
#&gt; 3:      xor   spam   145
#&gt; 4:      xor    not   155
</code></pre>
<p>The table above shows that the <code>spam</code> label is the minority class
(<code>not</code> is majority, so that will be the prediction of the featureless
baseline). Below we visualize the data in the feature space:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x1, x2, color=y),
      shape=1,
      data=class.data)+
    facet_grid(. ~ task_id, labeller=label_both)+
    coord_equal()
}
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAIAAABHLKd9AAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nOzdd5xU1dk48OfcNnOnz+zM9r7AAtI7gkgTBJEOYosaE42JGo153xiTn29iYo9RozGWFCSioogoNkQURUTK0jtsYftO25nZmbn9nt8fM6zLNnZhpXm+H/5YZu7cdu48c+8pz0EYYyAIgiAAqHO9AwRBEOcLEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJBIQCYIgkkhAJAiCSCIBkSAIIokERIIgiCQSEAmCIJJIQCQIgkgiAZEgCCKJBESCIIgkEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJBIQCYIgkkhAJAiCSCIBkSAIIokERIIgiCQSEAmCIJJIQCQIgkgiAZEgCCKJBESCIIgkEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJBIQCYIgkkhAJAiCSCIBkSAIIokERIIgiCQSEAmCIJJIQCQIgkgiAZEgCCKJBESCIIgkEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJBIQCYIgkkhAJAiCSCIBkSAIIokERIIgiCQSEAmCIJJIQCQIgkgiAZEgCCKJBESCIIgkEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJBIQCYIgkkhAJAiCSCIBkSAIIokERIIgiCQSEAmCIJJIQCQIgkgiAZEgCCKJBESCIIgkEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJBIQCYIgkkhAJAiCSCIBkSAIIokERIIgiCQSEAmCIJJIQCQIgkgiAZEgCCKJBESCIIgkEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJBIQCYIgkkhAJAiCSCIBkSAIIokERIIgiCQSEAmCIJJIQCQIgkgiAZEgCCKJBESCIIgkEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJBIQCYIgkkhAJAiCSCIBkSAIIokERIIgiCQSEAmCIJJIQCQIgkgiAZEgCCKJBESCIIgkEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJBIQCYIgkkhAJAiCSCIBkSAIIokERIIgiCQSEAmCIJJIQCQIgkgiAZEgCCKJBESCIIgkEhAJgiCSSEAkCIJIIgGRIAgiiQREgiCIJOZc7wAAwJEjR871LhA9yeVyud3ulq8cPXoUY3yu9ofocU6n0+PxnOu96HnkDpEgCCKJBESCIIgkEhAJgiCSSEAkCIJI+sEFxEgkctNNN3Vx4bVr17744oudL/PFF1/87Gc/a/nKG2+88c4775zm/nVBtw6hWwv/oFwEVwLR486LVuYL2ujRo/v373+u94I4976PK0HTtHg8brVae3a1REd+cHeITz/9tNfrfeaZZzDGf/vb3xYuXHjLLbc8//zzGONYLPbAAw8sXrz4hhtu2LlzZ8tPvfrqq3/84x81TWu7wrKyshdeeEHTtKeffnrJkiV33HFHWVkZAIiiOGnSpGAw2HLhf/3rX9dff/2SJUvWrl2beGXp0qXXX3/9DTfcsGzZMgDYt2/fww8//NJLLz344IN//OMfRVFsu1edHELbjzcv/D2dzwvXObwSPv7444cffhgADh48+POf/zyxtrZXwh//+Mef/vSna9as+V7PA9HSD+4O8d57773rrrvuueee8vLy6urqFStWAMBNN900Z86cnTt3Wq3Wt956q6SkZNOmTUOHDk185K233jpy5MhDDz1E03RHq/3www/r6+tfe+21pqamO+64o2/fvgaDYdmyZXa7vXmZL7/88uDBg8uWLQsGg7feeuuECRP27Nmzbdu2f/3rX4kd69evH8/zGzduXLlypcVi+d3vfldSUhIIBFrtVSeHAACtPt688Pd6Vi9E5/BKmDFjxhdffPHNN98sW7bsN7/5DU3TW7ZsaXslbNu27eWXX87MzPyezwTxnR/cHWKzgoKCBx54YPv27f/9738bGxtlWb7kkkv27Nnz73//m+f5O++8M7HY119//eqrr44ePbqT7wAA7N69e86cOQzDOJ3OiRMnAgBCKCcnp+WnduzYMX36dJqmPR7PG2+8wXHcrl27pk+fbjQajUbjFVdcsWvXLgDo37+/xWIBgMzMzI72qqNDaPvxnj1pF6WzfyUAwH333ffoo4+OHz++oKAAANq9EgYMGECi4Vn2ww2I+/fvv/fee48fPz5mzJjevXsDQFFR0SuvvOJ2u5cuXfrggw8mFvN4PC+88MKrr74aDoc7WRtFUQih5r/bXUbTtOa3VFXFGGOMmz+FENJ1HQBaVRi1u1cdHULbjxOndPavBACIx+M0Tfv9/sR/270SDAbDGR8c0T0/xICYqLLZsWPH2LFjFy9e7HQ6jx8/rqrqsmXL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" alt="plot of chunk unnamed-chunk-35" /></p>
<p>The plot above shows how the output <code>y</code> is related to the two inputs <code>x1</code> and
<code>x2</code>, for the two tasks.</p>
<ul>
<li>For the constant task, the two inputs are not related to the output.</li>
<li>For the xor task, the spam label is associated with either <code>x1</code> or
<code>x2</code> being negative (but not both).</li>
</ul>
<p>In the mlr3 code below, we define a list of learners, our resampling
method, and a benchmark grid:</p>
<pre><code class="language-r">class.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerClassifRpart$new(),
  mlr3::LearnerClassifFeatureless$new())
size_cv &lt;- mlr3resampling::ResamplingVariableSizeTrainCV$new()
(class.bench.grid &lt;- mlr3::benchmark_grid(
  class.task.list,
  class.learner.list,
  size_cv))
#&gt;        task             learner             resampling
#&gt;      &lt;char&gt;              &lt;char&gt;                 &lt;char&gt;
#&gt; 1: constant       classif.rpart variable_size_train_cv
#&gt; 2: constant classif.featureless variable_size_train_cv
#&gt; 3:      xor       classif.rpart variable_size_train_cv
#&gt; 4:      xor classif.featureless variable_size_train_cv
</code></pre>
<p>Below we run the learning algorithm for each of the train/test splits
defined by our benchmark grid:</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(class.bench.result &lt;- mlr3::benchmark(
  class.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 180 rows with 4 resampling runs
#&gt;  nr  task_id          learner_id          resampling_id iters warnings errors
#&gt;   1 constant       classif.rpart variable_size_train_cv    45        0      0
#&gt;   2 constant classif.featureless variable_size_train_cv    45        0      0
#&gt;   3      xor       classif.rpart variable_size_train_cv    45        0      0
#&gt;   4      xor classif.featureless variable_size_train_cv    45        0      0
</code></pre>
<p>Below we compute scores (test error) for each resampling iteration,
and show the first row of the result.</p>
<pre><code class="language-r">class.bench.score &lt;- mlr3resampling::score(class.bench.result)
class.bench.score[1]
#&gt;    test.fold  seed small_stratum_size train_size_i train_size
#&gt;        &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt; 1:         1     1                 10            1         21
#&gt;                          train                  test iteration train_min_size
#&gt;                         &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt; 1: 132,239, 10,216,245,276,...  5, 6, 8,21,23,28,...         1             21
#&gt;                                   uhash    nr                   task  task_id
#&gt;                                  &lt;char&gt; &lt;int&gt;                 &lt;list&gt;   &lt;char&gt;
#&gt; 1: e960895e-2364-4ec6-8f99-48c776d2273f     1 &lt;TaskClassif:constant&gt; constant
#&gt;                                learner    learner_id
#&gt;                                 &lt;list&gt;        &lt;char&gt;
#&gt; 1: &lt;LearnerClassifRpart:classif.rpart&gt; classif.rpart
#&gt;                         resampling          resampling_id          prediction
#&gt;                             &lt;list&gt;                 &lt;char&gt;              &lt;list&gt;
#&gt; 1: &lt;ResamplingVariableSizeTrainCV&gt; variable_size_train_cv &lt;PredictionClassif&gt;
#&gt;    classif.ce algorithm
#&gt;         &lt;num&gt;    &lt;char&gt;
#&gt; 1:  0.4257426     rpart
</code></pre>
<p>The output above has columns which are very similar to the regression
example in the previous section. The main difference is the
<code>classif.ce</code> column, which is the classification error on the test
set.</p>
<p>Finally we plot the test error values below.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_line(aes(
      train_size, classif.ce,
      group=paste(algorithm, seed),
      color=algorithm),
      shape=1,
      data=class.bench.score)+
    geom_point(aes(
      train_size, classif.ce, color=algorithm),
      shape=1,
      data=class.bench.score)+
    facet_grid(
      task_id ~ test.fold,
      labeller=label_both,
      scales=&quot;free&quot;)+
    scale_x_log10()
}
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAIAAABHLKd9AAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nOydd2AURf//Z3u5lsvdpRcSQkcSioAY0QhIeQQeC0UpimgARUXsWMHy2L4K/uwFI4qKYMPy4KMiIh1DR1oaaXdp129vr+zu74+FeOTuNnfJBZKwr7/udmd2PjO797nZmc+8BxIEAcjIyMjIAABfaANkZGRkOguyQ5SRkZE5g+wQZWRkZM4gO0QZGRmZM6AX2oB/aGxsvNAmXHhgGI6Pjw884nA4PB7PhbKn86DX61sckR8YAABJkkql8kJb0X3oRA7RbDZfaBMuPBiGtXCILpfLbrdfKHs6D8EOUX5gAAAajUZ2iDFEfmWWkZGROYPsEGVkZGTOIDtEGRkZmTPIDlFGRkbmDN3BIdrt9ltuuaU9iV988cWnn346OPG+ffueeeaZwCOff/75V199Fe7ijY2Nd955Z4SWdDSdpFk+//zzWbNmTZs2beXKlRzHRWhPh9IZWkYQhNdff/3GG2+cNm3aRx99FKExMh1NJ5plvlCwLPvXX3+tX7++ndf54osvfv75ZxTtJk0ak2Y5efLkhg0b1qxZAwBYtmzZTz/9NHny5BgZeMGIScvs3Lnz77//XrNmjSAIt91226hRo/r06RMrC2XaTHfoIb722mv19fUrV64EAHz55Zc333zz3Llzi4qKAAAul2vZsmXTp0+fPXv2/v37WyQWef311+12+0svvQQAKCoqmjVr1uzZs8XfsAjHca+99trMmTMXLVpUVlYGAGBZtqCgoEXYR8+ePadOnXo+KhwZnaFZGhsbp06dqlAoFArFZZddZjKZzlPlJekMLZOQkLB48WKapkmS1Ov1EASdp8rLSNIdHOJ9992XkJCwZMmS/fv3b968+d13333nnXeOHz/+66+//vbbbyqV6ssvv7zvvvu2b98emLg5+z333BMfH//QQw/t3r177969H3744QcffLBz5869e/eKCX788UeTyfTpp58+//zzhw8fBgAQBLFmzRqNRhNoxqWXXjp06NDzWO9W6AzNMmrUqLlz5wIAGhsbN23aNGrUqPPaBGHoDC2Tk5MzcODAjz/+eMKECdnZ2b179z6/bSATmu7gEJvZv3+/w+FYvnz5k08+aTKZjh8/PmDAgEOHDq1evZqiqMWLF0tnP3DgwPjx40mSJEly3LhxBw4cEI8fPHhw6tSpKIpqtdqrrroKAABBUHp6OoIgHV2jmHDBm+X7779fvHjxbbfdNmDAgA6oX9u54C1zyy23vPLKK3v37t29e3cH1E8marrJgJcISZKTJ0+eOXMmAEAcv0cQ5P3339+8eXNRURFJkitWrJDILghC85sLBEE8z4ufYRhuPg7DXe8v5AI2C8/zzzzzDM/zb731VosVOJ2BC9gy27dv1+l0ffv2zc3NLSgoOHz48IgRI2JVL5k20/V+3iERn+YhQ4b89ttvDMNwHPfggw9u27ZtzZo169evnzJlyiOPPPLXX3+JarhiYkEQamtrA+c9c3Nzf/nlF6/X6/F4fvnll7y8PPH4oEGDvv/+e47jHA7HH3/8ETJv5+SCN8uff/7pdruXL1/e2bzhBW+Z+vr6oqIilmWdTuf+/ft79ux5PqsvE47u4BAVCoVSqXzxxRf79u07fvz4hQsXzpo1q3fv3ldeeeW4ceP27Nkzc+bMe+6555577oEgqDmxx+OZNWuWzWZrvs5ll12Wl5c3f/78+fPnDx8+vPkfe9KkSQaDYe7cuQ8//PA111yjUqmC83ZCOkOzHDp0qLi4eNJZ3n333fPdCqHoDC0zefJktVo9a9as+fPnDxkyRHyzlrngQJ1nC4GTJ09eaBMuPBiGZWVlBR4xmUyyuAMAIHjaQX5gAAAajSYxMfFCW9F96A49RBkZGZmYIDtEGRkZmTPIDlFGRkbmDLJDlJGRkTlDJ5pUcblcwQcRBAkX3YJhmN/vD2m/RC4URXmebw4ZCwkEQYFhZeHSYBjm9XpDnpUwQOIUAACGYYqiAo94PB6/3x+cTBCEcHUHZyNFgm0OVy8EQSAICi4oKuNF2nZfWr2yQqFocSSqBwaCIBRFfT5fVKVL3+VWsweCoqggCCGTSdxNMYxR4lFEUdThcEgXHRKKooKbVKa9gdlbtmxZt24dAOCGG24YO3Zs4Knjx4+/9957ZrN51KhRhYWF0okBAG63O/j6CoUi5HEAAEVRDMOE/A1L5NJoNGLgmESlEATBMIxlWYk0oucKF3kjYYDEKbHoFg4xpLUEQXAcF67uIExjoigKw3DInzdFUSiKShgWifEiJEm24b7QNM2yrMTfc/CvN6oHBkVRgiDCzdeHyyXejlbjqyJpFqVSyXFcyGQ4jvM8H7LFcBwXBCGcHwcAkCTZtq0UtFqt7BCDaZdDtFgsRUVFq1atgmF4yZIleXl5zRtfeL3eV155ZcWKFXq9/pFHHikuLs7Ozg6XWEZGRqYz0K4xxOLi4pycHI1Go1Kphg8f3ry4XTw1cODAlJQUHMf/85//XHLJJRKJZWRkZDoD7eohNjU1paeni58NBkNg191kMrnd7iVLllgslqFDh951113hEj/33HPHjx+HYfjDDz8MLgKGYQzDQpYOw7BKpQo38hIuF4IgNE23eC1tgTjWRpKkRBoxWVxcXDjbJMwOdwoAEFwdgiCCrRWXykqMOoUsQsxF03TIXBLVidD45jRtuC8wDOM4Ln3lFoS0NlwREATBMBzt/RKfhFg1CwCAIIiQpYAwd1PilIj0SLdMtLR3DDFQxy3wtrnd7tLS0pdeeomiqGeffXbTpk3hEl9//fXiqHDIMXKSJMON5alUKrfbHXKUWiKXQqHwer0SgzIAAARBEASRHkqHYVipVIa0WdoAiVMg1E/L5/MFjy5hGMbzfLi6AwBCFoEgCAzDIetOEASCIAzDhDMsEuNF2nZfSJL0eDwSv/wWYmsgygdG/COM9n5J3+VWswdCURTP8yEHryXuJoZhgiBITHa16ohloqJdDlGn0zXLFpnN5tTU1OZTWq02Ly9PXNJ/6aWXVlZW9urVK2Tifv36iR9C7juO47iE8/L7/S2eFYbnv7U5YByfQOJxoeS5xJk+aYco/utKpxH/8MOlkTBbukbBClE8zwenh2E43KSK2M8KWYQgCOEcIoqiEARJV7lV45tLCb4vrWbHMMzn80UV8xDyUuGKEKdxo70p4u2ISbOI82Ahk4lT/yFbDIIg6UmVrqJB11Vo1xji0KFDS0tLGYZhWXbPnj3Dhg0TBMFkMvE8P3jw4H379jEMwzDMrl27evfuHZw4VnVoxi8It1bWYBCkQ9F5lbUu+W1CRkYmGtrVQ9RqtXPmzFm2bJkgCNOmTTMYDCzLFhYWrlmzJikpacaMGQ8++CDLspdffvnVV18NQVCLxLGqQzPHPd5citQiiEfgr1Urd7rcY1VyYIGMjEyktHcMsaCgoKCgoPkrSZIbN24UP48fP378+PESiWNOHAzX+LgVdQ0aDL2UJPKoVmZFZGRkZALpVorZaTiGAlDm9fo8nv4YNpSWmkqWkZGRaUF3W8tc5/c/aND3IakJatWFtkVGRqaL0a0cYonHu9ftnhcfd7VGtc3VSgSJjIyMTAu6lUN8q9F8U5xGjcBXqlXbWosdk5GRkWlB93GIFj/3jc1xh04LALhCrTzCemydfhMoGRmZTkX3cYgfWaxXqRQ9cAwAoEGQfgSxm2lFgERGRkYmkG7iEL28sLrJulCnbT6Sr6DlYUQZGZmo6CYO8WubPQlDRwTE2eQr6G1O2SHKyMhEQTdxiO82WRYFdA8BACMV1Amv1ywPI8rIyERMd3CI21xME8dNPjfwUAnDl5DkTvmtWUZGJmK6g0N8p9Fye3wcDkMtjl8hvzXLyMhEQydauhdSOxNBkJDHRTAMq/D7t7mYd7MzCRRpkatAq3m0qrZFdnGzIWlLYBiWLheclQ4Nl0Yiu/SVAyUjJdKjKCqKNoa8PgjfmKLZwafE7Vakq9yq8SIQBOE4Hs426WaJSv4rqgdGrHu0N0VC1TWS7BEaIO4/FbLFxFOiGSGROCXTBjqRQwwpkBlOOLP57BumhpnxcRronOxirktJstTjNbKeBAxtkUt6jzRBECAIkk4j7pQWLo1EEdKlBz/fIUuBYTjcdUThP4ld98K1c6tVbtX4ZjiOi/ZuijZH5RDb8MBEe1NEe2LSLIIghEsm8SyJ/15RPTAy7aETOcSQApnScsFNXu86s/V/PTNbpBFzYQDkkcSfdsdUjSrwVDgxzmZEZWnpNOKDGC6NhNnSNQopEBucXtz3MuR1RHXbcEWEqxeGYSFPVfn8TxjrWZ5PQJEXUhIJgmh1q1Lxtx3t3RSrGZVDjLaINpwSb0ckVW41jbj5bchk4t9buFPSF2/1dUcmKrr230tRo/lyBd2LCLsXxxVKORqxXTxtrH8mOeGttOQpGvX/a2zLdpcyMl2ILuwQfYLwQaNloV4rkUYOz24njMDvY9xDTpYNJIkSTyv7tcvIdHW6sEPc0NCkQeDLFSH2kGvmUpqq9vqMvlZeZ2TCkYRiS2pMGhS+31g3RqW80ObIyHQsXdghvl5rXJygDzFjGgAOQcNoarvcSWwTAgC1Pu8AEk9FsdNe38w49YW2SEamY+mqDnE3465gPddF8BPNl4cR28rqJkuVz7++R8a6zLQqr6+mtY3lZGS6Ol3VIb7TZFmckkRGEHMgDyO2jQqv7z/1TW+kJlMwpELgMUr6a6vjQhslI9OxdEmHWOXzb3a4bk9KjCTxEIps8HNVXrl3EwV+QVhYbVyo0w6hz2zUNT1Os85mv7BWych0NF3SIb7TaL5Bo0rEsUgSYxA0QiEPI0bHygazXxDuNcQ3HxmjUjT4/IdkiUmZbk3Xc4hOnv/CartdJxVt04LLaWq7/EuOmENu9u0m8ztpyVjAIj8Mgv4dp/5cDkWU6dZ0PYf4idk2jKL6k60sHQ0kX0H/Kas8RIZHEBbXmJYl6HOCwt2naVTrGs1cNItJZGS6Fl3MIXKC8KHZsjCa7iEAIJci7TxXIQ8jRsByU30iit4WqoWH0ZQaRbbKfy0y3Zf2LoTcsmXLunXrAAA33HDD2LFjA0/dfvvtVqtV/Pzss8/27ds3+Ei0xf3ocFIwfJVKEVUuFIJG0tQ2F9MD10Rb4kXFVqdrvdWxJSczXHTntHjtBpujIMr2l5HpKrTLIVoslqKiolWrVsEwvGTJkry8PL1eL57yer0AgA0bNjQnDj7SBt5ptCzQaaWDsUMiBt/M1soOMSw2P3dvbd1LKYmpWNjZqtkG3TBj3Ut8gqLjRVYOezyHXeyNGg0eQhZLRqZDaNdjXVxcnJOTo9FoVCrV8OHD9+7d23zKaDRiGPbqq68+/PDDP//8c8gj0XLAzZZ5vDe2ab2EuMWKPPolwb0VlcMp6jqNSiJNJoH3J/Gf7M6ONmZyedWEktMr6ut7HD9Z5pXXUMucJ9rVQ2xqakpPTxc/GwwGs/mfKUir1ZqQkDBnzhyv17tixQqDwYAgSIsjQ4YMAQBs3bq1sbERhuEWb9xn7ENRkjwTCvdObd0difo46sxOUqIQaUj5o8BcIsMI0ne6ugpA8TCMYVhIkdRmRIFY6bqL2oItSpEwIJJTIIxAbHB6USA2ZN1Fy0MWAZ8l+NR3NvufdsfOfr1JVKriKIrOMui/strmJCVIVIEgiAjvS4tTZ/QHAfiLYU7nDVQjyOzS8vlVdTsH9ArOEvJS4YqAYbgN90tsK4n7JZ09EFFTLqS+GYqiPM+Ha7Fw2rHNl5UuVyYq2juGGPgDDrzZubm5ubm54ueJEycWFxffcccdLY6IDvH48eNlZWUwDE+cODH4+jAMYxgGAKjx+n62OV7NzsQCXujEx0UiVyD5avV2xp0XrxW1i6Ur1arupniF4FIkDGj1VEhCKmMjCCIKO4ZMH84wsVLBdTf5fPeWV33SJyeBauVXDcPwdIP+0araJgCSwtQCgiDxxx8ye7i6i2aLd9PDcQiAR/x9CgbCv3XxRxhryFzh6hjyuPgHFu1Nkc7VavYWaQRBaE7m4XkMgsVtL8Q/4JB3U2xGWQX2vNEuh6jT6Xbv3i1+NpvNqampzadKSkooihKPiILywUfElIWFheKHxsbG4CIUCoXL5QIAvGpquFaloFnWwbLiqfj4eIZhQmpnNucKZCSB/9poXpicyLKsx+ORqBeCIBiGsWcLCgkMw1qt1uEIvZotpAGtngKhxOi9Xm+wtQRBhBNhVSgUAICQRYj7BHjPfQMVALj9dPUNWk2BShGuOoEXx1h3gVKxptq4KIzwmlarjeq+iNA07Xa7m//eFDBU7fFkEdhbxrp301MdDkew+H5Ia8MVgaKoSqWK9n6JT0IkzSJxT0WUSiXHcW63WwDgEWN9tdfHCvx0jXqGVoPjeDiBWBzHBUHwhV9F3mrPVCYq2vXPM3To0NLSUoZhWJbds2fPsGHDBEEwmUw8zxuNxlWrVomuZ8uWLXl5ecFHIi+I4fnPrLYF+vjWk4YnX0lvYxheHkc8l4+aLKUe74r0lMizTNOovrTaOs4kAIABQyAApWLoN5npU9TdalJ7s9OVjCL/SUn4KD31K5vdLT+RnYl29RC1Wu2cOXOWLVsmCMK0adMMBgPLsoWFhWvWrMnPzz927NiCBQtomh47duyQIUMEQWhxJPKCPrPaLyGJgdEEYwfTl8ARAP52u3OC9ue7aKnw+p6vb1qXmRrVrPE1KuX9xrpjHm+/8Frl7aHe7z/BeqfHad5MS+qI619Y6nz+LByfUVGtguG+JGHhODn0ofPQ3jHEgoKCgoKC5q8kSW7cuFH8XFhY2Pw6DACAIKjFkQjhBfBeo/m55IikHCSAALiMprdY7TnxXfIJLPf6Kry+IRShidE4ul8QFlUbF+i0Q2kqqow4DF2rVm2w2p9I1MfEkhbcXlULAeiF5LDzNl2aAqVi+ukqD89rEXiT3fFiux9smRjSBQZrNzkcEIDGKGPw3pSvpLd0TcmWTy22F+sbS73eWytrYyXlv6rR7BWEJYa2DERMj1Ovt9o6Yhmfned3udwjFKQK6QIPZxtIwlBOgAZT1HUa9RCKmltZ4wk1nSJzQegCz9w7TZaFem1MXnPzFfRWu6MrrsbdaLO/nZbcB8dvi48rMlvbf8GDbvatxpYKDpEznKZwCOoIDaHFVUYAQDfuN/3X7vAK/LvpyXfotEWZqX5BuK2i2t8Fn8luSWd3iAdczDHWOyNG4vW9CJyCoSNuqenjTosggGK3e6mx7jOL7Ylq41+utseZs4JwV43p0USDxIaF0kAA3KhRr7fGuLvNcPzPTmc6hkUl3tG1WNlgXmLQoRAEACAh6LPMtCa//67KGnlypTPQ2R3i/zPV3xofR8cuDutKjXqro8MXWsScG+PUt1fVIADqTxCvpSZ5BH5uRdXgE2XLjHV/OF3R9i+eMTUkoej8+Lj2mDRdq/7R4YztJOkDtSYAwGNJHTI02RnY7HTV+7npmn/+4CkY+rJnjxMe76Om+gtomIxIp3aIJp9/o8U2r32/2xZc1TUd4vQ4zbPJiUNp8rPM1Kka1UvpqUf69/k4IyUOQR6srRtwvPSuatPPDqcvAs+41en60mpfmZLYzkGIbBzvReCbYteYXp7/xuYkIehatdTywS7Na/VNi/Va/NwBIDUCb8jO2OZ0PW6UfeIFplM7xA/N1slaTQrW3qnwQK7SqLc7ou5SdQZSMHSUgm6Oj4EhkEuRDyXo9/TO/i4rPRNHnzI1DDxRenvp6Z+sNm+Yjpud40UFh7TI9MalmRaniWFA4qOmOgECC3RavE3Dmp2fPx3OUq93dqg/eD2Kru+R/l+787UGWYL3QhJLXxNb3LywxmL9tk8vAGLpvLJJQosiB91stLEmnZm+JNGXJB5K0B9nPZtYz+OVNSav7xqVcopGWaBUiP5lh4sp9fl/cTjzKFJawSFyrtOolhvrG/ycQXIFdCT4efCF2Q4LYE58dGKXXYiXauvu0seTYdx9CoZ+lZU+ubySgMCd7VuDINNmOm8PcZ3V1ofAhyml9qFvG1eolN11H76+JPFYavK+Qf2/z0rPxNGX65tyjp2adbrm9sqaH+yOap9vs8M1WxOzMEwdgoxWKr61xWA3vserq/1AGKNUpsf0haDzsNfpOsgwt0iO//TAsW96pL/ZaPnE0vZ+N8dx9gCWL18ufmjzBS8qOunDJwDwfpPlsY6J+x2tUq5rMt/bEZfuNDT3GU95vN/bHW80mHkAYAi8kZH2g802JnaL4abHqd9oNN+ha9c4rwDAB/VNNATfpuuSMfOR8EKN6a5Eg7K16cEcAv+yR9r1FVVKGG5bR/6uu+5yOp3NWgH19fV33303AODjjz9uw9UuNjqpQ/zV4WJ5YbxK2REXH61S3FdZ7eUF/CJYw9eLwJcadLtd7meSE4wcb8Cx/c5YCkaNVyuX1ppOery927GM7+X6Rq8gJGDoldGH33OCUOXz6xCkbYHcnCBU+vyZJBdtZjFjAopEsurxKOvZ7nC8n5UOziprVPp8SgiODzXUMIAkPs1Ivfl0jQKGrtVF/e6clZX18MMPN39duXLlkiVLor3IRUunc4i/OFwfmS37GHaqRo10zOB6Go4noOh+lh3RjYYRpVmsj19mrM8hiVKP943UWMY8i5PCG6y2ZYmGNl/k7SZLIobOj486/N7KcYXVxhwcK/P4Zmo1/46yS2X2c4XVxt4EVlHXeLNaeW3E2Zs4bkGVsTeBlXi8t8bHTVO04sf/r75xUWKCBkHcAPgEYWGVUYsiZr9/MEXdHWql0KU09UF68ryq2o8x/OooN2yYM2fOJ598MnTo0P79+5eXl997b/d+F4oxncsh1vr8n1isjyTor6uoKvN6mziug3ROxB0FLh6HeIWSHq6gzAJII3AuvJZU25gep767xvRIgqFtHe43G5oYThAE7qboN3hYY7Yu0sX3JrBf7a6X6hvtHEe43CG13WAYJp0Mw5wzdvyL09WfxPsQxIqkhJknSiN3iB82We436Fie7034nqtrdCCohKBcnd//P4crXxu3ur7R5/MddnsQCAwiif6k+vVGs4PjdaFyXalUvJGaNK+8ckPPzLxoQgJWrlyZk5Pz8ssvv/baa2+//XZ6err4yiwTCZ3IIVIUVe51XB0Xp6KolzLS6n2+0wKUjaIUFdpticrMIYU50fC5YBjGcXyMNq6ooenx8GlEgWUJa0Xp0HClSBggcQqEUm8VRQyDD/I8H67uAIDgIigA4mEYgiAulDIzhmEwDEsYJmH8GIqCa+sOcPzlKgWI/r6sbLRkk3i+Rp2iUoaU+w0HRVEeBEmhKQaCtrMeOy9sc3tgjy+k0ioEQYjH10JzsNTj8wFoq8t9hOMJBAm2TbwdwcdZGE5U0GOPnbxKrbbxwu92Z8hCRf5yMRkEsdflFjV9Kz1eGIK2utmXG8wujnvVYp2PJ/QhQ7TYDRTF48SMstM/9sm5JMyfd/CzYbPZCgsL4+LiTpw48Z///GfGjBmyQ4ycTuQQ3W53Lxi8YbFcr6CuJvAFjU03qRR+v9/tDr3HPEVRHo8npKwmDMPhcuE47vV6h+PoIqfLwjAhYyAiFIilKCpcKRIGSJwSi6bpcybW/X6/x+PxC8J6m6PM471aqbhMQUkIxIq/kJBFhBSIDTwrYZi08depVZ/W1Q9BkwAAJElGfl8+tVhtHA9D/vn6+ECB2GAUQa+lbrf73wr6kcrqW+O1mSicEad+PFEvLRBrsVgCDx5jPU+YGhbExz1irJ+oVgZXDUGQkHf5RqViUWkFAqBMBO6n1TydlRFOIPa013elzb6rV1aONk4UiDX7uduqaicq6CE4sdnl8vh8Y4+e0KPIFLVyRpwm89zO4PVqJZOaPPlEyXdZGSFHaYMFYpOTk+vr6wcNGrRr165hw4apVN02yr0j6EQOEQCQgKJLDLp7a4wwgB4x6OM6bL+IRBRNx7Fixn25IvZhPR3Bk6b6XgRxfZz69YYmlucnBMlHX1imxaknlp1+PiUxXJBdOJ41NfYjMRKGhyjoVt1xML0I/I3U5D9czFVKRRtuZT+SWJWauNXlfigl6Z26eouf00YWUNmfJK5Q0DDkHq9WjpQceFnZ0HSTVpMUEEsUjyIfZ6T8z+HqSWIL9WkwBJ5LT/3N7vjGbLuqpKI/SUzVqK7XqPVnLZkVH2f1eqdVVH2fnZERweYTWVlZCxYsyMzMLCkp+fXXX0eOHBlJjWREOpdDBACMoKkRGamtp2s34jBiV3GI5V7f88mJX1jtN8dpvrM7JnSywN3eBN4Dx39xuCarowgM+NbmMHNcGo7e2o5g7GQMndkO7Y9UDLspDlMoFIedzkeM9e+mJ0eY8ajHc7NWI+0Na3y+r22ObTk9WhzXIMi0AJsJGJ6gVo2lKTuX8F+7Y6PducLUMFJBT9OorjfoaAgq1GktHHdDedX3WRlJrcVpHj9+/IUXXhBHTnAcD9zYQ6ZVOm9gdkeTr6D/dHal8Gw7xzf5/bMqq8u9vkjWLJ9npsWp10e5jO8JU/0giqz0+WO1cqY9vJicsJtxfxdZkDknCHsZ9nJFK0OubzRarteo0iOeElEj8AytZm1m6qE+PaeolWsstp6H/p5ZVrnR7rhPr7tWrbquouow432tvvEQE3YO5957792zZ0/Pnj0hCNq/f38b+t0XMxexQ1TS+90s00W0OR9J0N9WVbuLcY+iaS/Pjz52ah/TuR70GzXqLU6XmeMiTP8/h6vO5++BYzfHaaJ90e4INAiyMjXxodq6+lCjny04xHpICMrGpUIvG/zc5xZbyKiaVolHkbnxcT9mZ/zVv89VKsXK+qYBJ0rr/BwFwWPKyoustonlpwura0PmXb58ud/vdzqdjz322NGjR5977rk2GHDRcvE6RB2C9CTwPZ3MrYQjlyI39EgrSk/5okfaxuyMQoPu+tLTy4x1nWeLIj2KXEbT3zmmDzsAACAASURBVEaskPiosS6XJn91uOZEH23TQVylVEzRqJbW1LWacmcEgy1vNponqpXSTrNV0nBsoUG3OafHN1npiShy1OPBYFgBwUf75PxgC60zZLFY5s2bt3nz5nHjxj366KMlJSXtMeBi4+J1iACAy2lqu6trOEQRMVIdAmCeQfdHn+yTHt/okvKOkK1uG9Pj1Osje+Xc5mKqvL58mhpBUz07ZqeqtvF0kuGEx/NZa0uJt7vc0u/LZj+3xmJdEruh3oEk8VSSQQlDc+Pimnw8jYTtUyMIYjabt2/fPnLkyOLiYrx9Hvli46J2iPlK+s9O402iJRPH1/dIe8Cgu62q9v7aOlcnePefpFYdZz0nI+h0P1Bb158gfnUysRW7bD8KGH4rLeUJU32FN2z4OicIuxn3KMke4rtNlqsUdJ9Y637fqYtfbTHTCOhzrCSPCr0j8+zZs2fPnk0QRP/+/Xfu3Ll06dLY2tC9uagd4iiaPsyyDu7Cu5K2AQEwQ6vZmtOjyc9dcap8i7OVvdI7GgqG/qVRfdHYJJ2s2O0u9fhmaTVOnh8X5bq088ClNDlHG7e42hhuNOII6yEhKCd8x9bB8avN1nsNIVegtIsb49Q4BPck8CcSdT9lZ4RMM3HixB9//HHFihUAgMWLF0e1369Mpwu7OZ9oUaQPju9m3GM7388ychJRtCgjZaPdsaDKmK+g3+6VHWEwXUcwTaN6uK5xieSw4NKaul44toNhbtHGddBy9XayLFE/tqTiA7NlUUIIvaXtLmaU5Pvy+2bLcJrKDdODaw+rGppmazX/kdyg9eeffw55fPz48TG3p/vRGXuIZV7v6fAvLLElX0k3ayNWe30nPd42TFJwgnDM441kdrLjmKJWbe+VRcLwkEN/b7TEYFu+tnGFQuHh+b3hR2aPs95jrOehJN1mJzOr00yntACHoDfTU/5T13icDRHdssPlHqWgnTy/3cVU+VredIbn32u03NumyWVp6v3+b2yOVrVjy8vLy8vLN23a9Mknn5QHEHN7uiWdq4coAHBPtZGCYQ4AGICXUzp8L8p8Bf1SfRMA4IW6xiqfPx6Bq3z+1T3SIl9M7+D4+dW1A0nitMc3SkHN110wwWc9iryZlrTV57+7vHIYSb6UmqjrsKU+4YAhMMOgX2e2DAnTi7m3xpiBYydZ70S1sv062x3HJSRxlz5+UVXtnsRzKsILYDfjLtRpZ5+uGadSrDHb8pX0woBlhR+ZrQMpcngH6Ia80Wi+VqNqVUB34cKFAIDTp0/feeed8fHx06dPj7kl3Zj2OsQtW7asW7cOAHDDDTeMHTs28NTtt99utZ7pqjz77LN9+/aVSCyyn2GTMOyxRH2Dn3utofEY6xnWmrBSOxmloI+xtae9vlMe7/Ikwzc2R4XPd09V7QAF7ZNUhYEgiHK4GIbZy7B6BNYhyLykuKW1dbfGX+DXwIlxmuJB/R8uO51/qvzpRMOM894LuyXRcOXBI88kGYK3RilnvftZ9sO0lMdM9e+np5xnw6JliSH+F6fzxcrqRQGy7UdYFoXAHy7myUT9YdbzQkrCgmrjwrNnPYLwTpPlnbRIl7tEjsXPfWqxbcrObDUly7Jr16796aefCgsL9+zZ4/F45syZE3N7uivtcogWi6WoqGjVqlUwDC9ZsiQvL0+vPzPmIioIbNiwIZLEzXgEQQFDJR7vpPLK8Uqlp+PXYyhheCBF7HAxChhaY7FudjJKGGYEgfZ4OckYYwiCCNjL+vwNHMcB+ICbfa3BnIahfgGEj4g4T2gQ5P9SEq9Vq5bWmr6zO15JSYrtRl3S9KepFAz71eGcFLR5XmFZRRKKChDQIEjn115DIejtjLRxJeWXZaY1T+nuYNz5CtrBcffX1pd5vX97zlHK+MRsTcewjlgP+oHZOlqhiESF99Zbbx06dOjq1as1Gs2111777LPPxtyYbky7fifFxcU5OTkajQYAMHz48L17906cOFE8ZTQaMQx79dVX6+rqrr766vHjx0skbmYoRa5qaFLAyDUq5Qar/XpNhyhmtyBfoTjCejgAfWVzXKmgK3y+TzLT40miVbUbrVbb1NRk9PkXVRsna5QYBP3icM2pqlmZktQr1kbW+f3PmRoaOW4IRS2NbPqyQEnvyMl6paHpqtKKe3Xxp7zeBo4brKDvi6YPa+a4Z00NJr9/AEk8FGqGISTTtZr1VnsLh2j0+nc4nG+mJX/UZG3nltDnjV4E/lRm+uIa4289M4mze3UloOg3NjsFw3fqtasazHefHdTzCcJbTZZXOmCch+H5D5osazNbWZVcW1ubkpLy5JNP9u/fXzyCIMjjjz8ec3u6Me2aVGlqakpPTxc/GwwGs/mfHRStVmtCQsKcOXPuueeer7/+et++feESMwwjboIDQRCBwJ9kpmXg2HUadVFG6u3Vxp+sNigM4KwoYVSIhQYeyVfQ2xn3a6lJdT7fYJr6LDNdjSIRXgqCoBQcK8pIVcDQvHjtkX45l5DklSUVq+sb22BboIXNiAcfMzbcZdB93iNdjcBrw7cJdG4FaQR+MsnwaUbq/zU0nfJ4/y89NRHDiiwhsgc3i8iTpoZbdNpPM9OyCeJ9szVC+2fEa391uCwcH3j83lqTHkPzaOogy94Yp4nkUsEWBrdMVFeINgsEQfempugR5MX6RgiCWAH87nRttDveSU/d3it7BE3P12l3MG7xuuus9jgYvlqlbEMp0nxssQ2iyEsVdPCpwAbZuHEjAKDZG4og530cuUvT3jepwFsSKGaXm5ubm5srfp44cWJxcbFarQ6ZeMmSJfv27UMQZPfu3eKRWYYzPRGdRj3z7xNFfXv9Wx+6T6QJv4FcsE5cMy2UOP8Vp51TWXMARlII8r5ePZuPBwvwBaPT6QAAOgByzh5ZpddPt9lvPX7qJ5p6v3dOSmQads0E64wSBKFUKn21dQMTE1+rrinskflURaVS2UrfOVDTdJJON8pqH6hQXHGi9PnszAN2h2h2MESQqpijtq6nXt9jz74r4zQWv38phoXLG0gfvS4/TvM7xxeenZFo9Pr/cJ54s1f2FwwzJymxR0KI/QZaladtQThLJJpXwniJXJ9e0n/wXweG6/XPnK7iATh86ZBUAgcAZAFwLc/337P/R4frOn38WyWnX8rJ0ku2Twuxy0jwCcL7R09+3K+XLi7E0y490i0TLe1yiDqdrtmLmc3mQKGhkpISiqLEIziOIwgSLvF7770nfmhsbGxx/WEAfNkre+bxU5YUR7CuVHx8vN1uDylEGk4lFACg0WhYlm0h+J5LEh9V1aQi8DslZdeolFoci0QgVnxlBgA0+rlfHc4kDL1SqYAA6APArgF9Hy2vGLBn3/PJCdPOFaeSsA0AgCCIVnvOPDXLsjabjfRzu2prXzhdbXO5BhGEw+EIJxAr+vEWRWh4YRyGTMjOmF5akY5hpXV1mnM7DhRFoSjqcLRceBfH8++Vn+5D4DjnN7LuxB17xioU12lU49RKIsx7t1ardTgc/6bJ1dW11+NnHrC5lTVqFJqmUeWUVWzMSg++1zRNSwvEBo84B18EhG/ekAKxreZCECQuLk7pdExSKW45fjJfQfdTKQmHvTGgnZ5M0N13qqzGYoUFfpQghLQKAKBUKkWB2OBTOI7zPB/ybuI4XtRoNiDQJX5fyCtL+HGZNtCuV+ahQ4eWlpYyDMOy7J49e4YNGyYIgslk4nneaDSuWrVKdD1btmzJy8sLThxJEVeoVZ9kpC6tMX3Rjp1qWyVfQf9kd8SjiADA3MoaW8SSLQCAKq/v9qpaAoaL3eyjxnrxII3AzycnvpeW/Fxd4/zK2sg1YMLxn5SEL6x2EobqfP42yP89m2T40uZ42VS/KEGfjWMFpacjVLVYkWTYZHc0cdwlJLmnV/aBQf1HKKi3myy9jp2aX1n7s8PpDbOeY7JGdZT1iPGkTp7/n8N5n07/eZN5AEn0i/WCtg7F7ucWVBn/dDFDKbLC6x8VNBd0rVrZhyafq2+436CL+TaOnCC8Xte4JMwbkkzMaVcPUavVzpkzZ9myZYIgTJs2zWAwsCxbWFi4Zs2a/Pz8Y8eOLViwgKbpsWPHiuuHWiSOsJQRNPVZZuqsyhoBgm5qhxSoBP0Iws3zI2nyZ4fTzfM3llZmkESrs8y4scHj8ZR4vHEo8pPdMZym93jdgbubFqgUW3N6LK9ryD9V/kpKYvCsa+TEI8jLKYkIBGmRtvzotCjyYnJC8xYC6yy2m05XL9Bp7zfopCdYNAiSgKK3xsfdrNUAANJwvFCnLdRpq3z+b6y2FaaGxX7TNSrlFI1yjFKBBlyKhuHxauVXNvtSg25pbR0JwXcatOPKqxZ3kekUkf1utvBkWT8c29wz0yeAASdKQjbXeLX6d5t9SAcsTfnWakch0EH78coE094xxIKCgoKCguavJEmKI7sAgMLCwsLCQonEkXMpTX2ZmTajotrD87d2wC8qDoUFAF5tsNxniAcAGDB0kELRahwiTdMulwuFgApB+hL4Hy7XFgczraJ6qkY5EyfEsSI1Av9fSuJElfK+WtNXVscrKYntiavMpciNtkj1tSSYodUMoanCqtqdLvdbacnJkkE5R1jPgwkteyjpGHqPQXePQXec9Wy0O54w1j8gCJPVyqka9fizr/zT49SP1tYv1Gm/tzruT9DtYdxGr29SNJLaFxABgPebLC/UN67okTGbIgAAR1mPEoJfaWiaola1WBz5eZM5X6F4rq7hvVgHV66qa1ia2MbtDGXaQOdaqSJBHkVuzEq/8XQ1KwgLY7oa5ICbvbPahEAgFUNPerwQAM+nJFE4HuEY4o1x6vlVteI0zXPJCSoY2mh3PnXgyCCSmKpRXadRG1BkrEqxLafHMmPDFSUVb/XMHN3WqMA8ilx+9q28nfQi8J97Zr5Y31RQUrEyNem6MBMaNo6r9/v7hn/J7UsSfUnioQT9cdaz3uaYX1lL1NZNVCkmq5QuXqjw+nKOlXBAWKTXPlBbNz9Rj3XKxcstaPRzi6uN1X7/f3OyRiUliiPF213MVUoagaDHTPVvBYRe/8/hbPT71/ZIzy+p2OFipFVwouIXh8vq527QaoTIVoWKix2OHDnS4nh2dvbu3bvb1he52OgyDhEA0Ickvu6RfkNFlYvn74+FlEhzL6AXjvcn8AQMvVsfn4ljUS01oWF4bUZahc+rQxBxpmKGVuMjya+NdeLmGLkUOVWjuiFO/WZa0ka7Y0Hp6Ulq5fIkgzJoA8lW6Y1jbkGo9vp6xmKTKRyCnkjUX6GgFlebfnK53+zZIzjNEdaTTeDh5k8C6UsST5DEsgTdYRj9pNY4p7LGznEDSOIw6xlAEAurjX84Xc/2yAD+zj4rutXpurPadKVS8VFGqjLgr2uHy52voKfFqUeXVGy0O6acHQBZ1WB+MCXJgKEPJegeM9b/2jMzVkuVVjU03ZtkQCEowibLyckBAKxfv77F8TvvvHPdunWyQ4yEzijuIEEvAv8hO+Mzs+2ZutBzeZFT7/fPrKj+xGL7ISvDwnGTNKq/GHdmNDuCNwNDIBvHA+dt4xBE3BzjcJ+ec7WaP5xM7vHSf5VVWv3c7wP6Nvq50afKt0UvxYhA0ECSOOCW6rpGy1VKxZacHk1+/6jDfx8N0jI4ynoGRjMHgkBQQZx6VXrKkd49FTCcjKFaBFmelLDf5R6jUmZ0Ji3YYPyC8FJ94/wq47PJCW+mJVEBb6rCWZVsDYKsTEl6qObMTgN/OF2nvb7Z+ngAwK3xcTwAn0WsGS7NLsZd5vXeHP0A0ZNPPjl8+HAcxzEMGzZs2JNPPpmYmPjOO+/ExKpuTxdziACADAz7Nit9o83+SPnpNl/kB5vjilMVPQnst56ZBhSt8fnHKRXVPv/SmrpjoQRO2owWRZq3DZqr1fzscI08cswvCNeolbdV1t5fW/dGo6X/8ZKhJ8r2RrYZ0GCKPBhTCwEAehT5qnf27YmGyeWV7zVZAqeND7vZAW3qjeIwpEPQ/iT5bVbao3X1LBBu7ZTaNiaff53FttvpqvL6ppRXbnYyv+Vk/jto06vjHi+AQB+CAAAUqBQT1cq7qk3rLLYVdY13G+JJGAYAIBD0XHLC83UNUUUphGNlfdMiXTwV/WvE66+/vm3bNnG8ftu2ba+//nr7jbl46EqvzM2k49i3WenTKo1NjPuF5ISo3k/cPP9wVc1XZuubacmiDOIuxp1Hkktr6/qTRDqOPmWqX5WemhXBBrhREY8iM7SaGVoNSxBfGuvWWe0Mz39ncdgFbm58HAqBqWVVFX17U60tK8ilyC9j1AcJBAJgcXJiHgIXVhm3uZiVKUnxKAIAOMp6rte0cWb/p+z0RdWmjTb7JSTp5/nRyk4nOnmC9Swz1d8cp3m51vS7zTFbq16elBBylHO7ixlF/9NlnBMfN7WsShCEk6zHGuD+8hX0SJp6ub7pWUnJwlY5ynr2ut1tm6LZu3fvJ598Ii5QGTFixOzZs9tjycVG1+shiqRi2OZB/bc5XQ/X1kWuAHHAzQ47cKTS6/uzV1azKOweF9OPxnsS+GS18iubIwPHN9lDb98TE3QoKm6otqtXlhqFURh8YrE+lZSgguEf7K17ujyKPOBmO0j0Ipci/+jVIw1D80vKf3cyfkE46fEObGs0iR5F1/dI290728nz83XaTjiZss5mf9ig/8PpOuBi+hLE88mJ4eZ8tjtdlwc49O9sjpdTEv50MQ8k6PYx54xgLE9OWGuxnTxX9CFaXmtomh8fp0ba8vOMi4trDv92OBwt4vxlpOmqDhEAkELgP+Rk7WbcS2pMre49xwtgVUPTDRVV96YkfdGzR6BQ4B63ezSlKPV458drF+m0m53Ox2tM006Vf2W1d9BGJVaO+8xiW1prqvX5YQA/k2QQeN4h8CNaWyyIOJ05BC4AUNGm3xvsbN3RkxD0fHLiiylJC6prF9eYVAhsQBFf0AqWyKloMu9k3NPb1M1EIjC4PRh9/luqapw8v2NgXwnvIwCwi3EHhmTTMJRF4Gsz0+bFx7V4RDIwrFCnfdzY+tZ94Sjzen9zuBa0dYOq4cOHL1iw4P3333/33XcXLVqUlpb2+eeff/75522256KiS74yN2PA0O+y0mecrl5YXftWWjIa5u+9xue7q9rUxHE/ZGeOTDAExtMwPH+E9eQraQQGt1TVwACaGadZYND/5HStbmhaUmMarVRMUSunaNRUu4PB7Bz/X7vjx2rTZptdnHp+My1lfFnF08bGp02N49R0Kh72hRn/41di7y4BhSAeTB4zudjFZESzuTu5Yyu2c6sAI5AgcLPncQmtCPZNVivzyMxpFdULS47SP3zOwTAkgIYZsxV9+ktnDMT8v+/TDh3sDYNaADlSFoK4KAIDqB+/RY8dERAYQJBz0VIQi1n1QOwcv7yuYbPTZUCQVAxbUHZ6bnzYIc7jrIcDoG+ADfPjtQuqaweQxIdmyy1B8x73JehGnSr/2eFsW0D16w3mm7TqNov7pqSkXH/99eLnadOmte0iFy1d2yECAOIQZH1m+szT1bdW1q7OSAkWJf3B5ri/tu6GONXTSQnBZ/9i3Fk4Ho8i/1Kr/nU2kAJBkHkG3U0qRY3P96PducZiW2aqn6BSTdEor1Yqoo2kYwXhD6dro835o90xgCSmGXQvJ+kT0TMtv693T+nsIkTxbuaOu+CDB/GjB1/+Y9OLdtvMhho81MpfGEEAAPS54/pI+Sk+NRMQBGiqoz77iE/PapELQRAAAdr/T64+APwrIe3BE0fGjxwzxcsMq63uv+HzbwYODpafaAGKohzHCYJw3eGD3/UbdHdaz9/3bjF8sppOSYMRhA4z4YAgCBVwCik/xWX1Yi/LJ7ZupjesZWbdJl1oVPzmdC2tMQ2jqB29suJguNTr66nRIGzYSa3tLmYUTQf+IepRZF1mWqnHm4xhwV1LEoIeT9Q/bqwvUCqCHzlpan3+b2yObTk9osoVyOjRowmCEIVUBEHweDzyeufI6fIOEQCgRuANPdJmV9bcUllTlJHaHDTHCsIKU/23Nkfz/EkwuxlWQqk0FcPElWqVPt+3VvvTpoa7OdM4pXJ6nOpKVSsdtEA/mIZj0zWqJ3plJWGotLiDBJxGS/59AHLalRC8T4Cg0lMhf2oCBAAAcJCrhKorz3wAAC5ruXm5AAEoKNdRXSoM+CdOHFrRa+DOlLQP6mtfoVufKYYAEC8zFQgvaxMmGas0DINxfrisRIBCGNZsQItTcFkJlpLmT8kkjh9utdAIsXHcirrG/9odL6UkXXt2zUxvAlcgsMQtCRlujUKQxC6j12vURWbrO43me6IMmH2r0TxVrUxvU/iXyMSJE9euXZuSkgIAqK6unjt37u+//97mq11sdDqHSG76Hvv7EADAO3iIp6Clgmw4xOjouZU1m77/ZnrJMU4AVdk50wYOz8DQLTk9EtCw1dzDuG/UqAAAxO6d2M4tEM9zWT09N85qkSwDwwJXqj1QW+cVTDcmGq7BseE05f74XV1jAwcj9WMmUpfkbnG6fjI1bjRbUnFsilq5JadHj/DPN/3NF0h5qQBBvlEFnhGXhUvGk5Ri9du+/oPw4l22gYP26ROZR5bzXKRqN4p3XoMwzNfnEuyvHb6+A9gJU1rkEtVunOeOFR46XuKgFbk+94d+NvngnvqsntvHjWnVm4tqN36/3/fX1o3H9rkys7V+rzF3mDBmvMSfQQu1G9XKF/kEg+BhyeI9nitD7DbRDHr8b3zPn4LO4J4wFUi+Zv5kti4oqbiUorb1yoo/mxL7+yD21y4oKRWMmRgyuziAeH+QOC525BC2b6egT3ZPatmYIs8lJ/67vHJ6nCYpaGESUl1J/P4zoGjm2htAQPfN4uc+s9r+mxV6f1ERfN9u7NBBf2qaZ9ykkAm++uqrZlm8lJSUr776SuJqMi2AJASXzjONjY1IeSn9zTqm8C6k3kR8u56ZOJlO78EwoQOYNRqNy+UKFE2yWswJ339TeNWkQRrNwo1f/Djiiom9W2pXK5Uqn9fj8XoBAJwAejbZt2iVPTg//cUnzISpIE5Nrf+MGzoMzh3KesKG+/EC2Mvz33PQl3bnykO7x9QbT/17pqW68uqdW5InTM9B4WlK+l8wyAi1mQBN0801wo4eRg8Uu2fO4SBItfYjx10PIApFi2lBh8Ph8XgAx9HffAGbG30D89hRV/Y9XrKpV3ZWqHmAkA4RcBz97ZewuYHrP9h9+RXBuYLlv+r8/iEnysr7ZLPfrFM01tt694+X9GjNNDtEzuNxf/0ZZbXZBw3WXn4lkJQ+ayn/xbL0N+tgp807dJR3yDAQRv6LKN6F//Gbv08/xGgErNu5+IGQRVg57rkG8ya784Uk/b8CJDaIPdvwbX/4+wxAa6t5v9e1qOWe7giC1GD46AOHj/fJCXxlJnb9iW/f6u87AK6uBBwPHnwsZL3uqzH5Afh/qUkgQP4Lqa6kv1jjz+kFOZ1wQ53zvmXN8l8v1jeeYD2rM/6R0cNxXBCE5mX1xC8/YUcOcH36wRXlEEE4599FkmRtbW3oOyGJVquNXGDl4qETOUS32w19+yUwmoRb74BffBoAAIAAQBRDMEaSpjnfHZeMqKTor/b9CQtCsuR65P1q7b+HjT69+bs22+yHICuGb4lPvOuSoZlu5s+dv56mqN7Rzo1CgH/qRfilFfyESWDQsBY6qSEV9KacKLnZoJsZHyKiQpS/DalMAcMwBEEhVXyahXCaj/xisz9dVbt9YN8WF29VkZQkSa/XG3KoUSI7iqIhBQGbCZaPdbvd0GvPQ5deDgAQ/vgV8nsFFG9+YW/mJ33S4v6DR1ma/t+JA1rvubPzPi9AEAAjEADA5xWwEAtp3kvL+lWX+OXBXecc9fsACgOAAAAgnxdgeMhfUQNGDBo1buP+7ZfaLeJzLAAA/H4IAgKCAgAgn09AYQhCAABOBOmTP2Hj/h1D7P+INv6TS/zq9wooDhIShDvuhp9Zxj/xPARBlZWV4RpNAtkhhqQTvTK7XC4kpy99+KDbYkGmTiN++CraHiJhtip//OrtlERlnBra5W0YdRWTnd0iV2APcQvjHenjmFvuAF4vvW4NM2Ey0Gip9Z9xQ4fDuYMleogAABiG1Wo1Y7WyW7dMqK0qTdDaqhyIIKTdcBNzbjewBef0EP8+jO4vds+cI5w6rmDdrtQshGVb/PL9fr8nyJI8itxjtU8OtRIudA8RABDK6zUj9hADc/1lsfbDsZav3hH0EHEcd7vd0Qr3tioQG+wQXS6XAsW52kpv7/6EPgExVfP6BBiGm31xA4o9mpL1u0qzqrrsWrsZiddz51qF1Bt5ghA08bAgQHW1vD4omhqC/kzJyHfYWpxCGow8QQoqLQAAMdYICUkh/wB0ADzSUH3vJcO2njiEwhAAgOd52GoGPq94QcRUI8QnCCgqAPCeIWUw68rDscCymudGxK9wvRGiKG9iir+2lgbA5XLJEyaxpRM5RAAAl9XTOyiX/vBNAQLeISO5frm8QsGF+wXGx3N2e+AjjiUkVxkvTfnvN5AAGXv10468PERfSKPhWJbzeAAAu6pqh6vUnE4LAPCOvob65b8Qz/uzensLrsEwjJPsXQowDLRaDqc0N97k/PgD/edFGAwbr5kcl5AMAJAwO/AUl5BMWS305x8LEOS98moQ8cOdR1H/r64hwsRt4yjrHdbpN8Zjr5tJf/QWWnoK+Pz+3v3dU25UKBSMywUA2Gh3PFRTd7mC3pqSqB18iRdFVSqV41zFbKS+nv70fdDUCDifv98A97+ub3F9GEH+PHbqziFDmHPnT5B6I/3JauBtBJzXPyAXnnYTE+Z23yIIRaWni/51/e3pqWcUs71e1VuvIo31gOd5faLrljtwHHf7/a8fO/VuWjJz2cjA7C1emZHKcnrDWuzoIXx/sXfYiJAlCoLw22+/HThwAEXRtDh3egAAIABJREFUoUOHXnFFiBESmXB0olfmqBThQSy2EMg9UbomIzU3aCUGgiBRbSEQlQHRbiFwZgzxXBogaOjRE2X9egWHXranhxg4hnj5qfKXUxJbzK5GNYYYfKo9PUSJLQSQ8lIhKYWnKLGICpv9oVrTXoZ9JSVxwtmpZIktBJDSUrJXr5BB+KV+bkJJxfE+2SEFbJDSUi4tDRCEdLP84XQtqjYeybtEAf0zAALXVkEKJafRAgBwHP+wvnGt2bopu+V0SguHCAAAHIdUVHCpqeLfZ/AY4ttvv3369OmxY8fyPP/zzz/3799//vz5wVbJr8wh6Vw9xPNJpc9n4/gBXUrOvpk0HFfByEmPt3/H2M8KQpnX10EXjzlc1j+xnF+bLfeWVY5RKbf16hEXWWwz17MnoCgQyqNtc7pGx6nDyXlxPSOKIb1SqRhMUS/VmpanJjUf5FPS/7mOILzZYF6eFNkurwgiXe6OHTuKiorEtcxjxoyZO3duSIcoE5KL1yHucjHDaCrc4pbOTx5NHnCzHeSzjrOeZAyN0KFcWH50uD5usvQksLt18ctMDUc8nnfTk6+MkZDEdqdrdHwbl9AF8lxywtWlp+fotCF3Vv7aYkMhMK61nRQjxO/3u1wutVoNADCbzdI7Yci0oAuvZW4nexh2ON2FB6QH01TMdcCaOcp6ukTfeb3V/kCNcaJaeYD1DDlVrkORPZf0i5U3BADsdDFXxWIbnx44dkeifllViPgYAYDX6xoeiN0+AXPmzLn11lvtdrvL5Zo/f/68efNic92Lg4vXIe5m3BJrVDo/eTR1IDIJxTZwpK0yiOeZ1WbrS8mJfkGo9fqUMPRySqIqdr3aEo/XzQu5MXKvj6QmF7uY350tYw9+cTjtPP/v2O2eNmnSpA8//JCmaZIk161bN378+Fhd+WLgIn1ltnJcmdc7tCs7xCE0dcTt8QpCtKtlI+EI62mz2sr5JAFF9rNuJYwkI1gp74nt3/t2FzNSQcdqPwAVgixPS3681rQlp0fgcviVDU33JhpQCIpo25TIOHHixMGDByEIGjx48KWXXhq7C3d/LtIe4h7G3Y8g2rCrSechAUX1KBJbfW8RAYBjHm9UOwdcKF5LSV5vdRQ12faz7tHKmO3uJLLD5c6P6TVn6eNVCLLabA0ogqnw+m6K6UaSq1evXrt2bXJyclJSUlFR0ccffxzDi3d7LtIe4h5JTYeuQh5FHXCzwWFD7aTa5+cEISPWmuEdQTwKH+7Ts9HvP8x67qo2WjkuhqrcOxhmcdD+q+0BAuDF5IQbKqqv06jE9fUrG5ru1MdTAcHk7ef333//8MMPcRwHAFxzzTXz58+/5ZZbYnXxbk8X7iK1h10uZoSiyzvEXIo4GNMNp0QOu939SLwL7QWsR9ECpWIkTb1QHzostA2UerwMz18S6z+bXIqcoFa+UNcIADjCeva5PXO1Md5nXBCEwHBOqMvGUVwQLsYeoofnD7jZ4WF2Iu5C5FHkD7a2a1mH4yjrvaQLNs6zyYn5JeW3OJl+sfAA213MSDpmA4iBPJVoGHGq3A9MB93uuVpN2/YJkGDMmDFLly4dN26cIAj/+9//rrnmmthev3tzMTrE/Yw7GUODRZm6HINJ8rjHywoCGdPf7VHWc3Wsx+POAykYutSgW1JR+d8e6e3v3u5g3KM65h3Cw/MGBN7lYkw+7gAa+yHgefPm9e3bV5xUmTdv3vDhw2NeRDemvf9OW7ZsWbRo0aJFi3799deQCdauXfvBBx+In2+//fYbz3L8+PF2Ft1mdjpdI4L0PrsiWhRJRtEjsX5rPsKyXSIIMZiFOq2H5z+z2tp/qZCisDFhq4t5NNEgADA3XpONYzWtqQdFy5EjR1QqVX5+/uWXX07T9JEjR2J7/e5Nu3pJFoulqKho1apVMAwvWbIkLy+vxYLTv//++7vvvhM77eIS2g0bNrSnxJiwy8mM7foDiCLiJnwxVGFwcHy1z9+3azpEFIJWZmXMOFk6Sa2Mb0dAYpnX6+D4SzqmEVIwdC/DfpuVroGReVW1uvDqxW1j/fr14geHw/H3339fccUVAwcOjG0R3Zh23Yzi4uKcnBxRnnf48OF79+6dOPEfjWuGYT744IPrrrtOXPduNBoxDHv11Vfr6uquvvrqCxUvKgCw2+V6zNAFguwiIebzKn97PFk4puiyAUmXq5QFSsWzpoZXAxYOR8t2l3ukoqOWdV6lVPzuZB6orfMIwq3xcbEd7gAALF++vPmz0+lcu3ZtbK/fvWmXQ2xqakpPP7NG3WAwmM3mwLNvv/32zJkzzWaz6BCtVmtCQsKcOXO8Xu+KFSsMBsOQIUMAAO+9915ZWRkMw0899VQI+1AUDvPjhCCIpumQ+igSuU6yHgBBQ/R6iWEmCIJgGMYk404gCIIgSBVmZxUJAyROhQTHcTGEIhAEQQRB4Hl+FC98XVEVaAaKogCAkEWIB4lQS1AQBBGrU+Jy56mUbahXYCltuC8oiqIoGpX2UkgjURR9LSc798CROyB4eMAiE/GeRlivPaaGAq1WpVJJ3+Vw2cOlEQEAvKpSBUofi3lDRt5InIoEpVJZU1PTtrwXJ+3trgdO6gc+zVu2bKFpevjw4Zs2bRKP5Obm5ubmip8nTpxYXFwsOsS+ffvq9XoYhsOJPIfTWMZx3O/3h3uMwuXaZrOPUik5v09iyTsMwwiCSEtDQxCE43i4NBIGSJwSL9vCYXEcF1xH0RvyPD+IIE64WYvH0xxkLt6RcI0Jw3A4YWqxygcczgEE0TbjRTAM4zgupKaARHYIgnw+n4RDDPbj4eqoBcLDyQn3lJ3e0jeneZoYhmEURSOs13aHc6FB7/P5xP/FVqscSbPAMNxSyOssKIqKdzPkKUEQJAQakKCRgbfeequ5GY1GIxrrV/LuTbsaS6fT7d69W/xsNptTU//R8vjzzz/Ly8sPHDjAMIzP52MYZtKkSRRFiWlwHG++kaNHjxY/hNRDRBAknC4hTdNerzfkz1si13a7YzhFSWsdRqiHSNN0uDQSBkicEs8qzt2unuO4YD1EgiA4jvP7/TgAmTj2l9U28uwwotiwIYuQ0EMU3SjLsocY5hpFW+rVDEVRHo8n2vsCwzDLshIOURkkBhPyUmIRt6qVnzY0vVtruk13RlwSRVGCICKpV4XXZ/b5e8OAZVkEQajWnhbpejUj7s4aMlnzniohT4VzoyLBitkDBgxo9q15eXlit0MmQto1VDR06NDS0lKGYViW3bNnz7BhwwRBMJlMPM8/8cQTq1evfvfdd2fNmjV27Nh77rnHaDSuWrVKFGfdsmVLXl5erOoQFdvtjpFdMKZEAnFeJSaX4gThWBfRuZEGgaAXUxKfr2+qk9ynJSTbXcxImop29+3OQ58+faqrqwsKCjIzM5uammK4BuZioF0OUavVzpkzZ9myZQ8//PC0adMMBoPH4yksLLTb7cGJ8/Pzc3JyFixYsGTJkhEjRlyQP656v7/W68vr+ov2AsklyVjNq5R5fRQMp3T9CE0AwHCamqhSPGuKeqOFHa6OikA8Pyxfvtzv9zudzscee+zo0aPPPffchbaoK9HeR7+goKCgoKD5K0mSGzduDEwwYcIE8QMEQYWFhYWFhe0ssT3sYtyXKhUkDHeUjuCFII8i11israeLgK4igxghy5MSLjtVHm1E4Q6GmRef3HFWdTQWi2XevHkbN24cN27cbbfdNn369AttUVeiq0ZXtI3dLvfl6lZmDLscgyiiwuuzxUIY+Sjr6RIyiBESjyIPJ+geMdb7Ip68Pu31WfxczPUyzicIgpjN5u3bt48cObK4uDg4REFGgovMITLuy1SxEWrvPChgOIfAD7lj0Os97O6qa1TCcWu8loKhQMUtaba7mOE02XUHEAEAs2fPnj17NkEQ/fv337lz59KlSy+0RV2J7jBaFCEunj/m8YxUKQEXQy3OToE4r3JFuyeLjno8T1Ddaic2GAIvJifeWFF9Q7w2kleDHYy7g1bsnTcmTpw4YcIEMWxg8eLFF9qcLsZF1EP8i3H3xPH4bjFj0IJcijzYWthHq5j9nJnjenW7N6w8ipzy/9k78/AmqvWPn9mX7E3TfaGlpexlLchFdpFFlFU2ERUtKi6IXr2iXJerP1Gvihc3EJBVXBCv6wUFwQWRpeyUAoXSUro3afbJJJP5/TEQ0iaZJG2ANp3Pw8OTzpwzc2bJm3PO+57vq5QvqagKpfCfVtvf2rhB5DjObDabrvDSSy8JH250u9oGUWgdAtHWk6iIkEsSH9Xpg5cT5YjVmoXjbUkHMWSWxOsGFV/Y1WASD/UqczrrXK5cn8i+tsWCBQssFosnzrempubRRx8FAEjS2aHQjgzifhszPXKpfFoVPSmy0uXSu7gYtPmKBsestojrobYSNCjyfGLc4+cv7OiQIjI/+KfVPlBGt/WfhIyMjGeeecbz57JlyxYuXHgD29O2aC9DZhfPF9jsUaCS7RcCgjrheAuzkh6z2qPJxdyEOTEaJQyvqDeIlNljsQ6i2/Z4GQAwZ86cDRs2FBYWAgBKSkoef/zxG92itkR7MYgnGIccgdtEnpDm0fL1Ksft9m5ktE0geoAhsDwr462a+otswGVwe9r+BCIAYNmyZXa7/c0332xoaPjwww/fe++9G92itkR7MYj7bfaBUTqBKJBLtWi9CuvmT9vtXdv49Jk4veWy6RrViwHWrlxyOus4LrftRx0Zjcb8/PyxY8eePn36tdde+/XXX290i9oSrc4g7rXa7ymruK/s0gFbJLOw77Pao0MlOxAt7CEWMYwWRWNbMAXZJnguLnafzb7TYvXd9bvFlke3+QlEAEBiYmJNTU3Pnj1PnToFAoikSQSidTlVql2u/9TVf5yaxPH8A+WVK5ITI5VVcr/dvjCiKSVbG10Jotblqna5MptV/bjNnhvVPxgCCgR+Pj722Yrq37MziMbelT+ttja9hNlDRkbG/Pnz09PTi4uLd+zYMXDgwBvdorZEKzKIKIoW2ZhRSqURgM0G4xC57KyLS4UgEUE3XzE4AahxrQsO1sK5e8hoFIIEoVBxkThBNzBoGXBFjTVoA0Lc5Tlsky2+5X2LoQB0p8gTrDMLhnme93sKFEUDnf2EnelJ00G188Qb7ykT4nPxRrjMsARi/R4q0CkEBVwURWfrtJ8bzR/pjU/Gx3rX2mtn7tZpm9QVf8pBT9rkUIGeC4IggfRlhe0it8U3y2hRUdHSpUuFE+E47i3KJxGUVmQQEQTpLqPX6A1TtOrP9A00jNwTFytotQaqIvIaedfab2fy5DRx5V0UPya4YhDFywhayoHKiFQXP7Lv++33LDAM+5bsI6OPMo5JgRsm1PK767jd/kBCvPglB228h2Zcu9CwsAxioGv0u13YKPz/VlryqNPF02M16Vei0Ctcrmqnq59chjR+o4QXLCK3RfglDtRmnucDNTvQLs9hm2yZPXu20+kUJBTtdrvRaJRyqoROKzKIDodDC8BctfKRkospGHbYzpwyW+NJ0lceVUAmkzmdTr+ymiiKetfaYzL3v3IckiRdLlegYwoIArHiZYSXOFCZJg0IcRfw993zKxArbG9y7d1x7EeTRVBX9ltFRCD2uNXenQp4q0NsvICIcK9IdQRBHA6HiEH0nQsLdI2BthMEIezKhKFZatXTpeXr0y73nnbZmf40CZzOJjURBKFpOiK3RRAS91tM0D/3e8eErPNhCcRKSaZaQisyiAIj5LIRchkAYL2+4YGLFX9pVC13fO6z2V9LiGt521o5vSjy1eqw5f8AABVOl83tziIJmyXCKTFbLf+Ijx10tuQns2W0Qg4A+MNsbetLmD1ISaZaQqvzMnu4O0Y9REbdXVzChTOM8sXg4s472D50NAeUCHQmcKubvxQ4zi4QJxlHN5pE2rLES7jIYfiFeN0/Kmvsbh4A8JvJHAURiL5ISabCpdX1EL15Mznhtgvlb9XWPx0XG7x0APbZ7N1Jou3m1QwdBIK6kXiB1ZqMq8OqeJJx9KCiwcEaFlPUyk0NxuV19Xdp1BWss3e0LFuUkky1hFZ9swgI+iw7c9DxU31paqS8mRE4++1Rq+ngSy+KPGy13a4JzyCeYJihatU1alJr5o3E+GHFF75sMGtQRO/iEqNCCUlKMtUSWnu/KY3Al6ckPFxeWRYszWMgoj4k25tckizwF3UszgnG0aPd/GZ4c8TO9KbJMpa9XaN+trLmRjcnMgwePLjvFXr06PHGG29I8l+h0wZ+Ekcr5Hdr1HNLL/2vYzoZ5jwXy/NHBQdi+6AXRS6prg1rztXmdpeyzu7tb8gMADhkt7+eGD+n9NLM2JhXyspvdHMigyT/1RLagEEEADwbF3uUYZ6vrPl3UnxYFQ/ZmSQMjW830yjZBMEBcIFxhO5TP8U4kjFUgbT2scK1oC9FbTNbDuZklsMIAUXJHZDkv1pC23gJYAh8kJz4s9myuSG8nv9fVlv7mUAEAMAQyKXpQ1Zb6FVOMI7uUa3pIMJktZKEoJkXyt+tqnktMUoCs7ytIQBAsoZh0TYMIgAgFkVWpyY9V1l9LBwJg/22djSBKNBHRh+2hWEQoyz1aFhAADwcG/NZh5QPM9Kiw6Mi0ULajEEEAPSjqWfjdPdfrAgx5SYPwEE70656iACA3jIqzB4i0729GkQJiSa0JYMIAHhAq+5P0w+XV4XiNyhiHBAPsoioFT31S1+Z7JDF6g7NscIDUORgu0dLCJ6ERAtpqUHcvXv3Qw899NBDD+3YscNvgU2bNq1atSrEwqHwZlJcmdP5n9r6oCX32ewDZFQ7Wn4BAAAgkyQQCDrvb8GyLxdYJwRAijRalJAAALTQy2wwGNauXfvuu+/CMLxw4cJevXrFxjZaUlJYWPjNN9+MHj06lMIhQsPw2tSkMefLbo435onKee632fPa2XgZAAAB0FsmO2JnQukaCxOI7e03Q0IiEC3qIRYUFGRlZalUKoVCkZeXd+DAAe+9Nptt1apVkyZNCqVwWHQk8HeT4+8uOlvpFEs5v8/ajtaoeNNHRoeYTuCEnYnixFISEuHSoh5ifX19amqq8Fmn0+n1jVIDf/jhhzNmzNDr9VarVaRwQUGBwWCAICgvL8/3FAiCEP6+sZN0xCGOv6e0/MfsTF/ZdwRB9BBcy3F5KlWTvSFqeQY6r/dxIAgKVEakuviRfeXt/JYXhLwCKej1VciXm8y+tQSdR+9TnHI6x6mUBEEIBxS/5KCN91wCjuOB2iZyW3A8vNlev4cKdApBIDbchyLoIUbktog0AEVRt9vt944JormBdD9BYElQiebR0skj72+Xt5jd7t27aZrOy8vbtm2beOHffvvt7NmzCIIMGTLE9/jCa+T31G927DDiyImXq2v/nZHmW+sg6+ynkCl9eoge5WTx6wpFIBb4U6ML2myRXcCfNrIgzujbPEEpz+/xB6iU84rPowSBQk1/DEBj/ecTdmZJeipJkoKhDHQ5ITbecxYcxwO1LVB1wViLH7kJflsb6BTCD1i4z0u8VtDqTcoEukahrt87JrJLwLNsWSIitMggarXaffv2CZ/1er23WPnvv/9eUlJy5MgRm83mdDptNlvXrl39Fn7iiSeED3V1db6nkMlkQgfTl5iYmNVpSUOKzuXA4M7G2gQymWxXbV1fHDMajU1qqVQqhmFCEYhlGLFRJwzDGo3G9/hBmy2yC/jrKLEs69tagiB8BWI9x0+AAA1BB2tquzSOp2kiEGvkuArWmex0Go1GiqJQFDWbzYEaFkrjBTQajcViCdS2QNVpmrbb7SLffN8ZZ783P9ApUBRVKBThPi8EQdRqdaBaQat7I5fLOY6z2/2kTsNxPJBArPDTEpZArERLaFF/u2/fvufOnbPZbAzD7N+/v1+/fjzPV1VVud3uJUuWrFmzZsWKFbNnzx41atRjjz3mW7jlrY9D0RWpic9W1hT55GjfZ7MPaPtJx5tNLkkGzVt/knF0JHCq7eeZk5CIFC3qIWo0mjlz5ixevJjn+WnTpul0OoZh8vPz169fr1Y3VaDyLdySU3v4m4x+PDbmnosVP2emexbkWjjuNMv2bcfhdb0o8qidmaFWipQ5ybCSR0VCwpuWziEOHz58+PDhnj9Jkvz222+9C4wZMyZQ4UjxqE572M48UVG1KjVJ2PKX2ZqF45pozzIsQi5F/qdOL17mBMN0I9tX1LqEhDjR4KKCAFiekljIOFbWG4Qtf1mt7TPgxkMfmjxuZ5yi2RdOMg5pjYqEhDfRYBABAHIYXp2W/HpN3V82OwDgT7OlHYZkexOPohoUKXIEXK/i4vmidizrICHhlygxiACALgT+RmL8vaUV/1dd+6fJmhFmUFv00YsijwQOzy52sHIYbj9KkRISoRA9BhEAMEGpwGDwWYNJiUCvVNeGKIoTreSSpMh6lZOMo4c0XpaQaExUGcQih+NOtSoBRUeoVLerFPtsfmK+2g/iPcSTDmm8LCHRlKgyiHEoeoFlP0tPeS0t+QzjSPRZ4NGu6E2ThYzDEcCvckKaQJSQ8CGqDGIChg6kqfzyygfPl2pQpEf7/sJrESQBQ0/a/Ydnn7BLurASEk2Jtjn1+7Wa+2I0lIx2hCOjH63kksQRu72PT9LBOhdn5NztTTpXQiIoUdVDFIAhgIaZrTRayaX8L+A7zjhyCByT7pKERGOi0CBKeAjkV5HGyxISfpEMYjTTiyLPOFibj0LUSYe0RkVCwg+SQYxm1AiSiqEnfEbN7Tn1qISECK3IqSKTyXw3YhjmdzsAAIIgiqL8CmSK1BLEjcUFYiEICkUgFoKgQGcRaYDILr+gKOrbWgRBeJ4PdO3A62b2U8gLOfdwmQwAIKjAuhHknIPtFxMj8xK/EKQSgzYslMbDMNyM54KiaFCN1SaE9cII4qzhPhShSRG5LRiGCRqxvrtEnqawS0RLPNybJiFOKzKIfiU2RaQ3CYKw2+3hCpGiKOpwOCIiEEsQRDNUYIMKxFJUo1XYLpcrXIFY4HUzu2HoAaPZqpCBK1avwGiKx1DCwVi9jioIxAZVOQ1FCRXH8WY8l6ACsU1uCwjzhRF+V8J9KMLPZ0RuCwRBkkBs60caMkc5vSjySOMv4UnGIckgSkj4RTKIUU4uRZ5nnWbu6nDsBMNIE4gSEn6RDGKUI4fhTBw75jX8P8mwkotZQsIvkkGMfnpRlCcakQegkHFIQtkSzWbnzp0zZ84Mt9bnn3/ev3//+vr6Ll26AAD27Nkzbdq0a9C6lhLcIG7atGnhwoUul2vr1q3XoUESESeXIjw6YOWsk+X5DphkECWuExzH6fX6cePGbdmy5Ua3JThBDOILL7ywadOmn376CYKg999//5lnnrk+zZKIIN7rVY7b7N1IQkq0JxEiPM8/+uijycnJ3bp1W7hwoScMwO12P/XUUx07dhw4cOD06dPXrVsHAHjxxRezsrKys7NffvllAMCePXumT5+em5u7cuXKY8eOPfXUUw8//HBZWdmCBQsAAA0NDTNnzuzSpcu0adOsVuuePXsmTpx433333XzzzX//+9+ffvrpiRMnjhs3TjwgJOIECbv57LPPCgoKJk2ahCDItm3bsrOzX3/99evTMolI0YMky50uvYuLQ1HJoyIRFidPnjx79uyFCxcAAN26dXvooYeE7V988UVhYeHp06dramo6d+48bty4H3/8cfv27ceOHQMADB8+fMCAAXK5fPv27YcOHcrMzNyzZw8A4IMPPjh27Nj777+/Z8+eXbt2nT17Nj09fciQITt37tRqtXv27CkvL+c4TqvVbt269Y033pgyZcrOnTvHjRt33a43SA+RZVlPDBTDML6xYBKtHwqGsglc8KsIPcQb3SKJNkP37t03bNjw888/v/rqq1VVVZ7g3B07dtx3330oiiYlJQ0ZMgQAsHv37rlz59I0TdP0XXfdtXv3bgDAoEGDMjMz/R75pptuysjIgGG4d+/eQnjmTTfdRBAETdOxsbEjR44EAKSlpRkMhutzpQJBDOKCBQtGjx5dUlLy5ptv3nzzzZ7fB4m2hWfUfNwu9RAlwmDv3r3Dhg07derU+PHje/fu7dnOcZxn1Y2wOIrnec+yGSEKHYgu8klISGiyxXttmPg6sWtHEIP41FNPvf7667NmzeI4btWqVY899tj1aZZEZMkliaN2xuJ2l7HOrpJBlAiZHTt2TJgw4cknn4yPjz916pRnvDh06NB169ZxHFdbW7tr1y5hy8aNGxmGsdvtGzduHDZsmN8D+l2Q03oI7mXOy8t74YUXFi1alJ6efh0aJHEt6EVRRxlHod3RAcdl/pbTSkj4ZdasWYcPH+7bt++iRYsWLFjw4osvCtvnzJmTkpKSk5MzZ86cKVOmqNXq2267bdiwYbm5ubm5uWPGjPE78adWq9Vq9b333hvi2WEYFpcdiDiQyOpRAMC6desWLVp0/vx5p9PZrVu3pUuXhn4x4VJX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" alt="plot of chunk unnamed-chunk-39" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>in constant task, rpart does not have significantly lower error
rates than featureless, which is expected, because the best
prediction function is constant (predict the most frequent class, no
relationship between inputs and output).</li>
<li>in xor task, more than 30 samples are required for rpart to be more
accurate than featureless, which indicates it has learned a
non-trivial relationship between inputs and output.</li>
</ul>
<p>Exercise for the reader: compute and plot mean and SD for these
classification tasks, similar to the plot for the regression tasks in
the previous section.</p>
<h3 id="interactive-visualization-of-data-test-error-and-splits_3">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">class.grid.vec &lt;- seq(-class.abs.x, class.abs.x, l=21)
class.grid.dt &lt;- CJ(x1=class.grid.vec, x2=class.grid.vec)
class.pred.dt.list &lt;- list()
class.point.dt.list &lt;- list()
for(score.i in 1:nrow(class.bench.score)){
  class.bench.row &lt;- class.bench.score[score.i]
  task.dt &lt;- data.table(
    class.bench.row$task[[1]]$data(),
    class.bench.row$resampling[[1]]$instance$id.dt)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=class.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ][]
  class.point.dt.list[[score.i]] &lt;- data.table(
    class.bench.row[, .(task_id, iteration)],
    i.points)
  if(class.bench.row$algorithm!=&quot;featureless&quot;){
    i.learner &lt;- class.bench.row$learner[[1]]
    i.learner$predict_type &lt;- &quot;prob&quot;
    i.task &lt;- class.bench.row$task[[1]]
    grid.class.task &lt;- mlr3::TaskClassif$new(
      &quot;grid&quot;, class.grid.dt[, label:=factor(NA,levels(task.dt$y))], target=&quot;label&quot;)
    pred.grid &lt;- as.data.table(
      i.learner$predict(grid.class.task)
    )[, data.table(class.grid.dt, prob.spam)]
    pred.wide &lt;- dcast(pred.grid, x1 ~ x2, value.var=&quot;prob.spam&quot;)
    prob.mat &lt;- as.matrix(pred.wide[,-1])
    if(length(table(prob.mat))&gt;1){
      contour.list &lt;- contourLines(
        class.grid.vec, class.grid.vec, prob.mat, levels=0.5)
      class.pred.dt.list[[score.i]] &lt;- data.table(
        class.bench.row[, .(
          task_id, iteration, algorithm
        )],
        data.table(contour.i=seq_along(contour.list))[, {
          do.call(data.table, contour.list[[contour.i]])[, .(level, x1=x, x2=y)]
        }, by=contour.i]
      )
    }
  }
}
(class.pred.dt &lt;- rbindlist(class.pred.dt.list))
#&gt;        task_id iteration algorithm contour.i level     x1          x2
#&gt;         &lt;char&gt;     &lt;int&gt;    &lt;char&gt;     &lt;int&gt; &lt;num&gt;  &lt;num&gt;       &lt;num&gt;
#&gt;    1: constant         1     rpart         1   0.5 0.0375 -1.00000000
#&gt;    2: constant         1     rpart         1   0.5 0.0375 -0.90000000
#&gt;    3: constant         1     rpart         1   0.5 0.0375 -0.80000000
#&gt;    4: constant         1     rpart         1   0.5 0.0375 -0.70000000
#&gt;    5: constant         1     rpart         1   0.5 0.0375 -0.60000000
#&gt;   ---                                                                
#&gt; 5190:      xor        45     rpart         2   0.5 0.6000  0.04888889
#&gt; 5191:      xor        45     rpart         2   0.5 0.7000  0.04888889
#&gt; 5192:      xor        45     rpart         2   0.5 0.8000  0.04888889
#&gt; 5193:      xor        45     rpart         2   0.5 0.9000  0.04888889
#&gt; 5194:      xor        45     rpart         2   0.5 1.0000  0.04888889
(class.point.dt &lt;- rbindlist(class.point.dt.list))
#&gt;         task_id iteration set.name row_id      y         x1           x2  fold
#&gt;          &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt; &lt;fctr&gt;      &lt;num&gt;        &lt;num&gt; &lt;int&gt;
#&gt;     1: constant         1   unused      1   spam -0.4689827  0.347424466     3
#&gt;     2: constant         1   unused      2    not -0.2557522 -0.810284289     2
#&gt;     3: constant         1   unused      3   spam  0.1457067 -0.014807758     3
#&gt;     4: constant         1    train      4    not  0.8164156 -0.076896319     3
#&gt;     5: constant         1     test      5   spam -0.5966361 -0.249566938     1
#&gt;    ---                                                                        
#&gt; 53996:      xor        45    train    296    not  0.3628850  0.297101895     2
#&gt; 53997:      xor        45    train    297    not -0.8016618 -0.040328411     2
#&gt; 53998:      xor        45     test    298   spam -0.7621949 -0.009871789     3
#&gt; 53999:      xor        45     test    299    not -0.8991207 -0.240254817     3
#&gt; 54000:      xor        45    train    300   spam  0.8585078 -0.099029126     2

set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Variable size train sets, classification&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      theme_animint(width=600)+
      coord_equal()+
      scale_fill_manual(values=set.colors)+
      scale_color_manual(values=c(spam=&quot;black&quot;,&quot;not spam&quot;=&quot;white&quot;))+
      geom_point(aes(
        x1, x2, color=y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        stroke=2,
        shape=21,
        data=class.point.dt)+
      geom_path(aes(
        x1, x2, 
        group=paste(algorithm, iteration, contour.i)),
        showSelected=c(&quot;iteration&quot;,&quot;algorithm&quot;),
        color=algo.colors[[&quot;rpart&quot;]],
        data=class.pred.dt)+
      facet_grid(
        . ~ task_id,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      scale_y_continuous(
        &quot;Classification error on test set&quot;)+
      scale_color_manual(values=algo.colors)+
      scale_x_log10(
        &quot;Train set size&quot;)+
      geom_line(aes(
        train_size, classif.ce,
        group=paste(algorithm, seed),
        color=algorithm),
        clickSelects=&quot;seed&quot;,
        alpha_off=0.2,
        showSelected=&quot;algorithm&quot;,
        size=4,
        data=class.bench.score)+
      facet_grid(
        test.fold~task_id,
        labeller=label_both,
        scales=&quot;free&quot;)+
      geom_point(aes(
        train_size, classif.ce,
        color=algorithm),
        size=5,
        stroke=3,
        fill=&quot;black&quot;,
        fill_off=NA,
        showSelected=c(&quot;algorithm&quot;,&quot;seed&quot;),
        clickSelects=&quot;iteration&quot;,
        data=class.bench.score),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/ResamplingVariableSizeTrainCV.Rmd&quot;)
  viz
}
</code></pre>
<p></p>
<div id='ResamplingVariableSizeTrainCVAnimintClassification'></div>
<script>var ResamplingVariableSizeTrainCVAnimintClassification = new animint("#ResamplingVariableSizeTrainCVAnimintClassification", "ResamplingVariableSizeTrainCVAnimintClassification/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-27-train-sizes-classification&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-27-train-sizes-classification/">https://tdhock.github.io/2023-12-27-train-sizes-classification/</a></p>
<p>The interactive data viz consists of two plots</p>
<ul>
<li>The first plot shows the data, with each point colored according to
its label/y value (black outline for spam, white outline for not),
and the set it was assigned (fill color) in the currently selected
split/iteration. The red lines additionally show the learned
decision boundary for rpart, given the currently selected
split/iteration.  For constant, the ideal decision boundary is none
(always predict the most frequent class), and for xor, the ideal
decision boundary looks like a plus sign.</li>
<li>The second plot shows the test error rates, as a function of train
set size. Clicking a line selects the corresponding random seed,
which makes the corresponding points on that line appear. Clicking a
point selects the corresponding iteration (seed, test fold, and train
set size).</li>
</ul>
<h2 id="conclusion_2">Conclusion</h2>
<p>In this section we have shown how to use mlr3resampling for comparing
test error of models trained on different sized train sets.</p>
<h1 id="session-info">Session info</h1>
<pre><code class="language-r">sessionInfo()
#&gt; R version 4.3.2 (2023-10-31)
#&gt; Platform: x86_64-pc-linux-gnu (64-bit)
#&gt; Running under: Ubuntu 18.04.6 LTS
#&gt; 
#&gt; Matrix products: default
#&gt; BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1 
#&gt; LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1
#&gt; 
#&gt; locale:
#&gt;  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
#&gt;  [3] LC_TIME=fr_FR.UTF-8        LC_COLLATE=C              
#&gt;  [5] LC_MONETARY=fr_FR.UTF-8    LC_MESSAGES=en_US.UTF-8   
#&gt;  [7] LC_PAPER=fr_FR.UTF-8       LC_NAME=C                 
#&gt;  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
#&gt; [11] LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C       
#&gt; 
#&gt; time zone: America/Toronto
#&gt; tzcode source: system (glibc)
#&gt; 
#&gt; attached base packages:
#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     
#&gt; 
#&gt; other attached packages:
#&gt; [1] lgr_0.4.4              animint2_2024.3.12     directlabels_2024.1.21
#&gt; [4] mlr3_0.17.0            ggplot2_3.5.0          data.table_1.15.0     
#&gt; 
#&gt; loaded via a namespace (and not attached):
#&gt;  [1] utf8_1.2.4              future_1.33.0           generics_0.1.3         
#&gt;  [4] stringi_1.8.3           listenv_0.9.1           digest_0.6.34          
#&gt;  [7] magrittr_2.0.3          evaluate_0.23           grid_4.3.2             
#&gt; [10] plyr_1.8.9              backports_1.4.1         fansi_1.0.6            
#&gt; [13] mlr3resampling_2024.7.7 scales_1.3.0            mlr3tuning_0.19.2      
#&gt; [16] codetools_0.2-19        mlr3measures_0.5.0      palmerpenguins_0.1.1   
#&gt; [19] cli_3.6.2               rlang_1.1.3             crayon_1.5.2           
#&gt; [22] parallelly_1.37.0       future.apply_1.11.0     munsell_0.5.0          
#&gt; [25] commonmark_1.9.1        withr_3.0.0             nc_2024.2.21           
#&gt; [28] tools_4.3.2             parallel_4.3.2          reshape2_1.4.4         
#&gt; [31] RJSONIO_1.3-1.9         uuid_1.1-1              checkmate_2.3.1        
#&gt; [34] dplyr_1.1.4             colorspace_2.1-0        globals_0.16.2         
#&gt; [37] bbotk_0.7.3             vctrs_0.6.5             R6_2.5.1               
#&gt; [40] mime_0.12               rpart_4.1.23            lifecycle_1.0.4        
#&gt; [43] stringr_1.5.1           mlr3misc_0.13.0         pkgconfig_2.0.3        
#&gt; [46] pillar_1.9.0            gtable_0.3.4            Rcpp_1.0.12            
#&gt; [49] glue_1.7.0              paradox_0.11.1          xfun_0.42              
#&gt; [52] tibble_3.2.1            tidyselect_1.2.0        highr_0.10             
#&gt; [55] knitr_1.45              farver_2.1.1            labeling_0.4.3         
#&gt; [58] compiler_4.3.2          quadprog_1.5-8          markdown_1.12
</code></pre>
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</body>
</html>
