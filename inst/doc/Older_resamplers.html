<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.6">
<title></title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.11/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
</div>
<div class="body">
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Older resamplers}
-->
<p>The goal of this vignette is to explain the older resamplers:
<code>ResamplingVariableSizeTrainCV</code> and <code>ResamplingSameOtherCV</code>, which
output some data which are useful for visualizing the train/test
splits. If you do not want to visualize the train/test splits, then it
is recommended to instead use the newer resampler,
<code>ResamplingSameOtherSizesCV</code> (see other vignette).</p>
<h1 id="chp:same-other-all-resampler">Same/Other/All resampler</h1>
<p>The goal of thie section is to explain how to quantify the extent to
which it is possible to train on one data subset, and predict on
another data subset. This kind of problem occurs frequently in many
different problem domains:</p>
<ul>
<li>geography: can we train on one region (say Europe) and accurately
predict on another? (North America)</li>
<li>time series: can we train on one time period (2000) and accurately
predict on another? (2001)</li>
<li>personalization: can we train on one person (Alice) and accurately
predict on another? (Bob)</li>
</ul>
<p>The ideas are similar to my previous blog posts about how to do this
in
<a href="https://tdhock.github.io/blog/2022/generalization-to-new-subsets/">python</a>
and <a href="https://tdhock.github.io/blog/2023/R-gen-new-subsets/">R</a>. Below
we explain how to use <code>mlr3resampling</code> for this purpose, in simulated
regression and classification problems. To use this method in
real data, the important sections to read below are named “Benchmark:
computing test error,” which show how to create these cross-validation
experiments using mlr3 code.</p>
<h2 id="sec:simulated-regression-problems_1">Simulated regression problems</h2>
<p>We begin by generating some data which can be used with regression algorithms.
Assume there is a data set with some rows from one person, some rows
from another,</p>
<pre><code class="language-r">N &lt;- 300
library(data.table)
set.seed(1)
abs.x &lt;- 2
reg.dt &lt;- data.table(
  x=runif(N, -abs.x, abs.x),
  person=rep(1:2, each=0.5*N))
reg.pattern.list &lt;- list(
  easy=function(x, person)x^2,
  impossible=function(x, person)(x^2+person*3)*(-1)^person)
reg.task.list &lt;- list()
for(task_id in names(reg.pattern.list)){
  f &lt;- reg.pattern.list[[task_id]]
  yname &lt;- paste0(&quot;y_&quot;,task_id)
  reg.dt[, (yname) := f(x,person)+rnorm(N)][]
  task.dt &lt;- reg.dt[, c(&quot;x&quot;,&quot;person&quot;,yname), with=FALSE]
  reg.task &lt;- mlr3::TaskRegr$new(
    task_id, task.dt, target=yname)
  reg.task$col_roles$subset &lt;- &quot;person&quot;
  reg.task$col_roles$stratum &lt;- &quot;person&quot;
  reg.task$col_roles$feature &lt;- &quot;x&quot;
  reg.task.list[[task_id]] &lt;- reg.task
}
reg.dt
#&gt;               x person      y_easy y_impossible
#&gt;           &lt;num&gt;  &lt;int&gt;       &lt;num&gt;        &lt;num&gt;
#&gt;   1: -0.9379653      1  1.32996609    -2.918082
#&gt;   2: -0.5115044      1  0.24307692    -3.866062
#&gt;   3:  0.2914135      1 -0.23314657    -3.837799
#&gt;   4:  1.6328312      1  1.73677545    -7.221749
#&gt;   5: -1.1932723      1 -0.06356159    -5.877792
#&gt;  ---                                           
#&gt; 296:  0.7257701      2 -2.48130642     5.180948
#&gt; 297: -1.6033236      2  1.20453459     9.604312
#&gt; 298: -1.5243898      2  1.89966190     7.511988
#&gt; 299: -1.7982414      2  3.47047566    11.035397
#&gt; 300:  1.7170157      2  0.60541972    10.719685
</code></pre>
<p>The table above shows some simulated data for two regression problems:</p>
<ul>
<li>easy problem has the same pattern for each person, so it is possible/easy to train on one person, and accurately predict on another.</li>
<li>impossible problem has a different pattern for each person, so it is impossible to train on one person, and accurately predict on another.</li>
<li>when adapting the code above to real data, the important part is the
<code>mlr3::TaskRegr</code> line which tells mlr3 what data set to use, what is
the target column, and what is the subset/stratum column.</li>
</ul>
<h3 id="sec:static-visualization-of-simulated-data_1">Static visualization of simulated data</h3>
<p>First we reshape the data using the code below,</p>
<pre><code class="language-r">(reg.tall &lt;- nc::capture_melt_single(
  reg.dt,
  task_id=&quot;easy|impossible&quot;,
  value.name=&quot;y&quot;))
#&gt;               x person    task_id           y
#&gt;           &lt;num&gt;  &lt;int&gt;     &lt;char&gt;       &lt;num&gt;
#&gt;   1: -0.9379653      1       easy  1.32996609
#&gt;   2: -0.5115044      1       easy  0.24307692
#&gt;   3:  0.2914135      1       easy -0.23314657
#&gt;   4:  1.6328312      1       easy  1.73677545
#&gt;   5: -1.1932723      1       easy -0.06356159
#&gt;  ---                                         
#&gt; 596:  0.7257701      2 impossible  5.18094849
#&gt; 597: -1.6033236      2 impossible  9.60431191
#&gt; 598: -1.5243898      2 impossible  7.51198770
#&gt; 599: -1.7982414      2 impossible 11.03539747
#&gt; 600:  1.7170157      2 impossible 10.71968480
</code></pre>
<p>The table above is a more convenient form for the visualization which we create using the code below,</p>
<pre><code class="language-r">if(require(animint2)){
  my_theme &lt;- theme_bw(20)
  theme_set(my_theme)
  ggplot()+
    geom_point(aes(
      x, y),
      data=reg.tall)+
    facet_grid(
      task_id ~ person,
      labeller=label_both,
      space=&quot;free&quot;,
      scales=&quot;free&quot;)+
    scale_y_continuous(
      breaks=seq(-100, 100, by=2))
}
#&gt; Le chargement a nécessité le package : animint2
#&gt; Registered S3 methods overwritten by 'animint2':
#&gt;   method                   from   
#&gt;   [.uneval                 ggplot2
#&gt;   drawDetails.zeroGrob     ggplot2
#&gt;   grid.draw.absoluteGrob   ggplot2
#&gt;   grobHeight.absoluteGrob  ggplot2
#&gt;   grobHeight.zeroGrob      ggplot2
#&gt;   grobWidth.absoluteGrob   ggplot2
#&gt;   grobWidth.zeroGrob       ggplot2
#&gt;   grobX.absoluteGrob       ggplot2
#&gt;   grobY.absoluteGrob       ggplot2
#&gt;   heightDetails.titleGrob  ggplot2
#&gt;   heightDetails.zeroGrob   ggplot2
#&gt;   makeContext.dotstackGrob ggplot2
#&gt;   print.element            ggplot2
#&gt;   print.ggplot2_bins       ggplot2
#&gt;   print.rel                ggplot2
#&gt;   print.theme              ggplot2
#&gt;   print.uneval             ggplot2
#&gt;   widthDetails.titleGrob   ggplot2
#&gt;   widthDetails.zeroGrob    ggplot2
#&gt; 
#&gt; Attachement du package : 'animint2'
#&gt; Les objets suivants sont masqués depuis 'package:ggplot2':
#&gt; 
#&gt;     %+%, %+replace%, Coord, CoordCartesian, CoordFixed, CoordFlip,
#&gt;     CoordMap, CoordPolar, CoordQuickmap, CoordTrans, Geom, GeomAbline,
#&gt;     GeomAnnotationMap, GeomArea, GeomBar, GeomBlank, GeomContour,
#&gt;     GeomCrossbar, GeomCurve, GeomCustomAnn, GeomDensity, GeomDensity2d,
#&gt;     GeomDotplot, GeomErrorbar, GeomErrorbarh, GeomHex, GeomHline,
#&gt;     GeomLabel, GeomLine, GeomLinerange, GeomLogticks, GeomMap,
#&gt;     GeomPath, GeomPoint, GeomPointrange, GeomPolygon, GeomRaster,
#&gt;     GeomRasterAnn, GeomRect, GeomRibbon, GeomRug, GeomSegment,
#&gt;     GeomSmooth, GeomSpoke, GeomStep, GeomText, GeomTile, GeomViolin,
#&gt;     GeomVline, Position, PositionDodge, PositionFill, PositionIdentity,
#&gt;     PositionJitter, PositionJitterdodge, PositionNudge, PositionStack,
#&gt;     Scale, ScaleContinuous, ScaleContinuousDate,
#&gt;     ScaleContinuousDatetime, ScaleContinuousIdentity,
#&gt;     ScaleContinuousPosition, ScaleDiscrete, ScaleDiscreteIdentity,
#&gt;     ScaleDiscretePosition, Stat, StatBin, StatBin2d, StatBindot,
#&gt;     StatBinhex, StatContour, StatCount, StatDensity, StatDensity2d,
#&gt;     StatEcdf, StatEllipse, StatFunction, StatIdentity, StatQq,
#&gt;     StatSmooth, StatSum, StatSummary, StatSummary2d, StatSummaryBin,
#&gt;     StatSummaryHex, StatUnique, StatYdensity, aes, aes_, aes_all,
#&gt;     aes_auto, aes_q, aes_string, annotate, annotation_custom,
#&gt;     annotation_logticks, annotation_map, annotation_raster,
#&gt;     as_labeller, autoplot, benchplot, borders, calc_element,
#&gt;     continuous_scale, coord_cartesian, coord_equal, coord_fixed,
#&gt;     coord_flip, coord_map, coord_munch, coord_polar, coord_quickmap,
#&gt;     coord_trans, cut_interval, cut_number, cut_width, discrete_scale,
#&gt;     draw_key_abline, draw_key_blank, draw_key_crossbar,
#&gt;     draw_key_dotplot, draw_key_label, draw_key_path, draw_key_point,
#&gt;     draw_key_pointrange, draw_key_polygon, draw_key_rect,
#&gt;     draw_key_smooth, draw_key_text, draw_key_vline, draw_key_vpath,
#&gt;     economics, economics_long, element_blank, element_grob,
#&gt;     element_line, element_rect, element_text, expand_limits,
#&gt;     facet_grid, facet_null, facet_wrap, fortify, geom_abline,
#&gt;     geom_area, geom_bar, geom_bin2d, geom_blank, geom_contour,
#&gt;     geom_count, geom_crossbar, geom_curve, geom_density,
#&gt;     geom_density2d, geom_density_2d, geom_dotplot, geom_errorbar,
#&gt;     geom_errorbarh, geom_freqpoly, geom_hex, geom_histogram,
#&gt;     geom_hline, geom_jitter, geom_label, geom_line, geom_linerange,
#&gt;     geom_map, geom_path, geom_point, geom_pointrange, geom_polygon,
#&gt;     geom_qq, geom_raster, geom_rect, geom_ribbon, geom_rug,
#&gt;     geom_segment, geom_smooth, geom_spoke, geom_step, geom_text,
#&gt;     geom_tile, geom_violin, geom_vline, gg_dep, ggplot, ggplotGrob,
#&gt;     ggplot_build, ggplot_gtable, ggsave, ggtitle, guide_colorbar,
#&gt;     guide_colourbar, guide_legend, guides, is.Coord, is.facet,
#&gt;     is.ggplot, is.theme, label_both, label_bquote, label_context,
#&gt;     label_parsed, label_value, label_wrap_gen, labeller, labs,
#&gt;     last_plot, layer, layer_data, layer_grob, layer_scales, lims,
#&gt;     map_data, margin, mean_cl_boot, mean_cl_normal, mean_sdl, mean_se,
#&gt;     median_hilow, position_dodge, position_fill, position_identity,
#&gt;     position_jitter, position_jitterdodge, position_nudge,
#&gt;     position_stack, presidential, qplot, quickplot, rel,
#&gt;     remove_missing, resolution, scale_alpha, scale_alpha_continuous,
#&gt;     scale_alpha_discrete, scale_alpha_identity, scale_alpha_manual,
#&gt;     scale_color_brewer, scale_color_continuous, scale_color_discrete,
#&gt;     scale_color_distiller, scale_color_gradient, scale_color_gradient2,
#&gt;     scale_color_gradientn, scale_color_grey, scale_color_hue,
#&gt;     scale_color_identity, scale_color_manual, scale_colour_brewer,
#&gt;     scale_colour_continuous, scale_colour_date, scale_colour_datetime,
#&gt;     scale_colour_discrete, scale_colour_distiller,
#&gt;     scale_colour_gradient, scale_colour_gradient2,
#&gt;     scale_colour_gradientn, scale_colour_grey, scale_colour_hue,
#&gt;     scale_colour_identity, scale_colour_manual, scale_fill_brewer,
#&gt;     scale_fill_continuous, scale_fill_date, scale_fill_datetime,
#&gt;     scale_fill_discrete, scale_fill_distiller, scale_fill_gradient,
#&gt;     scale_fill_gradient2, scale_fill_gradientn, scale_fill_grey,
#&gt;     scale_fill_hue, scale_fill_identity, scale_fill_manual,
#&gt;     scale_linetype, scale_linetype_continuous, scale_linetype_discrete,
#&gt;     scale_linetype_identity, scale_linetype_manual, scale_radius,
#&gt;     scale_shape, scale_shape_continuous, scale_shape_discrete,
#&gt;     scale_shape_identity, scale_shape_manual, scale_size,
#&gt;     scale_size_area, scale_size_continuous, scale_size_date,
#&gt;     scale_size_datetime, scale_size_discrete, scale_size_identity,
#&gt;     scale_size_manual, scale_x_continuous, scale_x_date,
#&gt;     scale_x_datetime, scale_x_discrete, scale_x_log10, scale_x_reverse,
#&gt;     scale_x_sqrt, scale_y_continuous, scale_y_date, scale_y_datetime,
#&gt;     scale_y_discrete, scale_y_log10, scale_y_reverse, scale_y_sqrt,
#&gt;     should_stop, stat_bin, stat_bin2d, stat_bin_2d, stat_bin_hex,
#&gt;     stat_binhex, stat_contour, stat_count, stat_density,
#&gt;     stat_density2d, stat_density_2d, stat_ecdf, stat_ellipse,
#&gt;     stat_function, stat_identity, stat_qq, stat_smooth, stat_spoke,
#&gt;     stat_sum, stat_summary, stat_summary2d, stat_summary_2d,
#&gt;     stat_summary_bin, stat_summary_hex, stat_unique, stat_ydensity,
#&gt;     theme, theme_bw, theme_classic, theme_dark, theme_get, theme_gray,
#&gt;     theme_grey, theme_light, theme_linedraw, theme_minimal,
#&gt;     theme_replace, theme_set, theme_update, theme_void,
#&gt;     transform_position, update_geom_defaults, update_labels,
#&gt;     update_stat_defaults, waiver, xlab, xlim, ylab, ylim, zeroGrob
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAtAAAAH4CAMAAABUnipoAAAAGFBMVEUAAAAaGhpNTU1/f3/MzMzl5eX6+vr///9+X1YfAAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nO2djZajKhCEnewkvv8b3ztRoRu6+RMQseqc3UkUyxa+YIuGLCsETaTl6gAgqKYANDSVADQ0lQA0NJUANDSVADQ0lQA0NJUANDSVzgL9D8oUqi5bXYH+hbL0D1WXKwA9sgB0tgD0yALQ2QLQIwtAZwtAjywAnS0APbIAdLYA9MgC0NkC0CMLQGcLQI8sAJ0tAD2yAHS2AHRcP5ft+cZA//yvK/YLoKO6pmG+ui/QPz8XEQ2gI7qqp/nqtkB/6wxAN9KPpXJ/8f9/P7+/bLFT0G78WKDPVNsP+b+vHgG0Of/Rv+S0yP5ua9jml0T9p2uBPlFtALqlzPmPv/g9/tPW082v0cVA/56ptl8A3UqmHUy/QVrmV13MN79E1wNdXm3IoZvpSPi8Jvj5cdYDaKKT1XZRvT0LaCfZO97Z9bY42fzxQJdU21XX0g8CmtT5D3sFoEWdqrbLKu0RQIeSQeGUKm5+icbNoSPVdl2dPQZodpXutIxwFe9ufo2uB7qw2kaospmBPgb+eTIoDKh+FzsMPxfo8mqzY9i99Qig7RUKawJ7g8s03FYcQP/pRLX9AOiWug7IsxrgovBuAtAjC0BnC0CPLACdLQA9sgB0tp4A9H112+ehrxOAHlkAOlsAemQB6GwB6JEFoLMFoEcWgM4WgB5ZADpbfYGGMoWqa6F6QNuX73jpT7xIgkslmwSXBsf0z3mFWou6JJzKAHSaC4AucQHQVLdvmmXx6hRAl9gA6EybNk2zLD7RALrEBkBn2gDoEhsATfWApgHQcwEtZJBk6ROaBjl0D6B/OgEt9U9k6dObZgXQ6TYS0D9UvYFmrwD0LgAt2UjdoAD0TwegP0bv//990d3eyi+jeieWu5MNdfnnVF39PdzQRgTEuBCgu6cc34/a9nGTOusH9DUxF/TQgo2YqY5xUWijk4Kcv2miLgBasBkVaN41CzHO3zRcexUA6JhNYg7tzCbSGuhA17zrAU1DddREDtDoBjwXelF4/OuSQwe65l0Pa5oCoJGo+S7ORaHURZ8C+vUibySgdbHDkAvP1DQA+oyN0kNbqpsDHeiad9HDUPC/ZdNoB56fQwNo34Xm0CTvqAX0Swc6qkmBDpyaviuQQ5fYhO8U9gdaauOHAO3eI8UoR4lN6E6hM8hxBuhXYsoh8jppDu0cK3lbADRSDtdFulNYDehXAGjWrnGgI4cR0HBN43XQ5UAL9TZrrXF5h93nxsordZTjUUBzeTf9C4E2DwxEL7YnqDWfFyWHJrOzVwD6RYD+hvDvbfVdQN+9H6rQoROgxe1sJZpXvF4n1bKoh+kO29Uc5Xit1YbtFN2pr/keb71nObZOyklXVvXyOT3OTWPU2uI8SHwc2g40OU51HLoi0K9DZknBsF24de7TNDtoig09yiyg/bczAX0cy8d5b4jeX64BoH/HAjrSPLdpmjDQrKHKgJ4yh9aBZk+1sSsP/1mOTre+45s+EGj3cEMXhUrFzJSohYBeeZWpN1ZqP20HoA8FcugioEmLaoEqdXefWtNyaF5EA1r7Qb6OQLOA58qhgzYsNSTLIz208/yt+5HReoN71BqJPWij5tCq+s3LwVtgppNnqk16Du0DvSc1fppZEOf1tUaD/5hFcRftS7I/ADrXJWrz/8Fl3s4vAJr32CLSt6g1H+hg+gmgM20qAC2MS8QeuIoBvf+lftR1WUSmx6w1J8zzQB9UX5hyCDl0WGM2jaK6QAtbuzn1apHOifOr7rXmhenl0CVA137aztGz57ZrDvRXfBz6xkC7NkGetVGOjl+SjZeeDei6ObQKtLvLSYAO86zk0MeLZkCfmC9H1LBzAC3Jkz+FXIIzJ6XtYuNZ38MJVbYRj8cu5MehH5Nz63t7hR66xIXYqN1JvYeTXB07vHGt+drr0euh/fOO20OHfqgcQKe5XAq02eONa80XAZolaH4mBaAzbRJuVgHoEpd8oBcrwQVAp9mEXI665ZdsERv1EicLaN7KsUCFPWgaA+j9+FjKsdwH6CNCqWl4AmVcgle+my4BOmqj9OFL+q1vx+V0Ds3jGQRoa8OBtveVXJe2QL9y5uU4Qj7+foR1/GVsLOer7kCHQuJAeyXdRYVfko1Uylsq4lgND7Tm0hRo5/n+i4COF6maQwdj8oDmJesAbfswEhzRW9pwaKCXRfq2mejSEuiX+6XCS4COlolbrDlNw/fHzcm7KkALsX8OX4u18CzHvYB2YpNatA/Q5P9tZ0IAPG7yV0HBRTsaU6xQkkkp0B7dkYZZ8nJoQeaDkgn0hTl0tP7vCrRwEFK1B089mlH5+k15N3EVc3dX4o6LgTb9ACNZBjoKUUeg4w1QAHRIJ0c5zgAdPDMmAh3LoasDrZsn7aoUaNIvs4unQOMHNBTQn3hHID/LYZ+Frvc8dHoOzVUP6IQ9VXBRbBK6ZEengDZ15tedfeucScSg+gEtNHJBkW5AqzMnpcyOI00DRBZ4666UECpZRf7kKDRzkhiAK3e1EHAg8C6K7987lpDaphx8GLrsW998of2s/v0d6OSpdyL7mu+fj12WEkxuDu3KW0tcFhqXZ9a5h46XyO+hGwDNcU4HevGG7egqkiKWAC1UTXegQw10NuUIDXH7QC9iLMLG0v4C0WxKzaGl5XYxPxq5uPaAf9VvrLg8pwK9x38GaHLUH29NyVWSF4x07lBj6Qj0dmMlODxEH6lfpMDF3j1SRlTCTS3tmKg/dVH2KwG9o1xvBn+X5xpA00sZHWh61G2AzrFZ7HhaFaDlbY9aC65le1CjqAZ0SqEEoJVbbKKL8IB/PaDzbn27MUceTloCOfSVQLPlTt+S9XXPVQFa25p8bsSVHtDqSaU50HSpX/nHeWM0oL25Gk/k0OQwxKbxDTSgz+XQYhTMxo1UGLYLs1AMtB7YGq81IU6/D/Ec1SjSgxFv5zu7z/kmZsse2lN6D/33RwTaQnL00FqVHS9rXq9zWu2f7X8Ht8UD2jZVd6BpjURvAK1/xxvrglO66IT8RwWaBROVnkNXnMHfUxrQxwFJQFtIvn/8pxL8GjwLNA3Gq+ttAe1T2gMd/gjnPly4EJHFH3ZQkpKATti0GdADzJy070UAmnSIFG0PaKGWtcES8i4WzJIEtEuATwmJXd9j2SiH2VXm55fyTIP/8IMK7TEgLRi6pZJDp9gQdXyWgygHaLm2nP6PAm07P+fkKTg5hSKckCtU10sAmq307dRdScE0ApqEwYG2h/ARrs38XYb28rf6Eym4LEk3x24O9BrqGezSozIsz4u9qcC3kMBiQPPeySm3Ax2KJ9b2RkN8SZYGynjmQHtlA4EqO/mYV3qZZkBr88xc8yXZFDqYC22SENASe7RN/Si2/CchoIQiQ8zLweIkR07rgH61JiFQZSfTA50+7c5WH6mz7tAN3C35+/2dUIQaCNtuL4NBpcUcU+rMSWmSIlLiJFWQpHAw1kt23Wvzf6CTdyhZeMGMmHJs+0rooM0wFtvAeS/MXijsy+mnvCg+rIwa8nU9tLwHHtL+Wnl6gpU9P9i5BHPobWfHv4jkkRsW74g5tBt14oPMCkZm8SdemuXQst/HUq/GkzCpwqVA729MRThbyp/ktECpiRqMuLOEXkApMzrQXtSxxrftkwI06YBZIS8YDWhxCIWpcja4tgGa/r+6hcXtAoG6pZztMoBOP/UdrwG02ifxpuHliIsItFOpS/gk2htoFgtBOfLRTAXa84kCTWmkWwQDEj6W7rHNA7RaEcfiNKC91U4H8lktCZ7FYjr6GCvdgWYi6FQF2v3M2GBcl2M9Kbcs0Yg+gV3YYDYN9I0VN860HDpa9YEviZiPhG/j1jwF2ivnfC5GBJqExGLUQo3z7AJt6ou7CJ9/voJ9dyzhmK4E+pU1FZirtMZPBloQqcgsoN3+QgA6pWnUYzKqBjQL6S1fkrGgMyrfQ1TZLV1wAmj5s9YF6MyZk1wlNn6Y5+BaWpFKzTs59Opu4ABNypw5pkOtgJYurFS21UAZhmlA0x17NlXOa+2/glUNaOGAU0azpZpi7SnXpLPQn5TOYG0M3qyMGM8oQAvL3ZdRpnndiVuIA8jOsnf4gvBrE4lk1R8frfpb36dmTjrzVRPTeSrEOp1RSndkg5GAdqIZD2h5RIAt94GOVIvTsUrlpWBc57a3vqWfwToLtCW6E9BbSdaVVgTaaUmx51MtuwK9KNd9wW5gfxUG1ZYK19/xLIe/WTQazyas2wKdUhm0pqNA/70pDEb4eMU+HD2BpucQdQ+ySKXpwJLkNxSMW2ASoL+HkTVzkjSBDp3uJzLTzlF0kTYJbp4cjLbnesqZOUkLpjCmY6NF394CnRCG79xGPtC1pzEo7qGlT77T6wROnrSLIVuKCgyKH38THqekw2GaRuqhg6E6F8FioOYc6K9b2NhQsE7aPeD/R3LdUQ7y/7YzIQBVYkWkAc22Fu4UmleLMzzhbW62SnjgfTSgIzk0j9Ut5H0uvEKLjrrZRsqhXd3oGyvnhu3k6uKclQFtmkK3EYFmHb+gwXLoyB7YkXiH5X8uaF+9GKkdtAU6KZqghgK6+MZKsLczXWusj5C+3kobIwNo0oqyBnzaLrCHZKBpEZK+sT7B2ToBaLNF05Sj8o/Xn7v1Hevt1jU0WbZZ7n8NKAFoKYcO9Eh7NLFwhwKaHclJoL3NbTegyG7RdJTjp+pFYYXpdCNKmP1dAJrlHFIwgudHaHQvmrCFCSasbkAzufFqQNMTlT2FaVVzLdDHf5fPnLSrHdDuWycYyTQT6PwWFoNpBHS0zsQChtz94N62qH+4sZSjUw9tqb4J0Al5CcmhtZTxYUBHD0QrwDvn0AlpL3NxDk3yjtsAnW7jEk3+BoA+Xj0QaK8Q4Tk8xJQCtFHbi0Lpebv7Ac2awgFaSj30HNq0/Wf1u6FQNErZsYEmH3PLrbOdXT460ArONwSaNwUH2s88BKAFqwuaZu2dQ9u68WrKrreL/POa9+5aoF2QJwPav3xZMoCO9c56NExDAK310HS5OJ0uX/B21/muk91Y8ZQxc1KaZJdv1eqz7Zh1y/Hmbd5L5WOWkWhyVXfmJEnawTjLY0fMg1mWpDqK2ZRKmjlp/4HCMea2W6vn0P4606lIDzd4WyXc5okVGLyHpnWTXflC0p1yVms+bDfHKIeYckilaMrxGKATZngqqHwLtP2TQjSAJtJ7aNbXhC6C0oCeKofOGezMsXFAHgPo3wmBDp1i6UVhqP6nGuWIFzl5ehwGaPHppHmBVm6sFAZzP6ADwFUAWrT3lzW+sVJ3fugOE82I4jl0tKt4KNChejnT0VtXz0XYZcNhO/+eykmgS3+ncFO9k2fs1AegJZsWtdYXaAN2JaD7zJzUx+Z5QDc5r3UCmnTNNZ/lqDvRjCQAfWoPwRyasicWLAqmTw5tf15FeJQDQCe63A/ooA0BWu6sx6y1f5ZkCeaTF4V/AtB5NqMALT1zmGtz5bMcKs8ngUYOnWkzDNBWtwRazThKgLaDG8ffb52cmzlpSC1tpwEyNXpt1bU9yqpyRjkqPeB/AN38S7IJsTTtoVnfNW0PXWwzxuOj9e4UcpxHBjp6kxZAl9iMAXS1HNrleVyg448dAOgSm9mAdhfMBzTr2gF0xKXecLbu0raHHuTWd9SmHOjMaB4NdMvBkh5Av+4DdHEOnRsNgD5vEw5mnB/e9DRw07S0AdCnggHQaTYAusRmshzaE4B+NtANbQB0pg2ALrGZHmgoU6i6FqoGNAQNJQANTSUADU0lAA1NJQANTSUADU0lAA1NJQANTSUADU0l3CnsLVRdC9UD2r7EUwkpLniWI9UGDydl2gDoEhsATfX0plkBdLoNgM60AdAlNgCa6ulNswLodBsAnWkDoEtsADTV05tmBdDpNgA60wZAl9gAaKqnN80KoNNtAHSmDYAusQHQVE9vmjUCtDzb05S1FprYyvmpSQCdZjMe0Mp8fDPWmnOo7hvyY8C9gf4YvT81VMdlLBvq8s+pOrru25Kn93BC/Wz4oYrvjAt66DQb9NAlNk16aPEdUo5Mm/GAfmwOvXhErwA622ZAoKvsoa1Ni1pbFuncBKAzbQB0iQ2Appq+aeIuANq3EXkG0Lk2ALrEpkmthWeZbgS0+dnNyX+nsIENgC6xaQz0zrHzEysAGkC3smkKtP0d2RW/9Z1tA6BLbPoBvQLoPBsAXWLTJeXY8w67GEAD6EY2PYG2RANoAH3Chg9v8Hfdgf4OHv57Q1kiQF8dyvX6IqS8s0IPnWaDHrrE5nStbd3w53itPqKElCPXZjyglYfep6q1nVoVaPsWF4WZNsMB7d4APt5NVWsMaD+HJgv6AI1huwKbHKBti5rXU9UaB1pe6bg0Bxo3VjJtMoFeyNuCPWgapNZoDs0WrVcAjVvfJTYZOfT8QPs2/Jh9l6ZA4+GkApuMUQ4RaOViUdmDpmFrzRxo13FoRQC68rAdadSjuxafFtb3oGnYWjuOr++wnSIA3Wwc2iQgswO92g4aQJ+wGQloidjnAL0LQJ+zGQhoEVkD9Ow5tBFy6FM2owNtcugPXVIc531rDTMnjWYTnTnpS27cZ1HLDXW4ZTbekWHmpEybgXpovetle+B3EoU9pNno6lxrNFz/yJByZNqMBDSRD6Vp6hjQ4avHfrUWz/m/NixcAH3aZkygfWjJgnsAnTAqA6Ab2IwHtBmjY23L3iuoqECTBWMD7R8ZgM60GQ7ohcpdzN5re5B4NouGAzqSmgDoTJsxgVZyDrdUYpyXAJ2aQ6cG0xZoPJyUb5MF9OoBwfdwA6DvNA79cp4fBdCVc+joHrKAviSHzrdZjoeTRJeWQOMB/xKbsoeTtD0EcugcG0nXPZzkXzp0BBpfwcq0qQt0bA9tbQC0ehiy7t00cRcA7dtcDTRSjkybQYCOD6ddmEN7PPe8KCRRYPqfTJ2fOWkRpxdK2m4p3baD9NDa9tAY5ci3qdpDJ45y+IWETlCyiRRJqrXEGysRl+MFcug0m7sBbQep/Rvh0iNO4l3DKNCxMok3VmJEDwP09j+mAsuyKQZ6OeawWByZ1fvLONBulioi1xPoaJGeQNsFALoh0DsYH4/nxX5LWgTa74xj702gzgfGK1IL6IwrVKQcaTY3AXpZHKClhz7e0nbeosB7G6jdViyjH64tnJJDDwM0LgrzbU4CvYhAM2oFoEnOveYAzR4pyQBajUbUR/jQScH8qfnDSZgKLNPmTA5tED4WrAxoMU6/N/fTBxGmjkDHr1E7Ae0IQLcd5ZB5NL22EidZb4slB2p8Jd4q99AAup7NLYD+4+Qjd5Z0ieBSDnRQwRxaG3NRCgPoqjY3AHphw3aJeyAb02xlTKBTggHQaTbjA703uQ+0R0IA6NJApd0cLiKJPtBSsVB+rgQDoNNs7gO025n5NEj3rIWtEgONXRQqNLo5tJInbWedeDQXAX1yvhxPE8wBFHQRZ05S9G19YV4lb8Gfy7aQruDF/I20QI+S6hYxq7deLCUK7oKZk1Jtxu+hQ2PIXg9tLrMWVm6V34UCPUrm9tDcRk6STQ8diWRFypFtcwOgN4lAe3vwgeZJRj7QmTk0t5F5pumMEKMQzCoD/QOgS1zuBLQ/OO3bxBa/gyW/ih3u37YG6FCp6MWhBPQPFYDOdhkDaO8CymeAXoZpTWoDddMS8f6MYhQ4XPOJagb0D4A+5zII0PytRADJFRQ+5Nz62GJf8GblRafIOLQBOpyWlAKNlOOcy4hAcxzZHsI8mzU+0MeSFKBVACnQkST7fA5d76IQDyfl2zQCmjD3dhe4CgJtlkSBVs4Bi73J/vfvHc43/GMS1QdoPD5aYNML6EC/xxDzOnkBaO02n8TqvsxG0wzoPXX++ckAOhgJHvAvsWmUQ/tAkyIOY4xPn7fFy6E9mZ5c2NZZ1gzoP5C3fxk5tHxS2QWgS2zqAm1l20kGmjflh6+OBervy3NkK6jNsUAHqRDo478coE2Q0oqXuwBAXwi0vIc1CrQKmpSpsKwkqYM2QLsr5GCix8R7aEt1Zg4tMv3CRWGBTXegxf40/m1Aj0ziQTpdoYwbjViWvi3NoUnekQm0eHph3yn8rsbMSZk6P3OSqMWbd+howHApU5K9cD0W81opo8V0rPr+1UuGJd4pzAKakOwQjRy6xKZ9Dy30Pd6ij5ZJss5X66HVJFrsoe3GpMz5HlrBOeGikLxjKzHRTIlNJ6CF3Jbb2OxBLCl/Ko7iO8vSffgA0KwMKXjiolBSEOjQTgB0iU0voPkgtMvZx+8oeUmlA+e78IPxN9KAzjumLjdWMHNSiU2Hi0Lv/C7aHP2kUjLE81E6o9aInedcfmPF3F2pAzTmhy6waQ40y20DQDvrnZLhHjo5mOq15g7blY1yKMKt7wKbakArwPGrtRjQ4q3G0IZKMLruBDTGoQtsagGtEbdQolUshUC9jOMWQP9WBdoRgL4J0AmsJpW5HGjx6SQAneZyE6DXONBJve+ZJ6XO2QSDcW+sZD5tlycAPUAOvY1yaMN1x5a2RFKg0WCs7WmbcDB02M6/pwKgM1xGAzppD6L4dSNbTm3i3fiHbdYdaEUAOs1lfKCX+IPMtqCPX/44x4eV6ww0/5LsTxOghZluTmmoKY8unjkpri9QyS5HaWnJIs7RFDUSy1eutb5A25fooVNc6vbQRw+ZWGtSxkG72uweWlbblEN4NglAJ7rMBrRoQIyyc2hZTYHOftouTwB65ByacRcMdAf6XDCHmo5yZH9JNk8AeuBRDp4ZhG2+JdUJNezii2+s/BwvAHSJy4OA3myU4WpidPmdwv0VgC5xeSbQwdG964BWn+4/CzQeTsq1uezGSnoOvdsAaAA9MtD5NsrgXTyHppvcC2g8PpptcyOgvwoNyiku7EMAoIkA9Nk9tLWZDugXUo5sGwB9KpimQL8AdL7NA4C+bQ79sheF3w8lZk7KVKOZk2ZWS6BfL4xy5Ns8oYeub9Olh3ZnMQDQALqVjfa0XU2gX6+XM48BgL4p0OLQ3Ji1Jj4PzZ/nANBpLvMC3fKrJjcC+iukHLk2ALrEpkfK8RWAzrUB0CU2ADrT5tFA3zOHNklHVaCZAPRNgS61uRboHeXcGfwzBKABdCMb8aLQfQGgs1wAdIkLgKaaumnWGwAd+eI3gKYC0MMDHZuaY4QcuuIM/p4wc1KmS92Zk6Q9nLNJnTwpYlMnmE2YOSnNBj20ZDN2D60JQKe5PBDooXNoAH3S5YlAn3dpf1GImZMKXQB0iQuAppq6aVYAnW6DlCPTBkCX2EwHNH7WLd8GQJfY9AEaP7xZYAOgS2y6AI2fRi6xAdAlNn2AJv9vOxMC0PX0plkBdLoNgM60AdAlNpMBvQlA59kA6BKbfkDvOTRmTioRZk7KFr71nWaDHrrE5uI7hfWB5sPQABpAt7LpNQ7N3wNoAN3Ipt84NBWABtCNbGIpRx2g3QUAGkA3sgkCXa+Hxq3vfBsAXWITSjlq9dDeXI0AGkC3sukBtC8ADaAb2QDoTBsAXWIzSA4NoItcAHSJSweg3R4bQKe5AOgSF6QcVFM3zQqg020AdKYNgC6xmR7oZhNAVbE5O63V86YCG8cmPBXYM3vo4LxW6KFLbHBRSAWgAXSyTZeHkzwBaADdyAZACzahmQcBdInNZUCrU+k+CuiTLgC6xKVhD72RXHXCc3xjJd8GQJfYiBeF7ovTQL8wFVi+DYAusekCNGZOKrEB0CU2/YDGvByZNgC6xEbOoUkqXQVo8v+2MyEAXU9vmhVAp9uIw3bVv4K1/W+JBtAAupGNNg7t3ycE0KkuALrE5U43VijQmAqsRJgKLFtCyoEeuswFPXSJS4+LwspA2wUAGkA3ssGwXaYNgC6xmRFo3FjJtAHQJTa49Z1pA6BLbCbLofFwUokNgC6xCd1Y+a0HtCMADaAb2Sjj0ALOADrVBUCXuNzpxoonAA2gG9nIOfTPlnYA6CIXAF3i0niUw/19FQBNXfYvHWrfPQTQBS4Amqpv0+xfC1e/HQ6gC1xaA/3bFOhm8+V0sfmSbP60igYzJ51y4UD/NAbavrxjX4MeOtfm8otCKeMA0MYFOXSmzeU3Vn4lAeg0FwBd4oJxaKqpm2YF0Ok2GIfOtAHQJTYDjHLUHbab62m70Nx3GTYZwQDoVJs+QA/xO4UxDFODWYKzkybbRAWgS2y6jEMP8YB/FMPEYBYAnW9zOdB1x6GH+E4hgA7uoa3N5ReFdcehJwT6tE28CIAusek4Dj1ADu2TyJek5tDnowHQjWz6jUNfnUMfl3NsmbNkzKZZAXS6jZhDkxn8aWddALQd3Dj+Xjlz0nff4pLvH3flQMLMSdlqC/QYX5JVe+jFSN36WPfxlhRFgx66kU2flIPjXAfo3Fzhz0bLOOJAm5UfYVu3sBSNUwxAN7LpArTLcw2gOX6FTeMDrTHNgKYPj0qbvMWLT7YMQDeyCefQ/IGOk8N2RCeAPrjwgY6NPgSA/r5YQ0RToBdbWgZaWAagO9moDycJY3cneuhqt74ZggzocApMbGgxZ5O3zjTJoS3Kq5x5AOgCl8a3vn8FpEuBfrUA2suhg+nC14YTKMkAHfzhTV5AcFV6be2YtGDIawCdatMDaF81gKaLgkCTPtSOaCgFg2mHCUZYzzYScmjJJiIAXWJzN6B9mL4ohXLoVKCdctL6NRHo8PGsK4BuZiPn0CSVHg1oTwboYAHhr1ZO+WTsq4+Uwy1E3wPoApe2z3LU/RUsT02AVs/zPIfWOlgfdP7WB1qthbe0PReAbmSjjUPfaLLGWA5NygWQ34gOlM8GOlgEQDey6fdwElWLW9+JQEuFDJ5vvzx7v5ocGkBn2Ux2Y8VTi5mTvvyEypiO1Stllr7FpZpbaE+fhIAiwsxJp1z6Am1f1vtcKqmxtRET5b3YtpDbiN1wQjDmVIAcOsMFKQeV7MKZ+viL3IJO5sIKL87DSboAdDr/3fAAAAipSURBVIkLgLbSyOFd7CdQdi8YAPp4rQXD0QfQ2S4dhu3uArSKDr92C9gcybV7belRalzcPe6rF/JcR4hnAN3KRruxcqfJGmNA28eKgg5LkEMOtLdL1iubUQ59jwC6kY1267v6dLoNZ06KAy1lvwsZw+PkqzuxLglAI+XIcwHQViqMAaA57FGgHRe/8JFxAOhCl5sB3XhuuwA9UaDJZZ/+mJzrYgryLRY2WAKgM1zaA1314aTrgFYu0XygZRvahdtgeNfuFn5HeQbQrWzki8IfaTbdU7OPlqQcBxGlQDuoCTlCHGhKLglGBvp4847fhwfQjWz6jEO/SoDeoYiQYUrq9/+8N04hZRN5iQo06e9jQEdx/wpAl9h0ArrkonBr9oTGV4okA21HO/wcWgHaz6FpAvMOfwyj+cgmAF1i0xjo7auEr1fJzEnfksJsR0pBebFZobgYDrV9RPfuGCVsF96hKMyclK2mQK9Fw3ZHxlHYQ7ujyx+7+Fjrjt4ldBJaNDSIyMOs6KEb2vRIOV7e175zRjkSml4twoj+kGU272ZpTTj/IVuHg4g9nZ3EM4Aushkf6DN1mgD0sSwcjCmddsKIl8MoRyObbk/btRuH/iNHc+FAU9TE075kw0sLW9m+2+6SvS04JjcYAJ1qMzTQi/gQhl8o+K1vm0Nz1KQuVLDZNrL4SzyzLpkjz96RlwC6kc3IQB8wZAKtnes/i8Qwkwq0xd8LJgi0m9iY1wC6kU03oJlaAq1iewpo66IUsOW8DhpAA+htLzwbDRRbk4COD5ioOTR1UQqQcm+6Tr65A6Ab2YwDtECb0/UJKz2XINBR1W8aFgty6PY2wwBNOORA+oAKnL/JyX05hiOcnd62aVYAnW4zINAOwR7Q2wKWnfoTOwv99G2bZgXQ6TbjA+31tRRoc7MZQJ/cQ1ub6YEWZrpZjmmGviyqM+Ps4Jq/u8vC3xdOW1R5DqCSEHyXP2HmpGyXq3toIrdv/fB1tIO2jwPxDnqIHDpwOatct6rBoIdOtRkm5Qjo7zDcfMTJMIZsGoVbNztKCQZAp9rcBGg6hCE9UzFk0yjcAuiWNncDWnno54KmCSDJLnTdUgsBWj4YIRgAnWozHNBC20o9tHYYAdVtmlAnS28WqUCv6ulGCAZAp9p0AvqVOo0Ba9vFPm0XbvvbAb3Z8INyiwLoEps+QAd/p9AdnPB64/sCbY/N/Zj6QHuGALrEpgvQG8sK0LwhnQzTA1pJXYfIoc0S38aj9cO2WBbh6+0AusRmMKAXDWjpfqF0GAG1bhp7IBGgTcqhF3FdAHSqTR+g3QVpQNMc2pVzih6haWxEYaC/rwUb5NA1bDoBHboo9DKO+CPI3mDuCE1jIwrf/dSADgUDoFNtOqUcyT9eL2XKNwF6DQHtFgPQjWwaA21nTjoSj29zxqb/+RZKKJJQrqcSwymIGTMnZav1zEnsa7KxO4X8Akn7XJJeepC+Rs2hU23MYS/8i7/ooVNtOl4UBoAWhjASgCYFJ2kaejnMqgRAp9r0BNoucC8K3RGreA5ty00ANO2XyZ0WUgJAp9r0G4fWLgoXCehjP3YcWlH6SX7cprGHv7/yawRAp9pcf+s7APS+fPamIYdPO2jk0CU21z+cFO6gHwY0XQCgS2wGeHxUoXmdB2jhCOUcmi0A0CU2AwAdUDyHTnHZdVnTSGcg3FhpZDM20Jvu3jQpQAudOIAusQHQmTZtgJaKAOgSGwCdadMihwbQ9WwAdKZNm6YB0DcHutl8OXeyWcjESos/yRJmTjrlgh46zaZeXxO6RYqHk0ptkHJk2tQHOnCP1AhAp9oA6EwbAF1iA6CpZm0aAN3A5g5A6/fGc1zGbBrk0JVt+j2cRN9mAa1fOeW43LhpVgCdbtMH6PQvyQoC0AA63aYL0MEH/KNbA2gAnW7TD2j1K1hRzZxDS1q2qUkAdInNHYB+WNNIw3kAOtXmBinH05oGQJ+x6XhRSN4DaADdyKYx0MfMSZbob1Nh+p+Q/vLnhc+uhJmTstVrKrCtVYRPlK65+xr1khcXhSU2fXLo7f/0qcC4pm4afVASQJfY9ATaLgDQALqRDYbtMm0AdInNdECfufU9edMgh65q0+/hJAzbZdoA6BKbTkA7AtAAupENgM60AdAlNgCa6ulNswLodBsAnWkDoEtsADTV05tmBdDpNgA60wZAl9hMD3Sz+XImssHMSadc0EOn2aCHLrGZvocWAtD19KZZAXS6zUVAWy3/aqiOy1g2zMWpOtRaFZdqQBPVsaoU0FA2IRfUWl0XAN3BBkD3cwHQHWwAdD8XAN3BBkD3c6kINARdLwANTSUADU0lAA1NJQANTaWaQDtfNzxhdNqgUiDnI/maBMNBrSkmZeFUBNr9QvgJoxqRVAjkfCSbSSgc1JpmUhZOPaC9iUmLfc6ajBNJPJpxYh0nklPRVASa/H/Kp07TDBGJjUMFOrg2Yy+PqrWAxgP6fDcxTiRfD/J/7tqs/Tyo1gKqPcoxQoV4M0peFglxOrE2cQ+PqzVRlYEe4vJmwKYJG6HW6hnVANpmTacOxdjM1zSSD2qtiU9NoE9eDUzbNHK9oNZiLkU2VcehBzEa6/KmR7pRw+hWtaar8jj0EE61BqB69FeotcoetYftqjgNcoug5gBU2dqs/Tyo1gKq2UPjJq7sEQoHtaZ5XH3r+zVQ01R7zKbSnWC9XlBrmsXlQEPQCALQ0FQC0NBUAtDQVALQ0FQC0NBUAtDQVALQ0FQC0NBUAtDQVALQ0FQC0NBUAtBd9a3uBZXeTqjbrvpjGTy3FCq3rwB0Y6Fy+2pZwHNToXY7C0C3FWq3s8BzW6F6Ows9dFuhdvsKOXRjoXb7CqMcjYXK7SqMQ7cWKrenFtwpbC3ULTSVADQ0lQA0NJUANDSVADQ0lQA0NJUANDSVADQ0lQA0NJUANDSVADQ0lQA0NJUANDSVADQ0lf4DSYgA0DywuWEAAAAASUVORK5CYII=" alt="plot of chunk unnamed-chunk-3" /></p>
<p>In the simulated data above, we can see that</p>
<ul>
<li>for the easy pattern, it is the same for both people, so it should
be possible/easy to train on one person, and accurately predict on
another.</li>
<li>for the impossible pattern, it is different for each person, so it
should not be possible to train on one person, and accurately
predict on another.</li>
</ul>
<h3 id="sec:benchmark-computing-test-error_1">Benchmark: computing test error</h3>
<p>In the code below, we define a K-fold cross-validation experiment.</p>
<pre><code class="language-r">(reg_same_other &lt;- mlr3resampling::ResamplingSameOtherCV$new())
#&gt; 
#&gt; ── &lt;ResamplingSameOtherCV&gt; : Same versus Other Cross-Validation ────────────────
#&gt; • Iterations:
#&gt; • Instantiated: FALSE
#&gt; • Parameters: folds=3
</code></pre>
<p>In the code below, we define two learners to compare,</p>
<pre><code class="language-r">(reg.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerRegrRpart$new(),
  mlr3::LearnerRegrFeatureless$new()))
#&gt; [[1]]
#&gt; 
#&gt; ── &lt;LearnerRegrRpart&gt; (regr.rpart): Regression Tree ────────────────────────────
#&gt; • Model: -
#&gt; • Parameters: xval=0
#&gt; • Packages: mlr3 and rpart
#&gt; • Predict Types: [response]
#&gt; • Feature Types: logical, integer, numeric, factor, and ordered
#&gt; • Encapsulation: none (fallback: -)
#&gt; • Properties: importance, missings, selected_features, and weights
#&gt; • Other settings: use_weights = 'use'
#&gt; 
#&gt; [[2]]
#&gt; 
#&gt; ── &lt;LearnerRegrFeatureless&gt; (regr.featureless): Featureless Regression Learner ─
#&gt; • Model: -
#&gt; • Parameters: robust=FALSE
#&gt; • Packages: mlr3 and stats
#&gt; • Predict Types: [response], se, and quantiles
#&gt; • Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt; POSIXct, and Date
#&gt; • Encapsulation: none (fallback: -)
#&gt; • Properties: featureless, importance, missings, selected_features, and weights
#&gt; • Other settings: use_weights = 'use'
</code></pre>
<p>In the code below, we define the benchmark grid, which is all
combinations of tasks (easy and impossible), learners (rpart and
featureless), and the one resampling method.</p>
<pre><code class="language-r">(reg.bench.grid &lt;- mlr3::benchmark_grid(
  reg.task.list,
  reg.learner.list,
  reg_same_other))
#&gt;          task          learner    resampling
#&gt;        &lt;char&gt;           &lt;char&gt;        &lt;char&gt;
#&gt; 1:       easy       regr.rpart same_other_cv
#&gt; 2:       easy regr.featureless same_other_cv
#&gt; 3: impossible       regr.rpart same_other_cv
#&gt; 4: impossible regr.featureless same_other_cv
</code></pre>
<p>In the code below, we execute the benchmark experiment (in parallel
using the multisession future plan).</p>
<pre><code class="language-r">if(FALSE){#for CRAN.
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
#&gt; Le chargement a nécessité le package : lgr
#&gt; 
#&gt; Attachement du package : 'lgr'
#&gt; L'objet suivant est masqué depuis 'package:ggplot2':
#&gt; 
#&gt;     Layout
(reg.bench.result &lt;- mlr3::benchmark(
  reg.bench.grid, store_models = TRUE))
#&gt; 
#&gt; ── &lt;BenchmarkResult&gt; of 72 rows with 4 resampling run ──────────────────────────
#&gt;  nr    task_id       learner_id resampling_id iters warnings errors
#&gt;   1       easy       regr.rpart same_other_cv    18        0      0
#&gt;   2       easy regr.featureless same_other_cv    18        0      0
#&gt;   3 impossible       regr.rpart same_other_cv    18        0      0
#&gt;   4 impossible regr.featureless same_other_cv    18        0      0
</code></pre>
<p>The code below computes the test error for each split,</p>
<pre><code class="language-r">reg.bench.score &lt;- mlr3resampling::score(reg.bench.result)
reg.bench.score[1]
#&gt;    train.subsets test.fold test.subset person iteration                  test
#&gt;           &lt;char&gt;     &lt;int&gt;       &lt;int&gt;  &lt;int&gt;     &lt;int&gt;                &lt;list&gt;
#&gt; 1:           all         1           1      1         1  1, 3, 5, 6,12,13,...
#&gt;                    train                                uhash    nr
#&gt;                   &lt;list&gt;                               &lt;char&gt; &lt;int&gt;
#&gt; 1:  4, 7, 9,10,18,20,... 7c11294c-bd1a-46ae-98ff-c20f08a426ce     1
#&gt;               task task_id                       learner learner_id
#&gt;             &lt;list&gt;  &lt;char&gt;                        &lt;list&gt;     &lt;char&gt;
#&gt; 1: &lt;TaskRegr:easy&gt;    easy &lt;LearnerRegrRpart:regr.rpart&gt; regr.rpart
#&gt;                 resampling resampling_id  prediction_test regr.mse algorithm
#&gt;                     &lt;list&gt;        &lt;char&gt;           &lt;list&gt;    &lt;num&gt;    &lt;char&gt;
#&gt; 1: &lt;ResamplingSameOtherCV&gt; same_other_cv &lt;PredictionRegr&gt; 1.638015     rpart
</code></pre>
<p>The code below visualizes the resulting test accuracy numbers.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    scale_x_log10()+
    geom_point(aes(
      regr.mse, train.subsets, color=algorithm),
      shape=1,
      data=reg.bench.score)+
    facet_grid(
      task_id ~ person,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-9" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>for the easy task, training on same is just as good as all or other
subsets. rpart has much lower test error than featureless, in all
three train subsets.</li>
<li>for the impossible task, the least test error is using rpart with same train subsets; featureless with same train subsets is next best; training on all is substantially worse (for both featureless and rpart); training on other is even worse (patterns in the two people are completely different).</li>
<li>in a real data task, training on other will most likely not be quite as bad as in the impossible task above, but also not as good as in the easy task.</li>
</ul>
<h3 id="sec:interactive-visualization-of-data-test-error-and-splits_1">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">inst &lt;- reg.bench.score$resampling[[1]]$instance
rect.expand &lt;- 0.3
grid.dt &lt;- data.table(x=seq(-abs.x, abs.x, l=101), y=0)
grid.task &lt;- mlr3::TaskRegr$new(&quot;grid&quot;, grid.dt, target=&quot;y&quot;)
pred.dt.list &lt;- list()
point.dt.list &lt;- list()
for(score.i in 1:nrow(reg.bench.score)){
  reg.bench.row &lt;- reg.bench.score[score.i]
  task.dt &lt;- data.table(
    reg.bench.row$task[[1]]$data(),
    reg.bench.row$resampling[[1]]$instance$id.dt)
  names(task.dt)[1] &lt;- &quot;y&quot;
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=reg.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ]
  point.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(task_id, iteration)],
    i.points)
  i.learner &lt;- reg.bench.row$learner[[1]]
  pred.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(
      task_id, iteration, algorithm
    )],
    as.data.table(
      i.learner$predict(grid.task)
    )[, .(x=grid.dt$x, y=response)]
  )
}
(pred.dt &lt;- rbindlist(pred.dt.list))
#&gt;          task_id iteration   algorithm     x        y
#&gt;           &lt;char&gt;     &lt;int&gt;      &lt;char&gt; &lt;num&gt;    &lt;num&gt;
#&gt;    1:       easy         1       rpart -2.00 3.557968
#&gt;    2:       easy         1       rpart -1.96 3.557968
#&gt;    3:       easy         1       rpart -1.92 3.557968
#&gt;    4:       easy         1       rpart -1.88 3.557968
#&gt;    5:       easy         1       rpart -1.84 3.557968
#&gt;   ---                                                
#&gt; 7268: impossible        18 featureless  1.84 7.204232
#&gt; 7269: impossible        18 featureless  1.88 7.204232
#&gt; 7270: impossible        18 featureless  1.92 7.204232
#&gt; 7271: impossible        18 featureless  1.96 7.204232
#&gt; 7272: impossible        18 featureless  2.00 7.204232
(point.dt &lt;- rbindlist(point.dt.list))
#&gt;           task_id iteration set.name row_id           y          x  fold person
#&gt;            &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;       &lt;num&gt;      &lt;num&gt; &lt;int&gt;  &lt;int&gt;
#&gt;     1:       easy         1     test      1  1.32996609 -0.9379653     1      1
#&gt;     2:       easy         1    train      2  0.24307692 -0.5115044     3      1
#&gt;     3:       easy         1     test      3 -0.23314657  0.2914135     1      1
#&gt;     4:       easy         1    train      4  1.73677545  1.6328312     2      1
#&gt;     5:       easy         1     test      5 -0.06356159 -1.1932723     1      1
#&gt;    ---                                                                         
#&gt; 21596: impossible        18    train    296  5.18094849  0.7257701     1      2
#&gt; 21597: impossible        18    train    297  9.60431191 -1.6033236     1      2
#&gt; 21598: impossible        18     test    298  7.51198770 -1.5243898     3      2
#&gt; 21599: impossible        18    train    299 11.03539747 -1.7982414     1      2
#&gt; 21600: impossible        18     test    300 10.71968480  1.7170157     3      2
#&gt;        subset display_row
#&gt;         &lt;int&gt;       &lt;int&gt;
#&gt;     1:      1           1
#&gt;     2:      1         101
#&gt;     3:      1           2
#&gt;     4:      1          51
#&gt;     5:      1           3
#&gt;    ---                   
#&gt; 21596:      2         198
#&gt; 21597:      2         199
#&gt; 21598:      2         299
#&gt; 21599:      2         200
#&gt; 21600:      2         300
set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
make_person_subset &lt;- function(DT){
  DT[, &quot;person/subset&quot; := person]
}
make_person_subset(point.dt)
make_person_subset(reg.bench.score)
#&gt; Warning in `[.data.table`(DT, , `:=`(&quot;person/subset&quot;, person)): A shallow copy
#&gt; of this data.table was taken so that := can add or remove 1 columns by
#&gt; reference. At an earlier point, this data.table was copied by R (or was created
#&gt; manually using structure() or similar). Avoid names&lt;- and attr&lt;- which in R
#&gt; currently (and oddly) may copy the whole data.table. Use set* syntax instead to
#&gt; avoid copying: ?set, ?setnames and ?setattr. It's also not unusual for
#&gt; data.table-agnostic packages to produce tables affected by this issue. If this
#&gt; message doesn't help, please report your use case to the data.table issue
#&gt; tracker so the root cause can be fixed or this message improved.

if(require(animint2)){
  viz &lt;- animint(
    title=&quot;SOAK algorithm: train/predict on subsets, regression&quot;,
    video=&quot;https://vimeo.com/1053413000&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      geom_point(aes(
        x, y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        help=&quot;One dot for each train/test/unused data point.&quot;,
        shape=21,
        data=point.dt)+
      scale_color_manual(values=algo.colors)+
      geom_line(aes(
        x, y, color=algorithm,
        group=paste(algorithm, iteration)),
        help=&quot;One line for each learned prediction function.&quot;,
        showSelected=&quot;iteration&quot;,
        data=pred.dt)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;)+
      scale_x_continuous(
        &quot;x = input/feature in regression&quot;)+
      scale_y_continuous(
        &quot;y = output to predict in regression&quot;,
        breaks=seq(-100, 100, by=2)),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400, width=350)+
      guides(fill=&quot;none&quot;)+
      scale_y_log10(
        &quot;Mean squared error on test set&quot;)+
      scale_fill_manual(values=algo.colors)+
      scale_x_discrete(
        &quot;People/subsets in train set&quot;)+
      geom_point(aes(
        train.subsets, regr.mse, fill=algorithm),
        help=&quot;One dot per test set and learning algorithm.&quot;,
        shape=1,
        size=5,
        stroke=2,
        color=&quot;black&quot;,
        color_off=NA,
        showSelected=&quot;algorithm&quot;,
        clickSelects=&quot;iteration&quot;,
        data=reg.bench.score)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        scales=&quot;free&quot;),
    diagram=ggplot()+
      ggtitle(&quot;Select train/test split&quot;)+
      theme_animint(height=400, width=300)+
      facet_grid(
        . ~ train.subsets,
        scales=&quot;free&quot;,
        space=&quot;free&quot;)+
      scale_size_manual(values=c(subset=3, fold=1))+
      scale_color_manual(values=c(subset=&quot;orange&quot;, fold=&quot;grey50&quot;))+
      geom_rect(aes(
        xmin=-Inf, xmax=Inf,
        color=rows,
        size=rows,
        ymin=display_row, ymax=display_end),
        help=&quot;One rect per chunk of data with common fold (grey) and subset (gold).&quot;,
        fill=NA,
        data=inst$viz.rect.dt)+
      scale_fill_manual(values=set.colors)+
      geom_text(aes(
        x=ifelse(rows==&quot;subset&quot;, Inf, -Inf),
        y=(display_row+display_end)/2,
        hjust=ifelse(rows==&quot;subset&quot;, 1, 0),
        label=paste0(rows, &quot;=&quot;, ifelse(rows==&quot;subset&quot;, subset, fold))),
        help=&quot;Text labels indicate chunks of data with common fold (grey) and subset (gold).&quot;,
        showSelected=&quot;rows&quot;,
        data=data.table(train.name=&quot;same&quot;, inst$viz.rect.dt))+
      geom_rect(aes(
        xmin=iteration-rect.expand, ymin=display_row,
        xmax=iteration+rect.expand, ymax=display_end,
        fill=set.name),
        help=&quot;One rect per chunk of data assigned to train/test set in cross-validation.&quot;,
        alpha=0.5,
        alpha_off=0.5,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=inst$viz.set.dt)+
      scale_x_continuous(
        &quot;Split number&quot;,
        breaks=c(1,6, 7,12, 13,18))+
      scale_y_continuous(
        &quot;Row number&quot;),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Older_resamplers.Rmd&quot;)
}
if(FALSE){
  animint2pages(viz, &quot;2023-12-13-train-predict-subsets-regression&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-13-train-predict-subsets-regression/">https://tdhock.github.io/2023-12-13-train-predict-subsets-regression/</a></p>
<h2 id="sec:simulated-classification-problems_1">Simulated classification problems</h2>
<p>The previous section investigated a simulated regression problem, whereas in this section we simulate a binary classification problem.
Assume there is a data set with some rows from one person, some rows
from another,</p>
<pre><code class="language-r">N &lt;- 200
library(data.table)
(full.dt &lt;- data.table(
  label=factor(rep(c(&quot;spam&quot;,&quot;not spam&quot;), l=N)),
  person=rep(1:2, each=0.5*N)
)[, signal := ifelse(label==&quot;not spam&quot;, 0, 3)][])
#&gt;         label person signal
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;
#&gt;   1:     spam      1      3
#&gt;   2: not spam      1      0
#&gt;   3:     spam      1      3
#&gt;   4: not spam      1      0
#&gt;   5:     spam      1      3
#&gt;  ---                       
#&gt; 196: not spam      2      0
#&gt; 197:     spam      2      3
#&gt; 198: not spam      2      0
#&gt; 199:     spam      2      3
#&gt; 200: not spam      2      0
</code></pre>
<p>Above each row has an person ID between 1 and 2.
We can imagine a spam filtering system, that has training data for multiple people (here just two).
Each row in the table above represents a message which has been labeled as spam or not, by one of the two people.
Can we train on one person, and accurately predict on the other person?
To do that we will need some features, which we generate/simulate below:</p>
<pre><code class="language-r">set.seed(1)
n.people &lt;- length(unique(full.dt$person))
for(person.i in 1:n.people){
  use.signal.vec &lt;- list(
    easy=rep(if(person.i==1)TRUE else FALSE, N),
    impossible=full.dt$person==person.i)
  for(task_id in names(use.signal.vec)){
    use.signal &lt;- use.signal.vec[[task_id]]
    full.dt[
    , paste0(&quot;x&quot;,person.i,&quot;_&quot;,task_id) := ifelse(
      use.signal, signal, 0
    )+rnorm(N)][]
  }
}
full.dt
#&gt;         label person signal    x1_easy x1_impossible    x2_easy x2_impossible
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;      &lt;num&gt;         &lt;num&gt;      &lt;num&gt;         &lt;num&gt;
#&gt;   1:     spam      1      3  2.3735462     3.4094018  1.0744410    -0.3410670
#&gt;   2: not spam      1      0  0.1836433     1.6888733  1.8956548     1.5024245
#&gt;   3:     spam      1      3  2.1643714     4.5865884 -0.6029973     0.5283077
#&gt;   4: not spam      1      0  1.5952808    -0.3309078 -0.3908678     0.5421914
#&gt;   5:     spam      1      3  3.3295078     0.7147645 -0.4162220    -0.1366734
#&gt;  ---                                                                         
#&gt; 196: not spam      2      0 -1.0479844    -0.9243128  0.7682782    -1.0293917
#&gt; 197:     spam      2      3  4.4411577     1.5929138 -0.8161606     2.9890743
#&gt; 198: not spam      2      0 -1.0158475     0.0450106 -0.4361069    -1.2249912
#&gt; 199:     spam      2      3  3.4119747    -0.7151284  0.9047050     0.4038886
#&gt; 200: not spam      2      0 -0.3810761     0.8652231 -0.7630863     1.1691226
</code></pre>
<p>In the table above, there are two sets of two features:</p>
<ul>
<li>For easy features, one is correlated with the label (<code>x1_easy</code>), and
one is random noise (<code>x2_easy</code>), so the algorithm just needs to
learn to ignore the noise feature, and concentrate on the signal
feature. That should be possible given data from either person (same
signal in each person).</li>
<li>Each impossible feature is correlated with the label (when feature
number same as person number), or is just noise (when person number
different from feature number). So if the algorithm has access to
the correct person (same as test, say person 2), then it needs to
learn to use the corresponding feature <code>x2_impossible</code>. But if
the algorithm does not have access to that person, then the best it
can do is same as featureless (predict most frequent class label in
train data).</li>
</ul>
<h3 id="sec:static-visualization-of-simulated-data_2">Static visualization of simulated data</h3>
<p>Below we reshape the data to a table which is more suitable for visualization:</p>
<pre><code class="language-r">(scatter.dt &lt;- nc::capture_melt_multiple(
  full.dt,
  column=&quot;x[12]&quot;,
  &quot;_&quot;,
  task_id=&quot;easy|impossible&quot;))
#&gt;         label person signal    task_id         x1         x2
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;     &lt;char&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;   1:     spam      1      3       easy  2.3735462  1.0744410
#&gt;   2: not spam      1      0       easy  0.1836433  1.8956548
#&gt;   3:     spam      1      3       easy  2.1643714 -0.6029973
#&gt;   4: not spam      1      0       easy  1.5952808 -0.3908678
#&gt;   5:     spam      1      3       easy  3.3295078 -0.4162220
#&gt;  ---                                                        
#&gt; 396: not spam      2      0 impossible -0.9243128 -1.0293917
#&gt; 397:     spam      2      3 impossible  1.5929138  2.9890743
#&gt; 398: not spam      2      0 impossible  0.0450106 -1.2249912
#&gt; 399:     spam      2      3 impossible -0.7151284  0.4038886
#&gt; 400: not spam      2      0 impossible  0.8652231  1.1691226
</code></pre>
<p>Below we visualize the pattern for each person and feature type:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x1, x2, color=label),
      shape=1,
      data=scatter.dt)+
    facet_grid(
      task_id ~ person,
      labeller=label_both)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-13" /></p>
<p>In the plot above, it is apparent that</p>
<ul>
<li>for easy features (left), the two label classes differ in x1 values
for both people. So it should be possible/easy to train on person 1, and
predict accurately on person 2.</li>
<li>for impossible features (right), the two people have different label
patterns. For person 1, the two label classes differ in x1 values,
whereas for person 2, the two label classes differ in x2 values. So
it should be impossible to train on person 1, and predict accurately
on person 2.</li>
</ul>
<h3 id="sec:benchmark-computing-test-error_2">Benchmark: computing test error</h3>
<p>We use the code below to create a list of classification tasks, for
use in the mlr3 framework.</p>
<pre><code class="language-r">class.task.list &lt;- list()
for(task_id in c(&quot;easy&quot;,&quot;impossible&quot;)){
  feature.names &lt;- grep(task_id, names(full.dt), value=TRUE)
  task.col.names &lt;- c(feature.names, &quot;label&quot;, &quot;person&quot;)
  task.dt &lt;- full.dt[, task.col.names, with=FALSE]
  this.task &lt;- mlr3::TaskClassif$new(
    task_id, task.dt, target=&quot;label&quot;)
  this.task$col_roles$subset &lt;- &quot;person&quot;
  this.task$col_roles$stratum &lt;- c(&quot;person&quot;,&quot;label&quot;)
  this.task$col_roles$feature &lt;- setdiff(names(task.dt), this.task$col_roles$stratum)
  class.task.list[[task_id]] &lt;- this.task
}
class.task.list
#&gt; $easy
#&gt; 
#&gt; ── &lt;TaskClassif&gt; (200x3) ───────────────────────────────────────────────────────
#&gt; • Target: label
#&gt; • Target classes: not spam (positive class, 50%), spam (50%)
#&gt; • Properties: twoclass, strata
#&gt; • Features (2):
#&gt;   • dbl (2): x1_easy, x2_easy
#&gt; • Strata: person and label
#&gt; 
#&gt; $impossible
#&gt; 
#&gt; ── &lt;TaskClassif&gt; (200x3) ───────────────────────────────────────────────────────
#&gt; • Target: label
#&gt; • Target classes: not spam (positive class, 50%), spam (50%)
#&gt; • Properties: twoclass, strata
#&gt; • Features (2):
#&gt;   • dbl (2): x1_impossible, x2_impossible
#&gt; • Strata: person and label
</code></pre>
<p>Note in the code above that person is assigned roles subset and
stratum, whereas label is assigned roles target and stratum.  When
adapting the code above to real data, the important part is the
<code>mlr3::TaskClassif</code> line which tells mlr3 what data set to use, and
what columns should be used for target/subset/stratum.</p>
<p>The code below is used to define a K-fold cross-validation experiment,</p>
<pre><code class="language-r">(class_same_other &lt;- mlr3resampling::ResamplingSameOtherCV$new())
#&gt; 
#&gt; ── &lt;ResamplingSameOtherCV&gt; : Same versus Other Cross-Validation ────────────────
#&gt; • Iterations:
#&gt; • Instantiated: FALSE
#&gt; • Parameters: folds=3
</code></pre>
<p>The code below is used to define the learning algorithms to test,</p>
<pre><code class="language-r">(class.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerClassifRpart$new(),
  mlr3::LearnerClassifFeatureless$new()))
#&gt; [[1]]
#&gt; 
#&gt; ── &lt;LearnerClassifRpart&gt; (classif.rpart): Classification Tree ──────────────────
#&gt; • Model: -
#&gt; • Parameters: xval=0
#&gt; • Packages: mlr3 and rpart
#&gt; • Predict Types: [response] and prob
#&gt; • Feature Types: logical, integer, numeric, factor, and ordered
#&gt; • Encapsulation: none (fallback: -)
#&gt; • Properties: importance, missings, multiclass, selected_features, twoclass,
#&gt; and weights
#&gt; • Other settings: use_weights = 'use'
#&gt; 
#&gt; [[2]]
#&gt; 
#&gt; ── &lt;LearnerClassifFeatureless&gt; (classif.featureless): Featureless Classification
#&gt; • Model: -
#&gt; • Parameters: method=mode
#&gt; • Packages: mlr3
#&gt; • Predict Types: [response] and prob
#&gt; • Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt; POSIXct, and Date
#&gt; • Encapsulation: none (fallback: -)
#&gt; • Properties: featureless, importance, missings, multiclass, selected_features,
#&gt; twoclass, and weights
#&gt; • Other settings: use_weights = 'use'
</code></pre>
<p>The code below defines the grid of tasks, learners, and resamplings.</p>
<pre><code class="language-r">(class.bench.grid &lt;- mlr3::benchmark_grid(
  class.task.list,
  class.learner.list,
  class_same_other))
#&gt;          task             learner    resampling
#&gt;        &lt;char&gt;              &lt;char&gt;        &lt;char&gt;
#&gt; 1:       easy       classif.rpart same_other_cv
#&gt; 2:       easy classif.featureless same_other_cv
#&gt; 3: impossible       classif.rpart same_other_cv
#&gt; 4: impossible classif.featureless same_other_cv
</code></pre>
<p>The code below runs the benchmark experiment grid. Note that each
iteration can be parallelized by declaring a future plan.</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(class.bench.result &lt;- mlr3::benchmark(
  class.bench.grid, store_models = TRUE))
#&gt; 
#&gt; ── &lt;BenchmarkResult&gt; of 72 rows with 4 resampling run ──────────────────────────
#&gt;  nr    task_id          learner_id resampling_id iters warnings errors
#&gt;   1       easy       classif.rpart same_other_cv    18        0      0
#&gt;   2       easy classif.featureless same_other_cv    18        0      0
#&gt;   3 impossible       classif.rpart same_other_cv    18        0      0
#&gt;   4 impossible classif.featureless same_other_cv    18        0      0
</code></pre>
<p>Below we compute scores (test error) for each resampling iteration,
and show the first row of the result.</p>
<pre><code class="language-r">class.bench.score &lt;- mlr3resampling::score(class.bench.result)
class.bench.score[1]
#&gt;    train.subsets test.fold test.subset person iteration                  test
#&gt;           &lt;char&gt;     &lt;int&gt;       &lt;int&gt;  &lt;int&gt;     &lt;int&gt;                &lt;list&gt;
#&gt; 1:           all         1           1      1         1  1, 2, 8,11,12,18,...
#&gt;                    train                                uhash    nr
#&gt;                   &lt;list&gt;                               &lt;char&gt; &lt;int&gt;
#&gt; 1:  3, 4, 5, 6, 9,10,... 618ff518-03cd-4c15-9141-a900ec906b1e     1
#&gt;                  task task_id                             learner    learner_id
#&gt;                &lt;list&gt;  &lt;char&gt;                              &lt;list&gt;        &lt;char&gt;
#&gt; 1: &lt;TaskClassif:easy&gt;    easy &lt;LearnerClassifRpart:classif.rpart&gt; classif.rpart
#&gt;                 resampling resampling_id     prediction_test classif.ce
#&gt;                     &lt;list&gt;        &lt;char&gt;              &lt;list&gt;      &lt;num&gt;
#&gt; 1: &lt;ResamplingSameOtherCV&gt; same_other_cv &lt;PredictionClassif&gt; 0.08823529
#&gt;    algorithm
#&gt;       &lt;char&gt;
#&gt; 1:     rpart
</code></pre>
<p>Finally we plot the test error values below.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      classif.ce, train.subsets, color=algorithm),
      shape=1,
      data=class.bench.score)+
    facet_grid(
      person ~ task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-20" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>for the easy task, training on same is just as good as all or other
subsets.</li>
<li>for the impossible task, we must train on same subset for minimal
test error; training on all is almost as good, because the pattern
in person 1 is orthogonal to person 2; training on other is just as
bad as featureless, because patterns are different.</li>
<li>in a real data task, training on other will most likely not be quite as bad as in the impossible task above, but also not as good as in the easy task.</li>
</ul>
<h3 id="sec:interactive-visualization-of-data-test-error-and-splits_2">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">inst &lt;- class.bench.score$resampling[[1]]$instance
rect.expand &lt;- 0.3
grid.value.dt &lt;- scatter.dt[
, lapply(.SD, function(x)do.call(seq, c(as.list(range(x)), l=21)))
, .SDcols=c(&quot;x1&quot;,&quot;x2&quot;)]
grid.class.dt &lt;- data.table(
  label=full.dt$label[1],
  do.call(
    CJ, grid.value.dt
  )
)
class.pred.dt.list &lt;- list()
class.point.dt.list &lt;- list()
for(score.i in 1:nrow(class.bench.score)){
  class.bench.row &lt;- class.bench.score[score.i]
  task.dt &lt;- data.table(
    class.bench.row$task[[1]]$data(),
    class.bench.row$resampling[[1]]$instance$id.dt)
  names(task.dt)[2:3] &lt;- c(&quot;x1&quot;,&quot;x2&quot;)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=class.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ][]
  class.point.dt.list[[score.i]] &lt;- data.table(
    class.bench.row[, .(task_id, iteration)],
    i.points)
  if(class.bench.row$algorithm!=&quot;featureless&quot;){
    i.learner &lt;- class.bench.row$learner[[1]]
    i.learner$predict_type &lt;- &quot;prob&quot;
    i.task &lt;- class.bench.row$task[[1]]
    setnames(grid.class.dt, names(i.task$data()))
    grid.class.task &lt;- mlr3::TaskClassif$new(
      &quot;grid&quot;, grid.class.dt, target=&quot;label&quot;)
    pred.grid &lt;- as.data.table(
      i.learner$predict(grid.class.task)
    )[, data.table(grid.class.dt, prob.spam)]
    names(pred.grid)[2:3] &lt;- c(&quot;x1&quot;,&quot;x2&quot;)
    pred.wide &lt;- dcast(pred.grid, x1 ~ x2, value.var=&quot;prob.spam&quot;)
    prob.mat &lt;- as.matrix(pred.wide[,-1])
    contour.list &lt;- contourLines(
      grid.value.dt$x1, grid.value.dt$x2, prob.mat, levels=0.5)
    class.pred.dt.list[[score.i]] &lt;- data.table(
      class.bench.row[, .(
        task_id, iteration, algorithm
      )],
      data.table(contour.i=seq_along(contour.list))[, {
        do.call(data.table, contour.list[[contour.i]])[, .(level, x1=x, x2=y)]
      }, by=contour.i]
    )
  }
}
(class.pred.dt &lt;- rbindlist(class.pred.dt.list))
#&gt;         task_id iteration algorithm contour.i level       x1        x2
#&gt;          &lt;char&gt;     &lt;int&gt;    &lt;char&gt;     &lt;int&gt; &lt;num&gt;    &lt;num&gt;     &lt;num&gt;
#&gt;   1:       easy         1     rpart         1   0.5 1.856156 -3.008049
#&gt;   2:       easy         1     rpart         1   0.5 1.856156 -2.606579
#&gt;   3:       easy         1     rpart         1   0.5 1.856156 -2.205109
#&gt;   4:       easy         1     rpart         1   0.5 1.856156 -1.803639
#&gt;   5:       easy         1     rpart         1   0.5 1.856156 -1.402169
#&gt;  ---                                                                  
#&gt; 766: impossible        18     rpart         1   0.5 3.743510  1.225096
#&gt; 767: impossible        18     rpart         1   0.5 4.158037  1.225096
#&gt; 768: impossible        18     rpart         1   0.5 4.572564  1.225096
#&gt; 769: impossible        18     rpart         1   0.5 4.987091  1.225096
#&gt; 770: impossible        18     rpart         1   0.5 5.401618  1.225096
(class.point.dt &lt;- rbindlist(class.point.dt.list))
#&gt;           task_id iteration set.name row_id    label         x1         x2
#&gt;            &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;   &lt;fctr&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;     1:       easy         1     test      1     spam  2.3735462  1.0744410
#&gt;     2:       easy         1     test      2 not spam  0.1836433  1.8956548
#&gt;     3:       easy         1    train      3     spam  2.1643714 -0.6029973
#&gt;     4:       easy         1    train      4 not spam  1.5952808 -0.3908678
#&gt;     5:       easy         1    train      5     spam  3.3295078 -0.4162220
#&gt;    ---                                                                    
#&gt; 14396: impossible        18    train    196 not spam -0.9243128 -1.0293917
#&gt; 14397: impossible        18    train    197     spam  1.5929138  2.9890743
#&gt; 14398: impossible        18    train    198 not spam  0.0450106 -1.2249912
#&gt; 14399: impossible        18    train    199     spam -0.7151284  0.4038886
#&gt; 14400: impossible        18    train    200 not spam  0.8652231  1.1691226
#&gt;         fold person subset display_row
#&gt;        &lt;int&gt;  &lt;int&gt;  &lt;int&gt;       &lt;int&gt;
#&gt;     1:     1      1      1           1
#&gt;     2:     1      1      1           2
#&gt;     3:     2      1      1          35
#&gt;     4:     2      1      1          36
#&gt;     5:     2      1      1          37
#&gt;    ---                                
#&gt; 14396:     2      2      2         166
#&gt; 14397:     2      2      2         167
#&gt; 14398:     1      2      2         133
#&gt; 14399:     1      2      2         134
#&gt; 14400:     2      2      2         168

set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
make_person_subset &lt;- function(DT){
  DT[, &quot;person/subset&quot; := person]
}
make_person_subset(class.point.dt)
make_person_subset(class.bench.score)
#&gt; Warning in `[.data.table`(DT, , `:=`(&quot;person/subset&quot;, person)): A shallow copy
#&gt; of this data.table was taken so that := can add or remove 1 columns by
#&gt; reference. At an earlier point, this data.table was copied by R (or was created
#&gt; manually using structure() or similar). Avoid names&lt;- and attr&lt;- which in R
#&gt; currently (and oddly) may copy the whole data.table. Use set* syntax instead to
#&gt; avoid copying: ?set, ?setnames and ?setattr. It's also not unusual for
#&gt; data.table-agnostic packages to produce tables affected by this issue. If this
#&gt; message doesn't help, please report your use case to the data.table issue
#&gt; tracker so the root cause can be fixed or this message improved.
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;SOAK algorithm: train/predict on subsets, classification&quot;,
    video=&quot;https://vimeo.com/manage/videos/1053464329&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=350, width=350)+
      scale_fill_manual(values=set.colors)+
      scale_color_manual(values=c(spam=&quot;black&quot;,&quot;not spam&quot;=&quot;white&quot;))+
      geom_point(aes(
        x1, x2, color=label, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        help=&quot;One dot for each train/test/unused data point.&quot;,
        stroke=2,
        shape=21,
        data=class.point.dt)+
      geom_path(aes(
        x1, x2, 
        group=paste(algorithm, iteration, contour.i)),
        showSelected=c(&quot;iteration&quot;,&quot;algorithm&quot;),
        help=&quot;Red path represents decision boundary of rpart decision tree learning algorithm.&quot;,
        color=algo.colors[[&quot;rpart&quot;]],
        data=class.pred.dt)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;)+
      scale_y_continuous(
        breaks=seq(-100, 100, by=2)),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=350, width=350)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      scale_y_continuous(
        &quot;Classification error on test set&quot;,
        breaks=seq(0, 1, by=0.25))+
      scale_fill_manual(values=algo.colors)+
      scale_x_discrete(
        &quot;People/subsets in train set&quot;)+
      geom_hline(aes(
        yintercept=yint),
        help=&quot;Horizontal lines highlight baseline error rate of 50%.&quot;,
        data=data.table(yint=0.5),
        color=&quot;grey50&quot;)+
      geom_point(aes(
        train.subsets, classif.ce, fill=algorithm),
        help=&quot;One dot per test set and learning algorithm.&quot;,
        shape=1,
        size=5,
        stroke=2,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=class.bench.score)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both),
    diagram=ggplot()+
      ggtitle(&quot;Select train/test split&quot;)+
      theme_animint(height=350, width=300)+
      facet_grid(
        . ~ train.subsets,
        scales=&quot;free&quot;,
        space=&quot;free&quot;)+
      scale_size_manual(values=c(subset=3, fold=1))+
      scale_color_manual(values=c(subset=&quot;orange&quot;, fold=&quot;grey50&quot;))+
      geom_rect(aes(
        xmin=-Inf, xmax=Inf,
        color=rows,
        size=rows,
        ymin=display_row, ymax=display_end),
        help=&quot;One rect per chunk of data with common fold (grey) and subset (gold).&quot;,
        fill=NA,
        data=inst$viz.rect.dt)+
      scale_fill_manual(values=set.colors)+
      geom_text(aes(
        x=ifelse(rows==&quot;subset&quot;, Inf, -Inf),
        y=(display_row+display_end)/2,
        hjust=ifelse(rows==&quot;subset&quot;, 1, 0),
        label=paste0(rows, &quot;=&quot;, ifelse(rows==&quot;subset&quot;, subset, fold))),
        help=&quot;Text labels indicate chunks of data with common fold (grey) and subset (gold).&quot;,
        showSelected=&quot;rows&quot;,
        data=data.table(train.name=&quot;same&quot;, inst$viz.rect.dt))+
      geom_rect(aes(
        xmin=iteration-rect.expand, ymin=display_row,
        xmax=iteration+rect.expand, ymax=display_end,
        fill=set.name),
        help=&quot;One rect per chunk of data assigned to train/test set in cross-validation.&quot;,
        alpha=0.5,
        alpha_off=0.5,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=inst$viz.set.dt)+
      scale_x_continuous(
        &quot;Split number / cross-validation iteration&quot;,
        breaks=c(1,6, 7,12, 13,18))+
      scale_y_continuous(
        &quot;Row number&quot;),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Older_resamplers.Rmd&quot;)
}
if(FALSE){
  animint2pages(viz, &quot;2023-12-13-train-predict-subsets-classification&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-13-train-predict-subsets-classification/">https://tdhock.github.io/2023-12-13-train-predict-subsets-classification/</a></p>
<h2 id="sec:conclusion_1">Conclusion</h2>
<p>In this section we have shown how to use mlr3resampling for comparing
test error of models trained on same/all/other subsets.</p>
<h1 id="chp:variable-size-train-resampler">Variable size train resampler</h1>
<p>The goal of this section is to explain how to
<code>ResamplingVariableSizeTrainCV</code>, which can be used to determine how
many train data are necessary to provide accurate predictions on a
given test set.</p>
<h2 id="sec:simulated-regression-problems_2">Simulated regression problems</h2>
<p>The code below creates data for simulated regression problems. First
we define a vector of input values,</p>
<pre><code class="language-r">N &lt;- 300
abs.x &lt;- 10
set.seed(1)
x.vec &lt;- runif(N, -abs.x, abs.x)
str(x.vec)
#&gt;  num [1:300] -4.69 -2.56 1.46 8.16 -5.97 ...
</code></pre>
<p>Below we define a list of two true regression functions (tasks in mlr3
terminology) for our simulated data,</p>
<pre><code class="language-r">reg.pattern.list &lt;- list(
  sin=sin,
  constant=function(x)0)
</code></pre>
<p>The constant function represents a regression problem which can be
solved by always predicting the mean value of outputs (featureless is
the best possible learning algorithm). The sin function will be used
to generate data with a non-linear pattern that will need to be
learned. Below we use a for loop over these two functions/tasks, to
simulate the data which will be used as input to the learning
algorithms:</p>
<pre><code class="language-r">library(data.table)
reg.task.list &lt;- list()
reg.data.list &lt;- list()
for(task_id in names(reg.pattern.list)){
  f &lt;- reg.pattern.list[[task_id]]
  task.dt &lt;- data.table(
    x=x.vec,
    y = f(x.vec)+rnorm(N,sd=0.5))
  reg.data.list[[task_id]] &lt;- data.table(task_id, task.dt)
  reg.task.list[[task_id]] &lt;- mlr3::TaskRegr$new(
    task_id, task.dt, target=&quot;y&quot;
  )
}
(reg.data &lt;- rbindlist(reg.data.list))
#&gt;       task_id         x          y
#&gt;        &lt;char&gt;     &lt;num&gt;      &lt;num&gt;
#&gt;   1:      sin -4.689827  1.2248390
#&gt;   2:      sin -2.557522 -0.5607042
#&gt;   3:      sin  1.457067  0.8345056
#&gt;   4:      sin  8.164156  0.4875994
#&gt;   5:      sin -5.966361 -0.4321800
#&gt;  ---                              
#&gt; 596: constant  3.628850 -0.6728968
#&gt; 597: constant -8.016618  0.5168327
#&gt; 598: constant -7.621949 -0.4058882
#&gt; 599: constant -8.991207  0.9008627
#&gt; 600: constant  8.585078  0.8857710
</code></pre>
<p>In the table above, the input is x, and the output is y. Below we
visualize these data, with one task in each facet/panel:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x, y),
      data=reg.data)+
    facet_grid(task_id ~ ., labeller=label_both)
}
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAtAAAAGwCAMAAAC3laJpAAAAGFBMVEUAAAAaGhpNTU1/f3/MzMzl5eX6+vr///9+X1YfAAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nO2djZakqg6FnblTXe//xve0VSo/SUggQNDstc6cLkXYhq8woqXb2+W6kbbZBlwuTTnQrlvJgXbdSg6061ZyoF23kgPtupVkQP/9T52MuFwaEgH9968T7bItCdA7yyHQ/3O5bKgO6ODfD9BQqZegRkI/OtUouTFmx5ab3nb+968oB1oqW3ZsuVkW6I8c6AZ5cAjNAfqvA90gDw6hKUAfPG+/+t/L5equjkAnk3Y+QkuV2vlvVKip5hnBOdQP6HQO2oGWKrGzH+cqqnlEcE71m+VIr6k40FI50IQmTduFLUlsCfWIPnOgQ00YoZNL3w60VJ5DExoN9F8HulkeHEKTLqyELUlsCfWsPhPKlhsHmqNn9ZlQttw40Bw9q8+EsuXGgeboWX0mlC03DjRHz+ozoWy5caA5elafCWXLjQPN0bP6TChbbhxojp7VZ0LZcuNAc/SsPhPKlhsHmqNn9ZlQttw40Bw9q8+EsuXGgeboWX0mlC03NwL6B9ALWjhNttwYs2PLDWrHR+hAiwxCQtlyM2OE/uNAt8mWHVtuBgL9J5QD3SBbdmy5GQf0Hwd6kT4Typab/+xU/vImFgNoTzkcaEJqwan9bWQsA7McEltCWesznWpuGhwHuixrfaZTzU2DMwzob+r8548D3ShbdjA3QqzWy6H/HP95Dt0oW3YQN9KBcpHgJCeF0BDtQEtly854oMmKB07bhVQ70A2yZSd0E6DWD2i65oEXVoK8Qwdof/pok/SDE6HWLYc2AzR0VaUFaBuP0xX0W4UbsPY1gBZqOaARnBsep2sCaEkfyt3AtT8caCs5dAqyA13WYkC3zJgtko/1vLBiFWi0V1/McmTttB2J/ASDEC+HPq+u3AfoHEt8zH4xy1G1l+wI9EygmQcR7rSd5izHCbStlwbtbhTLuTTVGvUhQH++OlCRGYOQ6gjdbgfXI0dobtQFF1asAC3ASdZnijm0hh1Uh53Gex+eDDR4d9IkoCUDpLk++1hvJPFrp/XuNAPBCXeAtrPpAf3vOwlt5aRwZaA/3ltJvA3Q0R6QdraNSzRn2i6/puJAV8ko0K1uqn3MAhrRYKDP3aH2K1l3a6C1cuhGOy92NpBpDtDxj2T/zAKaO/sbFbIGNJlDs6mI7NTD+PPdeh7Qc3JofaCTlni2bgF04eDCxCK0A2zFrebnGvhmAZ3Y0RAz5QDuTXKgxSL3QQtodj0H0PNy6NSOhnhAa95tl7XEtMWKmnIO/a3u5kC3qdM8dK0x3izHQ38ke/T3K1jQVpnghBYXnUNLgNb4XWraVbVVxn1V/VVj5dDHH2sB/V9ElIFuAbI9WT1VCI4gh9ZQfhlV49XjomrCosxL35+/lgJaAR8R0IX2tGh+Dzx8sRzPBzoqWwAavbt/GaCBuIhCFbpRArqV7I5AR9bSPYJ9awANHLxkA/QiQDf1/HkGDyaZoppZOXSp0jMDah6r+wEdW0uMIr4VcujGdGwZoBt7ficIB1pQM48gqKF4wROArtm3RqAlObRxoEvHqaFAA+YyO/ByoUYBnYSTBXRDxqFzirE00ECSl81DA1VUAy2LOQZ01Yw6ZAcuyDZZzKF5KzV+/aDHswWg8Ve//CYNlPYwpJ9LG7FqhtxkzWW1AW4EraRVohu/qILyVhtcZm7adlpDhZcG2Z7lAEfo8Nte/hUEq53C/ZrHcsBOXFAw80u0lV1Y4SQGgJ3reNF+6Rtvha0xl75tAw0dbiOiGXdwcZqpBDpTNdDbccfFvrgO6GyFFtBK6YIDDakr0Njo0wvouIFtO2Yh63JoB7qk5wFNVBS0Dq/72OF2fTZA40BzhQEtvSiXLkpuH62GW/ZtR9eJ7oeO7+cwCPQ3tOcO6+bQfAPIAv5bF6KvZQB0nkPzlTYd/gSr6nv20eudWa2yxwcaaeOz8JZAn4Kn7cR16gLN8RMfaK4cetcxp8l2BUsN6HfsVB9oKqbp0mVTDuxLmgBdH2CkSmFpCGhyJiTcDln5Qm2J9nUZoIGY3Q9o8rBzij8kopUIK4CIvuxkWTbmDxihL8VAB+tkXtMcmrNtfKgI3YQlqlQAOowENZgxb/A38IuVy/f3f+XIUcNcYSvkk3DjRPlvRDCDGc9hmQjocF0T0NyN03L9n5wUxIIyuTFz6CNvnvAWLMB8GP1Ss3U8A8wJ+qwEdLJPJNBYpVEOLQM6XK8NdPXYHNvBmiSBvpYKbvAfDvQV6cj5MXvFBVpqKN9IMghRDWK3A5VyJwhocB2D5yCjj7cqxipkKijK+zlPWVdw8nogoJFvvH2gocGKR2qxFLI2W9z1qMrBIImAePugLAA0r6IYqnxI5AMNlyPPUXOM0y/yRKDZr6SAgD7PCjjB43ZRaYsXukbSbH644dnMCtcPhCTQgm2bgEYKCidd6oH+gqz2BP+/yUtWSjk0uH/xzqBtSa8UIrF85WuIVpFKtlO88rLa+Vuffwsn6UtAsyvrALQwh1Z9ctIOc0h0cZaD3j1y94VAg7y9IaCpVucCzavrt5R0kh4GSJ6PlYDmJmFwqeHz0B+WJUDTagD6OhsK66KAPtcqAM2q652UfTd9v+NSCledfiU/wYAbFbyUCxkZSDv9gA7+/bQksZWrBei0AmT8PHPoaz3RKrpqi3JoCG2GxV+9iA2+RSkL725At9SWfGepmrBDXWonUn5SqJRDf4G+iG69l4PadyHQQF372vy8pzhAF46qskQjKVs+PFAHifOPlhtdgg1f4ULueQZuDaoIKouVmAr0bmvGW7C24IVKH2SJktfa8wO1zTl+0O9sKpdI6mNuuq+6SiAb5hUw3VAOJDbJbQtbiio+1Dvl0BuhE0XfXGSEjr/f5dEgO5EnhxB8iPxJizGUD0fE8BQVyY3Gn1I3leMpOkJzq9zyuazChtTqWTm0GtDJzhF9dhWW9N62ATcgFys4CsTFan6UkQEt4Zk8kqsDHe8tw2dYl6R5SqufFKZRI4EOMBOFD3raFZdnxgGDFDxAn3+SzZeAxtfhZoJz288WeVfJgnyUW/UnWGrTducXmwV0XFg4HBQfPZGMMWE7ANCy1tPSCK2IQ2Jsj38/k1eVr9wOha1ghy/JAM0GulzlHKBFF1ZgfQNx/hssvwolV58wFEsqAX129JaUAIEu9jS4Ovq6YEbIGsKY7W5oI8D+lIAOSuEmQEtv+YwUovE3+AsufVM6IoGA+lF6ORXiuXBKmLsRAA3m0PH2efuQpw2qktG9YDXfzQojdFCSADq8t/YKMt/WVbgd6PT7FanjL1bYNyclVrNFAECJwl/q5xAmW+JoldxsoRC/l52UI8aXLK6acFxQDDSdQwdFo/1KvlBpSiO0pQj0Z+USP8EC92NLIgtVExAEZ6IIKUm9nB+ERUMaIiCHFgJdbKJgcguOZ6VZjmB/sCZhoMWudrF+JEs1wAd6+k+wipHCVodDYlwm6Krwr6xaHtBBcdToBr4hI9zi+CuvI+G5Kt7XhhuQtMLVlhpL1td+1d6ZHZGLqJjkJ1h2gcYUjdBp7ONzGyx1zd2gImnDVkU8ownLtaY2FLmB7B0QpDu00kG/KWTUsPFy6Hm/WEmsVig4xqdROT9RHMFuMJUG6DIcwTcLLE0PQgx34QJG0pptA7hCf/4pFO9X30WtAfQlWeDiWQ5sDIrTQIkb1Bw42EuARoofgxD3GEx8rAEacsV7lDfdyGmH00e0FgOatWsnF/EPm/PTwrDGLTqd57mhHEBE855MRgH9tcMNA1nICNDHpj94NcQxKxMrh/7zT/EnWFlLElucwJ27fxEEbBaNh9FG2FFVIMQm8+ru6QRZPw5oYJCfAXQxIqkdQPEsB3ROeBOgr/H8AhrsM4mQeiS3KxD7ORDo1Af6bQ8bk7HNATptgdAS89CB2B0ZAV3OacOBmg00PJ5fa9J18t9Zg8src+hU3JsnCk1lQEtH662YQwfVFitfYh5aqHPMJfssP5oe/+cCjYzD4VqiwaLQupkjdEk/nDq6Ah2VK36/gkMoUdsS89AyBTtceb8m4AYKowzo6zMbpL5AsyrhAh3P8PDMxQVZT4MnovJdYWCWQ/IuI4b2HWMXZZV7fZ9immxyQMer/SwabINuvMV1//5xlX3pvGuKV0mxTN5VsVu8osRAGCDCDeb6u6LwFqwRQEMLG0bo8Cus9kqKY2SIN6EGaLy1aKgGzlWvmqOD+PWRm0PnzRenLCoEdlVeN7yv4Qh9fCR94SvtjNDQQj2gq4KTudlChRXIjCXNwozlnZoDLVbmnZlDl1UPdJJDs4AGmwr/uHsOTUVHAHREtHj7y05sMK0gqD9a0QnoimoAQW6ythjBOnNoWVjT0ved5fhV4Vkq3MDFj44MN68Amhjic+iCcteKHkAXhk9CKNDC+mSPAkOb4s1DAzjbBTrYRdWHA2UVxXUz2mFdOyi7rfpJfF43/dgbyeEra7Mm6pUHjDqgQd0LaKrYCyklHa5LQDPHpuOAUSxIe+oDdH4gY6o2A0qaEj199MZAk+VejFIqQPP0Sqqp9NQT6AoNe4wBxrNZoKMcmjtW0Kge1SgAXTN4JUqAxlvmA62XQysCXVWRIOVYZYQO1Px20mPNdzXVW4zwKw5CLKDDmcKubqA2pcq2q/tqONBfnUMwsOIEunF41UQoyjgKruASnY/xQjUkPSw7jwN6FxTDCOixdhCJx8SlgOYceSrs5EArnhSKn8tRKw2gwxx6sB1ESr83GOqG/aWLcyk9Oz1PCuUPmqmVCtByN1hPTBsTR+bQmIHSlP01QDeNHXMeBRa1JLEllLjP4GAK3aB9YusgPw1o8oDhQFOaQ5ADnYkPdGtyx/2R7DNSjktRWB3oQOm+yXNodkrf56Tw/Ims2knhAkDHMV8+hwZV5yajsSqjZwFdlX040KDagMbkQJ91cOx0BfpfO9Bn8nwCvTue8RasonZns01MUHmvj0n5MWb02omBBp/M0Q7056sDlZ09Qjfl0KjMj9CcMTG9zFR2wxtnh+XQ/75z0I86KYxD6UATxYpumJUOfGkQdHf/vYFO+sCBJootCPQJ9oJA181qPhVowc22fDfmgP4TajGgwWAy80R1NwsAXaGOOXSNRL9YuQfQzDMffTd0n/GPJUvfF4BqHNDqKUfSksSWUNVAd3FTetQe19Xad25hWvVNsnlLEltCgTm0A/3RAkB3ubCyNtCQxGFyoH81HuiaS4XMk8J/Cz05KZCtszDPoSkNA/q4qLLMYwwCrQQ0X48JTiegj38c6FbZsmPLzbgc+rw5acVZDp1qHGhCiwQnzKH/Kd8+mrQksSXUs/pMKFtuplwpdKDbpG2n7rr+oZsHJxFwpTCZ5HCgxVK2U3UD/KV7BycVdKXQgW6UA03IrxQydO8+c6ABiW5O6gM09M6ihrdgdZAtN5edrf1VWO2yGpxEKz9O99KzBiGhbLmZkHL4LEerbNmx5caB5uhZfSaULTcONEfP6jOhbLkZD7RfWGmWLTu23Pg7Vjh6Vp8JZcuNz0Nz9Kw+E8qWm5UfY5C0JLEl1LP6TChbblZ+jEHSksSWUM/qM6FsuVn5MQZJSxJbQj2rz4Sy5cYfY8DRs/pMKFtuFj4pTN5J4UBL5cEhNB7ov39joh1oqTw4hIYDvbPsQLfIg0NoPNDBv5+WJLaEelafCWXLjQPN0bP6TChbbpYF+iMHukEeHEJzgP7m0PtviEy+NMh1N3UA+prc8Gm7JnlwCA0coQ+gb/9qZFS27NhysyDQX8U4O9ByeXAIzZmHjlqS2BLqWX0mlC036wKdtSSxJdSz+kwoW27WBdovfbfKg0NoNNB/HehmeXAI+U+wGFqkz4Sy5caB5uhZfSaULTcONEfP6jOhbLlxoDl6Vp8JZcuNA83Rs/pMKFtuHGiOntVnQtly40Bz9Kw+E8qWGweao2f1mVC23DjQHD2rz4Sy5caB5uhZfSaULTcONEfP6jOhbLm5EdCSV7/MkS03xuzYcsN4aZCP0KsMQkLZcnOjEdrlsiEC6KaXULtccwUB3faWU5dromBynWnXosKxdaZdCwpldts893CtJxDYgGQn2rWUkJPC4NNINy5XowCgidLJKylcLmtqeiWFy2VNba+kcLlsqA7o4N8P0FApv12BkAeHkL+SgqFF+kwoW26WBfojB7pBHhxC/koK1yPUFWh/JUWTPDiEJozQ/kqKRt07OI13SvgrKRhyoAkpB6f13h9/JQVDDjShxwOdtSSxJZTNPmvVrYODA80D3V9JwZADTWhUDs0cuv2VFAw50IRGBcco0EBLEltCKfbZHs3GM3BbCNly40BzpNdn2ykTdjRky03ZjtEcOm9JYksoB5qQLTcLX1hJW5LYEsqBJmTDzRlRB5ohz6EJmXBzjRGMHLrFjgMdaJGjqlAm3LCB5h4dHWiGHGhCDW6iLM6BZmh+n0WyZWe6m/isxIFmqE+fVWfS0xGKNN1NzKjn0Ax16bP6uY7pCEWa7kYGNFMOdEn/Bd2BJtSWQ18fADs1cTYAtOTFAuO141tYMlh2gvOrfm6qAu2vpCgIGI9/F1QN0vPHxFC23AB2qg6FBkZoiS2h+gCNLh1g51dVwckvcxoC+teZA81Qlxz6u3AtoIFL93aA/uQW4HI1Ow50oFsBfdq2D3SNHGiGADcRz1y4JyB0WFsO6NqZJAeaoYIb9nA9wk5s5bJmGWggh66eG3WgGZIATfXDADsJCCkXNnPoXQ40Q6199g2qAGiyI+YDPdgNItCTA81QY58dUX1dn7Fy6SY97BwSAE0dMKYBDcfoJ1zvOTQsXaA5o8ZsoDlnq9+lVoGuHpxJOw70uwro2Tl0JNjwsfSn9Qc4QjeALTCld6Bx6ebQbZFWsPOVFtDN+yNzEzmInOxaGehVnz7a2v8ONOxkV5JDa9vpCbSJx+mS6WUfN+Oz1mR3vh+PHNoq0E0aD3T6Urc5QNODF+AGLS7YeZU+K7WIr0/cTsuhL4E59Goj9JpAQ2u2TUi00r1SZIvE+gxoFakfvtbLodcB+jopdKAxDQA6+FwM91OBpnLoc9URWtNA5x+pnEPZzXsE0MGCcrynAr3bs/YWrA+k15/X4uB/SdFoaX9/ycdswTAvugrCni4PO6Ru924/Ql/KsoxzFAhG6HAtVANrnO4xJtZnnLZGaOJol3SI4RH605LEllCcPktiFAX2yqHhwuTSOjsM3RFoMn0TZBwONAw04gYJ+mdpOdq9HhNSV806QEfFKu0YArq6x6qAhpp7YWXDbRg9ooMQOx5D3OgCnS/VsgMB/WcK0PXH1KocGndDDyKcIUbrwgovHqWCP+/2i/lvzRz6nfqp6XoG0H9C3RDosCV4xev0gVtZEuiW2B7SmrYDsrY+QP95CtBUfvzmAq1nB1PaDn3MoN0YAnrb8gB3Alo95UhaKtnqnEOH7eQtXUEuEftZS5pVy6GDVugsiKrHPtC9c2itk8KkJdxWc7TLzxyOP1FAs+4KoglROg3jAp1vlrlp51kVaAU/loFuHz9ogoDxIGuQHJfzFYaBzvbEyiwHc7xginlSuP/v7kCDLdI8o6XBjbQQCrIgPgjZEd0I0IepYfdD/4L8+W90Dm0C6NMNZ/t3wDNQkVqfncdnQXwKQFeHegTQiTnKK/OkEBqil8+hEyCyHk/clLZ/xwP0OKDBzAexiwFdP3gMABrqKKmdeIS+qB4KdLMkQOM8o27IjGMY0OwDTWL4J/w8D+jDxDCgz9F5/AjdLMksRwXQUIXfCsCK9NLEkOTANfl1yt3EW84C+rSDShto6KrKeKBrAo4GCajsAJqfcvDq5diRKfgR+jlBfi6Il1CKgB6SQ5NtjMuhYZxHA101hGBBAisLgY5X2/zVd24WsY+6ycf2ejcMBd83cCVjUb0d6ErhzYF+o0OccaBPyWL0A30Vqt0wlKdI2TpsEd+dgQsr+LuMtuAlSPvuSV+JhCmsLKr2+yFpLHmzkqKRKr1OG6mRamcN0eW/BevbCNhWvDAtJ7DHeAvWn+8s9OQLKzVDCCOH5owX2R31laPZ3Ac5bcml5fhXqeNy6HLEPx/ihIhrjzttN2OWoyHKXzEIghuJlxkFGhHi7sD2XPmTrOjjBnMCLEwLFEYdYEPCzsOBBtxItkAKDAEa43Mc0KW64NZ+qAIkz6wTeODCyu2uFL65jSRB4vAMFvlR2KXcDtQ4YKAItFbKcdSF1lgEmuY3/qMOaPDupLkXVlgdMOn+Gxzo9oNO0Q7K51bKoZUurFwJA0F0vrDYV1uYV+d/YHa+Si+szLjbjhKvAwRAU9VhD2sk6opzwNPOAKDZKUQyJA4EumgH0vm1SzhOWuFM2+XXVMwCnSzkA02GH3kUGFkbtEkPoOH6kqXlIVERaGoyg1At0EU7H1m4wZ8SvEPp0llAI1Xq5dBnNSxfcKHet48Kayw9h/CzEyHRIjvYj2T/GAEa3iH7QGvoFWQIakA3uNER/rjqK4d5l3d4WaBBUUCnceAclS83NUfkbBNloNkH9jWARnclWtEO9EG1rZQDEZ5Dp4GQDLmvmgEasNYBaN6BHSz0ZKBV77ab8wT/2UArfCUuOy2zEqdSoCsr7A907KxgkzfLofkj2b/JOykGzUMLgY5WSoGGyioB/VvJS6e6BOjaGvvn0CKxcujjDw2gd5hDokfNQxdyaKr6l2z4Ar3pAL3XctwX0FhX8pae+UCriHnp+/OXGtDvCUCLlAFdv3GwtL3PLqDblbwDojfQpdoVL4JB+h/IsAbQwb+fliS2ria7AH3WqT9C19hBqu4DdN8cupz0602xguoN9EV05xy6ksSqHHrLZtLirXSAVj9jbsuGWG42B1pFwmvNWGEm0NdIh1zHawZ6A4GuwPF3k/KbLlkVO9D7v39PZ1Vvwdq470L6HKP5tSKFWdV8CwVlRa3XGqxoJN6kaaehrZCq1CKRV1Wu3OwInQ6CpKR3AyFlmTn00VaUcfQfoSsyhn2T6H5ovLWSeG7KNbUEJ2h0tZPCj3U+0CqTm/Un8vESlRyai1ChGhjoqCa84nB5u5uPlgW6bdouAJoRODhI4ogPnGqFvcVLlXPoIJJJUAmerzVloNmDT7WmA11/YeVrnUk0GCT5GDIOaNhbtFTjkPNxcyZIWIrEcln8ejErbTp8XS0MB7r10jc2moDqBnQdVWSfXV9UaJWUOYbCsUFWOQk0XRrXsCuF2kBr3Zw0E+hKqn7OrTFXV8VhoWFAc7+oYTEDQHPsgPdDx/dzzL59dGIO3QQ0OQoHPEeY9QO6NYdRugbWADTrgLEA0AyZHKEZeTIBtHoO3ar5NycJgVZPOdKWoIVUlAT9QAEtqEYzh9425NsQL8SB7vttz4wU5UCnLUELiSiRo2OyCpyHTrPVshT7DOU5VTpe69tBCJIefZSeCTQuhz6TjgWATtfBVwrzc6GCtIFurMYg0Aq7NW6W44vy7Cf4n401A12sRuCGUF6/faA39hEkdrMS0CfHJoCm4y0Aui2HZghI1X9kzarayQUQVMGzA521JLFVChwnh2ZtyXJTqjBN1Tv/bE4oDGhhNUq/cCy/sYxvB9KiQCfqfI8to8YYaKCVChLMAa3Bc/EyKrMFdg494Qn+gHSBDupSBPqoKD/3BICuHRMVhOTQojq2/QdhawFt68lJshGO/+JNPaCTmqIcugXoq1zneWiGg2CJdMaozo7qCI2p/0uDGNr3FFgo3pbahv9eHMwR2kpYmrQdFBTZ0ROwY8ciZsDbGmcU2VgvDeoNNLSQPQidmWq27FeSVyMTahmho+XwYoadbQvWThqh4RMAhXOCOjupvhHinxSayKEzbaeSZftf4Q+bg/8lS4uqy6Eho4XtsALxPtoB+ptDFwr1sZPqJkC/t/wydg50Y65XQRA8mDUCXW8HkpAgzN5yQNtOOT7tJ1E8P00DOm+pDDRxwIi3HQh00Kx1oL853S2ARlFgAV3uAQ2gsRyaXV+LHVDcd0CEH4Fi+W8K+9hh6h5AYyrk0MeqUh+oAP0G+mxYBgSpPEkfH1UQs/NvH430EKBRJZ0GSyOH/tjJUiM+0aNz6AxoRA502pLEllDFp13xOk2tz5K26NPAd1LwXDQW6FI1DnTaksSWUMXnEfYahMjWGNfb4zXJYDkuh+asc6DTliS2hOIBXaxG7AaplpuW2gCaUGjPgU5bktgSqvzEWFYS2w1oZgXJZkOBxndE183QX6z8+dyitADQSfiv+6EFZ18KbhBqf9hAx1fEE/cjgYbtxkA3xVZmpyzmlULoZd/1QGs9aAZaFi0d83JtQHCjP/gqqqZ0g/lARzk0VKQi6AsDrfLkJDDSCNCtTM88qmJAt39PW4A+1r1hoGtCPhjof2pA/9V5FJgQ6KbenwT0dl7dzFMOhSNPQw59rNmvNWdW6iI+FGjwRYUGgc6nb1WG6DlAf22fX8loomwY0KCv0F/6vo7aIWToSSGUcYxMOcrsQtpCJGQWSTfVkr257LKdIDIX6LNlGOj8+9fXTireg2b+QRoHNBmfdNX1+Qxsa9+PBzqmAgB6VA6NWDv+ehNAC/0tPA99Ar3vNuOlQXs55rrg8zeu5frHCLGSLw6YiBd0NoiLdhItyMwbUYenj57Js+oIna4LP1cd+opuKoV4yT0GSIAD9PgrhWfr0Nj7ioyGp7K97JAS/ep7FtDU8ZUC2tQTY+E+BhAJgd6gLScDnax8gWvlga9+629iByk+JOX4tCSxBSjdsfBz52+9SCDQ8VCcLFsZ6J52Yk/hkvcdgKZkCWj80iZ4jElyDn07wjmX01kGdDqP198O2Nh3gTDlWALoz57+/msKaKjPAJ6j8bCnHXlwLreBtVe6bowdDaAXGaGDEQ57WKMw8B2n7ZBhm3Q4HegI3Ve0apwdIOPgAR2QvSDQYJSloe8CNGmBdDgvHysAPdpOLHEObeHpoxytATTtwSjQb+BKoBmgP7oh0FEO7UCz3AiE59BT7KTiAxfZs5QAAAS8SURBVG3llRQSGc6hC18qkzk0qOV+saJ/Upi0JLEllM0+u44gU+10D45sDxe+lyNpSWKLpSuQJoFuTjcXAVq4nw40piCQDjQhB3oNoDcHmicH2oFuVJRD539zs06jQGfmPYcu22IoHBhsAh0oHsWYY5pNoFsPPA40piCuDrTITZUc6LQliS2hHGiRmyo50GlL0DuLNF70tKm9mqnja6dikzzLk96Cheh0oxfvFq3+FqxM5zDRfneBgptYtg4YttzcaISW2Crqwtgu0K2+HGhCDjRDPg8dKDXvQKctSWwVFN3YuO03+GvouUDnTjP3DnTaksQWrYjnXznQhBjBAaw60CVpAx0uMAn0Qjm0A12h5wHdqqlAew5dknIOHX22RdBpZ5mUg+PUgU5bktgSyibQrUn0rYPTKgeaIQeakAOdtiSxJZTNPnOgIa0LdPII/+cBvVAOzdDjgf77Nya6BegSGc/qM6FsuVkW6J1lJaCLx+5n9ZlQttysC3Tw76clia1Y9wKanYg40IQcaIaG9Bn/VHEM0IPdLAv0R55DZzIGNNuOA/1Wy6GLcqAJOdCNQF+TG8f/96Ax3oL1DG2m3hu1981sE4rqCLTOm2RZWmmE5stzaEIz5qGTliS2hPppf8rrrxbpM6FsuVkW6JTnvkDr/A5rkT4TypabdYHOWpLYEsqBJmTLzbpAa176LsmBJmTLzapA/x0LtOfQuGy5WRVooCWJLaGe1WdC2XLjQHP0rD4TypYbB5qjZ/WZULbcONAcPavPhLLlxoHm6Fl9JpTYDXyCvUhwHOhAi/SZUFI3yBToIsFxoAMt0mdCOdAOdKNs2XGgHehG2bLjObQD3Shbdmy5caA5elafCWXLjQPN0bP6TChbbm4EtORdRnNky40xO7bc3O8tWJGeNQgJZcvNjUZoSBu4dJZsuTFmx5abJjs6QIPSr7FFttwYs2PLjY4dB3qobNmx5caB5siWG2N2bLlxoDmy5caYHVturALtck2UA+26lRxo163kQLtuJQfadSupA30+djd7cNgcpQ/HmSkzRnZZioweNtpAfw3ZiZWhbrPjZJehyChiowv09RzpN/Cw0ikyYWKXoaDsMuREEZuOQJuImCWAzARll6nI6GHTJ+XI3pc1Tf/5sWDjV3aCsstQZDSx6Qq0gYAZShTtBGWXochoYnN/oN82jFgKyi5DkTEI9PlltwN0OP6Y6DYLQclkxI0DXZYDzZERN+aAPmXtpPAjE06sBWWXETvmTwrNzFAZoshOUHYZiowmNh2BNnFwDQI1W3aCsstQZDSxufulb0uTU4asvG1Fxuyl7+v7ZSZWhnrNTlB22YrM8f9WS377qOtWcqBdt5ID7bqVHGjXreRAu24lB9p1KznQrlvJgXbdSg6061ZyoF23kgPtupUcaNet5EAP1B5s8J2uLi15dAfql2Xnua88vCPlQHeXh3ekNvgl8i49eXyHyoHuLY/vUDnPveUBHiofoXvL4ztSnkN3l8d3pHyWo7s8vAPl89D95eEdp82vFPaXR9d1KznQrlvJgXbdSg6061ZyoF23kgPtupUcaNet5EC7biUH2nUrOdCuW8mBdt1KDrTrVnKgXbeSA+26lf4PXCLGSnwbJQ8AAAAASUVORK5CYII=" alt="plot of chunk unnamed-chunk-24" /></p>
<p>In the plot above we can see two different simulated data sets
(constant and sin).  Note that the code above used the <code>animint2</code>
package, which provides interactive extensions to the static graphics
of the <code>ggplot2</code> package (see below section Interactive data viz).</p>
<h3 id="sec:visualizing-instance-table">Visualizing instance table</h3>
<p>In the code below, we define a K-fold cross-validation experiment,
with K=3 folds.</p>
<pre><code class="language-r">reg_size_cv &lt;- mlr3resampling::ResamplingVariableSizeTrainCV$new()
reg_size_cv$param_set$values$train_sizes &lt;- 6
reg_size_cv
#&gt; 
#&gt; ── &lt;ResamplingVariableSizeTrainCV&gt; : Cross-Validation with variable size train s
#&gt; • Iterations:
#&gt; • Instantiated: FALSE
#&gt; • Parameters: folds=3, min_train_data=10, random_seeds=3, train_sizes=6
</code></pre>
<p>In the output above we can see the parameters of the resampling
object, all of which should be integer scalars:</p>
<ul>
<li><code>folds</code> is the number of cross-validation folds.</li>
<li><code>min_train_data</code> is the minimum number of train data to consider.</li>
<li><code>random_seeds</code> is the number of random seeds, each of which
determines a different random ordering of the train data. The random
ordering determines which data are included in small train set
sizes.</li>
<li><code>train_sizes</code> is the number of train set sizes, evenly spaced on a
log scale, from <code>min_train_data</code> to the max number of train data
(determined by <code>folds</code>).</li>
</ul>
<p>Below we instantiate the resampling on one of the tasks:</p>
<pre><code class="language-r">reg_size_cv$instantiate(reg.task.list[[&quot;sin&quot;]])
reg_size_cv$instance
#&gt; $iteration.dt
#&gt;     test.fold  seed small_stratum_size train_size_i train_size
#&gt;         &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt;  1:         1     1                 10            1         10
#&gt;  2:         1     1                 18            2         18
#&gt;  3:         1     1                 33            3         33
#&gt;  4:         1     1                 60            4         60
#&gt;  5:         1     1                110            5        110
#&gt;  6:         1     1                200            6        200
#&gt;  7:         1     2                 10            1         10
#&gt;  8:         1     2                 18            2         18
#&gt;  9:         1     2                 33            3         33
#&gt; 10:         1     2                 60            4         60
#&gt; 11:         1     2                110            5        110
#&gt; 12:         1     2                200            6        200
#&gt; 13:         1     3                 10            1         10
#&gt; 14:         1     3                 18            2         18
#&gt; 15:         1     3                 33            3         33
#&gt; 16:         1     3                 60            4         60
#&gt; 17:         1     3                110            5        110
#&gt; 18:         1     3                200            6        200
#&gt; 19:         2     1                 10            1         10
#&gt; 20:         2     1                 18            2         18
#&gt; 21:         2     1                 33            3         33
#&gt; 22:         2     1                 60            4         60
#&gt; 23:         2     1                110            5        110
#&gt; 24:         2     1                200            6        200
#&gt; 25:         2     2                 10            1         10
#&gt; 26:         2     2                 18            2         18
#&gt; 27:         2     2                 33            3         33
#&gt; 28:         2     2                 60            4         60
#&gt; 29:         2     2                110            5        110
#&gt; 30:         2     2                200            6        200
#&gt; 31:         2     3                 10            1         10
#&gt; 32:         2     3                 18            2         18
#&gt; 33:         2     3                 33            3         33
#&gt; 34:         2     3                 60            4         60
#&gt; 35:         2     3                110            5        110
#&gt; 36:         2     3                200            6        200
#&gt; 37:         3     1                 10            1         10
#&gt; 38:         3     1                 18            2         18
#&gt; 39:         3     1                 33            3         33
#&gt; 40:         3     1                 60            4         60
#&gt; 41:         3     1                110            5        110
#&gt; 42:         3     1                200            6        200
#&gt; 43:         3     2                 10            1         10
#&gt; 44:         3     2                 18            2         18
#&gt; 45:         3     2                 33            3         33
#&gt; 46:         3     2                 60            4         60
#&gt; 47:         3     2                110            5        110
#&gt; 48:         3     2                200            6        200
#&gt; 49:         3     3                 10            1         10
#&gt; 50:         3     3                 18            2         18
#&gt; 51:         3     3                 33            3         33
#&gt; 52:         3     3                 60            4         60
#&gt; 53:         3     3                110            5        110
#&gt; 54:         3     3                200            6        200
#&gt;     test.fold  seed small_stratum_size train_size_i train_size
#&gt;         &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt;                           train                  test iteration train_min_size
#&gt;                          &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt;  1: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         1             10
#&gt;  2: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         2             18
#&gt;  3: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         3             33
#&gt;  4: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         4             60
#&gt;  5: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         5            110
#&gt;  6: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         6            200
#&gt;  7: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         7             10
#&gt;  8: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         8             18
#&gt;  9: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         9             33
#&gt; 10: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        10             60
#&gt; 11: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        11            110
#&gt; 12: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        12            200
#&gt; 13:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        13             10
#&gt; 14:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        14             18
#&gt; 15:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        15             33
#&gt; 16:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        16             60
#&gt; 17:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        17            110
#&gt; 18:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        18            200
#&gt; 19: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        19             10
#&gt; 20: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        20             18
#&gt; 21: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        21             33
#&gt; 22: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        22             60
#&gt; 23: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        23            110
#&gt; 24: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        24            200
#&gt; 25: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        25             10
#&gt; 26: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        26             18
#&gt; 27: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        27             33
#&gt; 28: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        28             60
#&gt; 29: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        29            110
#&gt; 30: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        30            200
#&gt; 31:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        31             10
#&gt; 32:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        32             18
#&gt; 33:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        33             33
#&gt; 34:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        34             60
#&gt; 35:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        35            110
#&gt; 36:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        36            200
#&gt; 37: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        37             10
#&gt; 38: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        38             18
#&gt; 39: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        39             33
#&gt; 40: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        40             60
#&gt; 41: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        41            110
#&gt; 42: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        42            200
#&gt; 43: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        43             10
#&gt; 44: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        44             18
#&gt; 45: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        45             33
#&gt; 46: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        46             60
#&gt; 47: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        47            110
#&gt; 48: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        48            200
#&gt; 49:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        49             10
#&gt; 50:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        50             18
#&gt; 51:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        51             33
#&gt; 52:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        52             60
#&gt; 53:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        53            110
#&gt; 54:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        54            200
#&gt;                           train                  test iteration train_min_size
#&gt;                          &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt; 
#&gt; $id.dt
#&gt;      row_id  fold
#&gt;       &lt;int&gt; &lt;int&gt;
#&gt;   1:      1     1
#&gt;   2:      2     3
#&gt;   3:      3     3
#&gt;   4:      4     2
#&gt;   5:      5     3
#&gt;  ---             
#&gt; 296:    296     2
#&gt; 297:    297     1
#&gt; 298:    298     1
#&gt; 299:    299     3
#&gt; 300:    300     2
</code></pre>
<p>Above we see the instance, which need not be examined by the user, but
for informational purposes, it contains the following data:</p>
<ul>
<li><code>iteration.dt</code> has one row for each train/test split,</li>
<li><code>id.dt</code> has one row for each data point.</li>
</ul>
<h3 id="sec:benchmark-computing-test-error_3">Benchmark: computing test error</h3>
<p>In the code below, we define two learners to compare,</p>
<pre><code class="language-r">(reg.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerRegrRpart$new(),
  mlr3::LearnerRegrFeatureless$new()))
#&gt; [[1]]
#&gt; 
#&gt; ── &lt;LearnerRegrRpart&gt; (regr.rpart): Regression Tree ────────────────────────────
#&gt; • Model: -
#&gt; • Parameters: xval=0
#&gt; • Packages: mlr3 and rpart
#&gt; • Predict Types: [response]
#&gt; • Feature Types: logical, integer, numeric, factor, and ordered
#&gt; • Encapsulation: none (fallback: -)
#&gt; • Properties: importance, missings, selected_features, and weights
#&gt; • Other settings: use_weights = 'use'
#&gt; 
#&gt; [[2]]
#&gt; 
#&gt; ── &lt;LearnerRegrFeatureless&gt; (regr.featureless): Featureless Regression Learner ─
#&gt; • Model: -
#&gt; • Parameters: robust=FALSE
#&gt; • Packages: mlr3 and stats
#&gt; • Predict Types: [response], se, and quantiles
#&gt; • Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt; POSIXct, and Date
#&gt; • Encapsulation: none (fallback: -)
#&gt; • Properties: featureless, importance, missings, selected_features, and weights
#&gt; • Other settings: use_weights = 'use'
</code></pre>
<p>The code above defines</p>
<ul>
<li><code>regr.rpart</code>: Regression Tree learning algorithm, which should be
able to learn the non-linear pattern in the sin data (if there are
enough data in the train set).</li>
<li><code>regr.featureless</code>: Featureless Regression learning algorithm, which
should be optimal for the constant data, and can be used as a
baseline in the sin data. When the rpart learner gets smaller
prediction error rates than featureless, then we know that it has
learned some non-trivial relationship between inputs and outputs.</li>
</ul>
<p>In the code below, we define the benchmark grid, which is all
combinations of tasks (constant and sin), learners (rpart and
featureless), and the one resampling method.</p>
<pre><code class="language-r">(reg.bench.grid &lt;- mlr3::benchmark_grid(
  reg.task.list,
  reg.learner.list,
  reg_size_cv))
#&gt;        task          learner             resampling
#&gt;      &lt;char&gt;           &lt;char&gt;                 &lt;char&gt;
#&gt; 1:      sin       regr.rpart variable_size_train_cv
#&gt; 2:      sin regr.featureless variable_size_train_cv
#&gt; 3: constant       regr.rpart variable_size_train_cv
#&gt; 4: constant regr.featureless variable_size_train_cv
</code></pre>
<p>In the code below, we execute the benchmark experiment (optionally in parallel
using the multisession future plan).</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(reg.bench.result &lt;- mlr3::benchmark(
  reg.bench.grid, store_models = TRUE))
#&gt; 
#&gt; ── &lt;BenchmarkResult&gt; of 216 rows with 4 resampling run ─────────────────────────
#&gt;  nr  task_id       learner_id          resampling_id iters warnings errors
#&gt;   1      sin       regr.rpart variable_size_train_cv    54        0      0
#&gt;   2      sin regr.featureless variable_size_train_cv    54        0      0
#&gt;   3 constant       regr.rpart variable_size_train_cv    54        0      0
#&gt;   4 constant regr.featureless variable_size_train_cv    54        0      0
</code></pre>
<p>The code below computes the test error for each split, and visualizes
the information stored in the first row of the result:</p>
<pre><code class="language-r">reg.bench.score &lt;- mlr3resampling::score(reg.bench.result)
reg.bench.score[1]
#&gt;    test.fold  seed small_stratum_size train_size_i train_size
#&gt;        &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt; 1:         1     1                 10            1         10
#&gt;                          train                  test iteration train_min_size
#&gt;                         &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt; 1: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         1             10
#&gt;                                   uhash    nr           task task_id
#&gt;                                  &lt;char&gt; &lt;int&gt;         &lt;list&gt;  &lt;char&gt;
#&gt; 1: 293d6802-5ff9-40ed-a7da-2816ae651936     1 &lt;TaskRegr:sin&gt;     sin
#&gt;                          learner learner_id                      resampling
#&gt;                           &lt;list&gt;     &lt;char&gt;                          &lt;list&gt;
#&gt; 1: &lt;LearnerRegrRpart:regr.rpart&gt; regr.rpart &lt;ResamplingVariableSizeTrainCV&gt;
#&gt;             resampling_id  prediction_test  regr.mse algorithm
#&gt;                    &lt;char&gt;           &lt;list&gt;     &lt;num&gt;    &lt;char&gt;
#&gt; 1: variable_size_train_cv &lt;PredictionRegr&gt; 0.8008255     rpart
</code></pre>
<p>The output above contains all of the results related to a particular
train/test split. In particular for our purposes, the interesting
columns are:</p>
<ul>
<li><code>test.fold</code> is the cross-validation fold ID.</li>
<li><code>seed</code> is the random seed used to determine the train set order.</li>
<li><code>train_size</code> is the number of data in the train set.</li>
<li><code>train</code> and <code>test</code> are vectors of row numbers assigned to each set.</li>
<li><code>iteration</code> is an ID for the train/test split, for a particular
learning algorithm and task. It is the row number of <code>iteration.dt</code>
(see instance above), which has one row for each unique combination
of <code>test.fold</code>, <code>seed</code>, and <code>train_size</code>.</li>
<li><code>learner</code> is the mlr3 learner object, which can be used to compute
predictions on new data (including a grid of inputs, to show
predictions in the visualization below).</li>
<li><code>regr.mse</code> is the mean squared error on the test set.</li>
<li><code>algorithm</code> is the name of the learning algorithm (same as
<code>learner_id</code> but without <code>regr.</code> prefix).</li>
</ul>
<p>The code below visualizes the resulting test accuracy numbers.</p>
<pre><code class="language-r">train_size_vec &lt;- unique(reg.bench.score$train_size)
if(require(animint2)){
  ggplot()+
    scale_x_log10(
      breaks=train_size_vec)+
    scale_y_log10()+
    geom_line(aes(
      train_size, regr.mse,
      group=paste(algorithm, seed),
      color=algorithm),
      shape=1,
      data=reg.bench.score)+
    geom_point(aes(
      train_size, regr.mse, color=algorithm),
      shape=1,
      data=reg.bench.score)+
    facet_grid(
      test.fold~task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-31" /></p>
<p>Above we plot the test error for each fold and train set size.
There is a different panel for each task and test fold.
Each line represents a random seed (ordering of data in train set),
and each dot represents a specific train set size.
So the plot above shows that some variation in test error, for a given test fold,
is due to the random ordering of the train data.</p>
<p>Below we summarize each train set size, by taking the mean and standard deviation over each random seed.</p>
<pre><code class="language-r">reg.mean.dt &lt;- dcast(
  reg.bench.score,
  task_id + train_size + test.fold + algorithm ~ .,
  list(mean, sd),
  value.var=&quot;regr.mse&quot;)
if(require(animint2)){
  ggplot()+
    scale_x_log10(
      breaks=train_size_vec)+
    scale_y_log10()+
    geom_ribbon(aes(
      train_size,
      ymin=regr.mse_mean-regr.mse_sd,
      ymax=regr.mse_mean+regr.mse_sd,
      fill=algorithm),
      alpha=0.5,
      data=reg.mean.dt)+
    geom_line(aes(
      train_size, regr.mse_mean, color=algorithm),
      shape=1,
      data=reg.mean.dt)+
    facet_grid(
      test.fold~task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
#&gt; Warning in grid.Call.graphics(C_polygon, x$x, x$y, index): la semi-transparence
#&gt; n'est pas supportée sur ce périphérique : signalé seulement une fois par page
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-32" /></p>
<p>The plot above shows a line for the mean,
and a ribbon for the standard deviation,
over the three random seeds.
It is clear from the plot above that</p>
<ul>
<li>in constant task, the featureless always has smaller or equal
prediction error rates than rpart, which indicates that rpart
sometimes overfits for large sample sizes.</li>
<li>in sin task, more than 30 samples are required for rpart to be more
accurate than featureless, which indicates it has learned a
non-trivial relationship between input and output.</li>
</ul>
<h3 id="sec:interactive-data-viz">Interactive data viz</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">grid.dt &lt;- data.table(x=seq(-abs.x, abs.x, l=101), y=0)
grid.task &lt;- mlr3::TaskRegr$new(&quot;grid&quot;, grid.dt, target=&quot;y&quot;)
pred.dt.list &lt;- list()
point.dt.list &lt;- list()
for(score.i in 1:nrow(reg.bench.score)){
  reg.bench.row &lt;- reg.bench.score[score.i]
  task.dt &lt;- data.table(
    reg.bench.row$task[[1]]$data(),
    reg.bench.row$resampling[[1]]$instance$id.dt)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=reg.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ]
  point.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(task_id, iteration)],
    i.points)
  i.learner &lt;- reg.bench.row$learner[[1]]
  pred.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(
      task_id, iteration, algorithm
    )],
    as.data.table(
      i.learner$predict(grid.task)
    )[, .(x=grid.dt$x, y=response)]
  )
}
(pred.dt &lt;- rbindlist(pred.dt.list))
#&gt;         task_id iteration   algorithm     x           y
#&gt;          &lt;char&gt;     &lt;int&gt;      &lt;char&gt; &lt;num&gt;       &lt;num&gt;
#&gt;     1:      sin         1       rpart -10.0  0.25011658
#&gt;     2:      sin         1       rpart  -9.8  0.25011658
#&gt;     3:      sin         1       rpart  -9.6  0.25011658
#&gt;     4:      sin         1       rpart  -9.4  0.25011658
#&gt;     5:      sin         1       rpart  -9.2  0.25011658
#&gt;    ---                                                 
#&gt; 21812: constant        54 featureless   9.2 -0.03385654
#&gt; 21813: constant        54 featureless   9.4 -0.03385654
#&gt; 21814: constant        54 featureless   9.6 -0.03385654
#&gt; 21815: constant        54 featureless   9.8 -0.03385654
#&gt; 21816: constant        54 featureless  10.0 -0.03385654
(point.dt &lt;- rbindlist(point.dt.list))
#&gt;         task_id iteration set.name row_id          y         x  fold
#&gt;          &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;      &lt;num&gt;     &lt;num&gt; &lt;int&gt;
#&gt;     1:      sin         1     test      1  1.2248390 -4.689827     1
#&gt;     2:      sin         1   unused      2 -0.5607042 -2.557522     3
#&gt;     3:      sin         1   unused      3  0.8345056  1.457067     3
#&gt;     4:      sin         1   unused      4  0.4875994  8.164156     2
#&gt;     5:      sin         1   unused      5 -0.4321800 -5.966361     3
#&gt;    ---                                                              
#&gt; 64796: constant        54    train    296 -0.6728968  3.628850     2
#&gt; 64797: constant        54    train    297  0.5168327 -8.016618     1
#&gt; 64798: constant        54    train    298 -0.4058882 -7.621949     1
#&gt; 64799: constant        54     test    299  0.9008627 -8.991207     3
#&gt; 64800: constant        54    train    300  0.8857710  8.585078     2
set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Variable size train set, regression&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      geom_point(aes(
        x, y, fill=set.name),
        help=&quot;One dot per sample in train/test/unused set.&quot;,
        showSelected=&quot;iteration&quot;,
        size=3,
        shape=21,
        data=point.dt)+
      scale_size_manual(values=c(
        featureless=3,
        rpart=2))+
      scale_color_manual(values=algo.colors)+
      geom_line(aes(
        x, y,
        color=algorithm,
        size=algorithm,
        group=paste(algorithm, iteration)),
        help=&quot;One line per learned prediction function.&quot;,
        showSelected=&quot;iteration&quot;,
        data=pred.dt)+
      facet_grid(
        task_id ~ .,
        labeller=label_both),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(width=500)+
      theme(
        panel.margin=grid::unit(1, &quot;lines&quot;),
        legend.position=&quot;none&quot;)+
      scale_y_log10(
        &quot;Mean squared error on test set&quot;)+
      scale_color_manual(values=algo.colors)+
      scale_x_log10(
        &quot;Train set size&quot;,
        breaks=train_size_vec)+
      geom_line(aes(
        train_size, regr.mse,
        group=paste(algorithm, seed),
        color=algorithm),
        help=&quot;One line per algorithm and random seed used to order train set.&quot;,
        clickSelects=&quot;seed&quot;,
        alpha_off=0.2,
        showSelected=&quot;algorithm&quot;,
        size=4,
        data=reg.bench.score)+
      facet_grid(
        test.fold~task_id,
        labeller=label_both,
        scales=&quot;free&quot;)+
      geom_point(aes(
        train_size, regr.mse,
        color=algorithm),
        help=&quot;One point per algorithm and train set size, for the selected random ordering.&quot;,
        size=5,
        stroke=3,
        fill=&quot;black&quot;,
        fill_off=NA,
        showSelected=c(&quot;algorithm&quot;,&quot;seed&quot;),
        clickSelects=&quot;iteration&quot;,
        data=reg.bench.score),
    video=&quot;https://vimeo.com/manage/videos/1053467310&quot;,
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Older_resamplers.Rmd&quot;)
}
if(FALSE){
  animint2pages(viz, &quot;2023-12-26-train-sizes-regression&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-26-train-sizes-regression/">https://tdhock.github.io/2023-12-26-train-sizes-regression/</a></p>
<p>The interactive data viz consists of two plots:</p>
<ul>
<li>The first plot shows the data, with each point colored according to
the set it was assigned, in the currently selected
split/iteration. The red/blue lines additionally show the learned
prediction functions for the currently selected split/iteration.</li>
<li>The second plot shows the test error rates, as a function of train
set size. Clicking a line selects the corresponding random seed,
which makes the corresponding points on that line appear. Clicking a
point selects the corresponding iteration (seed, test fold, and train
set size).</li>
</ul>
<h2 id="sec:simulated-classification-problems_2">Simulated classification problems</h2>
<p>Whereas in the section above, we focused on regression (output is a real number),
in this section we simulate a binary classification problem (output if a factor with two levels).</p>
<pre><code class="language-r">class.N &lt;- 900
class.abs.x &lt;- 1
rclass &lt;- function(){
  runif(class.N, -class.abs.x, class.abs.x)
}
library(data.table)
set.seed(1)
class.x.dt &lt;- data.table(x1=rclass(), x2=rclass())
class.fun.list &lt;- list(
  constant=function(...)0.5,
  xor=function(x1, x2)xor(x1&gt;0, x2&gt;0))
class.data.list &lt;- list()
class.task.list &lt;- list()
for(task_id in names(class.fun.list)){
  class.fun &lt;- class.fun.list[[task_id]]
  y &lt;- factor(ifelse(
    class.x.dt[, class.fun(x1, x2)+rnorm(class.N, sd=0.5)]&gt;0.5,
    &quot;spam&quot;, &quot;not&quot;))
  task.dt &lt;- data.table(class.x.dt, y)
  this.task &lt;- mlr3::TaskClassif$new(
    task_id, task.dt, target=&quot;y&quot;)
  this.task$col_roles$stratum &lt;- &quot;y&quot;
  class.task.list[[task_id]] &lt;- this.task
  class.data.list[[task_id]] &lt;- data.table(task_id, task.dt)
}
(class.data &lt;- rbindlist(class.data.list))
#&gt;        task_id         x1          x2      y
#&gt;         &lt;char&gt;      &lt;num&gt;       &lt;num&gt; &lt;fctr&gt;
#&gt;    1: constant -0.4689827  0.66379798    not
#&gt;    2: constant -0.2557522  0.53368551   spam
#&gt;    3: constant  0.1457067 -0.45443937   spam
#&gt;    4: constant  0.8164156 -0.62367340    not
#&gt;    5: constant -0.5966361 -0.54847633   spam
#&gt;   ---                                       
#&gt; 1796:      xor -0.7614714 -0.01958119    not
#&gt; 1797:      xor  0.1871909 -0.96323285    not
#&gt; 1798:      xor -0.9253746 -0.64121842    not
#&gt; 1799:      xor -0.9808564 -0.40121772   spam
#&gt; 1800:      xor -0.6768077 -0.44607188    not
</code></pre>
<p>The simulated data table above consists of two input features (<code>x1</code>
and <code>x2</code>) along with an output/label to predict (<code>y</code>). Below we count
the number of times each label appears in each task:</p>
<pre><code class="language-r">class.data[, .(count=.N), by=.(task_id, y)]
#&gt;     task_id      y count
#&gt;      &lt;char&gt; &lt;fctr&gt; &lt;int&gt;
#&gt; 1: constant    not   462
#&gt; 2: constant   spam   438
#&gt; 3:      xor   spam   462
#&gt; 4:      xor    not   438
</code></pre>
<p>The table above shows that the <code>spam</code> label is the minority class
(<code>not</code> is majority, so that will be the prediction of the featureless
baseline). Below we visualize the data in the feature space:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x1, x2, color=y),
      shape=1,
      data=class.data)+
    facet_grid(. ~ task_id, labeller=label_both)+
    coord_equal()
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-35" /></p>
<p>The plot above shows how the output <code>y</code> is related to the two inputs <code>x1</code> and
<code>x2</code>, for the two tasks.</p>
<ul>
<li>For the constant task, the two inputs are not related to the output.</li>
<li>For the xor task, the spam label is associated with either <code>x1</code> or
<code>x2</code> being negative (but not both).</li>
</ul>
<p>In the mlr3 code below, we define a list of learners, our resampling
method, and a benchmark grid:</p>
<pre><code class="language-r">class.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerClassifRpart$new(),
  mlr3::LearnerClassifFeatureless$new())
size_cv &lt;- mlr3resampling::ResamplingVariableSizeTrainCV$new()
(class.bench.grid &lt;- mlr3::benchmark_grid(
  class.task.list,
  class.learner.list,
  size_cv))
#&gt;        task             learner             resampling
#&gt;      &lt;char&gt;              &lt;char&gt;                 &lt;char&gt;
#&gt; 1: constant       classif.rpart variable_size_train_cv
#&gt; 2: constant classif.featureless variable_size_train_cv
#&gt; 3:      xor       classif.rpart variable_size_train_cv
#&gt; 4:      xor classif.featureless variable_size_train_cv
</code></pre>
<p>Below we run the learning algorithm for each of the train/test splits
defined by our benchmark grid:</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(class.bench.result &lt;- mlr3::benchmark(
  class.bench.grid, store_models = TRUE))
#&gt; 
#&gt; ── &lt;BenchmarkResult&gt; of 180 rows with 4 resampling run ─────────────────────────
#&gt;  nr  task_id          learner_id          resampling_id iters warnings errors
#&gt;   1 constant       classif.rpart variable_size_train_cv    45        0      0
#&gt;   2 constant classif.featureless variable_size_train_cv    45        0      0
#&gt;   3      xor       classif.rpart variable_size_train_cv    45        0      0
#&gt;   4      xor classif.featureless variable_size_train_cv    45        0      0
</code></pre>
<p>Below we compute scores (test error) for each resampling iteration,
and show the first row of the result.</p>
<pre><code class="language-r">class.bench.score &lt;- mlr3resampling::score(class.bench.result)
class.bench.score[1]
#&gt;    test.fold  seed small_stratum_size train_size_i train_size
#&gt;        &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt; 1:         1     1                 10            1         21
#&gt;                          train                  test iteration train_min_size
#&gt;                         &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt; 1:  91,746,863,730,208,508,...  4,10,12,33,40,49,...         1             21
#&gt;                                   uhash    nr                   task  task_id
#&gt;                                  &lt;char&gt; &lt;int&gt;                 &lt;list&gt;   &lt;char&gt;
#&gt; 1: 640facf3-e501-4c22-b15c-8027e10bdddb     1 &lt;TaskClassif:constant&gt; constant
#&gt;                                learner    learner_id
#&gt;                                 &lt;list&gt;        &lt;char&gt;
#&gt; 1: &lt;LearnerClassifRpart:classif.rpart&gt; classif.rpart
#&gt;                         resampling          resampling_id     prediction_test
#&gt;                             &lt;list&gt;                 &lt;char&gt;              &lt;list&gt;
#&gt; 1: &lt;ResamplingVariableSizeTrainCV&gt; variable_size_train_cv &lt;PredictionClassif&gt;
#&gt;    classif.ce algorithm
#&gt;         &lt;num&gt;    &lt;char&gt;
#&gt; 1:  0.5266667     rpart
</code></pre>
<p>The output above has columns which are very similar to the regression
example in the previous section. The main difference is the
<code>classif.ce</code> column, which is the classification error on the test
set.</p>
<p>Finally we plot the test error values below.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_line(aes(
      train_size, classif.ce,
      group=paste(algorithm, seed),
      color=algorithm),
      shape=1,
      data=class.bench.score)+
    geom_point(aes(
      train_size, classif.ce, color=algorithm),
      shape=1,
      data=class.bench.score)+
    facet_grid(
      task_id ~ test.fold,
      labeller=label_both)+
    scale_x_log10(
      breaks=unique(class.bench.score$train_size))+
    scale_y_continuous(
      &quot;Test error rate&quot;,
      limits=c(0.1,0.6),
      breaks=seq(0.1,0.6,by=0.1))
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-39" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>in constant task, rpart does not have significantly lower error
rates than featureless, which is expected, because the best
prediction function is constant (predict the most frequent class, no
relationship between inputs and output).</li>
<li>in xor task, more than 30 samples are required for rpart to be more
accurate than featureless, which indicates it has learned a
non-trivial relationship between inputs and output.</li>
</ul>
<p>Exercise for the reader: compute and plot mean and SD for these
classification tasks, similar to the plot for the regression tasks in
the previous section.</p>
<h3 id="sec:interactive-visualization-of-data-test-error-and-splits_3">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">class.grid.vec &lt;- seq(-class.abs.x, class.abs.x, l=21)
class.grid.dt &lt;- CJ(x1=class.grid.vec, x2=class.grid.vec)
class.pred.dt.list &lt;- list()
class.point.dt.list &lt;- list()
for(score.i in 1:nrow(class.bench.score)){
  class.bench.row &lt;- class.bench.score[score.i]
  task.dt &lt;- data.table(
    class.bench.row$task[[1]]$data(),
    class.bench.row$resampling[[1]]$instance$id.dt)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=class.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ][]
  class.point.dt.list[[score.i]] &lt;- data.table(
    class.bench.row[, .(task_id, iteration)],
    i.points)
  if(class.bench.row$algorithm!=&quot;featureless&quot;){
    i.learner &lt;- class.bench.row$learner[[1]]
    i.learner$predict_type &lt;- &quot;prob&quot;
    i.task &lt;- class.bench.row$task[[1]]
    grid.class.task &lt;- mlr3::TaskClassif$new(
      &quot;grid&quot;, class.grid.dt[, label:=factor(NA,levels(task.dt$y))], target=&quot;label&quot;)
    pred.grid &lt;- as.data.table(
      i.learner$predict(grid.class.task)
    )[, data.table(class.grid.dt, prob.spam)]
    pred.wide &lt;- dcast(pred.grid, x1 ~ x2, value.var=&quot;prob.spam&quot;)
    prob.mat &lt;- as.matrix(pred.wide[,-1])
    if(length(table(prob.mat))&gt;1){
      contour.list &lt;- contourLines(
        class.grid.vec, class.grid.vec, prob.mat, levels=0.5)
      class.pred.dt.list[[score.i]] &lt;- data.table(
        class.bench.row[, .(
          task_id, iteration, algorithm
        )],
        data.table(contour.i=seq_along(contour.list))[, {
          do.call(data.table, contour.list[[contour.i]])[, .(level, x1=x, x2=y)]
        }, by=contour.i]
      )
    }
  }
}
(class.pred.dt &lt;- rbindlist(class.pred.dt.list))
#&gt;        task_id iteration algorithm contour.i level         x1         x2
#&gt;         &lt;char&gt;     &lt;int&gt;    &lt;char&gt;     &lt;int&gt; &lt;num&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;    1: constant         1     rpart         1   0.5 -1.0000000 -0.3531915
#&gt;    2: constant         1     rpart         1   0.5 -0.9000000 -0.3531915
#&gt;    3: constant         1     rpart         1   0.5 -0.8000000 -0.3531915
#&gt;    4: constant         1     rpart         1   0.5 -0.7000000 -0.3531915
#&gt;    5: constant         1     rpart         1   0.5 -0.6000000 -0.3531915
#&gt;   ---                                                                   
#&gt; 5502:      xor        45     rpart         2   0.5  0.7000000  0.0499392
#&gt; 5503:      xor        45     rpart         2   0.5  0.8000000  0.0499392
#&gt; 5504:      xor        45     rpart         2   0.5  0.8465335  0.0000000
#&gt; 5505:      xor        45     rpart         2   0.5  0.9000000 -0.0460000
#&gt; 5506:      xor        45     rpart         2   0.5  1.0000000 -0.0460000
(class.point.dt &lt;- rbindlist(class.point.dt.list))
#&gt;          task_id iteration set.name row_id      y         x1          x2  fold
#&gt;           &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt; &lt;fctr&gt;      &lt;num&gt;       &lt;num&gt; &lt;int&gt;
#&gt;      1: constant         1   unused      1    not -0.4689827  0.66379798     3
#&gt;      2: constant         1   unused      2   spam -0.2557522  0.53368551     2
#&gt;      3: constant         1   unused      3   spam  0.1457067 -0.45443937     2
#&gt;      4: constant         1     test      4    not  0.8164156 -0.62367340     1
#&gt;      5: constant         1     test      5   spam -0.5966361 -0.54847633     1
#&gt;     ---                                                                       
#&gt; 161996:      xor        45     test    896    not -0.7614714 -0.01958119     3
#&gt; 161997:      xor        45     test    897    not  0.1871909 -0.96323285     3
#&gt; 161998:      xor        45    train    898    not -0.9253746 -0.64121842     2
#&gt; 161999:      xor        45    train    899   spam -0.9808564 -0.40121772     1
#&gt; 162000:      xor        45    train    900    not -0.6768077 -0.44607188     1

set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Variable size train sets, classification&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      theme_animint(width=600)+
      coord_equal()+
      scale_fill_manual(values=set.colors)+
      scale_color_manual(values=c(spam=&quot;black&quot;,&quot;not spam&quot;=&quot;white&quot;))+
      geom_point(aes(
        x1, x2, color=y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        help=&quot;One dot per data sample in the train/test/unused set.&quot;,
        size=3,
        stroke=2,
        shape=21,
        data=class.point.dt)+
      geom_path(aes(
        x1, x2, 
        group=paste(algorithm, iteration, contour.i)),
        showSelected=c(&quot;iteration&quot;,&quot;algorithm&quot;),
        help=&quot;Red path represents decision boundary of rpart decision tree learning algorithm.&quot;,
        color=algo.colors[[&quot;rpart&quot;]],
        data=class.pred.dt)+
      facet_grid(
        . ~ task_id,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      scale_y_continuous(
        &quot;Classification error on test set&quot;,
        limits=c(0.1,0.6),
        breaks=seq(0.1,0.6,by=0.1))+
      scale_color_manual(values=algo.colors)+
      scale_x_log10(
        &quot;Train set size&quot;,
        breaks=unique(class.bench.score$train_size))+
      geom_line(aes(
        train_size, classif.ce,
        group=paste(algorithm, seed),
        color=algorithm),
        help=&quot;One line per algorithm and random seed used to order train set.&quot;,
        clickSelects=&quot;seed&quot;,
        alpha_off=0.2,
        showSelected=&quot;algorithm&quot;,
        size=4,
        data=class.bench.score)+
      facet_grid(
        test.fold~task_id,
        labeller=label_both,
        scales=&quot;free&quot;)+
      geom_point(aes(
        train_size, classif.ce,
        color=algorithm),
        size=5,
        stroke=3,
        fill=&quot;black&quot;,
        fill_off=NA,
        help=&quot;One point per algorithm and train set size, for the selected random ordering.&quot;,
        showSelected=c(&quot;algorithm&quot;,&quot;seed&quot;),
        clickSelects=&quot;iteration&quot;,
        data=class.bench.score),
    video=&quot;https://vimeo.com/1053477025&quot;,
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Older_resamplers.Rmd&quot;)
}
if(FALSE){
  animint2pages(viz, &quot;2023-12-27-train-sizes-classification&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-27-train-sizes-classification/">https://tdhock.github.io/2023-12-27-train-sizes-classification/</a></p>
<p>The interactive data viz consists of two plots</p>
<ul>
<li>The first plot shows the data, with each point colored according to
its label/y value (black outline for spam, white outline for not),
and the set it was assigned (fill color) in the currently selected
split/iteration. The red lines additionally show the learned
decision boundary for rpart, given the currently selected
split/iteration.  For constant, the ideal decision boundary is none
(always predict the most frequent class), and for xor, the ideal
decision boundary looks like a plus sign.</li>
<li>The second plot shows the test error rates, as a function of train
set size. Clicking a line selects the corresponding random seed,
which makes the corresponding points on that line appear. Clicking a
point selects the corresponding iteration (seed, test fold, and train
set size).</li>
</ul>
<h2 id="sec:conclusion_2">Conclusion</h2>
<p>In this section we have shown how to use mlr3resampling for comparing
test error of models trained on different sized train sets.</p>
<h1 id="chp:session-info">Session info</h1>
<pre><code class="language-r">sessionInfo()
#&gt; R Under development (unstable) (2025-05-21 r88220)
#&gt; Platform: x86_64-pc-linux-gnu
#&gt; Running under: Ubuntu 24.04.2 LTS
#&gt; 
#&gt; Matrix products: default
#&gt; BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.12.0 
#&gt; LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.12.0  LAPACK version 3.12.0
#&gt; 
#&gt; locale:
#&gt;  [1] LC_CTYPE=fr_FR.UTF-8       LC_NUMERIC=C              
#&gt;  [3] LC_TIME=fr_FR.UTF-8        LC_COLLATE=C              
#&gt;  [5] LC_MONETARY=fr_FR.UTF-8    LC_MESSAGES=fr_FR.UTF-8   
#&gt;  [7] LC_PAPER=fr_FR.UTF-8       LC_NAME=C                 
#&gt;  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
#&gt; [11] LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C       
#&gt; 
#&gt; time zone: Europe/Paris
#&gt; tzcode source: system (glibc)
#&gt; 
#&gt; attached base packages:
#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     
#&gt; 
#&gt; other attached packages:
#&gt; [1] lgr_0.4.4                animint2_2025.6.4        directlabels_2025.5.20  
#&gt; [4] mlr3resampling_2025.6.23 mlr3_1.0.0.9000          future_1.58.0           
#&gt; [7] ggplot2_3.5.1            data.table_1.17.99      
#&gt; 
#&gt; loaded via a namespace (and not attached):
#&gt;  [1] generics_0.1.3       stringi_1.8.7        listenv_0.9.1       
#&gt;  [4] digest_0.6.37        magrittr_2.0.3       evaluate_1.0.3      
#&gt;  [7] grid_4.6.0           plyr_1.8.9           backports_1.5.0     
#&gt; [10] scales_1.3.0         mlr3tuning_1.3.0     codetools_0.2-20    
#&gt; [13] mlr3measures_1.0.0   palmerpenguins_0.1.1 cli_3.6.5           
#&gt; [16] rlang_1.1.6          crayon_1.5.3         parallelly_1.45.0   
#&gt; [19] litedown_0.6         future.apply_1.20.0  munsell_0.5.1       
#&gt; [22] commonmark_1.9.5     withr_3.0.2          nc_2025.3.24        
#&gt; [25] tools_4.6.0          parallel_4.6.0       reshape2_1.4.4      
#&gt; [28] RJSONIO_1.3-1.9      uuid_1.2-1           checkmate_2.3.2     
#&gt; [31] dplyr_1.1.4          colorspace_2.1-1     globals_0.18.0      
#&gt; [34] bbotk_1.5.0          vctrs_0.6.5          R6_2.6.1            
#&gt; [37] mime_0.13            rpart_4.1.24         lifecycle_1.0.4     
#&gt; [40] stringr_1.5.1        mlr3misc_0.18.0      pkgconfig_2.0.3     
#&gt; [43] pillar_1.10.2        gtable_0.3.6         Rcpp_1.0.14         
#&gt; [46] glue_1.8.0           paradox_1.0.1        xfun_0.51           
#&gt; [49] tibble_3.2.1         tidyselect_1.2.1     knitr_1.50          
#&gt; [52] farver_2.1.2         labeling_0.4.3       compiler_4.6.0      
#&gt; [55] quadprog_1.5-8       markdown_2.0
</code></pre>
</div>
</body>
</html>
