<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Same/Other/All resampler</title>
<style type="text/css">
/**
 * Prism.s theme ported from highlight.js's xcode style
 */
pre code {
  padding: 1em;
}
.token.comment {
  color: #007400;
}
.token.punctuation {
  color: #999;
}
.token.tag,
.token.selector {
  color: #aa0d91;
}
.token.boolean,
.token.number,
.token.constant,
.token.symbol {
  color: #1c00cf;
}
.token.property,
.token.attr-name,
.token.string,
.token.char,
.token.builtin {
  color: #c41a16;
}
.token.inserted {
  background-color: #ccffd8;
}
.token.deleted {
  background-color: #ffebe9;
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: #9a6e3a;
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: #836c28;
}
.token.function,
.token.class-name {
  color: #DD4A68;
}
.token.regex,
.token.important,
.token.variable {
  color: #5c2699;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
</style>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  box-sizing: border-box;
}
body, .footnotes, code { font-size: .9em; }
li li { font-size: .95em; }
*, *:before, *:after {
  box-sizing: inherit;
}
pre, img { max-width: 100%; }
pre, pre:hover {
  white-space: pre-wrap;
  word-break: break-all;
}
pre code {
  display: block;
  overflow-x: auto;
}
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre) > code, code[class] { background-color: #F8F8F8; }
code.language-undefined, pre > code:not([class]) {
  background-color: inherit;
  border: 1px solid #eee;
}
table {
  margin: auto;
  border-top: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color: #666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC .numbered li { list-style: none; }
#TOC .numbered { padding-left: 0; }
#TOC .numbered ul { padding-left: 1em; }
table, .body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.footnote-ref a::before { content: "["; }
.footnote-ref a::after { content: "]"; }
section.footnotes::before {
  content: "";
  display: block;
  max-width: 20em;
}

@media print {
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  tr, img { page-break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  pre { white-space: pre; }
}
</style>
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>Same/Other/All resampler</h1></div>
<div class="author"><h2></h2></div>
<div class="date"><h3></h3></div>
</div>
<div class="body">
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Older resamplers}
-->
<p>The goal of this vignette is to explain the older resamplers:
<code>ResamplingVariableSizeTrainCV</code> and <code>ResamplingSameOtherCV</code>, which
output some data which are useful for visualizing the train/test
splits. If you do not want to visualize the train/test splits, then it
is recommended to instead use the newere resampler,
<code>ResamplingSameOtherSizesCV</code> (see other vignette).</p>
<h1 id="same-other-all-resampler">Same/Other/All resampler</h1>
<p>The goal of thie section is to explain how to quantify the extent to
which it is possible to train on one data subset, and predict on
another data subset. This kind of problem occurs frequently in many
different problem domains:</p>
<ul>
<li>geography: can we train on one region (say Europe) and accurately
predict on another? (North America)</li>
<li>time series: can we train on one time period (2000) and accurately
predict on another? (2001)</li>
<li>personalization: can we train on one person (Alice) and accurately
predict on another? (Bob)</li>
</ul>
<p>The ideas are similar to my previous blog posts about how to do this
in
<a href="https://tdhock.github.io/blog/2022/generalization-to-new-subsets/">python</a>
and <a href="https://tdhock.github.io/blog/2023/R-gen-new-subsets/">R</a>. Below
we explain how to use <code>mlr3resampling</code> for this purpose, in simulated
regression and classification problems. To use this method in
real data, the important sections to read below are named “Benchmark:
computing test error,” which show how to create these cross-validation
experiments using mlr3 code.</p>
<h2 id="simulated-regression-problems_1">Simulated regression problems</h2>
<p>We begin by generating some data which can be used with regression algorithms.
Assume there is a data set with some rows from one person, some rows
from another,</p>
<pre><code class="language-r">N &lt;- 300
library(data.table)
set.seed(1)
abs.x &lt;- 2
reg.dt &lt;- data.table(
  x=runif(N, -abs.x, abs.x),
  person=rep(1:2, each=0.5*N))
reg.pattern.list &lt;- list(
  easy=function(x, person)x^2,
  impossible=function(x, person)(x^2+person*3)*(-1)^person)
reg.task.list &lt;- list()
for(task_id in names(reg.pattern.list)){
  f &lt;- reg.pattern.list[[task_id]]
  yname &lt;- paste0(&quot;y_&quot;,task_id)
  reg.dt[, (yname) := f(x,person)+rnorm(N)][]
  task.dt &lt;- reg.dt[, c(&quot;x&quot;,&quot;person&quot;,yname), with=FALSE]
  reg.task &lt;- mlr3::TaskRegr$new(
    task_id, task.dt, target=yname)
  reg.task$col_roles$subset &lt;- &quot;person&quot;
  reg.task$col_roles$stratum &lt;- &quot;person&quot;
  reg.task$col_roles$feature &lt;- &quot;x&quot;
  reg.task.list[[task_id]] &lt;- reg.task
}
reg.dt
#&gt;               x person      y_easy y_impossible
#&gt;           &lt;num&gt;  &lt;int&gt;       &lt;num&gt;        &lt;num&gt;
#&gt;   1: -0.9379653      1  1.32996609    -2.918082
#&gt;   2: -0.5115044      1  0.24307692    -3.866062
#&gt;   3:  0.2914135      1 -0.23314657    -3.837799
#&gt;   4:  1.6328312      1  1.73677545    -7.221749
#&gt;   5: -1.1932723      1 -0.06356159    -5.877792
#&gt;  ---                                           
#&gt; 296:  0.7257701      2 -2.48130642     5.180948
#&gt; 297: -1.6033236      2  1.20453459     9.604312
#&gt; 298: -1.5243898      2  1.89966190     7.511988
#&gt; 299: -1.7982414      2  3.47047566    11.035397
#&gt; 300:  1.7170157      2  0.60541972    10.719685
</code></pre>
<p>The table above shows some simulated data for two regression problems:</p>
<ul>
<li>easy problem has the same pattern for each person, so it is possible/easy to train on one person, and accurately predict on another.</li>
<li>impossible problem has a different pattern for each person, so it is impossible to train on one person, and accurately predict on another.</li>
<li>when adapting the code above to real data, the important part is the
<code>mlr3::TaskRegr</code> line which tells mlr3 what data set to use, what is
the target column, and what is the subset/stratum column.</li>
</ul>
<h3 id="static-visualization-of-simulated-data_1">Static visualization of simulated data</h3>
<p>First we reshape the data using the code below,</p>
<pre><code class="language-r">(reg.tall &lt;- nc::capture_melt_single(
  reg.dt,
  task_id=&quot;easy|impossible&quot;,
  value.name=&quot;y&quot;))
#&gt;               x person    task_id           y
#&gt;           &lt;num&gt;  &lt;int&gt;     &lt;char&gt;       &lt;num&gt;
#&gt;   1: -0.9379653      1       easy  1.32996609
#&gt;   2: -0.5115044      1       easy  0.24307692
#&gt;   3:  0.2914135      1       easy -0.23314657
#&gt;   4:  1.6328312      1       easy  1.73677545
#&gt;   5: -1.1932723      1       easy -0.06356159
#&gt;  ---                                         
#&gt; 596:  0.7257701      2 impossible  5.18094849
#&gt; 597: -1.6033236      2 impossible  9.60431191
#&gt; 598: -1.5243898      2 impossible  7.51198770
#&gt; 599: -1.7982414      2 impossible 11.03539747
#&gt; 600:  1.7170157      2 impossible 10.71968480
</code></pre>
<p>The table above is a more convenient form for the visualization which we create using the code below,</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x, y),
      data=reg.tall)+
    facet_grid(
      task_id ~ person,
      labeller=label_both,
      space=&quot;free&quot;,
      scales=&quot;free&quot;)+
    scale_y_continuous(
      breaks=seq(-100, 100, by=2))
}
#&gt; Le chargement a nécessité le package : animint2
#&gt; Registered S3 methods overwritten by 'animint2':
#&gt;   method                   from   
#&gt;   [.uneval                 ggplot2
#&gt;   drawDetails.zeroGrob     ggplot2
#&gt;   grid.draw.absoluteGrob   ggplot2
#&gt;   grobHeight.absoluteGrob  ggplot2
#&gt;   grobHeight.zeroGrob      ggplot2
#&gt;   grobWidth.absoluteGrob   ggplot2
#&gt;   grobWidth.zeroGrob       ggplot2
#&gt;   grobX.absoluteGrob       ggplot2
#&gt;   grobY.absoluteGrob       ggplot2
#&gt;   heightDetails.titleGrob  ggplot2
#&gt;   heightDetails.zeroGrob   ggplot2
#&gt;   makeContext.dotstackGrob ggplot2
#&gt;   print.element            ggplot2
#&gt;   print.ggplot2_bins       ggplot2
#&gt;   print.rel                ggplot2
#&gt;   print.theme              ggplot2
#&gt;   print.uneval             ggplot2
#&gt;   widthDetails.titleGrob   ggplot2
#&gt;   widthDetails.zeroGrob    ggplot2
#&gt; 
#&gt; Attachement du package : 'animint2'
#&gt; Les objets suivants sont masqués depuis 'package:ggplot2':
#&gt; 
#&gt;     %+%, %+replace%, Coord, CoordCartesian, CoordFixed, CoordFlip,
#&gt;     CoordMap, CoordPolar, CoordQuickmap, CoordTrans, Geom, GeomAbline,
#&gt;     GeomAnnotationMap, GeomArea, GeomBar, GeomBlank, GeomContour,
#&gt;     GeomCrossbar, GeomCurve, GeomCustomAnn, GeomDensity, GeomDensity2d,
#&gt;     GeomDotplot, GeomErrorbar, GeomErrorbarh, GeomHex, GeomHline,
#&gt;     GeomLabel, GeomLine, GeomLinerange, GeomLogticks, GeomMap,
#&gt;     GeomPath, GeomPoint, GeomPointrange, GeomPolygon, GeomRaster,
#&gt;     GeomRasterAnn, GeomRect, GeomRibbon, GeomRug, GeomSegment,
#&gt;     GeomSmooth, GeomSpoke, GeomStep, GeomText, GeomTile, GeomViolin,
#&gt;     GeomVline, Position, PositionDodge, PositionFill, PositionIdentity,
#&gt;     PositionJitter, PositionJitterdodge, PositionNudge, PositionStack,
#&gt;     Scale, ScaleContinuous, ScaleContinuousDate,
#&gt;     ScaleContinuousDatetime, ScaleContinuousIdentity,
#&gt;     ScaleContinuousPosition, ScaleDiscrete, ScaleDiscreteIdentity,
#&gt;     ScaleDiscretePosition, Stat, StatBin, StatBin2d, StatBindot,
#&gt;     StatBinhex, StatContour, StatCount, StatDensity, StatDensity2d,
#&gt;     StatEcdf, StatEllipse, StatFunction, StatIdentity, StatQq,
#&gt;     StatSmooth, StatSum, StatSummary, StatSummary2d, StatSummaryBin,
#&gt;     StatSummaryHex, StatUnique, StatYdensity, aes, aes_, aes_all,
#&gt;     aes_auto, aes_q, aes_string, annotate, annotation_custom,
#&gt;     annotation_logticks, annotation_map, annotation_raster,
#&gt;     as_labeller, autoplot, benchplot, borders, calc_element,
#&gt;     continuous_scale, coord_cartesian, coord_equal, coord_fixed,
#&gt;     coord_flip, coord_map, coord_munch, coord_polar, coord_quickmap,
#&gt;     coord_trans, cut_interval, cut_number, cut_width, discrete_scale,
#&gt;     draw_key_abline, draw_key_blank, draw_key_crossbar,
#&gt;     draw_key_dotplot, draw_key_label, draw_key_path, draw_key_point,
#&gt;     draw_key_pointrange, draw_key_polygon, draw_key_rect,
#&gt;     draw_key_smooth, draw_key_text, draw_key_vline, draw_key_vpath,
#&gt;     economics, economics_long, element_blank, element_grob,
#&gt;     element_line, element_rect, element_text, expand_limits,
#&gt;     facet_grid, facet_null, facet_wrap, fortify, geom_abline,
#&gt;     geom_area, geom_bar, geom_bin2d, geom_blank, geom_contour,
#&gt;     geom_count, geom_crossbar, geom_curve, geom_density,
#&gt;     geom_density2d, geom_density_2d, geom_dotplot, geom_errorbar,
#&gt;     geom_errorbarh, geom_freqpoly, geom_hex, geom_histogram,
#&gt;     geom_hline, geom_jitter, geom_label, geom_line, geom_linerange,
#&gt;     geom_map, geom_path, geom_point, geom_pointrange, geom_polygon,
#&gt;     geom_qq, geom_raster, geom_rect, geom_ribbon, geom_rug,
#&gt;     geom_segment, geom_smooth, geom_spoke, geom_step, geom_text,
#&gt;     geom_tile, geom_violin, geom_vline, gg_dep, ggplot, ggplotGrob,
#&gt;     ggplot_build, ggplot_gtable, ggsave, ggtitle, guide_colorbar,
#&gt;     guide_colourbar, guide_legend, guides, is.Coord, is.facet,
#&gt;     is.ggplot, is.theme, label_both, label_bquote, label_context,
#&gt;     label_parsed, label_value, label_wrap_gen, labeller, labs,
#&gt;     last_plot, layer, layer_data, layer_grob, layer_scales, lims,
#&gt;     map_data, margin, mean_cl_boot, mean_cl_normal, mean_sdl, mean_se,
#&gt;     median_hilow, position_dodge, position_fill, position_identity,
#&gt;     position_jitter, position_jitterdodge, position_nudge,
#&gt;     position_stack, presidential, qplot, quickplot, rel,
#&gt;     remove_missing, resolution, scale_alpha, scale_alpha_continuous,
#&gt;     scale_alpha_discrete, scale_alpha_identity, scale_alpha_manual,
#&gt;     scale_color_brewer, scale_color_continuous, scale_color_discrete,
#&gt;     scale_color_distiller, scale_color_gradient, scale_color_gradient2,
#&gt;     scale_color_gradientn, scale_color_grey, scale_color_hue,
#&gt;     scale_color_identity, scale_color_manual, scale_colour_brewer,
#&gt;     scale_colour_continuous, scale_colour_date, scale_colour_datetime,
#&gt;     scale_colour_discrete, scale_colour_distiller,
#&gt;     scale_colour_gradient, scale_colour_gradient2,
#&gt;     scale_colour_gradientn, scale_colour_grey, scale_colour_hue,
#&gt;     scale_colour_identity, scale_colour_manual, scale_fill_brewer,
#&gt;     scale_fill_continuous, scale_fill_date, scale_fill_datetime,
#&gt;     scale_fill_discrete, scale_fill_distiller, scale_fill_gradient,
#&gt;     scale_fill_gradient2, scale_fill_gradientn, scale_fill_grey,
#&gt;     scale_fill_hue, scale_fill_identity, scale_fill_manual,
#&gt;     scale_linetype, scale_linetype_continuous, scale_linetype_discrete,
#&gt;     scale_linetype_identity, scale_linetype_manual, scale_radius,
#&gt;     scale_shape, scale_shape_continuous, scale_shape_discrete,
#&gt;     scale_shape_identity, scale_shape_manual, scale_size,
#&gt;     scale_size_area, scale_size_continuous, scale_size_date,
#&gt;     scale_size_datetime, scale_size_discrete, scale_size_identity,
#&gt;     scale_size_manual, scale_x_continuous, scale_x_date,
#&gt;     scale_x_datetime, scale_x_discrete, scale_x_log10, scale_x_reverse,
#&gt;     scale_x_sqrt, scale_y_continuous, scale_y_date, scale_y_datetime,
#&gt;     scale_y_discrete, scale_y_log10, scale_y_reverse, scale_y_sqrt,
#&gt;     should_stop, stat_bin, stat_bin2d, stat_bin_2d, stat_bin_hex,
#&gt;     stat_binhex, stat_contour, stat_count, stat_density,
#&gt;     stat_density2d, stat_density_2d, stat_ecdf, stat_ellipse,
#&gt;     stat_function, stat_identity, stat_qq, stat_smooth, stat_spoke,
#&gt;     stat_sum, stat_summary, stat_summary2d, stat_summary_2d,
#&gt;     stat_summary_bin, stat_summary_hex, stat_unique, stat_ydensity,
#&gt;     theme, theme_bw, theme_classic, theme_dark, theme_get, theme_gray,
#&gt;     theme_grey, theme_light, theme_linedraw, theme_minimal,
#&gt;     theme_replace, theme_set, theme_update, theme_void,
#&gt;     transform_position, update_geom_defaults, update_labels,
#&gt;     update_stat_defaults, waiver, xlab, xlim, ylab, ylim, zeroGrob
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-3" /></p>
<p>In the simulated data above, we can see that</p>
<ul>
<li>for the easy pattern, it is the same for both people, so it should
be possible/easy to train on one person, and accurately predict on
another.</li>
<li>for the impossible pattern, it is different for each person, so it
should not be possible to train on one person, and accurately
predict on another.</li>
</ul>
<h3 id="benchmark-computing-test-error_1">Benchmark: computing test error</h3>
<p>In the code below, we define a K-fold cross-validation experiment.</p>
<pre><code class="language-r">(reg_same_other &lt;- mlr3resampling::ResamplingSameOtherCV$new())
#&gt; &lt;ResamplingSameOtherCV&gt; : Same versus Other Cross-Validation
#&gt; * Iterations:
#&gt; * Instantiated: FALSE
#&gt; * Parameters:
#&gt; List of 1
#&gt;  $ folds: int 3
</code></pre>
<p>In the code below, we define two learners to compare,</p>
<pre><code class="language-r">(reg.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerRegrRpart$new(),
  mlr3::LearnerRegrFeatureless$new()))
#&gt; [[1]]
#&gt; &lt;LearnerRegrRpart:regr.rpart&gt;: Regression Tree
#&gt; * Model: -
#&gt; * Parameters: xval=0
#&gt; * Packages: mlr3, rpart
#&gt; * Predict Types:  [response]
#&gt; * Feature Types: logical, integer, numeric, factor, ordered
#&gt; * Properties: importance, missings, selected_features, weights
#&gt; 
#&gt; [[2]]
#&gt; &lt;LearnerRegrFeatureless:regr.featureless&gt;: Featureless Regression Learner
#&gt; * Model: -
#&gt; * Parameters: robust=FALSE
#&gt; * Packages: mlr3, stats
#&gt; * Predict Types:  [response], se
#&gt; * Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt;   POSIXct
#&gt; * Properties: featureless, importance, missings, selected_features
</code></pre>
<p>In the code below, we define the benchmark grid, which is all
combinations of tasks (easy and impossible), learners (rpart and
featureless), and the one resampling method.</p>
<pre><code class="language-r">(reg.bench.grid &lt;- mlr3::benchmark_grid(
  reg.task.list,
  reg.learner.list,
  reg_same_other))
#&gt;          task          learner    resampling
#&gt;        &lt;char&gt;           &lt;char&gt;        &lt;char&gt;
#&gt; 1:       easy       regr.rpart same_other_cv
#&gt; 2:       easy regr.featureless same_other_cv
#&gt; 3: impossible       regr.rpart same_other_cv
#&gt; 4: impossible regr.featureless same_other_cv
</code></pre>
<p>In the code below, we execute the benchmark experiment (in parallel
using the multisession future plan).</p>
<pre><code class="language-r">if(FALSE){#for CRAN.
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
#&gt; Le chargement a nécessité le package : lgr
#&gt; 
#&gt; Attachement du package : 'lgr'
#&gt; L'objet suivant est masqué depuis 'package:ggplot2':
#&gt; 
#&gt;     Layout
</code></pre>
<pre><code class="language-r">(reg.bench.result &lt;- mlr3::benchmark(
  reg.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 72 rows with 4 resampling runs
#&gt;  nr    task_id       learner_id resampling_id iters warnings errors
#&gt;   1       easy       regr.rpart same_other_cv    18        0      0
#&gt;   2       easy regr.featureless same_other_cv    18        0      0
#&gt;   3 impossible       regr.rpart same_other_cv    18        0      0
#&gt;   4 impossible regr.featureless same_other_cv    18        0      0
</code></pre>
<p>The code below computes the test error for each split,</p>
<pre><code class="language-r">reg.bench.score &lt;- mlr3resampling::score(reg.bench.result)
reg.bench.score[1]
#&gt;    train.subsets test.fold test.subset person iteration                  test
#&gt;           &lt;char&gt;     &lt;int&gt;       &lt;int&gt;  &lt;int&gt;     &lt;int&gt;                &lt;list&gt;
#&gt; 1:           all         1           1      1         1  1, 3, 5, 6,12,13,...
#&gt;                    train                                uhash    nr
#&gt;                   &lt;list&gt;                               &lt;char&gt; &lt;int&gt;
#&gt; 1:  4, 7, 9,10,18,20,... 7eb31050-513c-4ba8-8551-1616e5820596     1
#&gt;               task task_id                       learner learner_id
#&gt;             &lt;list&gt;  &lt;char&gt;                        &lt;list&gt;     &lt;char&gt;
#&gt; 1: &lt;TaskRegr:easy&gt;    easy &lt;LearnerRegrRpart:regr.rpart&gt; regr.rpart
#&gt;                 resampling resampling_id       prediction regr.mse algorithm
#&gt;                     &lt;list&gt;        &lt;char&gt;           &lt;list&gt;    &lt;num&gt;    &lt;char&gt;
#&gt; 1: &lt;ResamplingSameOtherCV&gt; same_other_cv &lt;PredictionRegr&gt; 1.638015     rpart
</code></pre>
<p>The code below visualizes the resulting test accuracy numbers.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    scale_x_log10()+
    geom_point(aes(
      regr.mse, train.subsets, color=algorithm),
      shape=1,
      data=reg.bench.score)+
    facet_grid(
      task_id ~ person,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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SkrKwoULmzVr1jhlAQA0vjoCceXKlT169NixY4efnx+l9JtvvmmcsgAAGl8dgfjaa6/NmDEjLi6OELJo0aI333yzUaoCAHCCWgPx7bffbtu27caNG9v+qXXr1tnZ2Y1ZHAA0Nfv27XvmmWce9FG7du2aMGGCRqN5++23CSHHjh17iEYaQa0/3ZszZ86MGTPS09NXr17tmFn/UUEr8eIAACAASURBVIkAAGxMJlOfPn06dOig1+s3bdo0f/58Z1dUq1p7iB4eHn5+ft99992WLVv+8Y9/SCSS69ev8zv0KQA0cRzHvfTSS5GRkSEhIc8//3zVX2e88cYb0dHRffr0GTp06K5duwghixYtio6ObtWq1VtvvUUIOXTo0OTJk0ePHr1ixYrffvvt73//e3p6ekFBwQsvvEAIKSsrGzduXGxs7NixY61W67Fjx5KSkjp06BAeHj5v3rwXX3yxdevWQ4YMMRgMjbm+dQzu8Oabb548eTI/P59S+vLLLyclJS1atKhxKgMAp7tw4UJubm5ubi7HcXFxcVeuXLHN37Vr14EDB3JycgoLC+Pi4l588cUdO3b89NNPFy5cIIT06NGje/fuEolk69atmZmZERER+/btI4SsXr36woULq1atOnbs2IEDB3JzcyMiInr37r1//36pVHrmzJmcnByBQBAWFvbRRx+tWLEiJSVl9+7dw4cPb7T1reOiyvfff7958+ZmzZrJZLLdu3d/9tlnjVMWADQFHTt2XLVq1ddffz1//vyioiK9Xm+bv3fv3qeeekogEERERPTt25cQcuDAgWeeeUYmk8lksqeeeurAgQOEkG7dukVERNyz5Z49e0ZGRlJKu3btahsQt1+/fiEhIQEBAUFBQePGjaOUxsXF8TvoX53qCESDweAY6M1gMGB4XoDHypEjR4YNG2YwGP7617/Gx8c75pvNZsftXMrKymwTjjksy9pG8LzPnSqCg4Orzal6Rk4kEvFR/gOrIxBnzpw5ZMiQ69ev//vf/+7Tp8+sWbMapywAaAoOHjyYkpIybdo0qVR67tw5xzC9AwYM2LJli8ViuXHjxunTpwkh/fv337x5s16v12q1mzdvTkpKumeDFoul8ap/cHWcQ3zllVc6d+588OBBk8n02WefVf2IAAC3N2HChLS0tE6dOrVq1WrChAkvv/yybYzn4cOHHzt2rE2bNu3a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" alt="plot of chunk unnamed-chunk-9" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>for the easy task, training on same is just as good as all or other
subsets. rpart has much lower test error than featureless, in all
three train subsets.</li>
<li>for the impossible task, the least test error is using rpart with same train subsets; featureless with same train subsets is next best; training on all is substantially worse (for both featureless and rpart); training on other is even worse (patterns in the two people are completely different).</li>
<li>in a real data task, training on other will most likely not be quite as bad as in the impossible task above, but also not as good as in the easy task.</li>
</ul>
<h3 id="interactive-visualization-of-data-test-error-and-splits_1">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">inst &lt;- reg.bench.score$resampling[[1]]$instance
rect.expand &lt;- 0.2
grid.dt &lt;- data.table(x=seq(-abs.x, abs.x, l=101), y=0)
grid.task &lt;- mlr3::TaskRegr$new(&quot;grid&quot;, grid.dt, target=&quot;y&quot;)
pred.dt.list &lt;- list()
point.dt.list &lt;- list()
for(score.i in 1:nrow(reg.bench.score)){
  reg.bench.row &lt;- reg.bench.score[score.i]
  task.dt &lt;- data.table(
    reg.bench.row$task[[1]]$data(),
    reg.bench.row$resampling[[1]]$instance$id.dt)
  names(task.dt)[1] &lt;- &quot;y&quot;
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=reg.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ]
  point.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(task_id, iteration)],
    i.points)
  i.learner &lt;- reg.bench.row$learner[[1]]
  pred.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(
      task_id, iteration, algorithm
    )],
    as.data.table(
      i.learner$predict(grid.task)
    )[, .(x=grid.dt$x, y=response)]
  )
}
(pred.dt &lt;- rbindlist(pred.dt.list))
#&gt;          task_id iteration   algorithm     x        y
#&gt;           &lt;char&gt;     &lt;int&gt;      &lt;char&gt; &lt;num&gt;    &lt;num&gt;
#&gt;    1:       easy         1       rpart -2.00 3.557968
#&gt;    2:       easy         1       rpart -1.96 3.557968
#&gt;    3:       easy         1       rpart -1.92 3.557968
#&gt;    4:       easy         1       rpart -1.88 3.557968
#&gt;    5:       easy         1       rpart -1.84 3.557968
#&gt;   ---                                                
#&gt; 7268: impossible        18 featureless  1.84 7.204232
#&gt; 7269: impossible        18 featureless  1.88 7.204232
#&gt; 7270: impossible        18 featureless  1.92 7.204232
#&gt; 7271: impossible        18 featureless  1.96 7.204232
#&gt; 7272: impossible        18 featureless  2.00 7.204232
</code></pre>
<pre><code class="language-r">(point.dt &lt;- rbindlist(point.dt.list))
#&gt;           task_id iteration set.name row_id           y          x  fold person
#&gt;            &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;       &lt;num&gt;      &lt;num&gt; &lt;int&gt;  &lt;int&gt;
#&gt;     1:       easy         1     test      1  1.32996609 -0.9379653     1      1
#&gt;     2:       easy         1    train      2  0.24307692 -0.5115044     3      1
#&gt;     3:       easy         1     test      3 -0.23314657  0.2914135     1      1
#&gt;     4:       easy         1    train      4  1.73677545  1.6328312     2      1
#&gt;     5:       easy         1     test      5 -0.06356159 -1.1932723     1      1
#&gt;    ---                                                                         
#&gt; 21596: impossible        18    train    296  5.18094849  0.7257701     1      2
#&gt; 21597: impossible        18    train    297  9.60431191 -1.6033236     1      2
#&gt; 21598: impossible        18     test    298  7.51198770 -1.5243898     3      2
#&gt; 21599: impossible        18    train    299 11.03539747 -1.7982414     1      2
#&gt; 21600: impossible        18     test    300 10.71968480  1.7170157     3      2
#&gt;        subset display_row
#&gt;         &lt;int&gt;       &lt;int&gt;
#&gt;     1:      1           1
#&gt;     2:      1         101
#&gt;     3:      1           2
#&gt;     4:      1          51
#&gt;     5:      1           3
#&gt;    ---                   
#&gt; 21596:      2         198
#&gt; 21597:      2         199
#&gt; 21598:      2         299
#&gt; 21599:      2         200
#&gt; 21600:      2         300
</code></pre>
<pre><code class="language-r">set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
make_person_subset &lt;- function(DT){
  DT[, &quot;person/subset&quot; := person]
}
make_person_subset(point.dt)
make_person_subset(reg.bench.score)

if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Train/predict on subsets, regression&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      geom_point(aes(
        x, y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        shape=21,
        data=point.dt)+
      scale_color_manual(values=algo.colors)+
      geom_line(aes(
        x, y, color=algorithm, subset=paste(algorithm, iteration)),
        showSelected=&quot;iteration&quot;,
        data=pred.dt)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;)+
      scale_y_continuous(
        breaks=seq(-100, 100, by=2)),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400)+
      scale_y_log10(
        &quot;Mean squared error on test set&quot;)+
      scale_fill_manual(values=algo.colors)+
      scale_x_discrete(
        &quot;People/subsets in train set&quot;)+
      geom_point(aes(
        train.subsets, regr.mse, fill=algorithm),
        shape=1,
        size=5,
        stroke=2,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=reg.bench.score)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        scales=&quot;free&quot;),
    diagram=ggplot()+
      ggtitle(&quot;Select train/test split&quot;)+
      theme_bw()+
      theme_animint(height=300)+
      facet_grid(
        . ~ train.subsets,
        scales=&quot;free&quot;,
        space=&quot;free&quot;)+
      scale_size_manual(values=c(subset=3, fold=1))+
      scale_color_manual(values=c(subset=&quot;orange&quot;, fold=&quot;grey50&quot;))+
      geom_rect(aes(
        xmin=-Inf, xmax=Inf,
        color=rows,
        size=rows,
        ymin=display_row, ymax=display_end),
        fill=NA,
        data=inst$viz.rect.dt)+
      scale_fill_manual(values=set.colors)+
      geom_rect(aes(
        xmin=iteration-rect.expand, ymin=display_row,
        xmax=iteration+rect.expand, ymax=display_end,
        fill=set.name),
        clickSelects=&quot;iteration&quot;,
        data=inst$viz.set.dt)+
      geom_text(aes(
        ifelse(rows==&quot;subset&quot;, Inf, -Inf),
        (display_row+display_end)/2,
        hjust=ifelse(rows==&quot;subset&quot;, 1, 0),
        label=paste0(rows, &quot;=&quot;, ifelse(rows==&quot;subset&quot;, subset, fold))),
        data=data.table(train.name=&quot;same&quot;, inst$viz.rect.dt))+
      scale_x_continuous(
        &quot;Split number / cross-validation iteration&quot;)+
      scale_y_continuous(
        &quot;Row number&quot;),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/ResamplingSameOtherCV.Rmd&quot;)
  viz
}
</code></pre>
<script>
// Copyright (c) 2013, Michael Bostock
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:

// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.

// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.

// * The name Michael Bostock may not be used to endorse or promote products
//   derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d3 = function() {
  var π = Math.PI, ε = 1e-6, d3 = {
    version: "3.0.6"
  }, d3_radians = π / 180, d3_degrees = 180 / π, d3_document = document, d3_window = window;
  function d3_target(d) {
    return d.target;
  }
  function d3_source(d) {
    return d.source;
  }
  var d3_format_decimalPoint = ".", d3_format_thousandsSeparator = ",", d3_format_grouping = [ 3, 3 ];
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  try {
    d3_document.createElement("div").style.setProperty("opacity", 0, "");
  } catch (error) {
    var d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + "", priority);
    };
  }
  function d3_class(ctor, properties) {
    try {
      for (var key in properties) {
        Object.defineProperty(ctor.prototype, key, {
          value: properties[key],
          enumerable: false
        });
      }
    } catch (e) {
      ctor.prototype = properties;
    }
  }
  var d3_array = d3_arraySlice;
  function d3_arrayCopy(pseudoarray) {
    var i = -1, n = pseudoarray.length, array = [];
    while (++i < n) array.push(pseudoarray[i]);
    return array;
  }
  function d3_arraySlice(pseudoarray) {
    return Array.prototype.slice.call(pseudoarray);
  }
  try {
    d3_array(d3_document.documentElement.childNodes)[0].nodeType;
  } catch (e) {
    d3_array = d3_arrayCopy;
  }
  var d3_arraySubclass = [].__proto__ ? function(array, prototype) {
    array.__proto__ = prototype;
  } : function(array, prototype) {
    for (var property in prototype) array[property] = prototype[property];
  };
  d3.map = function(object) {
    var map = new d3_Map();
    for (var key in object) map.set(key, object[key]);
    return map;
  };
  function d3_Map() {}
  d3_class(d3_Map, {
    has: function(key) {
      return d3_map_prefix + key in this;
    },
    get: function(key) {
      return this[d3_map_prefix + key];
    },
    set: function(key, value) {
      return this[d3_map_prefix + key] = value;
    },
    remove: function(key) {
      key = d3_map_prefix + key;
      return key in this && delete this[key];
    },
    keys: function() {
      var keys = [];
      this.forEach(function(key) {
        keys.push(key);
      });
      return keys;
    },
    values: function() {
      var values = [];
      this.forEach(function(key, value) {
        values.push(value);
      });
      return values;
    },
    entries: function() {
      var entries = [];
      this.forEach(function(key, value) {
        entries.push({
          key: key,
          value: value
        });
      });
      return entries;
    },
    forEach: function(f) {
      for (var key in this) {
        if (key.charCodeAt(0) === d3_map_prefixCode) {
          f.call(this, key.substring(1), this[key]);
        }
      }
    }
  });
  var d3_map_prefix = "\0", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
  function d3_identity(d) {
    return d;
  }
  function d3_true() {
    return true;
  }
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return arguments.length ? target : value;
    };
  }
  d3.ascending = function(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  };
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.mean = function(array, f) {
    var n = array.length, a, m = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
    } else {
      while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
    }
    return j ? m : undefined;
  };
  d3.median = function(array, f) {
    if (arguments.length > 1) array = array.map(f);
    array = array.filter(d3_number);
    return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s / m;
      };
    }
  };
  function d3_number(x) {
    return x != null && !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (!isNaN(a = +array[i])) s += a;
    } else {
      while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.shuffle = function(array) {
    var m = array.length, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m], array[m] = array[i], array[i] = t;
    }
    return array;
  };
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.bisector = function(f) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (f.call(a, a[mid], mid) < x) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (x < f.call(a, a[mid], mid)) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  };
  var d3_bisector = d3.bisector(function(d) {
    return d;
  });
  d3.bisectLeft = d3_bisector.left;
  d3.bisect = d3.bisectRight = d3_bisector.right;
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, valuesByKey = new d3_Map(), values, o = {};
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      valuesByKey.forEach(function(keyValue, values) {
        o[keyValue] = map(values, depth);
      });
      return o;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var a = [], sortKey = sortKeys[depth++], key;
      for (key in map) {
        a.push({
          key: key,
          values: entries(map[key], depth)
        });
      }
      if (sortKey) a.sort(function(a, b) {
        return sortKey(a.key, b.key);
      });
      return a;
    }
    nest.map = function(array) {
      return map(array, 0);
    };
    nest.entries = function(array) {
      return entries(map(array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.permute = function(array, indexes) {
    var permutes = [], i = -1, n = indexes.length;
    while (++i < n) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.merge = function(arrays) {
    return Array.prototype.concat.apply([], arrays);
  };
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(Math.abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  d3.xhr = function(url, mimeType, callback) {
    var xhr = {}, dispatch = d3.dispatch("progress", "load", "error"), headers = {}, response = d3_identity, request = new (d3_window.XDomainRequest && /^(http(s)?:)?\/\//.test(url) ? XDomainRequest : XMLHttpRequest)();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var s = request.status;
      !s && request.responseText || s >= 200 && s < 300 || s === 304 ? dispatch.load.call(xhr, response.call(xhr, request)) : dispatch.error.call(xhr, request);
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
    mimeType = null;
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  };
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  d3.text = function() {
    return d3.xhr.apply(d3, arguments).response(d3_text);
  };
  function d3_text(request) {
    return request.responseText;
  }
  d3.json = function(url, callback) {
    return d3.xhr(url, "application/json", callback).response(d3_json);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3.xhr(url, "text/html", callback).response(d3_html);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = function() {
    return d3.xhr.apply(d3, arguments).response(d3_xml);
  };
  function d3_xml(request) {
    return request.responseXML;
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.substring(0, i);
        name = name.substring(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i > 0) {
      name = type.substring(i + 1);
      type = type.substring(0, i);
    }
    return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.format = function(specifier) {
    var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "", basePrefix = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, suffix = "", integer = false;
    if (precision) precision = +precision.substring(1);
    if (zfill || fill === "0" && align === "=") {
      zfill = fill = "0";
      align = "=";
      if (comma) width -= Math.floor((width - 1) / 4);
    }
    switch (type) {
     case "n":
      comma = true;
      type = "g";
      break;

     case "%":
      scale = 100;
      suffix = "%";
      type = "f";
      break;

     case "p":
      scale = 100;
      suffix = "%";
      type = "r";
      break;

     case "b":
     case "o":
     case "x":
     case "X":
      if (basePrefix) basePrefix = "0" + type.toLowerCase();

     case "c":
     case "d":
      integer = true;
      precision = 0;
      break;

     case "s":
      scale = -1;
      type = "r";
      break;
    }
    if (basePrefix === "#") basePrefix = "";
    if (type == "r" && !precision) type = "g";
    type = d3_format_types.get(type) || d3_format_typeDefault;
    var zcomma = zfill && comma;
    return function(value) {
      if (integer && value % 1) return "";
      var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
      if (scale < 0) {
        var prefix = d3.formatPrefix(value, precision);
        value = prefix.scale(value);
        suffix = prefix.symbol;
      } else {
        value *= scale;
      }
      value = type(value, precision);
      if (!zfill && comma) value = d3_format_group(value);
      var length = basePrefix.length + value.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
      if (zcomma) value = d3_format_group(padding + value);
      if (d3_format_decimalPoint) value.replace(".", d3_format_decimalPoint);
      negative += basePrefix;
      return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix;
    };
  };
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?([0-9]+)?(,)?(\.[0-9]+)?([a-zA-Z%])?/;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_format_group = d3_identity;
  if (d3_format_grouping) {
    var d3_format_groupingLength = d3_format_grouping.length;
    d3_format_group = function(value) {
      var i = value.lastIndexOf("."), f = i >= 0 ? "." + value.substring(i + 1) : (i = value.length, 
      ""), t = [], j = 0, g = d3_format_grouping[0];
      while (i > 0 && g > 0) {
        t.push(value.substring(i -= g, i + g));
        g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];
      }
      return t.reverse().join(d3_format_thousandsSeparator || "") + f;
    };
  }
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, Math.abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * π / 2);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / (2 * π) * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * π / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.event = null;
  function d3_eventCancel() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      g.setAttribute("transform", string);
      var t = g.transform.baseVal.consolidate();
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolate = function(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  };
  d3.interpolateNumber = function(a, b) {
    b -= a;
    return function(t) {
      return a + b * t;
    };
  };
  d3.interpolateRound = function(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  };
  d3.interpolateString = function(a, b) {
    var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;
    d3_interpolate_number.lastIndex = 0;
    for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
      if (m.index) s.push(b.substring(s0, s1 = m.index));
      q.push({
        i: s.length,
        x: m[0]
      });
      s.push(null);
      s0 = d3_interpolate_number.lastIndex;
    }
    if (s0 < b.length) s.push(b.substring(s0));
    for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
      o = q[i];
      if (o.x == m[0]) {
        if (o.i) {
          if (s[o.i + 1] == null) {
            s[o.i - 1] += o.x;
            s.splice(o.i, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          } else {
            s[o.i - 1] += o.x + s[o.i + 1];
            s.splice(o.i, 2);
            for (j = i + 1; j < n; ++j) q[j].i -= 2;
          }
        } else {
          if (s[o.i + 1] == null) {
            s[o.i] = o.x;
          } else {
            s[o.i] = o.x + s[o.i + 1];
            s.splice(o.i + 1, 1);
            for (j = i + 1; j < n; ++j) q[j].i--;
          }
        }
        q.splice(i, 1);
        n--;
        i--;
      } else {
        o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
      }
    }
    while (i < n) {
      o = q.pop();
      if (s[o.i + 1] == null) {
        s[o.i] = o.x;
      } else {
        s[o.i] = o.x + s[o.i + 1];
        s.splice(o.i + 1, 1);
      }
      n--;
    }
    if (s.length === 1) {
      return s[0] == null ? q[0].x : function() {
        return b;
      };
    }
    return function(t) {
      for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateTransform = function(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3.interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3.interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3.interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3.interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3.interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3.interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
  d3.interpolateRgb = function(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  };
  d3.interpolateHsl = function(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var h0 = a.h, s0 = a.s, l0 = a.l, h1 = b.h - h0, s1 = b.s - s0, l1 = b.l - l0;
    if (h1 > 180) h1 -= 360; else if (h1 < -180) h1 += 360;
    return function(t) {
      return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t) + "";
    };
  };
  d3.interpolateLab = function(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  };
  d3.interpolateHcl = function(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  };
  d3.interpolateArray = function(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  };
  d3.interpolateObject = function(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolateByName(k)(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  };
  var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  function d3_interpolateByName(name) {
    return name == "transform" ? d3.interpolateTransform : d3.interpolate;
  }
  d3.interpolators = [ d3.interpolateObject, function(a, b) {
    return b instanceof Array && d3.interpolateArray(a, b);
  }, function(a, b) {
    return (typeof a === "string" || typeof b === "string") && d3.interpolateString(a + "", b + "");
  }, function(a, b) {
    return (typeof b === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) : b instanceof d3_Color) && d3.interpolateRgb(a, b);
  }, function(a, b) {
    return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b);
  } ];
  function d3_uninterpolateNumber(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return (x - a) * b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = b - (a = +a) ? 1 / (b - a) : 0;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) * b));
    };
  }
  function d3_Color() {}
  d3_Color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.rgb = function(r, g, b) {
    return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);
  };
  function d3_rgb(r, g, b) {
    return new d3_Rgb(r, g, b);
  }
  function d3_Rgb(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return d3_rgb(Math.min(255, Math.floor(r / k)), Math.min(255, Math.floor(g / k)), Math.min(255, Math.floor(b / k)));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_rgb(Math.floor(k * this.r), Math.floor(k * this.g), Math.floor(k * this.b));
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, name;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);
    if (format != null && format.charAt(0) === "#") {
      if (format.length === 4) {
        r = format.charAt(1);
        r += r;
        g = format.charAt(2);
        g += g;
        b = format.charAt(3);
        b += b;
      } else if (format.length === 7) {
        r = format.substring(1, 3);
        g = format.substring(3, 5);
        b = format.substring(5, 7);
      }
      r = parseInt(r, 16);
      g = parseInt(g, 16);
      b = parseInt(b, 16);
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      s = h = 0;
    }
    return d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));
  });
  d3.hsl = function(h, s, l) {
    return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);
  };
  function d3_hsl(h, s, l) {
    return new d3_Hsl(h, s, l);
  }
  function d3_Hsl(h, s, l) {
    this.h = h;
    this.s = s;
    this.l = l;
  }
  var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = h % 360;
    if (h < 0) h += 360;
    s = s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = function(h, c, l) {
    return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);
  };
  function d3_hcl(h, c, l) {
    return new d3_Hcl(h, c, l);
  }
  function d3_Hcl(h, c, l) {
    this.h = h;
    this.c = c;
    this.l = l;
  }
  var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();
  d3_hclPrototype.brighter = function(k) {
    return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = function(l, a, b) {
    return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);
  };
  function d3_lab(l, a, b) {
    return new d3_Lab(l, a, b);
  }
  function d3_Lab(l, a, b) {
    this.l = l;
    this.a = a;
    this.b = b;
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_Lab.prototype = new d3_Color();
  d3_labPrototype.brighter = function(k) {
    return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return d3_hcl(Math.atan2(b, a) / π * 180, Math.sqrt(a * a + b * b), l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  function d3_selection(groups) {
    d3_arraySubclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectRoot = d3_document.documentElement, d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector, d3_selectMatches = function(n, s) {
    return d3_selectMatcher.call(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = function(s, n) {
      return Sizzle.uniqueSort(Sizzle(s, n));
    };
    d3_selectMatches = Sizzle.matchesSelector;
  }
  var d3_selectionPrototype = [];
  d3.selection = function() {
    return d3_selectionRoot;
  };
  d3.selection.prototype = d3_selectionPrototype;
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return function() {
      return d3_selectAll(selector, this);
    };
  }
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = name.trim().split(/^|\s+/g)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.className;
          if (value.baseVal != null) value = value.baseVal;
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classed(name, value) {
    name = name.trim().split(/\s+/).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.className, cb = c.baseVal != null, cv = cb ? c.baseVal : c;
      if (value) {
        re.lastIndex = 0;
        if (!re.test(cv)) {
          cv = d3_collapse(cv + " " + name);
          if (cb) c.baseVal = cv; else node.className = cv;
        }
      } else if (cv) {
        cv = d3_collapse(cv.replace(re, " "));
        if (cb) c.baseVal = cv; else node.className = cv;
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3.ns.qualify(name);
    function append() {
      return this.appendChild(d3_document.createElementNS(this.namespaceURI, name));
    }
    function appendNS() {
      return this.appendChild(d3_document.createElementNS(name.space, name.local));
    }
    return this.select(name.local ? appendNS : append);
  };
  d3_selectionPrototype.insert = function(name, before) {
    name = d3.ns.qualify(name);
    function insert() {
      return this.insertBefore(d3_document.createElementNS(this.namespaceURI, name), d3_select(before, this));
    }
    function insertNS() {
      return this.insertBefore(d3_document.createElementNS(name.space, name.local), d3_select(before, this));
    }
    return this.select(name.local ? insertNS : insert);
  };
  d3_selectionPrototype.remove = function() {
    return this.each(function() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    });
  };
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;
        for (i = -1; ++i < n; ) {
          keyValue = key.call(node = group[i], node.__data__, i);
          if (nodeByKeyValue.has(keyValue)) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues.push(keyValue);
        }
        for (i = -1; ++i < m; ) {
          keyValue = key.call(groupData, nodeData = groupData[i], i);
          if (node = nodeByKeyValue.get(keyValue)) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          } else if (!dataByKeyValue.has(keyValue)) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
          dataByKeyValue.set(keyValue, nodeData);
          nodeByKeyValue.remove(keyValue);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValues[i])) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3.ascending;
    return function(a, b) {
      return !a - !b || comparator(a.__data__, b.__data__);
    };
  }
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf(".");
    if (i > 0) type = type.substring(0, i);
    function onRemove() {
      var wrapper = this[name];
      if (wrapper) {
        this.removeEventListener(type, wrapper, wrapper.$);
        delete this[name];
      }
    }
    function onAdd() {
      var node = this, args = d3_array(arguments);
      onRemove.call(this);
      this.addEventListener(type, this[name] = wrapper, wrapper.$ = capture);
      wrapper._ = listener;
      function wrapper(e) {
        var o = d3.event;
        d3.event = e;
        args[0] = node.__data__;
        try {
          listener.apply(node, args);
        } finally {
          d3.event = o;
        }
      }
    }
    return listener ? onAdd : onRemove;
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.transition = function() {
    var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = Object.create(d3_transitionInherit);
    transition.time = Date.now();
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id);
  };
  var d3_selectionRoot = d3_selection([ [ d3_document ] ]);
  d3_selectionRoot[0].parentNode = d3_selectRoot;
  d3.select = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.select(selector) : d3_selection([ [ selector ] ]);
  };
  d3.selectAll = function(selector) {
    return typeof selector === "string" ? d3_selectionRoot.selectAll(selector) : d3_selection([ d3_array(selector) ]);
  };
  function d3_selection_enter(selection) {
    d3_arraySubclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_transition(groups, id) {
    d3_arraySubclass(groups, d3_transitionPrototype);
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit = {
    ease: d3_ease_cubicInOut,
    delay: 0,
    duration: 250
  };
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3.transition = function(selection) {
    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
  };
  d3.transition.prototype = d3_transitionPrototype;
  function d3_transitionNode(node, i, id, inherit) {
    var lock = node.__transition__ || (node.__transition__ = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        event: d3.dispatch("start", "end"),
        time: time,
        ease: inherit.ease,
        delay: inherit.delay,
        duration: inherit.duration
      };
      ++lock.count;
      d3.timer(function(elapsed) {
        var d = node.__data__, ease = transition.ease, event = transition.event, delay = transition.delay, duration = transition.duration, tweened = [];
        return delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time), 1;
        function start(elapsed) {
          if (lock.active > id) return stop();
          lock.active = id;
          event.start.call(node, d, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, d, i)) {
              tweened.push(value);
            }
          });
          if (!tick(elapsed)) d3.timer(tick, 0, time);
          return 1;
        }
        function tick(elapsed) {
          if (lock.active !== id) return stop();
          var t = (elapsed - delay) / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            stop();
            event.end.call(node, d, i);
            return 1;
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node.__transition__;
          return 1;
        }
      }, 0, time);
      return transition;
    }
  }
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnode, node;
    if (typeof selector !== "function") selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, id, node.__transition__[id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
    if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node.__transition__[id];
          subnodes = selector.call(node, node.__data__, i);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            d3_transitionNode(subnode = subnodes[k], k, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.id, this.time).ease(this.ease());
  };
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = d3_interpolateByName(nameNS), name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    return d3_transition_tween(this, "attr." + nameNS, value, function(b) {
      function attrString() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      }
      function attrStringNS() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      }
      return b == null ? name.local ? attrNullNS : attrNull : (b += "", name.local ? attrStringNS : attrString);
    });
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    var interpolate = d3_interpolateByName(name);
    function styleNull() {
      this.style.removeProperty(name);
    }
    return d3_transition_tween(this, "style." + name, value, function(b) {
      function styleString() {
        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      }
      return b == null ? styleNull : (b += "", styleString);
    });
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    return this.tween("style." + name, function(d, i) {
      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    });
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    return this.each("end.transition", function() {
      var p;
      if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id;
    if (arguments.length < 1) return this.node().__transition__[id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node.__transition__[id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].delay = value.call(node, node.__data__, i, j) | 0;
    } : (value |= 0, function(node) {
      node.__transition__[id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j) | 0);
    } : (value = Math.max(1, value | 0), function(node) {
      node.__transition__[id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      d3_transitionInheritId = id;
      d3_selection_each(this, function(node, i, j) {
        d3_transitionInherit = node.__transition__[id];
        type.call(node, node.__data__, i, j);
      });
      d3_transitionInherit = inherit;
      d3_transitionInheritId = inheritId;
    } else {
      d3_selection_each(this, function(node) {
        node.__transition__[id].event.on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = Object.create(node.__transition__[id0]);
          transition.delay += transition.duration;
          d3_transitionNode(node, i, id1, transition);
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, id1);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id;
    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node.__transition__[id].tween.remove(name);
    } : function(node) {
      node.__transition__[id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node.__transition__[id].tween.set(name, value);
    }));
  }
  var d3_timer_id = 0, d3_timer_byId = {}, d3_timer_queue = null, d3_timer_interval, d3_timer_timeout;
  d3.timer = function(callback, delay, then) {
    if (arguments.length < 3) {
      if (arguments.length < 2) delay = 0; else if (!isFinite(delay)) return;
      then = Date.now();
    }
    var timer = d3_timer_byId[callback.id];
    if (timer && timer.callback === callback) {
      timer.then = then;
      timer.delay = delay;
    } else d3_timer_byId[callback.id = ++d3_timer_id] = d3_timer_queue = {
      callback: callback,
      then: then,
      delay: delay,
      next: d3_timer_queue
    };
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    var delay = d3_timer_flush() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    var elapsed, now = Date.now(), t1 = d3_timer_queue;
    while (t1) {
      elapsed = now - t1.then;
      if (!t1.delay) t1.flush = t1.callback(elapsed);
      t1 = t1.next;
    }
    d3_timer_flush();
  };
  function d3_timer_flush() {
    var t0 = null, t1 = d3_timer_queue, then = Infinity;
    while (t1) {
      if (t1.flush) {
        delete d3_timer_byId[t1.callback.id];
        t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
      } else {
        then = Math.min(then, t1.then + t1.delay);
        t1 = (t0 = t1).next;
      }
    }
    return then;
  }
  var d3_timer_frame = d3_window.requestAnimationFrame || d3_window.webkitRequestAnimationFrame || d3_window.mozRequestAnimationFrame || d3_window.oRequestAnimationFrame || d3_window.msRequestAnimationFrame || function(callback) {
    setTimeout(callback, 17);
  };
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
        svg = d3.select(d3_document.body).append("svg").style("position", "absolute").style("top", 0).style("left", 0);
        var ctm = svg[0][0].getScreenCTM();
        d3_mouse_bug44083 = !(ctm.f || ctm.e);
        svg.remove();
      }
      if (d3_mouse_bug44083) {
        point.x = e.pageX;
        point.y = e.pageY;
      } else {
        point.x = e.clientX;
        point.y = e.clientY;
      }
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  function d3_noop() {}
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    if (nice = nice(x1 - x0)) {
      domain[i0] = nice.floor(x0);
      domain[i1] = nice.ceil(x1);
    }
    return domain;
  }
  function d3_scale_niceDefault() {
    return Math;
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3.interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3.interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3.interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    scale.nice = function() {
      d3_scale_nice(domain, d3_scale_linearNice);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(dx) {
    dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
    return dx && {
      floor: function(x) {
        return Math.floor(x / dx) * dx;
      },
      ceil: function(x) {
        return Math.ceil(x / dx) * dx;
      }
    };
  }
  function d3_scale_linearTickRange(domain, m) {
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m) {
    return d3.format(",." + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + "f");
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear(), d3_scale_logp);
  };
  function d3_scale_log(linear, log) {
    var pow = log.pow;
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(pow);
      log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;
      pow = log.pow;
      linear.domain(x.map(log));
      return scale;
    };
    scale.nice = function() {
      linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(linear.domain()), ticks = [];
      if (extent.every(isFinite)) {
        var i = Math.floor(extent[0]), j = Math.ceil(extent[1]), u = pow(extent[0]), v = pow(extent[1]);
        if (log === d3_scale_logn) {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);
        } else {
          for (;i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (arguments.length < 2) format = d3_scale_logFormat;
      if (!arguments.length) return format;
      var k = Math.max(.1, n / scale.ticks().length), f = log === d3_scale_logn ? (e = -1e-12, 
      Math.floor) : (e = 1e-12, Math.ceil), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), log);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e");
  function d3_scale_logp(x) {
    return Math.log(x < 0 ? 0 : x) / Math.LN10;
  }
  function d3_scale_logn(x) {
    return -Math.log(x > 0 ? 0 : -x) / Math.LN10;
  }
  d3_scale_logp.pow = function(x) {
    return Math.pow(10, x);
  };
  d3_scale_logn.pow = function(x) {
    return -Math.pow(10, -x);
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1);
  };
  function d3_scale_pow(linear, exponent) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(powb);
      linear.domain(x.map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(scale.domain(), m);
    };
    scale.tickFormat = function(m) {
      return d3_scale_linearTickFormat(scale.domain(), m);
    };
    scale.nice = function() {
      return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      var domain = scale.domain();
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      return scale.domain(domain);
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
      range = steps(start + Math.round(error / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf" ];
  var d3_category20 = [ "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5" ];
  var d3_category20b = [ "#393b79", "#5254a3", "#6b6ecf", "#9c9ede", "#637939", "#8ca252", "#b5cf6b", "#cedb9c", "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94", "#843c39", "#ad494a", "#d6616b", "#e7969c", "#7b4173", "#a55194", "#ce6dbd", "#de9ed6" ];
  var d3_category20c = [ "#3182bd", "#6baed6", "#9ecae1", "#c6dbef", "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2", "#31a354", "#74c476", "#a1d99b", "#c7e9c0", "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb", "#636363", "#969696", "#bdbdbd", "#d9d9d9" ];
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (isNaN(x = +x)) return NaN;
      return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.filter(function(d) {
        return !isNaN(d);
      }).sort(d3.ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m) {
      return d3_scale_linearTickFormat(domain, m);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function arc() {
      var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, 
      a0 = a1, a1 = da), a1 - a0), df = da < π ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
      return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcOffset = -π / 2, d3_svg_arcMax = 2 * π - 1e-6;
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_line(projection) {
    var x = d3_svg_lineX, y = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  function d3_svg_lineX(d) {
    return d[0];
  }
  function d3_svg_lineY(d) {
    return d[1];
  }
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0 ];
    d3_svg_lineBasisBezier(path, px, py);
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    i = -1;
    while (++i < 2) {
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (Math.abs(d) < 1e-6) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] + d3_svg_arcOffset;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_svg_lineX, x1 = d3_svg_lineX, y0 = 0, y1 = d3_svg_lineY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, tickMajorSize = 6, tickMinorSize = 6, tickEndSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_, tickSubdivide = 0;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain() : tickValues, tickFormat = tickFormat_ == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String : tickFormat_;
        var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide), subtick = g.selectAll(".tick.minor").data(subticks, String), subtickEnter = subtick.enter().insert("line", ".tick").attr("class", "tick minor").style("opacity", 1e-6), subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(), subtickUpdate = d3.transition(subtick).style("opacity", 1);
        var tick = g.selectAll(".tick.major").data(ticks, String), tickEnter = tick.enter().insert("g", "path").attr("class", "tick major").style("opacity", 1e-6), tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(), tickUpdate = d3.transition(tick).style("opacity", 1), tickTransform;
        var range = d3_scaleRange(scale), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        var scale1 = scale.copy(), scale0 = this.__chart__ || scale1;
        this.__chart__ = scale1;
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text");
        switch (orient) {
         case "bottom":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize);
            lineEnter.attr("y2", tickMajorSize);
            textEnter.attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", 0).attr("y2", tickMajorSize);
            textUpdate.attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding);
            text.attr("dy", ".71em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
            break;
          }

         case "top":
          {
            tickTransform = d3_svg_axisX;
            subtickEnter.attr("y2", -tickMinorSize);
            subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize);
            lineEnter.attr("y2", -tickMajorSize);
            textEnter.attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", 0).attr("y2", -tickMajorSize);
            textUpdate.attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
            text.attr("dy", "0em").style("text-anchor", "middle");
            pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
            break;
          }

         case "left":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", -tickMinorSize);
            subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", -tickMajorSize);
            textEnter.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding));
            lineUpdate.attr("x2", -tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "end");
            pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
            break;
          }

         case "right":
          {
            tickTransform = d3_svg_axisY;
            subtickEnter.attr("x2", tickMinorSize);
            subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0);
            lineEnter.attr("x2", tickMajorSize);
            textEnter.attr("x", Math.max(tickMajorSize, 0) + tickPadding);
            lineUpdate.attr("x2", tickMajorSize).attr("y2", 0);
            textUpdate.attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0);
            text.attr("dy", ".32em").style("text-anchor", "start");
            pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize);
            break;
          }
        }
        if (scale.ticks) {
          tickEnter.call(tickTransform, scale0);
          tickUpdate.call(tickTransform, scale1);
          tickExit.call(tickTransform, scale1);
          subtickEnter.call(tickTransform, scale0);
          subtickUpdate.call(tickTransform, scale1);
          subtickExit.call(tickTransform, scale1);
        } else {
          var dx = scale1.rangeBand() / 2, x = function(d) {
            return scale1(d) + dx;
          };
          tickEnter.call(tickTransform, x);
          tickUpdate.call(tickTransform, x);
        }
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x, y) {
      if (!arguments.length) return tickMajorSize;
      var n = arguments.length - 1;
      tickMajorSize = +x;
      tickMinorSize = n > 1 ? +y : tickMajorSize;
      tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function(x) {
      if (!arguments.length) return tickSubdivide;
      tickSubdivide = +x;
      return axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x) {
    selection.attr("transform", function(d) {
      return "translate(" + x(d) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y) {
    selection.attr("transform", function(d) {
      return "translate(0," + y(d) + ")";
    });
  }
  function d3_svg_axisSubdivide(scale, ticks, m) {
    subticks = [];
    if (m && ticks.length > 1) {
      var extent = d3_scaleExtent(scale.domain()), subticks, i = -1, n = ticks.length, d = (ticks[1] - ticks[0]) / ++m, j, v;
      while (++i < n) {
        for (j = m; --j > 0; ) {
          if ((v = +ticks[i] - j * d) >= extent[0]) {
            subticks.push(v);
          }
        }
      }
      for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1]; ) {
        subticks.push(v);
      }
    }
    return subticks;
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, resizes = d3_svg_brushResizes[0], extent = [ [ 0, 0 ], [ 0, 0 ] ], extentDomain;
    function brush(g) {
      g.each(function() {
        var g = d3.select(this), bg = g.selectAll(".background").data([ 0 ]), fg = g.selectAll(".extent").data([ 0 ]), tz = g.selectAll(".resize").data(resizes, String), e;
        g.style("pointer-events", "all").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        bg.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        fg.enter().append("rect").attr("class", "extent").style("cursor", "move");
        tz.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        tz.style("display", brush.empty() ? "none" : null);
        tz.exit().remove();
        if (x) {
          e = d3_scaleRange(x);
          bg.attr("x", e[0]).attr("width", e[1] - e[0]);
          redrawX(g);
        }
        if (y) {
          e = d3_scaleRange(y);
          bg.attr("y", e[0]).attr("height", e[1] - e[0]);
          redrawY(g);
        }
        redraw(g);
      });
    }
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", extent[0][0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", extent[0][1]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), center, origin = mouse(), offset;
      var w = d3.select(d3_window).on("mousemove.brush", brushmove).on("mouseup.brush", brushend).on("touchmove.brush", brushmove).on("touchend.brush", brushend).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (dragging) {
        origin[0] = extent[0][0] - origin[0];
        origin[1] = extent[0][1] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1] ];
        origin[0] = extent[ex][0];
        origin[1] = extent[ey][1];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      d3_eventCancel();
      function mouse() {
        var touches = d3.event.changedTouches;
        return touches ? d3.touches(target, touches)[0] : d3.mouse(target);
      }
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= extent[1][0];
            origin[1] -= extent[1][1];
            dragging = 2;
          }
          d3_eventCancel();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += extent[1][0];
          origin[1] += extent[1][1];
          dragging = 0;
          d3_eventCancel();
        }
      }
      function brushmove() {
        var point = mouse(), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2 ];
            origin[0] = extent[+(point[0] < center[0])][0];
            origin[1] = extent[+(point[1] < center[1])][1];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], size = extent[1][i] - extent[0][i], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = Math.max(r0, Math.min(r1, point[i]));
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0][i] !== min || extent[1][i] !== max) {
          extentDomain = null;
          extent[0][i] = min;
          extent[1][i] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        event_({
          type: "brushend"
        });
        d3_eventCancel();
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        z = extentDomain || extent;
        if (x) {
          x0 = z[0][0], x1 = z[1][0];
          if (!extentDomain) {
            x0 = extent[0][0], x1 = extent[1][0];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          y0 = z[0][1], y1 = z[1][1];
          if (!extentDomain) {
            y0 = extent[0][1], y1 = extent[1][1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      extentDomain = [ [ 0, 0 ], [ 0, 0 ] ];
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        extentDomain[0][0] = x0, extentDomain[1][0] = x1;
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        extentDomain[0][1] = y0, extentDomain[1][1] = y1;
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;
      }
      return brush;
    };
    brush.clear = function() {
      extentDomain = null;
      extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;
      return brush;
    };
    brush.empty = function() {
      return x && extent[0][0] === extent[1][0] || y && extent[0][1] === extent[1][1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  d3.behavior = {};
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null;
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", mousedown);
    }
    function mousedown() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, touchId = d3.event.touches ? d3.event.changedTouches[0].identifier : null, offset, origin_ = point(), moved = 0;
      var w = d3.select(d3_window).on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", dragmove).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", dragend, true);
      if (origin) {
        offset = origin.apply(target, arguments);
        offset = [ offset.x - origin_[0], offset.y - origin_[1] ];
      } else {
        offset = [ 0, 0 ];
      }
      if (touchId == null) d3_eventCancel();
      event_({
        type: "dragstart"
      });
      function point() {
        var p = target.parentNode;
        return touchId != null ? d3.touches(p).filter(function(p) {
          return p.identifier === touchId;
        })[0] : d3.mouse(p);
      }
      function dragmove() {
        if (!target.parentNode) return dragend();
        var p = point(), dx = p[0] - origin_[0], dy = p[1] - origin_[1];
        moved |= dx | dy;
        origin_ = p;
        d3_eventCancel();
        event_({
          type: "drag",
          x: p[0] + offset[0],
          y: p[1] + offset[1],
          dx: dx,
          dy: dy
        });
      }
      function dragend() {
        event_({
          type: "dragend"
        });
        if (moved) {
          d3_eventCancel();
          if (d3.event.target === eventTarget) w.on("click.drag", click, true);
        }
        w.on(touchId != null ? "touchmove.drag-" + touchId : "mousemove.drag", null).on(touchId != null ? "touchend.drag-" + touchId : "mouseup.drag", null);
      }
      function click() {
        d3_eventCancel();
        w.on("click.drag", null);
      }
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  d3.behavior.zoom = function() {
    var translate = [ 0, 0 ], translate0, scale = 1, scale0, scaleExtent = d3_behavior_zoomInfinity, event = d3_eventDispatch(zoom, "zoom"), x0, x1, y0, y1, touchtime;
    function zoom() {
      this.on("mousedown.zoom", mousedown).on("mousemove.zoom", mousemove).on(d3_behavior_zoomWheel + ".zoom", mousewheel).on("dblclick.zoom", dblclick).on("touchstart.zoom", touchstart).on("touchmove.zoom", touchmove).on("touchend.zoom", touchstart);
    }
    zoom.translate = function(x) {
      if (!arguments.length) return translate;
      translate = x.map(Number);
      rescale();
      return zoom;
    };
    zoom.scale = function(x) {
      if (!arguments.length) return scale;
      scale = +x;
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(x) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      translate = [ 0, 0 ];
      scale = 1;
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      translate = [ 0, 0 ];
      scale = 1;
      return zoom;
    };
    function location(p) {
      return [ (p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale ];
    }
    function point(l) {
      return [ l[0] * scale + translate[0], l[1] * scale + translate[1] ];
    }
    function scaleTo(s) {
      scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      translate[0] += p[0] - l[0];
      translate[1] += p[1] - l[1];
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - translate[0]) / scale;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - translate[1]) / scale;
      }).map(y0.invert));
    }
    function dispatch(event) {
      rescale();
      d3.event.preventDefault();
      event({
        type: "zoom",
        scale: scale,
        translate: translate
      });
    }
    function mousedown() {
      var target = this, event_ = event.of(target, arguments), eventTarget = d3.event.target, moved = 0, w = d3.select(d3_window).on("mousemove.zoom", mousemove).on("mouseup.zoom", mouseup), l = location(d3.mouse(target));
      d3_window.focus();
      d3_eventCancel();
      function mousemove() {
        moved = 1;
        translateTo(d3.mouse(target), l);
        dispatch(event_);
      }
      function mouseup() {
        if (moved) d3_eventCancel();
        w.on("mousemove.zoom", null).on("mouseup.zoom", null);
        if (moved && d3.event.target === eventTarget) w.on("click.zoom", click, true);
      }
      function click() {
        d3_eventCancel();
        w.on("click.zoom", null);
      }
    }
    function mousewheel() {
      if (!translate0) translate0 = location(d3.mouse(this));
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);
      translateTo(d3.mouse(this), translate0);
      dispatch(event.of(this, arguments));
    }
    function mousemove() {
      translate0 = null;
    }
    function dblclick() {
      var p = d3.mouse(this), l = location(p), k = Math.log(scale) / Math.LN2;
      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
      translateTo(p, l);
      dispatch(event.of(this, arguments));
    }
    function touchstart() {
      var touches = d3.touches(this), now = Date.now();
      scale0 = scale;
      translate0 = {};
      touches.forEach(function(t) {
        translate0[t.identifier] = location(t);
      });
      d3_eventCancel();
      if (touches.length === 1) {
        if (now - touchtime < 500) {
          var p = touches[0], l = location(touches[0]);
          scaleTo(scale * 2);
          translateTo(p, l);
          dispatch(event.of(this, arguments));
        }
        touchtime = now;
      }
    }
    function touchmove() {
      var touches = d3.touches(this), p0 = touches[0], l0 = translate0[p0.identifier];
      if (p1 = touches[1]) {
        var p1, l1 = translate0[p1.identifier];
        p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
        l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
        scaleTo(d3.event.scale * scale0);
      }
      translateTo(p0, l0);
      touchtime = null;
      dispatch(event.of(this, arguments));
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ];
  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in document ? (d3_behavior_zoomDelta = function() {
    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
  }, "wheel") : "onmousewheel" in document ? (d3_behavior_zoomDelta = function() {
    return d3.event.wheelDelta;
  }, "mousewheel") : (d3_behavior_zoomDelta = function() {
    return -d3.event.detail;
  }, "MozMousePixelScroll");
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (2 * π - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, gravity = .1, theta = .8, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dn = 1 / Math.sqrt(dx * dx + dy * dy);
          if ((x2 - x1) * dn < theta) {
            var k = quad.charge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
            return true;
          }
          if (quad.point && isFinite(dn)) {
            var k = quad.pointCharge * dn * dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return theta;
      theta = +x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, j, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        var neighbors = neighbor(i), j = -1, m = neighbors.length, x;
        while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;
        return Math.random() * size;
      }
      function neighbor() {
        if (!neighbors) {
          neighbors = [];
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        return neighbors[i];
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1;
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = 2 * π;
    function pie(data) {
      var values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      });
      var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
      var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - startAngle) / d3.sum(values);
      var index = d3.range(data.length);
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      var arcs = [];
      index.forEach(function(i) {
        var d;
        arcs[i] = {
          data: data[i],
          value: d = values[i],
          startAngle: a,
          endAngle: a += d * k
        };
      });
      return arcs;
    }
    pie.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return pie;
    };
    pie.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return pie;
    };
    pie.startAngle = function(x) {
      if (!arguments.length) return startAngle;
      startAngle = x;
      return pie;
    };
    pie.endAngle = function(x) {
      if (!arguments.length) return endAngle;
      endAngle = x;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var n = series.length, m = series[0].length, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function recurse(node, depth, nodes) {
      var childs = children.call(hierarchy, node, depth);
      node.depth = depth;
      nodes.push(node);
      if (childs && (n = childs.length)) {
        var i = -1, n, c = node.children = [], v = 0, j = depth + 1, d;
        while (++i < n) {
          d = recurse(childs[i], j, nodes);
          d.parent = node;
          c.push(d);
          v += d.value;
        }
        if (sort) c.sort(sort);
        if (value) node.value = v;
      } else if (value) {
        node.value = +value.call(hierarchy, node, depth) || 0;
      }
      return node;
    }
    function revalue(node, depth) {
      var children = node.children, v = 0;
      if (children && (n = children.length)) {
        var i = -1, n, j = depth + 1;
        while (++i < n) v += revalue(children[i], j);
      } else if (value) {
        v = +value.call(hierarchy, node, depth) || 0;
      }
      if (value) node.value = v;
      return v;
    }
    function hierarchy(d) {
      var nodes = [];
      recurse(d, 0, nodes);
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      revalue(root, 0);
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ];
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      root.x = 0;
      root.y = 0;
      d3_layout_treeVisitAfter(root, function(d) {
        d.r = Math.sqrt(d.value);
      });
      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
      var w = size[0], h = size[1], k = Math.max(2 * root.r / w, 2 * root.r / h);
      if (padding > 0) {
        var dr = padding * k / 2;
        d3_layout_treeVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
        d3_layout_treeVisitAfter(root, function(d) {
          d.r -= dr;
        });
        k = Math.max(2 * root.r / w, 2 * root.r / h);
      }
      d3_layout_packTransform(root, w / 2, h / 2, 1 / k);
      return nodes;
    }
    pack.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return dr * dr - dx * dx - dy * dy > .001;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_treeVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ];
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0];
      function firstWalk(node, previousSibling) {
        var children = node.children, layout = node._tree;
        if (children && (n = children.length)) {
          var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
          while (++i < n) {
            child = children[i];
            firstWalk(child, previousChild);
            ancestor = apportion(child, previousChild, ancestor);
            previousChild = child;
          }
          d3_layout_treeShift(node);
          var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
            layout.mod = layout.prelim - midpoint;
          } else {
            layout.prelim = midpoint;
          }
        } else {
          if (previousSibling) {
            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          }
        }
      }
      function secondWalk(node, x) {
        node.x = node._tree.prelim + x;
        var children = node.children;
        if (children && (n = children.length)) {
          var i = -1, n;
          x += node._tree.mod;
          while (++i < n) {
            secondWalk(children[i], x);
          }
        }
      }
      function apportion(node, previousSibling, ancestor) {
        if (previousSibling) {
          var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
            vom = d3_layout_treeLeft(vom);
            vop = d3_layout_treeRight(vop);
            vop._tree.ancestor = node;
            shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
            if (shift > 0) {
              d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim._tree.mod;
            sip += vip._tree.mod;
            som += vom._tree.mod;
            sop += vop._tree.mod;
          }
          if (vim && !d3_layout_treeRight(vop)) {
            vop._tree.thread = vim;
            vop._tree.mod += sim - sop;
          }
          if (vip && !d3_layout_treeLeft(vom)) {
            vom._tree.thread = vip;
            vom._tree.mod += sip - som;
            ancestor = node;
          }
        }
        return ancestor;
      }
      d3_layout_treeVisitAfter(root, function(node, previousSibling) {
        node._tree = {
          ancestor: node,
          prelim: 0,
          mod: 0,
          change: 0,
          shift: 0,
          number: previousSibling ? previousSibling._tree.number + 1 : 0
        };
      });
      firstWalk(root);
      secondWalk(root, -root._tree.prelim);
      var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost), right = d3_layout_treeSearch(root, d3_layout_treeRightmost), deep = d3_layout_treeSearch(root, d3_layout_treeDeepest), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2, y1 = deep.depth || 1;
      d3_layout_treeVisitAfter(root, function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = node.depth / y1 * size[1];
        delete node._tree;
      });
      return nodes;
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(node) {
    var children = node.children;
    return children && children.length ? children[0] : node._tree.thread;
  }
  function d3_layout_treeRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? children[n - 1] : node._tree.thread;
  }
  function d3_layout_treeSearch(node, compare) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child, n, i = -1;
      while (++i < n) {
        if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
          node = child;
        }
      }
    }
    return node;
  }
  function d3_layout_treeRightmost(a, b) {
    return a.x - b.x;
  }
  function d3_layout_treeLeftmost(a, b) {
    return b.x - a.x;
  }
  function d3_layout_treeDeepest(a, b) {
    return a.depth - b.depth;
  }
  function d3_layout_treeVisitAfter(node, callback) {
    function visit(node, previousSibling) {
      var children = node.children;
      if (children && (n = children.length)) {
        var child, previousChild = null, i = -1, n;
        while (++i < n) {
          child = children[i];
          visit(child, previousChild);
          previousChild = child;
        }
      }
      callback(node, previousSibling);
    }
    visit(node, null);
  }
  function d3_layout_treeShift(node) {
    var shift = 0, change = 0, children = node.children, i = children.length, child;
    while (--i >= 0) {
      child = children[i]._tree;
      child.prelim += shift;
      child.mod += shift;
      shift += child.shift + (change += child.change);
    }
  }
  function d3_layout_treeMove(ancestor, node, shift) {
    ancestor = ancestor._tree;
    node = node._tree;
    var change = shift / (node.number - ancestor.number);
    ancestor.change += change;
    node.change -= change;
    node.shift += shift;
    node.prelim += shift;
    node.mod += shift;
  }
  function d3_layout_treeAncestor(vim, node, ancestor) {
    return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  function d3_dsv(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, callback) {
      return d3.xhr(url, mimeType, callback).response(response);
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    dsv.parse = function(text) {
      var o;
      return dsv.parseRows(text, function(row) {
        if (o) return o(row);
        o = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.substring(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.substring(j, I - k);
        }
        return text.substring(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && !(a = f(a, n++))) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  }
  d3.csv = d3_dsv(",", "text/csv");
  d3.tsv = d3_dsv("	", "text/tab-separated-values");
  d3.geo = {};
  d3.geo.stream = function(object, listener) {
    if (d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      var coordinate = object.coordinates;
      listener.point(coordinate[0], coordinate[1]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length, coordinate;
      while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), Math.asin(Math.max(-1, Math.min(1, cartesian[2]))) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, maxDepth = 16;
    function resample(stream) {
      var λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = polygonLineStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function polygonLineStart() {
        var λ00, φ00, x00, y00, a00, b00, c00;
        lineStart();
        resample.point = function(λ, φ) {
          linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resample.point = linePoint;
        };
        resample.lineEnd = function() {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
          resample.lineEnd = lineEnd;
          lineEnd();
        };
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = Math.abs(Math.abs(c) - 1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || Math.abs((dx * dx2 + dy * dy2) / d2 - .5) > .3) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 60 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.albers().rotate([ 160, 0 ]).center([ 0, 20 ]).parallels([ 8, 18 ]);
    var puertoRico = d3.geo.albers().rotate([ 60, 0 ]).center([ 0, 10 ]).parallels([ 8, 18 ]);
    function albersUsa(coordinates) {
      return projection(coordinates)(coordinates);
    }
    function projection(point) {
      var lon = point[0], lat = point[1];
      return lat > 50 ? alaska : lon < -140 ? hawaii : lat < 21 ? puertoRico : lower48;
    }
    albersUsa.scale = function(x) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(x);
      alaska.scale(x * .6);
      hawaii.scale(x);
      puertoRico.scale(x * 1.5);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(x) {
      if (!arguments.length) return lower48.translate();
      var dz = lower48.scale(), dx = x[0], dy = x[1];
      lower48.translate(x);
      alaska.translate([ dx - .4 * dz, dy + .17 * dz ]);
      hawaii.translate([ dx - .19 * dz, dy + .2 * dz ]);
      puertoRico.translate([ dx + .58 * dz, dy + .43 * dz ]);
      return albersUsa;
    };
    return albersUsa.scale(lower48.scale());
  };
  function d3_geo_albers(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function albers(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    albers.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, Math.asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return albers;
  }
  (d3.geo.albers = function() {
    var φ0 = 29.5 * d3_radians, φ1 = 45.5 * d3_radians, m = d3_geo_projectionMutator(d3_geo_albers), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 * d3_degrees, φ1 * d3_degrees ];
      return m(φ0 = _[0] * d3_radians, φ1 = _[1] * d3_radians);
    };
    return p.rotate([ 98, 0 ]).center([ 0, 38 ]).scale(1e3);
  }).raw = d3_geo_albers;
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  d3.geo.bounds = d3_geo_bounds(d3_identity);
  function d3_geo_bounds(projectStream) {
    var x0, y0, x1, y1;
    var bound = {
      point: boundPoint,
      lineStart: d3_noop,
      lineEnd: d3_noop,
      polygonStart: function() {
        bound.lineEnd = boundPolygonLineEnd;
      },
      polygonEnd: function() {
        bound.point = boundPoint;
      }
    };
    function boundPoint(x, y) {
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }
    function boundPolygonLineEnd() {
      bound.point = bound.lineEnd = d3_noop;
    }
    return function(feature) {
      y1 = x1 = -(x0 = y0 = Infinity);
      d3.geo.stream(feature, projectStream(bound));
      return [ [ x0, y0 ], [ x1, y1 ] ];
    };
  }
  d3.geo.centroid = function(object) {
    d3_geo_centroidDimension = d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var m;
    if (d3_geo_centroidW && Math.abs(m = Math.sqrt(d3_geo_centroidX * d3_geo_centroidX + d3_geo_centroidY * d3_geo_centroidY + d3_geo_centroidZ * d3_geo_centroidZ)) > ε) {
      return [ Math.atan2(d3_geo_centroidY, d3_geo_centroidX) * d3_degrees, Math.asin(Math.max(-1, Math.min(1, d3_geo_centroidZ / m))) * d3_degrees ];
    }
  };
  var d3_geo_centroidDimension, d3_geo_centroidW, d3_geo_centroidX, d3_geo_centroidY, d3_geo_centroidZ;
  var d3_geo_centroid = {
    sphere: function() {
      if (d3_geo_centroidDimension < 2) {
        d3_geo_centroidDimension = 2;
        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      }
    },
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      if (d3_geo_centroidDimension < 2) {
        d3_geo_centroidDimension = 2;
        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      }
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    if (d3_geo_centroidDimension) return;
    ++d3_geo_centroidW;
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidX += (cosφ * Math.cos(λ) - d3_geo_centroidX) / d3_geo_centroidW;
    d3_geo_centroidY += (cosφ * Math.sin(λ) - d3_geo_centroidY) / d3_geo_centroidW;
    d3_geo_centroidZ += (Math.sin(φ) - d3_geo_centroidZ) / d3_geo_centroidW;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00;
    d3_geo_centroidDimension = 1;
    d3_geo_centroidLineStart();
    d3_geo_centroidDimension = 2;
    var linePoint = d3_geo_centroid.point;
    d3_geo_centroid.point = function(λ, φ) {
      linePoint(λ00 = λ, φ00 = φ);
    };
    d3_geo_centroid.lineEnd = function() {
      d3_geo_centroid.point(λ00, φ00);
      d3_geo_centroidLineEnd();
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
    };
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    if (d3_geo_centroidDimension > 1) return;
    if (d3_geo_centroidDimension < 1) {
      d3_geo_centroidDimension = 1;
      d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    }
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW += w;
      d3_geo_centroidX += w * (x0 + (x0 = x));
      d3_geo_centroidY += w * (y0 + (y0 = y));
      d3_geo_centroidZ += w * (z0 + (z0 = z));
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radians, precision) {
    var cr = Math.cos(radians), sr = Math.sin(radians);
    return function(from, to, direction, listener) {
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * 2 * π;
      } else {
        from = radians + direction * 2 * π;
        to = radians;
      }
      var point;
      for (var step = direction * precision, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = Math.acos(Math.max(-1, Math.min(1, -a[1])));
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate) {
    return function(listener) {
      var line = clipLine(listener);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          invisible = false;
          invisibleArea = visibleArea = 0;
          segments = [];
          listener.polygonStart();
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          if (segments.length) {
            d3_geo_clipPolygon(segments, interpolate, listener);
          } else if (visibleArea < -ε || invisible && invisibleArea < -ε) {
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          listener.polygonEnd();
          segments = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        if (pointVisible(λ, φ)) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        line.point(λ, φ);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments, visibleArea, invisibleArea, invisible;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), ring;
      function pointRing(λ, φ) {
        ringListener.point(λ, φ);
        ring.push([ λ, φ ]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        if (!n) {
          invisible = true;
          invisibleArea += d3_geo_clipAreaRing(ring, -1);
          ring = null;
          return;
        }
        ring = null;
        if (clean & 1) {
          segment = ringSegments[0];
          visibleArea += d3_geo_clipAreaRing(segment, 1);
          var n = segment.length - 1, i = -1, point;
          listener.lineStart();
          while (++i < n) listener.point((point = segment[i])[0], point[1]);
          listener.lineEnd();
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipPolygon(segments, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      var n = segment.length;
      if (n <= 1) return;
      var p0 = segment[0], p1 = segment[n - 1], a = {
        point: p0,
        points: segment,
        other: null,
        visited: false,
        entry: true,
        subject: true
      }, b = {
        point: p0,
        points: [ p0 ],
        other: a,
        visited: false,
        entry: false,
        subject: false
      };
      a.other = b;
      subject.push(a);
      clip.push(b);
      a = {
        point: p1,
        points: [ p1 ],
        other: null,
        visited: false,
        entry: false,
        subject: true
      };
      b = {
        point: p1,
        points: [ p1 ],
        other: a,
        visited: false,
        entry: true,
        subject: false
      };
      a.other = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(d3_geo_clipSort);
    d3_geo_clipLinkCircular(subject);
    d3_geo_clipLinkCircular(clip);
    if (!subject.length) return;
    var start = subject[0], current, points, point;
    while (1) {
      current = start;
      while (current.visited) if ((current = current.next) === start) return;
      points = current.points;
      listener.lineStart();
      do {
        current.visited = current.other.visited = true;
        if (current.entry) {
          if (current.subject) {
            for (var i = 0; i < points.length; i++) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.point, current.next.point, 1, listener);
          }
          current = current.next;
        } else {
          if (current.subject) {
            points = current.prev.points;
            for (var i = points.length; --i >= 0; ) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.point, current.prev.point, -1, listener);
          }
          current = current.prev;
        }
        current = current.other;
        points = current.points;
      } while (!current.visited);
      listener.lineEnd();
    }
  }
  function d3_geo_clipLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.next = b = array[i];
      b.prev = a;
      a = b;
    }
    a.next = b = array[0];
    b.prev = a;
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.point)[0] < 0 ? a[1] - π / 2 - ε : π / 2 - a[1]) - ((b = b.point)[0] < 0 ? b[1] - π / 2 - ε : π / 2 - b[1]);
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      }
    };
  }
  function d3_geo_clipAreaRing(ring, invisible) {
    if (!(n = ring.length)) return 0;
    var n, i = 0, area = 0, p = ring[0], λ = p[0], φ = p[1], cosφ = Math.cos(φ), x0 = Math.atan2(invisible * Math.sin(λ) * cosφ, Math.sin(φ)), y0 = 1 - invisible * Math.cos(λ) * cosφ, x1 = x0, x, y;
    while (++i < n) {
      p = ring[i];
      cosφ = Math.cos(φ = p[1]);
      x = Math.atan2(invisible * Math.sin(λ = p[0]) * cosφ, Math.sin(φ));
      y = 1 - invisible * Math.cos(λ) * cosφ;
      if (Math.abs(y0 - 2) < ε && Math.abs(y - 2) < ε) continue;
      if (Math.abs(y) < ε || Math.abs(y0) < ε) {} else if (Math.abs(Math.abs(x - x0) - π) < ε) {
        if (y + y0 > 2) area += 4 * (x - x0);
      } else if (Math.abs(y0 - 2) < ε) area += 4 * (x - x1); else area += ((3 * π + x - x0) % (2 * π) - π) * (y0 + y);
      x1 = x0, x0 = x, y0 = y;
    }
    return area;
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = Math.abs(λ1 - λ0);
        if (Math.abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? π / 2 : -π / 2);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (Math.abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (Math.abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return Math.abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * π / 2;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (Math.abs(from[0] - to[0]) > ε) {
      var s = (from[0] < to[0] ? 1 : -1) * π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_clipCircle(degrees) {
    var radians = degrees * d3_radians, cr = Math.cos(radians), interpolate = d3_geo_circleInterpolate(radians, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ);
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v0 = v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) listener.point(point1[0], point1[1]);
          point0 = point1;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b) {
      var pa = d3_geo_cartesian(a, 0), pb = d3_geo_cartesian(b, 0);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t = Math.sqrt(w * w - uu * (d3_geo_cartesianDot(A, A) - 1)), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      return d3_geo_spherical(q);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular).scale(250 / π);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  d3.geo.graticule = function() {
    var x1, x0, y1, y0, dx = 22.5, dy = dx, x, y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(x0 / dx) * dx, x1, dx).map(x).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ x(x0).concat(y(y1).slice(1), x(x1).reverse().slice(1), y(y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, precision);
      y = d3_geo_graticuleY(x0, x1, precision);
      return graticule;
    };
    return graticule.extent([ [ -180 + ε, -90 + ε ], [ 180 - ε, 90 - ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))), k = 1 / Math.sin(d);
    function interpolate(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) / d3_radians, Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_radians ];
    }
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_, precision = 6 * d3_radians, interpolate;
    function greatArc() {
      var p0 = source_ || source.apply(this, arguments), p1 = target_ || target.apply(this, arguments), i = interpolate || d3.geo.interpolate(p0, p1), t = 0, dt = precision / i.distance, coordinates = [ p0 ];
      while ((t += dt) < 1) coordinates.push(i(t));
      coordinates.push(p1);
      return {
        type: "LineString",
        coordinates: coordinates
      };
    }
    greatArc.distance = function() {
      return (interpolate || d3.geo.interpolate(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments))).distance;
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      interpolate = source_ && target_ ? d3.geo.interpolate(source_, target_) : null;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      interpolate = source_ && target_ ? d3.geo.interpolate(source_, target_) : null;
      return greatArc;
    };
    greatArc.precision = function(_) {
      if (!arguments.length) return precision / d3_radians;
      precision = _ * d3_radians;
      return greatArc;
    };
    return greatArc;
  };
  function d3_geo_mercator(λ, φ) {
    return [ λ / (2 * π), Math.max(-.5, Math.min(+.5, Math.log(Math.tan(π / 4 + φ / 2)) / (2 * π))) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ 2 * π * x, 2 * Math.atan(Math.exp(2 * π * y)) - π / 2 ];
  };
  (d3.geo.mercator = function() {
    return d3_geo_projection(d3_geo_mercator).scale(500);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream;
    function path(object) {
      if (object) d3.geo.stream(object, projectStream(contextStream.pointRadius(typeof pointRadius === "function" ? +pointRadius.apply(this, arguments) : pointRadius)));
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidDimension = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ ? [ d3_geo_centroidX / d3_geo_centroidZ, d3_geo_centroidY / d3_geo_centroidZ ] : undefined;
    };
    path.bounds = function(object) {
      return d3_geo_bounds(projectStream)(object);
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return path;
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      return path;
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : +_;
      return path;
    };
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + +2 * radius + "z";
  }
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(λ, φ) {
      return project([ λ * d3_degrees, φ * d3_degrees ]);
    });
    return function(stream) {
      stream = resample(stream);
      return {
        point: function(λ, φ) {
          stream.point(λ * d3_radians, φ * d3_radians);
        },
        sphere: function() {
          stream.sphere();
        },
        lineStart: function() {
          stream.lineStart();
        },
        lineEnd: function() {
          stream.lineEnd();
        },
        polygonStart: function() {
          stream.polygonStart();
        },
        polygonEnd: function() {
          stream.polygonEnd();
        }
      };
    };
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x, y);
      context.arc(x, y, pointRadius, 0, 2 * π);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += Math.abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    if (d3_geo_centroidDimension) return;
    d3_geo_centroidX += x;
    d3_geo_centroidY += y;
    ++d3_geo_centroidZ;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    if (d3_geo_centroidDimension !== 1) {
      if (d3_geo_centroidDimension < 1) {
        d3_geo_centroidDimension = 1;
        d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
      } else return;
    }
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      x0 = x, y0 = y;
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX += z * (x0 + x) / 2;
      d3_geo_centroidY += z * (y0 + y) / 2;
      d3_geo_centroidZ += z;
      x0 = x, y0 = y;
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    if (d3_geo_centroidDimension < 2) {
      d3_geo_centroidDimension = 2;
      d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;
    }
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      var z = y0 * x - x0 * y;
      d3_geo_centroidX += z * (x0 + x);
      d3_geo_centroidY += z * (y0 + y);
      d3_geo_centroidZ += z * 3;
      x0 = x, y0 = y;
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingU, d3_geo_areaRingV;
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingU = 1, d3_geo_areaRingV = 0;
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * Math.atan2(d3_geo_areaRingV, d3_geo_areaRingU);
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u0 = d3_geo_areaRingU, v0 = d3_geo_areaRingV, u = cosφ0 * cosφ + k * Math.cos(dλ), v = k * Math.sin(dλ);
      d3_geo_areaRingU = u0 * u - v0 * v;
      d3_geo_areaRingV = v0 * u + u0 * v;
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, clip = d3_geo_clipAntimeridian, clipAngle = null;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(stream) {
      return d3_geo_projectionRadiansRotate(rotate, clip(projectResample(stream)));
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      clip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle(clipAngle = +_);
      return projection;
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadiansRotate(rotate, stream) {
    return {
      point: function(x, y) {
        y = rotate(x * d3_radians, y * d3_radians), x = y[0];
        stream.point(x > π ? x - 2 * π : x < -π ? x + 2 * π : x, y[1]);
      },
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_equirectangular;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - 2 * π : λ < -π ? λ + 2 * π : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδγ + y * sinδγ))) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδφ - x * sinδφ))) ];
    };
    return rotation;
  }
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  d3.geom = {};
  d3.geom.hull = function(vertices) {
    if (vertices.length < 3) return [];
    var len = vertices.length, plen = len - 1, points = [], stack = [], i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;
    for (i = 1; i < len; ++i) {
      if (vertices[i][1] < vertices[h][1]) {
        h = i;
      } else if (vertices[i][1] == vertices[h][1]) {
        h = vertices[i][0] < vertices[h][0] ? i : h;
      }
    }
    for (i = 0; i < len; ++i) {
      if (i === h) continue;
      y1 = vertices[i][1] - vertices[h][1];
      x1 = vertices[i][0] - vertices[h][0];
      points.push({
        angle: Math.atan2(y1, x1),
        index: i
      });
    }
    points.sort(function(a, b) {
      return a.angle - b.angle;
    });
    a = points[0].angle;
    v = points[0].index;
    u = 0;
    for (i = 1; i < plen; ++i) {
      j = points[i].index;
      if (a == points[i].angle) {
        x1 = vertices[v][0] - vertices[h][0];
        y1 = vertices[v][1] - vertices[h][1];
        x2 = vertices[j][0] - vertices[h][0];
        y2 = vertices[j][1] - vertices[h][1];
        if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {
          points[i].index = -1;
        } else {
          points[u].index = -1;
          a = points[i].angle;
          u = i;
          v = j;
        }
      } else {
        a = points[i].angle;
        u = i;
        v = j;
      }
    }
    stack.push(h);
    for (i = 0, j = 0; i < 2; ++j) {
      if (points[j].index !== -1) {
        stack.push(points[j].index);
        i++;
      }
    }
    sp = stack.length;
    for (;j < plen; ++j) {
      if (points[j].index === -1) continue;
      while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {
        --sp;
      }
      stack[sp++] = points[j].index;
    }
    var poly = [];
    for (i = 0; i < sp; ++i) {
      poly.push(vertices[stack[i]]);
    }
    return poly;
  };
  function d3_geom_hullCCW(i1, i2, i3, v) {
    var t, a, b, c, d, e, f;
    t = v[i1];
    a = t[0];
    b = t[1];
    t = v[i2];
    c = t[0];
    d = t[1];
    t = v[i3];
    e = t[0];
    f = t[1];
    return (f - b) * (c - a) - (d - b) * (e - a) > 0;
  }
  d3.geom.polygon = function(coordinates) {
    coordinates.area = function() {
      var i = 0, n = coordinates.length, area = coordinates[n - 1][1] * coordinates[0][0] - coordinates[n - 1][0] * coordinates[0][1];
      while (++i < n) {
        area += coordinates[i - 1][1] * coordinates[i][0] - coordinates[i - 1][0] * coordinates[i][1];
      }
      return area * .5;
    };
    coordinates.centroid = function(k) {
      var i = -1, n = coordinates.length, x = 0, y = 0, a, b = coordinates[n - 1], c;
      if (!arguments.length) k = -1 / (6 * coordinates.area());
      while (++i < n) {
        a = b;
        b = coordinates[i];
        c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }
      return [ x * k, y * k ];
    };
    coordinates.clip = function(subject) {
      var input, i = -1, n = coordinates.length, j, m, a = coordinates[n - 1], b, c, d;
      while (++i < n) {
        input = subject.slice();
        subject.length = 0;
        b = coordinates[i];
        c = input[(m = input.length) - 1];
        j = -1;
        while (++j < m) {
          d = input[j];
          if (d3_geom_polygonInside(d, a, b)) {
            if (!d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            subject.push(d);
          } else if (d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          c = d;
        }
        a = b;
      }
      return subject;
    };
    return coordinates;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  d3.geom.voronoi = function(vertices) {
    var polygons = vertices.map(function() {
      return [];
    }), Z = 1e6;
    d3_voronoi_tessellate(vertices, function(e) {
      var s1, s2, x1, x2, y1, y2;
      if (e.a === 1 && e.b >= 0) {
        s1 = e.ep.r;
        s2 = e.ep.l;
      } else {
        s1 = e.ep.l;
        s2 = e.ep.r;
      }
      if (e.a === 1) {
        y1 = s1 ? s1.y : -Z;
        x1 = e.c - e.b * y1;
        y2 = s2 ? s2.y : Z;
        x2 = e.c - e.b * y2;
      } else {
        x1 = s1 ? s1.x : -Z;
        y1 = e.c - e.a * x1;
        x2 = s2 ? s2.x : Z;
        y2 = e.c - e.a * x2;
      }
      var v1 = [ x1, y1 ], v2 = [ x2, y2 ];
      polygons[e.region.l.index].push(v1, v2);
      polygons[e.region.r.index].push(v1, v2);
    });
    polygons = polygons.map(function(polygon, i) {
      var cx = vertices[i][0], cy = vertices[i][1], angle = polygon.map(function(v) {
        return Math.atan2(v[0] - cx, v[1] - cy);
      }), order = d3.range(polygon.length).sort(function(a, b) {
        return angle[a] - angle[b];
      });
      return order.filter(function(d, i) {
        return !i || angle[d] - angle[order[i - 1]] > ε;
      }).map(function(d) {
        return polygon[d];
      });
    });
    polygons.forEach(function(polygon, i) {
      var n = polygon.length;
      if (!n) return polygon.push([ -Z, -Z ], [ -Z, Z ], [ Z, Z ], [ Z, -Z ]);
      if (n > 2) return;
      var p0 = vertices[i], p1 = polygon[0], p2 = polygon[1], x0 = p0[0], y0 = p0[1], x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1], dx = Math.abs(x2 - x1), dy = y2 - y1;
      if (Math.abs(dy) < ε) {
        var y = y0 < y1 ? -Z : Z;
        polygon.push([ -Z, y ], [ Z, y ]);
      } else if (dx < ε) {
        var x = x0 < x1 ? -Z : Z;
        polygon.push([ x, -Z ], [ x, Z ]);
      } else {
        var y = (x2 - x1) * (y1 - y0) < (x1 - x0) * (y2 - y1) ? Z : -Z, z = Math.abs(dy) - dx;
        if (Math.abs(z) < ε) {
          polygon.push([ dy < 0 ? y : -y, y ]);
        } else {
          if (z > 0) y *= -1;
          polygon.push([ -Z, y ], [ Z, y ]);
        }
      }
    });
    return polygons;
  };
  var d3_voronoi_opposite = {
    l: "r",
    r: "l"
  };
  function d3_voronoi_tessellate(vertices, callback) {
    var Sites = {
      list: vertices.map(function(v, i) {
        return {
          index: i,
          x: v[0],
          y: v[1]
        };
      }).sort(function(a, b) {
        return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0;
      }),
      bottomSite: null
    };
    var EdgeList = {
      list: [],
      leftEnd: null,
      rightEnd: null,
      init: function() {
        EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l");
        EdgeList.leftEnd.r = EdgeList.rightEnd;
        EdgeList.rightEnd.l = EdgeList.leftEnd;
        EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);
      },
      createHalfEdge: function(edge, side) {
        return {
          edge: edge,
          side: side,
          vertex: null,
          l: null,
          r: null
        };
      },
      insert: function(lb, he) {
        he.l = lb;
        he.r = lb.r;
        lb.r.l = he;
        lb.r = he;
      },
      leftBound: function(p) {
        var he = EdgeList.leftEnd;
        do {
          he = he.r;
        } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
        he = he.l;
        return he;
      },
      del: function(he) {
        he.l.r = he.r;
        he.r.l = he.l;
        he.edge = null;
      },
      right: function(he) {
        return he.r;
      },
      left: function(he) {
        return he.l;
      },
      leftRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[he.side];
      },
      rightRegion: function(he) {
        return he.edge == null ? Sites.bottomSite : he.edge.region[d3_voronoi_opposite[he.side]];
      }
    };
    var Geom = {
      bisect: function(s1, s2) {
        var newEdge = {
          region: {
            l: s1,
            r: s2
          },
          ep: {
            l: null,
            r: null
          }
        };
        var dx = s2.x - s1.x, dy = s2.y - s1.y, adx = dx > 0 ? dx : -dx, ady = dy > 0 ? dy : -dy;
        newEdge.c = s1.x * dx + s1.y * dy + (dx * dx + dy * dy) * .5;
        if (adx > ady) {
          newEdge.a = 1;
          newEdge.b = dy / dx;
          newEdge.c /= dx;
        } else {
          newEdge.b = 1;
          newEdge.a = dx / dy;
          newEdge.c /= dy;
        }
        return newEdge;
      },
      intersect: function(el1, el2) {
        var e1 = el1.edge, e2 = el2.edge;
        if (!e1 || !e2 || e1.region.r == e2.region.r) {
          return null;
        }
        var d = e1.a * e2.b - e1.b * e2.a;
        if (Math.abs(d) < 1e-10) {
          return null;
        }
        var xint = (e1.c * e2.b - e2.c * e1.b) / d, yint = (e2.c * e1.a - e1.c * e2.a) / d, e1r = e1.region.r, e2r = e2.region.r, el, e;
        if (e1r.y < e2r.y || e1r.y == e2r.y && e1r.x < e2r.x) {
          el = el1;
          e = e1;
        } else {
          el = el2;
          e = e2;
        }
        var rightOfSite = xint >= e.region.r.x;
        if (rightOfSite && el.side === "l" || !rightOfSite && el.side === "r") {
          return null;
        }
        return {
          x: xint,
          y: yint
        };
      },
      rightOf: function(he, p) {
        var e = he.edge, topsite = e.region.r, rightOfSite = p.x > topsite.x;
        if (rightOfSite && he.side === "l") {
          return 1;
        }
        if (!rightOfSite && he.side === "r") {
          return 0;
        }
        if (e.a === 1) {
          var dyp = p.y - topsite.y, dxp = p.x - topsite.x, fast = 0, above = 0;
          if (!rightOfSite && e.b < 0 || rightOfSite && e.b >= 0) {
            above = fast = dyp >= e.b * dxp;
          } else {
            above = p.x + p.y * e.b > e.c;
            if (e.b < 0) {
              above = !above;
            }
            if (!above) {
              fast = 1;
            }
          }
          if (!fast) {
            var dxs = topsite.x - e.region.l.x;
            above = e.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b);
            if (e.b < 0) {
              above = !above;
            }
          }
        } else {
          var yl = e.c - e.a * p.x, t1 = p.y - yl, t2 = p.x - topsite.x, t3 = yl - topsite.y;
          above = t1 * t1 > t2 * t2 + t3 * t3;
        }
        return he.side === "l" ? above : !above;
      },
      endPoint: function(edge, side, site) {
        edge.ep[side] = site;
        if (!edge.ep[d3_voronoi_opposite[side]]) return;
        callback(edge);
      },
      distance: function(s, t) {
        var dx = s.x - t.x, dy = s.y - t.y;
        return Math.sqrt(dx * dx + dy * dy);
      }
    };
    var EventQueue = {
      list: [],
      insert: function(he, site, offset) {
        he.vertex = site;
        he.ystar = site.y + offset;
        for (var i = 0, list = EventQueue.list, l = list.length; i < l; i++) {
          var next = list[i];
          if (he.ystar > next.ystar || he.ystar == next.ystar && site.x > next.vertex.x) {
            continue;
          } else {
            break;
          }
        }
        list.splice(i, 0, he);
      },
      del: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l && ls[i] != he; ++i) {}
        ls.splice(i, 1);
      },
      empty: function() {
        return EventQueue.list.length === 0;
      },
      nextEvent: function(he) {
        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l; ++i) {
          if (ls[i] == he) return ls[i + 1];
        }
        return null;
      },
      min: function() {
        var elem = EventQueue.list[0];
        return {
          x: elem.vertex.x,
          y: elem.ystar
        };
      },
      extractMin: function() {
        return EventQueue.list.shift();
      }
    };
    EdgeList.init();
    Sites.bottomSite = Sites.list.shift();
    var newSite = Sites.list.shift(), newIntStar;
    var lbnd, rbnd, llbnd, rrbnd, bisector;
    var bot, top, temp, p, v;
    var e, pm;
    while (true) {
      if (!EventQueue.empty()) {
        newIntStar = EventQueue.min();
      }
      if (newSite && (EventQueue.empty() || newSite.y < newIntStar.y || newSite.y == newIntStar.y && newSite.x < newIntStar.x)) {
        lbnd = EdgeList.leftBound(newSite);
        rbnd = EdgeList.right(lbnd);
        bot = EdgeList.rightRegion(lbnd);
        e = Geom.bisect(bot, newSite);
        bisector = EdgeList.createHalfEdge(e, "l");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(lbnd, bisector);
        if (p) {
          EventQueue.del(lbnd);
          EventQueue.insert(lbnd, p, Geom.distance(p, newSite));
        }
        lbnd = bisector;
        bisector = EdgeList.createHalfEdge(e, "r");
        EdgeList.insert(lbnd, bisector);
        p = Geom.intersect(bisector, rbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, newSite));
        }
        newSite = Sites.list.shift();
      } else if (!EventQueue.empty()) {
        lbnd = EventQueue.extractMin();
        llbnd = EdgeList.left(lbnd);
        rbnd = EdgeList.right(lbnd);
        rrbnd = EdgeList.right(rbnd);
        bot = EdgeList.leftRegion(lbnd);
        top = EdgeList.rightRegion(rbnd);
        v = lbnd.vertex;
        Geom.endPoint(lbnd.edge, lbnd.side, v);
        Geom.endPoint(rbnd.edge, rbnd.side, v);
        EdgeList.del(lbnd);
        EventQueue.del(rbnd);
        EdgeList.del(rbnd);
        pm = "l";
        if (bot.y > top.y) {
          temp = bot;
          bot = top;
          top = temp;
          pm = "r";
        }
        e = Geom.bisect(bot, top);
        bisector = EdgeList.createHalfEdge(e, pm);
        EdgeList.insert(llbnd, bisector);
        Geom.endPoint(e, d3_voronoi_opposite[pm], v);
        p = Geom.intersect(llbnd, bisector);
        if (p) {
          EventQueue.del(llbnd);
          EventQueue.insert(llbnd, p, Geom.distance(p, bot));
        }
        p = Geom.intersect(bisector, rrbnd);
        if (p) {
          EventQueue.insert(bisector, p, Geom.distance(p, bot));
        }
      } else {
        break;
      }
    }
    for (lbnd = EdgeList.right(EdgeList.leftEnd); lbnd != EdgeList.rightEnd; lbnd = EdgeList.right(lbnd)) {
      callback(lbnd.edge);
    }
  }
  d3.geom.delaunay = function(vertices) {
    var edges = vertices.map(function() {
      return [];
    }), triangles = [];
    d3_voronoi_tessellate(vertices, function(e) {
      edges[e.region.l.index].push(vertices[e.region.r.index]);
    });
    edges.forEach(function(edge, i) {
      var v = vertices[i], cx = v[0], cy = v[1];
      edge.forEach(function(v) {
        v.angle = Math.atan2(v[0] - cx, v[1] - cy);
      });
      edge.sort(function(a, b) {
        return a.angle - b.angle;
      });
      for (var j = 0, m = edge.length - 1; j < m; j++) {
        triangles.push([ v, edge[j], edge[j + 1] ]);
      }
    });
    return triangles;
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var p, i = -1, n = points.length;
    if (arguments.length < 5) {
      if (arguments.length === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      } else {
        x1 = y1 = Infinity;
        x2 = y2 = -Infinity;
        while (++i < n) {
          p = points[i];
          if (p.x < x1) x1 = p.x;
          if (p.y < y1) y1 = p.y;
          if (p.x > x2) x2 = p.x;
          if (p.y > y2) y2 = p.y;
        }
      }
    }
    var dx = x2 - x1, dy = y2 - y1;
    if (dx > dy) y2 = y1 + dx; else x2 = x1 + dy;
    function insert(n, p, x1, y1, x2, y2) {
      if (isNaN(p.x) || isNaN(p.y)) return;
      if (n.leaf) {
        var v = n.point;
        if (v) {
          if (Math.abs(v.x - p.x) + Math.abs(v.y - p.y) < .01) {
            insertChild(n, p, x1, y1, x2, y2);
          } else {
            n.point = null;
            insertChild(n, v, x1, y1, x2, y2);
            insertChild(n, p, x1, y1, x2, y2);
          }
        } else {
          n.point = p;
        }
      } else {
        insertChild(n, p, x1, y1, x2, y2);
      }
    }
    function insertChild(n, p, x1, y1, x2, y2) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = p.x >= sx, bottom = p.y >= sy, i = (bottom << 1) + right;
      n.leaf = false;
      n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
      if (right) x1 = sx; else x2 = sx;
      if (bottom) y1 = sy; else y2 = sy;
      insert(n, p, x1, y1, x2, y2);
    }
    var root = d3_geom_quadtreeNode();
    root.add = function(p) {
      insert(root, p, x1, y1, x2, y2);
    };
    root.visit = function(f) {
      d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);
    };
    points.forEach(root.add);
    return root;
  };
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  d3.time = {};
  var d3_time = Date, d3_time_daySymbols = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
  function d3_time_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_time_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  var d3_time_formatDateTime = "%a %b %e %X %Y", d3_time_formatDate = "%m/%d/%Y", d3_time_formatTime = "%H:%M:%S";
  var d3_time_days = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], d3_time_dayAbbreviations = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], d3_time_months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], d3_time_monthAbbreviations = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
  d3.time.format = function(template) {
    var n = template.length;
    function format(date) {
      var string = [], i = -1, j = 0, c, p, f;
      while (++i < n) {
        if (template.charCodeAt(i) === 37) {
          string.push(template.substring(j, i));
          if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
          if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(template.substring(j, i));
      return string.join("");
    }
    format.parse = function(string) {
      var d = {
        y: 1900,
        m: 0,
        d: 1,
        H: 0,
        M: 0,
        S: 0,
        L: 0
      }, i = d3_time_parse(d, template, string, 0);
      if (i != string.length) return null;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      var date = new d3_time();
      date.setFullYear(d.y, d.m, d.d);
      date.setHours(d.H, d.M, d.S, d.L);
      return date;
    };
    format.toString = function() {
      return template;
    };
    return format;
  };
  function d3_time_parse(date, template, string, j) {
    var c, p, i = 0, n = template.length, m = string.length;
    while (i < n) {
      if (j >= m) return -1;
      c = template.charCodeAt(i++);
      if (c === 37) {
        p = d3_time_parsers[template.charAt(i++)];
        if (!p || (j = p(date, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_formatPad(value, fill, width) {
    value += "";
    var length = value.length;
    return length < width ? new Array(width - length + 1).join(fill) + value : value;
  }
  var d3_time_dayRe = d3_time_formatRe(d3_time_days), d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations), d3_time_monthRe = d3_time_formatRe(d3_time_months), d3_time_monthLookup = d3_time_formatLookup(d3_time_months), d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations), d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations);
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  };
  var d3_time_formats = {
    a: function(d) {
      return d3_time_dayAbbreviations[d.getDay()];
    },
    A: function(d) {
      return d3_time_days[d.getDay()];
    },
    b: function(d) {
      return d3_time_monthAbbreviations[d.getMonth()];
    },
    B: function(d) {
      return d3_time_months[d.getMonth()];
    },
    c: d3.time.format(d3_time_formatDateTime),
    d: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    e: function(d, p) {
      return d3_time_formatPad(d.getDate(), p, 2);
    },
    H: function(d, p) {
      return d3_time_formatPad(d.getHours(), p, 2);
    },
    I: function(d, p) {
      return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
    },
    j: function(d, p) {
      return d3_time_formatPad(1 + d3.time.dayOfYear(d), p, 3);
    },
    L: function(d, p) {
      return d3_time_formatPad(d.getMilliseconds(), p, 3);
    },
    m: function(d, p) {
      return d3_time_formatPad(d.getMonth() + 1, p, 2);
    },
    M: function(d, p) {
      return d3_time_formatPad(d.getMinutes(), p, 2);
    },
    p: function(d) {
      return d.getHours() >= 12 ? "PM" : "AM";
    },
    S: function(d, p) {
      return d3_time_formatPad(d.getSeconds(), p, 2);
    },
    U: function(d, p) {
      return d3_time_formatPad(d3.time.sundayOfYear(d), p, 2);
    },
    w: function(d) {
      return d.getDay();
    },
    W: function(d, p) {
      return d3_time_formatPad(d3.time.mondayOfYear(d), p, 2);
    },
    x: d3.time.format(d3_time_formatDate),
    X: d3.time.format(d3_time_formatTime),
    y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 100, p, 2);
    },
    Y: function(d, p) {
      return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
    },
    Z: d3_time_zone,
    "%": function() {
      return "%";
    }
  };
  var d3_time_parsers = {
    a: d3_time_parseWeekdayAbbrev,
    A: d3_time_parseWeekday,
    b: d3_time_parseMonthAbbrev,
    B: d3_time_parseMonth,
    c: d3_time_parseLocaleFull,
    d: d3_time_parseDay,
    e: d3_time_parseDay,
    H: d3_time_parseHour24,
    I: d3_time_parseHour24,
    L: d3_time_parseMilliseconds,
    m: d3_time_parseMonthNumber,
    M: d3_time_parseMinutes,
    p: d3_time_parseAmPm,
    S: d3_time_parseSeconds,
    x: d3_time_parseLocaleDate,
    X: d3_time_parseLocaleTime,
    y: d3_time_parseYear,
    Y: d3_time_parseFullYear
  };
  function d3_time_parseWeekdayAbbrev(date, string, i) {
    d3_time_dayAbbrevRe.lastIndex = 0;
    var n = d3_time_dayAbbrevRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseWeekday(date, string, i) {
    d3_time_dayRe.lastIndex = 0;
    var n = d3_time_dayRe.exec(string.substring(i));
    return n ? i += n[0].length : -1;
  }
  function d3_time_parseMonthAbbrev(date, string, i) {
    d3_time_monthAbbrevRe.lastIndex = 0;
    var n = d3_time_monthAbbrevRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseMonth(date, string, i) {
    d3_time_monthRe.lastIndex = 0;
    var n = d3_time_monthRe.exec(string.substring(i));
    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
  }
  function d3_time_parseLocaleFull(date, string, i) {
    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
  }
  function d3_time_parseLocaleDate(date, string, i) {
    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
  }
  function d3_time_parseLocaleTime(date, string, i) {
    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 4));
    return n ? (date.y = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i += n[0].length) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.m = n[0] - 1, i += n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.d = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.H = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.M = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 2));
    return n ? (date.S = +n[0], i += n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.substring(i, i + 3));
    return n ? (date.L = +n[0], i += n[0].length) : -1;
  }
  var d3_time_numberRe = /^\s*\d+/;
  function d3_time_parseAmPm(date, string, i) {
    var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
    return n == null ? -1 : (date.p = n, i);
  }
  var d3_time_amPmLookup = d3.map({
    am: 0,
    pm: 1
  });
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = ~~(Math.abs(z) / 60), zm = Math.abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  d3.time.format.utc = function(template) {
    var local = d3.time.format(template);
    function format(date) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time();
        utc._ = date;
        return local(utc);
      } finally {
        d3_time = Date;
      }
    }
    format.parse = function(string) {
      try {
        d3_time = d3_time_utc;
        var date = local.parse(string);
        return date && date._;
      } finally {
        d3_time = Date;
      }
    };
    format.toString = local.toString;
    return format;
  };
  var d3_time_formatIso = d3.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_time(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_time(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_time = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_time = d3_time_utc;
        var utc = new d3_time_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_time = Date;
      }
    };
  }
  d3.time.second = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3.time.seconds = d3.time.second.range;
  d3.time.seconds.utc = d3.time.second.utc.range;
  d3.time.minute = d3_time_interval(function(date) {
    return new d3_time(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3.time.minutes = d3.time.minute.range;
  d3.time.minutes.utc = d3.time.minute.utc.range;
  d3.time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3.time.hours = d3.time.hour.range;
  d3.time.hours.utc = d3.time.hour.utc.range;
  d3.time.day = d3_time_interval(function(date) {
    var day = new d3_time(1970, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3.time.days = d3.time.day.range;
  d3.time.days.utc = d3.time.day.utc.range;
  d3.time.dayOfYear = function(date) {
    var year = d3.time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  d3_time_daySymbols.forEach(function(day, i) {
    day = day.toLowerCase();
    i = 7 - i;
    var interval = d3.time[day] = d3_time_interval(function(date) {
      (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3.time[day + "s"] = interval.range;
    d3.time[day + "s"].utc = interval.utc.range;
    d3.time[day + "OfYear"] = function(date) {
      var day = d3.time.year(date).getDay();
      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3.time.week = d3.time.sunday;
  d3.time.weeks = d3.time.sunday.range;
  d3.time.weeks.utc = d3.time.sunday.utc.range;
  d3.time.weekOfYear = d3.time.sundayOfYear;
  d3.time.month = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3.time.months = d3.time.month.range;
  d3.time.months.utc = d3.time.month.utc.range;
  d3.time.year = d3_time_interval(function(date) {
    date = d3.time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3.time.years = d3.time.year.range;
  d3.time.years.utc = d3.time.year.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_nice(scale.domain(), function() {
        return m;
      }));
    };
    scale.ticks = function(m, k) {
      var extent = d3_time_scaleExtent(scale.domain());
      if (typeof m !== "function") {
        var span = extent[1] - extent[0], target = span / m, i = d3.bisect(d3_time_scaleSteps, target);
        if (i == d3_time_scaleSteps.length) return methods.year(extent, m);
        if (!i) return linear.ticks(m).map(d3_time_scaleDate);
        if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;
        m = methods[i];
        k = m[1];
        m = m[0].range;
      }
      return m(extent[0], new Date(+extent[1] + 1), k);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_time_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  function d3_time_scaleFormat(formats) {
    return function(date) {
      var i = formats.length - 1, f = formats[i];
      while (!f[1](date)) f = formats[--i];
      return f[0](date);
    };
  }
  function d3_time_scaleSetYear(y) {
    var d = new Date(y, 0, 1);
    d.setFullYear(y);
    return d;
  }
  function d3_time_scaleGetYear(d) {
    var y = d.getFullYear(), d0 = d3_time_scaleSetYear(y), d1 = d3_time_scaleSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3.time.second, 1 ], [ d3.time.second, 5 ], [ d3.time.second, 15 ], [ d3.time.second, 30 ], [ d3.time.minute, 1 ], [ d3.time.minute, 5 ], [ d3.time.minute, 15 ], [ d3.time.minute, 30 ], [ d3.time.hour, 1 ], [ d3.time.hour, 3 ], [ d3.time.hour, 6 ], [ d3.time.hour, 12 ], [ d3.time.day, 1 ], [ d3.time.day, 2 ], [ d3.time.week, 1 ], [ d3.time.month, 1 ], [ d3.time.month, 3 ], [ d3.time.year, 1 ] ];
  var d3_time_scaleLocalFormats = [ [ d3.time.format("%Y"), d3_true ], [ d3.time.format("%B"), function(d) {
    return d.getMonth();
  } ], [ d3.time.format("%b %d"), function(d) {
    return d.getDate() != 1;
  } ], [ d3.time.format("%a %d"), function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ d3.time.format("%I %p"), function(d) {
    return d.getHours();
  } ], [ d3.time.format("%I:%M"), function(d) {
    return d.getMinutes();
  } ], [ d3.time.format(":%S"), function(d) {
    return d.getSeconds();
  } ], [ d3.time.format(".%L"), function(d) {
    return d.getMilliseconds();
  } ] ];
  var d3_time_scaleLinear = d3.scale.linear(), d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);
  d3_time_scaleLocalMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);
  };
  d3.time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUTCFormats = [ [ d3.time.format.utc("%Y"), d3_true ], [ d3.time.format.utc("%B"), function(d) {
    return d.getUTCMonth();
  } ], [ d3.time.format.utc("%b %d"), function(d) {
    return d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%a %d"), function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ d3.time.format.utc("%I %p"), function(d) {
    return d.getUTCHours();
  } ], [ d3.time.format.utc("%I:%M"), function(d) {
    return d.getUTCMinutes();
  } ], [ d3.time.format.utc(":%S"), function(d) {
    return d.getUTCSeconds();
  } ], [ d3.time.format.utc(".%L"), function(d) {
    return d.getUTCMilliseconds();
  } ] ];
  var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);
  function d3_time_scaleUTCSetYear(y) {
    var d = new Date(Date.UTC(y, 0, 1));
    d.setUTCFullYear(y);
    return d;
  }
  function d3_time_scaleUTCGetYear(d) {
    var y = d.getUTCFullYear(), d0 = d3_time_scaleUTCSetYear(y), d1 = d3_time_scaleUTCSetYear(y + 1);
    return y + (d - d0) / (d1 - d0);
  }
  d3_time_scaleUTCMethods.year = function(extent, m) {
    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);
  };
  d3.time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
  };
  return d3;
}();
</script>
<script>
// Define functions to render linked interactive plots using d3.
// Another script should define e.g.
// <script>
//   var plot = new animint("#plot","path/to/plot.json");
// </script>
// Constructor for animint Object.
var animint = function (to_select, json_file) {

  var default_axis_px = 16;

   function wait_until_then(timeout, condFun, readyFun) {
    var args=arguments
    function checkFun() {
      if(condFun()) {
        readyFun(args[3],args[4]);
      } else{
        setTimeout(checkFun, timeout);
      }
    }
    checkFun();
  }

  function convert_R_types(resp_array, types){
    return resp_array.map(function (d) {
      for (var v_name in d) {
      	if(!is_interactive_aes(v_name)){
          var r_type = types[v_name];
          if (r_type == "integer") {
            d[v_name] = parseInt(d[v_name]);
          } else if (r_type == "numeric") {
            d[v_name] = parseFloat(d[v_name]);
          } else if (r_type == "factor" || r_type == "rgb" 
		     || r_type == "linetype" || r_type == "label" 
		     || r_type == "character") {
            // keep it as a character
          } else if (r_type == "character" & v_name == "outliers") {
            d[v_name] = parseFloat(d[v_name].split(" @ "));
          } 
      	}
      }
      return d;
    });
  }

  // replacing periods in variable with an underscore this makes sure
  // that selector doesn't confuse . in name with css selectors
  function safe_name(unsafe_name){
    return unsafe_name.replace(/[ .]/g, '_');
  }
  function legend_class_name(selector_name){
    return safe_name(selector_name) + "_variable";
  }

  function is_interactive_aes(v_name){
    if(v_name.indexOf("clickSelects") > -1){
      return true;
    }
    if(v_name.indexOf("showSelected") > -1){
      return true;
    }
    return false;
  }

  var linetypesize2dasharray = function (lt, size) {
    var isInt = function(n) {
      return typeof n === 'number' && parseFloat(n) == parseInt(n, 10) && !isNaN(n);
    };
    if(isInt(lt)){ // R integer line types.
      if(lt == 1){
        return null;
      }
      var o = {
        0: size * 0 + "," + size * 10,
        2: size * 4 + "," + size * 4,
        3: size + "," + size * 2,
        4: size + "," + size * 2 + "," + size * 4 + "," + size * 2,
        5: size * 8 + "," + size * 4,
        6: size * 2 + "," + size * 2 + "," + size * 6 + "," + size * 2
      };
    } else { // R defined line types
      if(lt == "solid" || lt === null){
        return null;
      }
      var o = {
        "blank": size * 0 + "," + size * 10,
        "none": size * 0 + "," + size * 10,
        "dashed": size * 4 + "," + size * 4,
        "dotted": size + "," + size * 2,
        "dotdash": size + "," + size * 2 + "," + size * 4 + "," + size * 2,
        "longdash": size * 8 + "," + size * 4,
        "twodash": size * 2 + "," + size * 2 + "," + size * 6 + "," + size * 2,
        "22": size * 2 + "," + size * 2,
        "42": size * 4 + "," + size * 2,
        "44": size * 4 + "," + size * 4,"13": size + "," + size * 3,
        "1343": size + "," + size * 3 + "," + size * 4 + "," + size * 3,
        "73": size * 7 + "," + size * 3,
        "2262": size * 2 + "," + size * 2 + "," + size * 6 + "," + size * 2,
        "12223242": size + "," + size * 2 + "," + size * 2 + "," + size * 2 + "," + size * 3 + "," + size * 2 + "," + size * 4 + "," + size * 2,
        "F282": size * 15 + "," + size * 2 + "," + size * 8 + "," + size * 2,
        "F4448444": size * 15 + "," + size * 4 + "," + size * 4 + "," + size * 4 + "," + size * 8 + "," + size * 4 + "," + size * 4 + "," + size * 4,
        "224282F2": size * 2 + "," + size * 2 + "," + size * 4 + "," + size * 2 + "," + size * 8 + "," + size * 2 + "," + size * 16 + "," + size * 2,
        "F1": size * 16 + "," + size
      };
    }

    if (lt in o){
      return o[lt];
    } else{ // manually specified line types
      str = lt.split("");
      strnum = str.map(function (d) {
        return size * parseInt(d, 16);
      });
      return strnum;
    }
  };

  var isArray = function(o) {
    return Object.prototype.toString.call(o) === '[object Array]';
  };

  // create a dummy element, apply the appropriate classes,
  // and then measure the element
  // Inspired from http://jsfiddle.net/uzddx/2/
  var measureText = function(pText, pFontSize, pAngle, pStyle) {
    if (!pText || pText.length === 0) return {height: 0, width: 0};
    if (pAngle === null || isNaN(pAngle)) pAngle = 0;

    var container = element.append('svg');
    // do we need to set the class so that styling is applied?
    //.attr('class', classname);

    container.append('text')
      .attr({x: -1000, y: -1000})
      .attr("transform", "rotate(" + pAngle + ")")
      .attr("style", pStyle)
      .attr("font-size", pFontSize)
      .text(pText);

    var bbox = container.node().getBBox();
    container.remove();

    return {height: bbox.height, width: bbox.width};
  };

  var nest_by_group = d3.nest().key(function(d){ return d.group; });
  var dirs = json_file.split("/");
  dirs.pop(); //if a directory path exists, remove the JSON file from dirs
  var element = d3.select(to_select);
  this.element = element;
  var viz_id = element.attr("id");
  var Widgets = {};
  this.Widgets = Widgets;
  var Selectors = {};
  this.Selectors = Selectors;
  var Plots = {};
  this.Plots = Plots;
  var Geoms = {};
  this.Geoms = Geoms;
  // SVGs must be stored separately from Geoms since they are
  // initialized first, with the Plots.
  var SVGs = {};
  this.SVGs = SVGs;
  var Animation = {};
  this.Animation = Animation;
  var all_geom_names = {};
  this.all_geom_names = all_geom_names;

  //creating an array to contain the selectize widgets
  var selectized_array = [];
  var data_object_geoms = {
    "line":true,
    "path":true,
    "ribbon":true,
    "polygon":true
  };
  var css = document.createElement('style');
  css.type = 'text/css';
  var styles = [".axis path{fill: none;stroke: black;shape-rendering: crispEdges;}",
            ".axis line{fill: none;stroke: black;shape-rendering: crispEdges;}",
            ".axis text {font-family: sans-serif;font-size: 11px;}"];

  var add_geom = function (g_name, g_info) {
    // Determine if data will be an object or an array.
    if(g_info.geom in data_object_geoms){
      g_info.data_is_object = true;
    }else{
      g_info.data_is_object = false;
    }
    // Add a row to the loading table.
    g_info.tr = Widgets["loading"].append("tr");
    g_info.tr.append("td").text(g_name);
    g_info.tr.append("td").attr("class", "chunk");
    g_info.tr.append("td").attr("class", "downloaded").text(0);
    g_info.tr.append("td").text(g_info.total);
    g_info.tr.append("td").attr("class", "status").text("initialized");

    // load chunk tsv
    g_info.data = {};
    g_info.download_status = {};
    Geoms[g_name] = g_info;
    // Determine whether common chunk tsv exists
    // If yes, load it
    if(g_info.hasOwnProperty("columns") && g_info.columns.common){
      var common_tsv = get_tsv(g_info, "_common");
      g_info.common_tsv = common_tsv;
      var common_path = getTSVpath(common_tsv);
      d3.tsv(common_path, function (error, response) {
        var converted = convert_R_types(response, g_info.types);
        g_info.data[common_tsv] = nest_by_group.map(converted);
      });
    } else {
      g_info.common_tsv = null;
    }
    // Save this geom and load it!
    update_geom(g_name, null);
  };
  var add_plot = function (p_name, p_info) {
    // Each plot may have one or more legends. To make space for the
    // legends, we put each plot in a table with one row and two
    // columns: tdLeft and tdRight.
    var plot_table = element.append("table").style("display", "inline-block");
    var plot_tr = plot_table.append("tr");
    var tdLeft = plot_tr.append("td");
    var tdRight = plot_tr.append("td").attr("class", p_name+"_legend");
    if(viz_id === null){
      p_info.plot_id = p_name;
    }else{
      p_info.plot_id = viz_id + "_" + p_name;
    }
    var svg = tdLeft.append("svg")
      .attr("id", p_info.plot_id)
      .attr("height", p_info.options.height)
      .attr("width", p_info.options.width);

    // divvy up width/height based on the panel layout
    var nrows = Math.max.apply(null, p_info.layout.ROW);
    var ncols = Math.max.apply(null, p_info.layout.COL);
    var panel_names = p_info.layout.PANEL;
    var npanels = Math.max.apply(null, panel_names);

    // Note axis names are "shared" across panels (just like the title)
    var xtitlepadding = 5 + measureText(p_info["xtitle"], default_axis_px).height;
    var ytitlepadding = 5 + measureText(p_info["ytitle"], default_axis_px).height;

    // 'margins' are fixed across panels and do not
    // include title/axis/label padding (since these are not
    // fixed across panels). They do, however, account for
    // spacing between panels
    var text_height_pixels = measureText("foo", 11).height;
    var margin = {
      left: 0,
      right: text_height_pixels * p_info.panel_margin_lines,
      top: text_height_pixels * p_info.panel_margin_lines,
      bottom: 0
    };
    var plotdim = {
      width: 0,
      height: 0,
      xstart: 0,
      xend: 0,
      ystart: 0,
      yend: 0,
      graph: {
	width: 0,
	height: 0
      },
      margin: margin,
      xlab: {
	x: 0,
	y: 0
      },
      ylab: {
	x: 0,
	y: 0
      },
      title: {
	x: 0,
	y: 0
      }
    };

    // Draw the title
    var titlepadding = measureText(p_info.title, p_info.title_size).height;
    // why are we giving the title padding if it is undefined?
    if (p_info.title === undefined) titlepadding = 0;
    plotdim.title.x = p_info.options.width / 2;
    plotdim.title.y = titlepadding;
    svg.append("text")
      .text(p_info.title)
      .attr("class", "plottitle")
      .attr("font-family", "sans-serif")
      .attr("font-size", p_info.title_size)
      .attr("transform", "translate(" + plotdim.title.x + "," + 
        plotdim.title.y + ")")
      .style("text-anchor", "middle");

    // grab max text size over axis labels and facet strip labels
    var axispaddingy = 5;
    if(p_info.hasOwnProperty("ylabs") && p_info.ylabs.length){
      axispaddingy += Math.max.apply(null, p_info.ylabs.map(function(entry){
	// + 5 to give a little extra space to avoid bad axis labels
	// in shiny.
	return measureText(entry, p_info.ysize).width + 5;
      }));
    }
    var axispaddingx = 10 + 20;
    if(p_info.hasOwnProperty("xlabs") && p_info.xlabs.length){
      // TODO: throw warning if text height is large portion of plot height?
      axispaddingx += Math.max.apply(null, p_info.xlabs.map(function(entry){
	     return measureText(entry, p_info.xsize, p_info.xangle).height;
      }));
      // TODO: carefully calculating this gets complicated with rotating xlabs
      //margin.right += 5;
    }
    plotdim.margin = margin;
    
    var strip_heights = p_info.strips.top.map(function(entry){ 
      return measureText(entry, p_info.strip_text_xsize).height;
    });
    var strip_widths = p_info.strips.right.map(function(entry){ 
      return measureText(entry, p_info.strip_text_ysize).height; 
    });

    // compute the number of x/y axes, max strip height per row, and
    // max strip width per columns, for calculating height/width of
    // graphing region.
    var row_strip_heights = [];
    var col_strip_widths = [];
    var n_xaxes = 0;
    var n_yaxes = 0;
    var current_row, current_col;
    for (var layout_i = 0; layout_i < npanels; layout_i++) {
      current_row = p_info.layout.ROW[layout_i] - 1;
      current_col = p_info.layout.COL[layout_i] - 1;
      if(row_strip_heights[current_row] === undefined){
	row_strip_heights[current_row] = [];
      }
      if(col_strip_widths[current_col] === undefined){
	col_strip_widths[current_col] = [];
      }
      row_strip_heights[current_row].push(strip_heights[layout_i]);
      col_strip_widths[current_col].push(strip_widths[layout_i]);
      if (p_info.layout.COL[layout_i] == 1) {
	n_xaxes += p_info.layout.AXIS_X[layout_i];
      }
      if (p_info.layout.ROW[layout_i] == 1) {
	n_yaxes += p_info.layout.AXIS_Y[layout_i];
      }
    }
    function cumsum_array(array_of_arrays){
      var cumsum = [], max_value, cumsum_value = 0;
      for(var i=0; i<array_of_arrays.length; i++){
	cumsum_value += d3.max(array_of_arrays[i]);
	cumsum[i] = cumsum_value;
      }
      return cumsum;
    }
    var cum_height_per_row = cumsum_array(row_strip_heights);
    var cum_width_per_col = cumsum_array(col_strip_widths);
    var strip_width = d3.max(cum_width_per_col);
    var strip_height = d3.max(cum_height_per_row);

    // the *entire graph* height/width
    var graph_width = p_info.options.width - 
        ncols * (margin.left + margin.right) -
	strip_width -
        n_yaxes * axispaddingy - ytitlepadding;
    var graph_height = p_info.options.height - 
        nrows * (margin.top + margin.bottom) -
	strip_height -
        titlepadding - n_xaxes * axispaddingx - xtitlepadding;

    // Impose the pixelated aspect ratio of the graph upon the width/height
    // proportions calculated by the compiler. This has to be done on the
    // rendering side since the precomputed proportions apply to the *graph*
    // and the graph size depends upon results of measureText()
    if (p_info.layout.coord_fixed[0]) {
      var aspect = (graph_height / nrows) / (graph_width / ncols);
    } else {
      var aspect = 1;
    }
    var wp = p_info.layout.width_proportion.map(function(x){
      return x * Math.min(1, aspect);
    })
    var hp = p_info.layout.height_proportion.map(function(x){
      return x * Math.min(1, 1/aspect);
    })

    // track the proportion of the graph that should be 'blank'
    // this is mainly used to implement coord_fixed()
    var graph_height_blank = 1;
    var graph_width_blank = 1;
    for (var layout_i = 0; layout_i < npanels; layout_i++) {
      if (p_info.layout.COL[layout_i] == 1) graph_height_blank -= hp[layout_i];
      if (p_info.layout.ROW[layout_i] == 1) graph_width_blank -= wp[layout_i];
    }
    // cumulative portion of the graph used
    var graph_width_cum = (graph_width_blank / 2) * graph_width;
    var graph_height_cum = (graph_height_blank / 2) * graph_height;

    // Bind plot data to this plot's SVG element
    svg.plot = p_info;
    Plots[p_name] = p_info;
    p_info.geoms.forEach(function (g_name) {
      var layer_g_element = svg.append("g").attr("class", g_name);
      panel_names.forEach(function(PANEL){
        layer_g_element.append("g").attr("class", "PANEL" + PANEL);
      });
      SVGs[g_name] = svg;
    });

    // create a grouping for strip labels (even if there are none).
    var topStrip = svg.append("g")
      .attr("class", "topStrip")
    ;
    var rightStrip = svg.append("g")
      .attr("class", "rightStrip")
    ;

    // this will hold x/y scales for each panel
    // eventually we inject this into Plots[p_name]
    var scales = {};
    n_xaxes = 0;
    n_yaxes = 0;
    // Draw a plot outline for every panel
    for (var layout_i = 0; layout_i < npanels; layout_i++) {
      var panel_i = layout_i + 1;
      var axis  = p_info["axis" + panel_i];

      //forces values to be in an array
      var xaxisvals = [];
      var xaxislabs = [];
      var yaxisvals = [];
      var yaxislabs = [];
      var outbreaks, outlabs;

      //function to write labels and breaks to their respective arrays
      var axislabs = function(breaks, labs, axis){
        if(axis=="x"){
          outbreaks = xaxisvals;
          outlabs = xaxislabs;
        } else {
          outbreaks = yaxisvals;
          outlabs = yaxislabs;
        } // set appropriate variable names
        if (isArray(breaks)) {
          breaks.forEach(function (d) {
            outbreaks.push(d);
          })
        } else {
          //breaks can be an object!
          for (key in breaks) {
            outbreaks.push(breaks[key]);
          }
        }
        if (labs){
          labs.forEach(function (d) {
            outlabs.push(d);
            // push each label provided into the array
          });
        } else {
          outbreaks.forEach(function (d) {
            outlabs.push("");
            // push a blank string to the array for each axis tick
            // if the specified label is null
          });
        }
      };

      if(axis["xticks"]){
	axislabs(axis.x, axis.xlab, "x");
      }
      if(axis["yticks"]){
	axislabs(axis.y, axis.ylab, "y");
      }

      // compute the current panel height/width
      plotdim.graph.height = graph_height * hp[layout_i];
      plotdim.graph.width = graph_width * wp[layout_i];

      current_row = p_info.layout.ROW[layout_i];
      current_col = p_info.layout.COL[layout_i];
      var draw_x = p_info.layout.AXIS_X[layout_i];
      var draw_y = p_info.layout.AXIS_Y[layout_i];
      // panels are drawn using a "typewriter approach" (left to right
      // & top to bottom) if the carriage is returned (ie, there is a
      // new row), change some parameters:
      var new_row = current_col <= p_info.layout.COL[layout_i - 1]
      if (new_row) {
	n_yaxes = 0;
	graph_width_cum = (graph_width_blank / 2) * graph_width;
	graph_height_cum += graph_height * hp[layout_i-1];
      }
      n_xaxes += draw_x;
      n_yaxes += draw_y;

      // calculate panel specific locations to be used in placing
      // axes, labels, etc.
      plotdim.xstart =  current_col * plotdim.margin.left +
        (current_col - 1) * plotdim.margin.right +
        graph_width_cum + n_yaxes * axispaddingy + ytitlepadding;
      // room for right strips should be distributed evenly across
      // panels to preserve aspect ratio
      plotdim.xend = plotdim.xstart + plotdim.graph.width;
      // total height of strips drawn thus far
      var strip_h = cum_height_per_row[current_row-1];
      plotdim.ystart = current_row * plotdim.margin.top +
        (current_row - 1) * plotdim.margin.bottom +
        graph_height_cum + titlepadding + strip_h;
      // room for xaxis title should be distributed evenly across
      // panels to preserve aspect ratio
      plotdim.yend = plotdim.ystart + plotdim.graph.height;
      // always add to the width (note it may have been reset earlier)
      graph_width_cum = graph_width_cum + plotdim.graph.width;

      // get the x position of the y-axis title (and add padding) when
      // rendering the first plot.
      if (layout_i === 0) {
	var ytitle_x = (plotdim.xstart - axispaddingy - ytitlepadding / 2);
	var xtitle_left = plotdim.xstart;
	var ytitle_top = plotdim.ystart;
      }
      // get the y position of the x-axis title when drawing the last
      // panel.
      if (layout_i === (npanels - 1)) {
	var xtitle_y = (plotdim.yend + axispaddingx);
	var xtitle_right = plotdim.xend;
	var ytitle_bottom = plotdim.yend;
      }

      var draw_strip = function(strip, side) {
        if (strip == "") {
          return(null);
        }
        var x, y, rotate, stripElement, strip_text_xy;
        if (side == "right") {
          x = plotdim.xend;
          y = (plotdim.ystart + plotdim.yend) / 2;
          rotate = 90;
	  stripElement = rightStrip;
          strip_text_xy = "y";
        }else{ //top
	  x = (plotdim.xstart + plotdim.xend) / 2;
          y = plotdim.ystart;
	  rotate = 0;
	  stripElement = topStrip;
          strip_text_xy = "x";
	}
	var trans_text = "translate(" + x + "," + y + ")";
	var rot_text = "rotate(" + rotate + ")";
        var strip_text_size = "strip_text_"+strip_text_xy+"size";
	stripElement
          .selectAll("." + side + "Strips")
          .data(strip)
          .enter()
          .append("text")
          .style("text-anchor", "middle")
          .style("font-size", p_info[strip_text_size])
          .text(function(d) { return d; })
        // NOTE: there could be multiple strips per panel
        // TODO: is there a better way to manage spacing?
          .attr("transform", trans_text + rot_text)
	;
      }
      draw_strip([p_info.strips.top[layout_i]], "top");
      draw_strip([p_info.strips.right[layout_i]], "right");

      // for each of the x and y axes, there is a "real" and fake
      // version. The real version will be used for plotting the
      // data, and the fake version is just for the display of the
      // axes.
      scales[panel_i] = {};
      scales[panel_i].x = d3.scale.linear()
        .domain(axis.xrange)
        .range([plotdim.xstart, plotdim.xend]);
      scales[panel_i].y = d3.scale.linear()
        .domain(axis.yrange)
        .range([plotdim.yend, plotdim.ystart]);
      if(draw_x){
        var xaxis = d3.svg.axis()
          .scale(scales[panel_i].x)
          .tickValues(xaxisvals)
          .tickFormat(function (d) {
            return xaxislabs[xaxisvals.indexOf(d)].toString();
          })
          .orient("bottom")
	;
  var axis_panel = "xaxis" + "_" + panel_i;
	var xaxis_g = svg.append("g")
          .attr("class", "xaxis axis " + axis_panel)
          .attr("transform", "translate(0," + plotdim.yend + ")")
          .call(xaxis);
	if(axis["xline"] == false){
	  var axis_path = xaxis_g.select("path.domain");
	  axis_path.remove();
	}
	xaxis_g.selectAll("text")
	  .style("text-anchor", p_info.xanchor)
	  .style("font-size", p_info.xsize)
	  .attr("transform", "rotate(" + p_info.xangle + " 0 9)");
      }
      if(draw_y){
	var yaxis = d3.svg.axis()
          .scale(scales[panel_i].y)
          .tickValues(yaxisvals)
          .tickFormat(function (d) {
            return yaxislabs[yaxisvals.indexOf(d)].toString();
          })
          .orient("left");
  var axis_panel = "yaxis" + "_" + panel_i;
	var yaxis_g = svg.append("g")
          .attr("class", "yaxis axis " + axis_panel)
          .attr("transform", "translate(" + (plotdim.xstart) + ",0)")
          .call(yaxis);
	if(axis["yline"] == false){
	  var axis_path = yaxis_g.select("path.domain");
	  axis_path.remove();
	}
  yaxis_g.selectAll(".tick text")
    .style("font-size", p_info.ysize);
      }

      if(!axis.xline) {
    	styles.push("#"+p_name+" #xaxis"+" path{stroke:none;}");
      }
      if(!axis.xticks) {
    	styles.push("#"+p_name+" #xaxis .tick"+" line{stroke:none;}");
      }
      if(!axis.yline) {
    	styles.push("#"+p_name+" #yaxis"+" path{stroke:none;}");
      }
      if(!axis.yticks) {
    	styles.push("#"+p_name+" #yaxis .tick"+" line{stroke:none;}");
      }
      
      // creating g element for background, grid lines, and border
      // uses insert to draw it right before plot title
      var background = svg.insert("g", ".plottitle")
        .attr("class", "background bgr" + panel_i);
      
      // drawing background
      if(Object.keys(p_info.panel_background).length > 1) {
        background.append("rect")
          .attr("x", plotdim.xstart)
          .attr("y", plotdim.ystart)
          .attr("width", plotdim.xend - plotdim.xstart)
          .attr("height", plotdim.yend - plotdim.ystart)
          .attr("class", "background_rect")
          .style("fill", p_info.panel_background.fill)
          .style("stroke", p_info.panel_background.colour)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(p_info.panel_background.linetype,
                                          p_info.panel_background.size);
          });
      }
      
      // drawing the grid lines
      ["grid_minor", "grid_major"].forEach(function(grid_class){
	var grid_background = p_info[grid_class];
        // if grid lines are defined
        if(grid_background.hasOwnProperty("size")) {
          var grid = background.append("g")
              .attr("class", grid_class);
	  ["x","y"].forEach(function(scale_var){
	    var const_var;
	    if(scale_var == "x"){
	      const_var = "y";
	    }else{
	      const_var = "x";
	    }
            grid.append("g")
              .attr("class", scale_var)
              .selectAll("line")
              .data(grid_background.loc[scale_var][layout_i])
              .enter()
              .append("line")
              .attr(const_var + "1", plotdim[const_var + "start"])
              .attr(const_var + "2", plotdim[const_var + "end"])
              .attr(scale_var + "1", function(d) {
		return scales[panel_i][scale_var](d);
	      })
              .attr(scale_var + "2", function(d) {
		return scales[panel_i][scale_var](d);
	      })
              .style("stroke", grid_background.colour)
              .style("stroke-linecap", grid_background.lineend)
              .style("stroke-width", grid_background.size)
              .style("stroke-dasharray", linetypesize2dasharray(
		grid_background.linetype, grid_background.size))
	    ;
	  });
	}
      });
      
      // drawing border
      // uses insert to draw it right before the #plottitle
      if(Object.keys(p_info.panel_border).length > 1) {
        background.append("rect")
          .attr("x", plotdim.xstart)
          .attr("y", plotdim.ystart)
          .attr("width", plotdim.xend - plotdim.xstart)
          .attr("height", plotdim.yend - plotdim.ystart)
          .attr("class", "border_rect")
          .style("fill", p_info.panel_border.fill)
          .style("stroke", p_info.panel_border.colour)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(p_info.panel_border.linetype,
                                          p_info.panel_border.size);
          });
      }

    } //end of for(layout_i
    // After drawing all backgrounds, we can draw the axis labels.
    if(p_info["ytitle"]){
      svg.append("text")
	.text(p_info["ytitle"])
	.attr("class", "ytitle")
	.style("text-anchor", "middle")
	.style("font-size", default_axis_px + "px")
	.attr("transform", "translate(" + 
	      ytitle_x +
	      "," +
	      (ytitle_top + ytitle_bottom)/2 + 
	      ")rotate(270)")
      ;
    }
    if(p_info["xtitle"]){
      svg.append("text")
	.text(p_info["xtitle"])
	.attr("class", "xtitle")
	.style("text-anchor", "middle")
	.style("font-size", default_axis_px + "px")
	.attr("transform", "translate(" + 
	      (xtitle_left + xtitle_right)/2 +
	      "," + 
	      xtitle_y + 
	      ")")
      ;
    }
    Plots[p_name].scales = scales;
  }; //end of add_plot()

  function update_legend_opacity(v_name){
    var s_info = Selectors[v_name];
    s_info.legend_tds.style("opacity", s_info.legend_update_fun);
  }

  var add_selector = function (s_name, s_info) {
    Selectors[s_name] = s_info;
    if(s_info.type == "multiple"){
      if(!isArray(s_info.selected)){
        s_info.selected = [s_info.selected];
      }
      // legend_update_fun is evaluated in the context of the
      // td.legend_entry_label.
      s_info.legend_update_fun = function(d){
	var i_value = s_info.selected.indexOf(this.textContent);
	if(i_value == -1){
	  return 0.5;
	}else{
	  return 1;
	}
      }
    }else{
      s_info.legend_update_fun = function(d){
	if(this.textContent == s_info.selected){
	  return 1;
	}else{
	  return 0.5;
	}
      }
    }
    s_info.legend_tds = 
      element.selectAll("tr."+legend_class_name(s_name)+" td.legend_entry_label")
    ;
    update_legend_opacity(s_name);
  }; //end of add_selector()

  function get_tsv(g_info, chunk_id){
    return g_info.classed + "_chunk" + chunk_id + ".tsv";
  }
  function getTSVpath(tsv_name){
    return dirs.concat(tsv_name).join("/");
  }
  
  /**
   * copy common chunk tsv to varied chunk tsv, returning an array of
   * objects.
  */
  function copy_chunk(g_info, varied_chunk) {
    var varied_by_group = nest_by_group.map(varied_chunk);
    var common_by_group = g_info.data[g_info.common_tsv];
    var new_varied_chunk = [];
    for(group_id in varied_by_group){
      var varied_one_group = varied_by_group[group_id];
      var common_one_group = common_by_group[group_id];
      var common_i = 0;
      for(var varied_i=0; varied_i < varied_one_group.length; varied_i++){
	// there are two cases: each group of varied data is of length
	// 1, or of length of the common data.
	if(common_one_group.length == varied_one_group.length){
	  common_i = varied_i;
	}
	var varied_obj = varied_one_group[varied_i];
	var common_obj = common_one_group[common_i];
	for(col in common_obj){
	  if(col != "group"){
	    varied_obj[col] = common_obj[col];
	  }
	}
	new_varied_chunk.push(varied_obj);
      }
    }
    return new_varied_chunk;
  }

  // update_geom is called from add_geom and update_selector. It
  // downloads data if necessary, and then calls draw_geom.
  var update_geom = function (g_name, selector_name) {
    var g_info = Geoms[g_name];
    // First apply chunk_order selector variables.
    var chunk_id = g_info.chunks;
    g_info.chunk_order.forEach(function (v_name) {
      if(chunk_id == null){
        return; // no data in a higher up chunk var.
      }
      var value = Selectors[v_name].selected;
      if(chunk_id.hasOwnProperty(value)){
	       chunk_id = chunk_id[value];
      }else{
	       chunk_id = null; // no data to show in this subset.
      }
    });
    if(chunk_id == null){
      draw_panels(g_info, [], selector_name); //draw nothing.
      return;
    }
    var tsv_name = get_tsv(g_info, chunk_id);
    // get the data if it has not yet been downloaded.
    g_info.tr.select("td.chunk").text(tsv_name);
    if(g_info.data.hasOwnProperty(tsv_name)){
      draw_panels(g_info, g_info.data[tsv_name], selector_name);
    }else{
      g_info.tr.select("td.status").text("downloading");
      var svg = SVGs[g_name];
      var loading = svg.append("text")
        .attr("class", "loading"+tsv_name)
	      .text("Downloading "+tsv_name+"...")
	      .attr("font-size", 9)
	      //.attr("x", svg.attr("width")/2)
        .attr("y", 10)
        .style("fill", "red");
      download_chunk(g_info, tsv_name, function(chunk){
      	loading.remove();
	draw_panels(g_info, chunk, selector_name);
      });
    }
  };
  var draw_panels = function(g_info, chunk, selector_name) {
    // derive the plot name from the geometry name
    var g_names = g_info.classed.split("_");
    var p_name = g_names[g_names.length - 1];
    var panels = Plots[p_name].layout.PANEL;
    panels.forEach(function(panel) {
      draw_geom(g_info, chunk, selector_name, panel);
    });
  };

  function download_next(g_name){
    var g_info = Geoms[g_name];
    var selector_value = Animation.sequence[g_info.seq_i];
    var chunk_id = g_info.chunks[selector_value];
    var tsv_name = get_tsv(g_info, chunk_id);
    g_info.seq_count += 1;
    if(Animation.sequence.length == g_info.seq_count){
      Animation.done_geoms[g_name] = 1;
      return;
    }
    g_info.seq_i += 1;
    if(g_info.seq_i == Animation.sequence.length){
      g_info.seq_i = 0;
    }
    if(typeof(chunk_id) == "string"){
      download_chunk(g_info, tsv_name, function(chunk){
	download_next(g_name);
      })
    }else{
      download_next(g_name);
    }
  }

  // download_chunk is called from update_geom and download_next.
  function download_chunk(g_info, tsv_name, funAfter){
    if(g_info.download_status.hasOwnProperty(tsv_name)){
      var chunk;
      if(g_info.data_is_object){
	chunk = {};
      }else{
	chunk = [];
      }
      funAfter(chunk);
      return; // do not download twice.
    }
    g_info.download_status[tsv_name] = "downloading";
    // prefix tsv file with appropriate path
    var tsv_file = getTSVpath(tsv_name);
    d3.tsv(tsv_file, function (error, response) {
      // First convert to correct types.
      g_info.download_status[tsv_name] = "processing";
      response = convert_R_types(response, g_info.types);
      wait_until_then(500, function(){
	if(g_info.common_tsv) {
          return g_info.data.hasOwnProperty(g_info.common_tsv);
	}else{
	  return true;
	}
      }, function(){
	if(g_info.common_tsv) {
          // copy data from common tsv to varied tsv
          response = copy_chunk(g_info, response);
	}
	var nest = d3.nest();
	g_info.nest_order.forEach(function (v_name) {
          nest.key(function (d) {
            return d[v_name];
          });
	});
	var chunk = nest.map(response);
	g_info.data[tsv_name] = chunk;
	g_info.tr.select("td.downloaded").text(d3.keys(g_info.data).length);
	g_info.download_status[tsv_name] = "saved";
	funAfter(chunk);
      });
    });
  }//download_chunk.

  // update_geom is responsible for obtaining a chunk of downloaded
  // data, and then calling draw_geom to actually draw it.
  var draw_geom = function(g_info, chunk, selector_name, PANEL){
    g_info.tr.select("td.status").text("displayed");
    var svg = SVGs[g_info.classed];
    // derive the plot name from the geometry name
    var g_names = g_info.classed.split("_");
    var p_name = g_names[g_names.length - 1];
    var scales = Plots[p_name].scales[PANEL];
    var selected_arrays = [ [] ]; //double array necessary.
    var has_clickSelects = g_info.aes.hasOwnProperty("clickSelects");
    var has_clickSelects_variable =
      g_info.aes.hasOwnProperty("clickSelects.variable");
    g_info.subset_order.forEach(function (aes_name) {
      var selected, values;
      var new_arrays = [];
      if(0 < aes_name.indexOf(".variable")){ 
	selected_arrays.forEach(function(old_array){
	  var some_data = chunk;
	  old_array.forEach(function(value){
            if(some_data.hasOwnProperty(value)) {
              some_data = some_data[value];
            } else {
              some_data = {};
            }
	  })
	  values = d3.keys(some_data);
	  values.forEach(function(s_name){
	    var selected = Selectors[s_name].selected;
	    var new_array = old_array.concat(s_name).concat(selected);
	    new_arrays.push(new_array);
	  })
	})
      }else{//not .variable aes:
	if(aes_name == "PANEL"){
	  selected = PANEL;
	}else{
          var s_name = g_info.aes[aes_name];
          selected = Selectors[s_name].selected;
	}
	if(isArray(selected)){ 
	  values = selected; //multiple selection.
	}else{
	  values = [selected]; //single selection.
	}
	values.forEach(function(value){
	  selected_arrays.forEach(function(old_array){
	    var new_array = old_array.concat(value);
	    new_arrays.push(new_array);
	  })
	})
      }
      selected_arrays = new_arrays;
    });
    // data can be either an array[] if it will be directly involved
    // in a data-bind, or an object{} if it will be involved in a
    // data-bind by group (e.g. geom_line).
    var data;
    if(g_info.data_is_object){
      data = {};
    }else{
      data = [];
    }
    selected_arrays.forEach(function(value_array){
      var some_data = chunk;
      value_array.forEach(function(value){
        if (some_data.hasOwnProperty(value)) {
          some_data = some_data[value];
        } else {
	  if(g_info.data_is_object){
	    some_data = {};
	  }else{
            some_data = [];
	  }
        }
      });
      if(g_info.data_is_object){
	if(isArray(some_data) && some_data.length){
	  data["0"] = some_data;
	}else{
	  for(k in some_data){
            data[k] = some_data[k];
          }
	}
      }else{//some_data is an array.
        data = data.concat(some_data);
      }
    });
    var aes = g_info.aes;
    var toXY = function (xy, a) {
      return function (d) {
        return scales[xy](d[a]);
      };
    };
    var layer_g_element = svg.select("g." + g_info.classed);
    var panel_g_element = layer_g_element.select("g.PANEL" + PANEL);
    var elements = panel_g_element.selectAll(".geom");

    // helper functions so we can write code that works for both
    // grouped and ungrouped geoms. get_one_row returns one row of
    // data (not one group), in both cases.
    var get_fun = function(fun){
      return function(input){
	var d = get_one_row(input);
	return fun(d);
      };
    };
    var get_attr = function(attr_name){
      return get_fun(function(d){
	return d[attr_name];
      });
    };

    var size = 2;
    var get_size;
    if(aes.hasOwnProperty("size")){
      get_size = get_attr("size");
    }else{
      get_size = function(d){
	return size;
      };
    }
    var get_style_on_stroke_width = get_size;
    
    // stroke_width for geom_point
    var stroke_width = 1;  // by default ggplot2 has 0.5, animint has 1
    var get_stroke_width;
    if(aes.hasOwnProperty("stroke")){
      get_stroke_width = get_attr("stroke");
    }else{
      get_stroke_width = function(d){
	return stroke_width;
      };
    }
    
    var linetype = "solid";
    var get_linetype;
    if(aes.hasOwnProperty("linetype")){
      get_linetype = get_attr("linetype");
    }else{
      get_linetype = function(d){
	return linetype;
      };
    }
    var get_dasharray = function(d){
      var lt = get_linetype(d);
      return linetypesize2dasharray(lt, get_size(d));
    };

    var alpha = 1, alpha_off = 0.5;
    var get_alpha;
    var get_alpha_off = function (d) {
      return alpha_off;
    };
    if(aes.hasOwnProperty("alpha")){
      get_alpha = get_attr("alpha");
      get_alpha_off = get_attr("alpha");
    } else {
      get_alpha = function(d){
	return alpha;
      };
    }
    
    var colour = "black", colour_off;
    var get_colour;
    var get_colour_off = function (d) {
      return colour_off;
    };
    if(aes.hasOwnProperty("colour")){
      get_colour = get_attr("colour");
      get_colour_off = get_colour;
    }else{
      get_colour = function (d) {
	return colour;
      };
    }
    var get_colour_off_default = get_colour;

    var fill = "black", fill_off = "black";
    var get_fill = function (d) {
      return fill;
    };
    var get_fill_off = function (d) {
      return fill_off;
    };
    
    var angle = 0;
    var get_angle;
    if(aes.hasOwnProperty("angle")){
      get_angle = get_attr("angle");
    }else{
      get_angle = function(d){
	return angle;
      };
    }
    var get_rotate = function(d){
      // x and y are the coordinates to rotate around, we choose the center 
      // point of the text because otherwise it will rotate around (0,0) of its 
      // coordinate system, which is the top left of the plot
      x = scales["x"](d["x"]);
      y = scales["y"](d["y"]);
      var angle = get_angle(d);
      // ggplot expects angles to be in degrees CCW, SVG uses degrees CW, so 
      // we negate the angle.
      return `rotate(${-angle}, ${x}, ${y})`;
    };
    
    // For aes(hjust) the compiler should make an "anchor" column.
    var text_anchor = "middle";
    var get_text_anchor;
    if(g_info.aes.hasOwnProperty("hjust")) {
      get_text_anchor = function(d){
	return d["anchor"];
      }
    }else{
      get_text_anchor = function(d){
	return text_anchor;
      }
    }

    var eActions, eAppend;
    var key_fun = null;
    if(g_info.aes.hasOwnProperty("key")){
      key_fun = function(d){
        return d.key;
      };
    }
    var get_one_row;//different for grouped and ungrouped geoms.
    var data_to_bind;
    g_info.style_list = [
      "opacity","stroke","stroke-width","stroke-dasharray","fill"];
    var line_style_list = [
      "opacity","stroke","stroke-width","stroke-dasharray"];
    var fill_comes_from="fill", fill_off_comes_from="fill_off";
    if(g_info.data_is_object) {

      // Lines, paths, polygons, and ribbons are a bit special. For
      // every unique value of the group variable, we take the
      // corresponding data rows and make 1 path. The tricky part is
      // that to use d3 I do a data-bind of some "fake" data which are
      // just group ids, which is the kv variable in the code below

      // // case of only 1 line and no groups.
      // if(!aes.hasOwnProperty("group")){
      //     kv = [{"key":0,"value":0}];
      //     data = {0:data};
      // }else{
      //     // we need to use a path for each group.
      //     var kv = d3.entries(d3.keys(data));
      //     kv = kv.map(function(d){
      // 	d[aes.group] = d.value;
      // 	return d;
      //     });
      // }

      // For an example consider breakpointError$error which is
      // defined using this R code

      // geom_line(aes(segments, error, group=bases.per.probe,
      //    clickSelects=bases.per.probe), data=only.error, lwd=4)

      // Inside update_geom the variables take the following values
      // (pseudo-Javascript code)

      // var kv = [{"key":"0","value":"133","bases.per.probe":"133"},
      //           {"key":"1","value":"2667","bases.per.probe":"2667"}];
      // var data = {"133":[array of 20 points used to draw the line for group 133],
      //             "2667":[array of 20 points used to draw the line for group 2667]};

      // I do elements.data(kv) so that when I set the d attribute of
      // each path, I need to select the correct group before
      // returning anything.

      // e.attr("d",function(group_info){
      //     var one_group = data[group_info.value];
      //     return lineThing(one_group);
      // })

      // To make color work I think you just have to select the group
      // and take the color of the first element, e.g.

      // .style("stroke",function(group_info){
      //     var one_group = data[group_info.value];
      //     var one_row = one_group[0];
      //     return get_color(one_row);
      // }

      // In order to get d3 lines to play nice, bind fake "data" (group
      // id's) -- the kv variable. Then each separate object is plotted
      // using path (case of only 1 thing and no groups).

      // we need to use a path for each group.
      var keyed_data = {}, one_group, group_id, k;
      for(group_id in data){
	one_group = data[group_id];
	one_row = one_group[0];
	if(one_row.hasOwnProperty("key")){
	  k = one_row.key;
	}else{
	  k = group_id;
	}
	keyed_data[k] = one_group;
      }
      var kv_array = d3.entries(d3.keys(keyed_data));
      var kv = kv_array.map(function (d) {
        //d[aes.group] = d.value;

        // Need to store the clickSelects value that will
        // be passed to the selector when we click on this
        // item.
        d.clickSelects = keyed_data[d.value][0].clickSelects;
        return d;
      });

      // line, path, and polygon use d3.svg.line(),
      // ribbon uses d3.svg.area()
      // we have to define lineThing accordingly.
      if (g_info.geom == "ribbon") {
        var lineThing = d3.svg.area()
          .x(toXY("x", "x"))
          .y(toXY("y", "ymax"))
          .y0(toXY("y", "ymin"));
      } else {
        var lineThing = d3.svg.line()
          .x(toXY("x", "x"))
          .y(toXY("y", "y"));
      }
      if(["line","path"].includes(g_info.geom)){
	fill = "none";
	fill_off = "none";
      }
      // select the correct group before returning anything.
      key_fun = function(group_info){
	return group_info.value;
      };
      data_to_bind = kv;
      get_one_row = function(group_info) {
        var one_group = keyed_data[group_info.value];
        var one_row = one_group[0];
	return one_row;
      };
      eActions = function (e) {
        e.attr("d", function (d) {
          var one_group = keyed_data[d.value];
          // filter NaN since they make the whole line disappear!
	  var no_na = one_group.filter(function(d){
            if(g_info.geom == "ribbon"){
              return !isNaN(d.x) && !isNaN(d.ymin) && !isNaN(d.ymax);
            }else{
              return !isNaN(d.x) && !isNaN(d.y);
            }
          });
          return lineThing(no_na);
        })
      };
      eAppend = "path";
    }else{
      get_one_row = function(d){
	return d;
      }
      data_to_bind = data;
      if (g_info.geom == "segment") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("x1", function (d) {
            return scales.x(d["x"]);
          })
            .attr("x2", function (d) {
              return scales.x(d["xend"]);
            })
            .attr("y1", function (d) {
              return scales.y(d["y"]);
            })
            .attr("y2", function (d) {
              return scales.y(d["yend"]);
            })
	};
	eAppend = "line";
      }
      if (g_info.geom == "linerange") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("x1", function (d) {
            return scales.x(d["x"]);
          })
            .attr("x2", function (d) {
              return scales.x(d["x"]);
            })
            .attr("y1", function (d) {
              return scales.y(d["ymax"]);
            })
            .attr("y2", function (d) {
              return scales.y(d["ymin"]);
            })
	  ;
	};
	eAppend = "line";
      }
      if (g_info.geom == "vline") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("x1", toXY("x", "xintercept"))
            .attr("x2", toXY("x", "xintercept"))
            .attr("y1", scales.y.range()[0])
            .attr("y2", scales.y.range()[1])
	  ;
	};
	eAppend = "line";
      }
      if (g_info.geom == "hline") {
	g_info.style_list = line_style_list;
	eActions = function (e) {
          e.attr("y1", toXY("y", "yintercept"))
            .attr("y2", toXY("y", "yintercept"))
            .attr("x1", scales.x.range()[0])
            .attr("x2", scales.x.range()[1])
	  ;
	};
	eAppend = "line";
      }
      if (g_info.geom == "text") {
	size = 12;//default
	get_colour = function(d){
	  return "none";
	};
	get_colour_off = function(d) {
	  return "none";
	};
	fill_comes_from = "colour";
	fill_off_comes_from = "colour_off";
	g_info.style_list = [
	  "opacity","fill"];
	eActions = function (e) {
          e.attr("x", toXY("x", "x"))
            .attr("y", toXY("y", "y"))
            .attr("font-size", get_size)
            .style("text-anchor", get_text_anchor)
            .attr("transform", get_rotate)
            .text(function (d) {
              return d.label;
            })
	  ;
	};
	eAppend = "text";
      }
      if (g_info.geom == "point") {
	// point is special because it takes SVG fill from ggplot
	// colour, if fill is not specified.
	if(!(
	  g_info.params.hasOwnProperty("fill") ||
	    aes.hasOwnProperty("fill")
	)){
	  fill_comes_from = "colour";
	}
	if(!g_info.params.hasOwnProperty("fill_off")){
	  fill_off_comes_from = "colour_off";
	}
	get_style_on_stroke_width = get_stroke_width;//not size.
	eActions = function (e) {
          e.attr("cx", toXY("x", "x"))
            .attr("cy", toXY("y", "y"))
            .attr("r", get_size)
	  ;
	};
	eAppend = "circle";
      }
      var rect_geoms = ["tallrect","widerect","rect"];
      if(rect_geoms.includes(g_info.geom)){
	eAppend = "rect";
	if (g_info.geom == "tallrect") {
	  eActions = function (e) {
            e.attr("x", toXY("x", "xmin"))
              .attr("width", function (d) {
		return scales.x(d["xmax"]) - scales.x(d["xmin"]);
              })
              .attr("y", scales.y.range()[1])
              .attr("height", scales.y.range()[0] - scales.y.range()[1])
	    ;
	  };
	}
	if (g_info.geom == "widerect") {
	  eActions = function (e) {
            e.attr("y", toXY("y", "ymax"))
              .attr("height", function (d) {
		return scales.y(d["ymin"]) - scales.y(d["ymax"]);
              })
              .attr("x", scales.x.range()[0])
              .attr("width", scales.x.range()[1] - scales.x.range()[0])
	    ;
	  };
	}
	if (g_info.geom == "rect") {
	  alpha_off = alpha;
	  colour_off = "transparent";
	  get_colour_off_default = get_colour_off;
	  eActions = function (e) {
            e.attr("x", toXY("x", "xmin"))
              .attr("width", function (d) {
		return Math.abs(scales.x(d.xmax) - scales.x(d.xmin));
              })
              .attr("y", toXY("y", "ymax"))
              .attr("height", function (d) {
		return Math.abs(scales.y(d.ymin) - scales.y(d.ymax));
              })
	    ;
	  };
	}
      }
    }
    // set params after geom-specific code, because each geom may have
    // a different default.
    if (g_info.params.hasOwnProperty("stroke")) {
      stroke_width = g_info.params.stroke;
    }
    if (g_info.params.hasOwnProperty("linetype")) {
      linetype = g_info.params.linetype;
    }
    if(g_info.params.hasOwnProperty("alpha")){
      alpha = g_info.params.alpha;
      alpha_off = alpha - 0.5
    }
    if(g_info.params.hasOwnProperty("alpha_off")){
      alpha_off = g_info.params.alpha_off;
    }
    if(g_info.params.hasOwnProperty("anchor")){
      text_anchor = g_info.params["anchor"];
    }
    if(g_info.params.hasOwnProperty("colour")){
      colour = g_info.params.colour;
    }
    if(g_info.params.hasOwnProperty("colour_off")){
      colour_off = g_info.params.colour_off;
    }else{
      get_colour_off = get_colour_off_default;
    }
    if (g_info.params.hasOwnProperty("angle")) {
      angle = g_info.params["angle"];
    }
    if (g_info.params.hasOwnProperty(fill_comes_from)) {
      fill = g_info.params[fill_comes_from];
    }
    if (g_info.params.hasOwnProperty(fill_off_comes_from)) {
      fill_off = g_info.params[fill_off_comes_from];
    }else{
      fill_off = fill;
    }
    if(aes.hasOwnProperty(fill_comes_from)){
      get_fill = get_attr(fill_comes_from);
      get_fill_off = get_attr(fill_comes_from);
    };
    if (g_info.params.hasOwnProperty("size")) {
      size = g_info.params.size;
    }
    var styleActions = function(e){
      g_info.style_list.forEach(function(s){
	e.style(s, function(d) {
	  var style_on_fun = style_on_funs[s];
	  return style_on_fun(d);
	});
      });
    };
    var style_on_funs = {
      "opacity": get_alpha,
      "stroke": get_colour,
      "fill": get_fill,
      "stroke-width": get_style_on_stroke_width,
      "stroke-dasharray": get_dasharray
    };
    var style_off_funs = {
      "opacity": get_alpha_off,
      "stroke": get_colour_off,
      "fill": get_fill_off
    };
    // TODO cleanup.
    var select_style_default = ["opacity","stroke","fill"];
    g_info.select_style = select_style_default.filter(
      X => g_info.style_list.includes(X));
    var over_fun = function(e){
      g_info.select_style.forEach(function(s){
        e.style(s, function (d) {
          return style_on_funs[s](d);
        });
      });
    };
    var out_fun = function(e){
      g_info.select_style.forEach(function(s){
        e.style(s, function (d) {
          var select_on = style_on_funs[s](d);
          var select_off = style_off_funs[s](d);
          if(has_clickSelects){
            return ifSelectedElse(
	      d.clickSelects,
	      g_info.aes.clickSelects,
              select_on, select_off);
          }else if(has_clickSelects_variable){
            return ifSelectedElse(
	      d["clickSelects.value"],
              d["clickSelects.variable"],
              select_on, select_off);
          }
        });
      });
    };
    elements = elements.data(data_to_bind, key_fun);
    elements.exit().remove();
    var enter = elements.enter();
    if(g_info.aes.hasOwnProperty("href")){
      enter = enter.append("svg:a")
        .append("svg:"+eAppend);
    }else{
      enter = enter.append(eAppend)
	.attr("class", "geom");
    }
    var moreActions = function(e){};
    if (has_clickSelects || has_clickSelects_variable) {
      moreActions = out_fun;
      elements.call(out_fun)
        .on("mouseover", function (d) {
          d3.select(this).call(over_fun);
        })
        .on("mouseout", function (d) {
          d3.select(this).call(out_fun);
        })
      ;
      if(has_clickSelects){
	elements.on("click", function (d) {
            var s_name = g_info.aes.clickSelects;
            update_selector(s_name, d.clickSelects);
	});
      }else{
	elements.on("click", function(d){
	  var s_name = d["clickSelects.variable"];
	  var s_value = d["clickSelects.value"];
	  update_selector(s_name, s_value);
	});
      }
    }
    // Set attributes of only the entering elements. This is needed to
    // prevent things from flying around from the upper left when they
    // enter the plot.
    var doActions = function(e) {
      eActions(e);
      styleActions(e);
      moreActions(e)
    };
    doActions(enter);  // DO NOT DELETE!
    var has_tooltip = g_info.aes.hasOwnProperty("tooltip");
    if(has_clickSelects || has_tooltip || has_clickSelects_variable){
      var text_fun;
      if(has_tooltip){
        text_fun = function(d){
	  return d.tooltip;
	};
      }else if(has_clickSelects){
	text_fun = function(d){
          var v_name = g_info.aes.clickSelects;
          return v_name + " " + d.clickSelects;
	};
      }else{ //clickSelects_variable
	text_fun = function(d){
	  return d["clickSelects.variable"] + " " + d["clickSelects.value"];
	};
      }
      // if elements have an existing title, remove it.
      elements.selectAll("title").remove();
      elements.append("svg:title")
        .text(get_fun(text_fun))
      ;
    }
    if(Selectors.hasOwnProperty(selector_name)){
      var milliseconds = Selectors[selector_name].duration;
      elements = elements.transition().duration(milliseconds);
    }
    if(g_info.aes.hasOwnProperty("id")){
      elements.attr("id", get_attr("id"));
    }
    if(g_info.aes.hasOwnProperty("href")){
      // elements are <a>, children are e.g. <circle>
      var linked_geoms = elements.select(eAppend);
      doActions(linked_geoms);
      elements.attr("xlink:href", get_attr("href"))
        .attr("target", "_blank")
        .attr("class", "geom");
    }else{
      // elements are e.g. <circle>
      doActions(elements); // Set the attributes of all elements (enter/exit/stay)
    }
  };
  
  var value_tostring = function(selected_values) {
      //function that is helpful to change the format of the string
      var selector_url="#"
      for (var selc_var in selected_values){
          if(selected_values.hasOwnProperty(selc_var)){
              var values_str=selected_values[selc_var].join();
              var sub_url=selc_var.concat("=","{",values_str,"}");
              selector_url=selector_url.concat(sub_url);
          }
      }
      var url_nohash=window.location.href.match(/(^[^#]*)/)[0];
      selector_url=url_nohash.concat(selector_url);
      return  selector_url;
 };
  
  var get_values=function(){
      // function that is useful to get the selected values
      var selected_values={}
      for(var s_name in Selectors){
          var s_info=Selectors[s_name];
          var initial_selections = [];
          if(s_info.type==="single"){
              initial_selections=[s_info.selected];
          }
          else{
          for(var i in s_info.selected) {
            initial_selections[i] =  s_info.selected[i];
          }
          }
          selected_values[s_name]=initial_selections;    
      }
      return selected_values;
  };
  
  // update scales for the plots that have update_axes option in
  // theme_animint
  function update_scales(p_name, axes, v_name, value){
    // Get pre-computed domain
    var axis_domains = Plots[p_name]["axis_domains"];
    if(!isArray(axes)){
      axes = [axes];
    }
    if(axis_domains != null){
      axes.forEach(function(xyaxis){
        // For Each PANEL, update the axes
        Plots[p_name].layout.PANEL.forEach(function(panel_i, i){
          // Determine whether this panel has a scale or not
          // If not we just update the scales according to the common
          // scale and skip the updating of axis
          var draw_axes = Plots[p_name].layout["AXIS_"+ xyaxis.toUpperCase()][i];
          if(draw_axes){
            var use_panel = panel_i;
          }else{
            var use_panel = Plots[p_name].layout.PANEL[0];
          }
          // We update the current selection of the plot every time
          // and use it to index the correct domain
          var curr_select = axis_domains[xyaxis].curr_select;
          if(axis_domains[xyaxis].selectors.indexOf(v_name) > -1){
            curr_select[v_name] = value;
            var str = use_panel+".";
            for(selec in curr_select){
              str = str + curr_select[selec] + "_";
            }
            str = str.substring(0, str.length - 1); // Strip off trailing underscore
            var use_domain = axis_domains[xyaxis]["domains"][str];
          }
          if(use_domain != null){
            Plots[p_name]["scales"][panel_i][xyaxis].domain(use_domain);
            var scales = Plots[p_name]["scales"][panel_i][xyaxis];
            // major and minor grid lines as calculated in the compiler
            var grid_vals = Plots[p_name]["axis_domains"][xyaxis]["grids"][str];

            // Once scales are updated, update the axis ticks if needed
            if(draw_axes){
              // Tick values are same as major grid lines
              update_axes(p_name, xyaxis, panel_i, grid_vals[1]);
            }
            // Update major and minor grid lines
            update_grids(p_name, xyaxis, panel_i, grid_vals, scales);
          }
        });
      });
    }
  }

  // Update the axis ticks etc. once plot is zoomed in/out
  // currently called from update_scales.
  function update_axes(p_name, axes, panel_i, tick_vals){
    var orientation;
    if(axes == "x"){
      orientation = "bottom";
    }else{
      orientation = "left";
    }
    if(!isArray(tick_vals)){
      tick_vals = [tick_vals];
    }
    var xyaxis = d3.svg.axis()
          .scale(Plots[p_name]["scales"][panel_i][axes])
          .orient(orientation)
          .tickValues(tick_vals);
    // update existing axis
    var xyaxis_g = element.select("#plot_"+p_name).select("."+axes+"axis_"+panel_i)
          .transition()
          .duration(1000)
          .call(xyaxis);
  }

  // Update major/minor grids once axes ticks have been updated
  function update_grids(p_name, axes, panel_i, grid_vals, scales){
    // Select panel to update
    var bgr = element.select("#plot_"+p_name).select(".bgr"+panel_i);
    // Update major and minor grid lines
    ["minor", "major"].forEach(function(grid_class, j){
      var lines = bgr.select(".grid_"+grid_class).select("."+axes);
      var xy1, xy2;
      if(axes == "x"){
        xy1 = lines.select("line").attr("y1");
        xy2 = lines.select("line").attr("y2");
      }else{
        xy1 = lines.select("line").attr("x1");
        xy2 = lines.select("line").attr("x2");
      }
      
      // Get default values for grid lines like colour, stroke etc.
      var grid_background = Plots[p_name]["grid_"+grid_class];
      var col = grid_background.colour;
      var lt = grid_background.linetype;
      var size = grid_background.size;
      var cap = grid_background.lineend;

      // Remove old lines
      lines.selectAll("line")
        .remove();

      if(!isArray(grid_vals[j])){
        grid_vals[j] = [grid_vals[j]];
      }

      if(axes == "x"){
        lines.selectAll("line")
          .data(grid_vals[j])
          .enter()
          .append("line")
          .attr("y1", xy1)
          .attr("y2", xy2)
          .attr("x1", function(d) { return scales(d); })
          .attr("x2", function(d) { return scales(d); })
          .style("stroke", col)
          .style("stroke-linecap", cap)
          .style("stroke-width", size)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(lt, size);
          });
      }else{
        lines.selectAll("line")
          .data(grid_vals[j])
          .enter()
          .append("line")
          .attr("x1", xy1)
          .attr("x2", xy2)
          .attr("y1", function(d) { return scales(d); })
          .attr("y2", function(d) { return scales(d); })
          .style("stroke", col)
          .style("stroke-linecap", cap)
          .style("stroke-width", size)
          .style("stroke-dasharray", function() {
            return linetypesize2dasharray(lt, size);
          });
      }
    });
  }

  var update_selector = function (v_name, value) {
    if(!Selectors.hasOwnProperty(v_name)){
      return;
    }
    value = value + "";
    var s_info = Selectors[v_name];
    if(s_info.type == "single"){
      // value is the new selection.
      s_info.selected = value;
    }else{
      // value should be added or removed from the selection.
      var i_value = s_info.selected.indexOf(value);
      if(i_value == -1){
        // not found, add to selection.
	s_info.selected.push(value);
      }else{
	// found, remove from selection.
	s_info.selected.splice(i_value, 1);
      }
    }
    // update_selector_url()
    // if there are levels, then there is a selectize widget which
    // should be updated.
    if(isArray(s_info.levels)){
      // the jquery ids
      if(s_info.type == "single") {
	var selected_ids = v_name.concat("___", value);
      } else {
	var selected_ids = [];
	for(i in s_info.selected) {
          selected_ids[i] = v_name.concat("___", s_info.selected[i]);
	}
      }
      // from
      // https://github.com/brianreavis/selectize.js/blob/master/docs/api.md:
      // setValue(value, silent) If "silent" is truthy, no change
      // event will be fired on the original input.
      selectized_array[v_name].setValue(selected_ids, true);
    }

    // For each updated geom, check if the axes of the plot need to be
    // updated and update them
    s_info.update.forEach(function(g_name){
      var plot_name = g_name.split("_").pop();
      var axes = Plots[plot_name]["options"]["update_axes"];
      if(axes != null){
        update_scales(plot_name, axes, v_name, value);
      }
    });

    update_legend_opacity(v_name);
    s_info.update.forEach(function(g_name){
      update_geom(g_name, v_name);
    });
  };

  var ifSelectedElse = function (s_value, s_name, selected, not_selected) {
    var is_selected;
    var s_info = Selectors[s_name];
    if(s_info.type == "single"){
      is_selected = s_value == s_info.selected;
    }else{
      is_selected = s_info.selected.indexOf(s_value) != -1;
    }
    if(is_selected){
      return selected;
    } else {
      return not_selected;
    }
  };
  
  function update_next_animation(){
    var values = d3.values(Animation.done_geoms);
    if(d3.sum(values) == values.length){
      // If the values in done_geoms are all 1, then we have loaded
      // all of the animation-related chunks, and we can start
      // playing the animation.
      var v_name = Animation.variable;
      var cur = Selectors[v_name].selected;
      var next = Animation.next[cur];
      update_selector(v_name, next);
    }
  }

  // The main idea of how legends work:

  // 1. In getLegend in animint.R I export the legend entries as a
  // list of rows that can be used in a data() bind in D3.

  // 2. Here in add_legend I create a <table> for every legend, and
  // then I bind the legend entries to <tr>, <td>, and <svg> elements.
  var add_legend = function(p_name, p_info){
    // case of multiple legends, d3 reads legend structure in as an array
    var tdRight = element.select("td."+p_name+"_legend");
    var legendkeys = d3.keys(p_info.legend);
    for(var i=0; i<legendkeys.length; i++){
      var legend_key = legendkeys[i];
      var l_info = p_info.legend[legend_key];
      // the table that contains one row for each legend element.
      var legend_table = tdRight.append("table")
	.attr("class", "legend")
      ;
      var legend_class = legend_class_name(l_info["class"]);
      var legend_id = p_info.plot_id + "_" + legend_class;
      // the legend table with breaks/value/label .
      // TODO: variable and value should be set in the compiler! What
      // if label is different from the data value?
      for(var entry_i=0; entry_i < l_info.entries.length; entry_i++){
	var entry = l_info.entries[entry_i];
	entry.variable = l_info.selector;
	entry.value = entry.label;
	entry.id = safe_name(legend_id + "_" + entry["label"]);
  	entry.text_size = l_info.text_size;
      }
      var legend_rows = legend_table.selectAll("tr")
        .data(l_info.entries)
        .enter()
        .append("tr")
      // in a good data viz there should not be more than one legend
      // that shows the same thing, so there should be no duplicate
      // id.
        .attr("id", function(d) { return d["id"]; })
	.attr("class", legend_class)
      ;
      if(l_info.selector != null){
	legend_rows
	  .on("click", function(d) { 
            update_selector(d.variable, d.value);
	  })
	  .attr("title", function(d) {
            return "Toggle " + d.value;
	  })
	  .attr("style", "cursor:pointer")
	;
      }
      var first_tr = legend_table.insert("tr", "tr");
      var first_th = first_tr.append("th")
	.attr("align", "left")
	.attr("colspan", 2)
        .text(l_info.title)
        .attr("class", legend_class)
        .style("font-size", l_info.title_size)
      ;
      var legend_svgs = legend_rows.append("td")
        .append("svg")
  	    .attr("id", function(d){return d["id"]+"_svg";})
  	    .attr("height", 14)
  	    .attr("width", 20);
      var pointscale = d3.scale.linear().domain([0,7]).range([1,4]);
      // scale points so they are visible in the legend. (does not
      // affect plot scaling)
      var linescale = d3.scale.linear().domain([0,6]).range([1,4]);
      // scale lines so they are visible in the legend. (does not
      // affect plot scaling)
      if(l_info.geoms.indexOf("polygon")>-1){
        // aesthetics that would draw a rect
        legend_svgs.append("rect")
          .attr("x", 2)
	        .attr("y", 2)
	        .attr("width", 10)
	        .attr("height", 10)
          .style("stroke-width", function(d){return d["polygonsize"]||1;})
          .style("stroke-dasharray", function(d){
            return linetypesize2dasharray(d["polygonlinetype"], d["size"]||2);
          })
          .style("stroke", function(d){return d["polygoncolour"] || "#000000";})
          .style("fill", function(d){return d["polygonfill"] || "#FFFFFF";})
          .style("opacity", function(d){return d["polygonalpha"]||1;});
      }
      if(l_info.geoms.indexOf("text")>-1){
        // aesthetics that would draw a rect
        legend_svgs.append("text")
	        .attr("x", 10)
	        .attr("y", 14)
          	.style("fill", function(d){return d["textcolour"]||1;})
	        .style("text-anchor", "middle")
          	.attr("font-size", function(d){return d["textsize"]||1;})
	        .text("a");
      }
      if(l_info.geoms.indexOf("path")>-1){
        // aesthetics that would draw a line
        legend_svgs.append("line")
          .attr("x1", 1).attr("x2", 19).attr("y1", 7).attr("y2", 7)
          .style("stroke-width", function(d){
            return linescale(d["pathsize"])||2;
          })
          .style("stroke-dasharray", function(d){
            return linetypesize2dasharray(d["pathlinetype"], d["pathsize"] || 2);
          })
          .style("stroke", function(d){return d["pathcolour"] || "#000000";})
          .style("opacity", function(d){return d["pathalpha"]||1;});
      }
      if(l_info.geoms.indexOf("point")>-1){
        // aesthetics that would draw a point
        legend_svgs.append("circle")
          .attr("cx", 10)
          .attr("cy", 7)
          .attr("r", function(d){return pointscale(d["pointsize"])||4;})
          .style("stroke", function(d){return d["pointcolour"] || "#000000";})
          .style("fill", function(d){
            return d["pointfill"] || d["pointcolour"] || "#000000";
          })
          .style("opacity", function(d){return d["pointalpha"]||1;});
      }
      legend_rows.append("td")
	.attr("align", "left") // TODO: right for numbers?
	.attr("class", "legend_entry_label")
	.attr("id", function(d){ return d["id"]+"_label"; })
  	.style("font-size", function(d){ return d["text_size"]})
	.text(function(d){ return d["label"];});
    }
  }

  // Download the main description of the interactive plot.
  d3.json(json_file, function (error, response) {
    if(response.hasOwnProperty("title")){
      // This selects the title of the web page, outside of wherever
      // the animint is defined, usually a <div> -- so it is OK to use
      // global d3.select here.
      d3.select("title").text(response.title);
    }
    // Add plots.
    for (var p_name in response.plots) {
      add_plot(p_name, response.plots[p_name]);
      add_legend(p_name, response.plots[p_name]);
      // Append style sheet to document head.
      css.appendChild(document.createTextNode(styles.join(" ")));
      document.head.appendChild(css);
    }
    // Then add selectors and start downloading the first data subset.
    for (var s_name in response.selectors) {
      add_selector(s_name, response.selectors[s_name]);
    }
    
    // Update the scales/axes of the plots if needed
    // We do this so that the plots zoom in initially after loading
    for (var p_name in response.plots) {
      if(response.plots[p_name].axis_domains !== null){
        for(var xy in response.plots[p_name].axis_domains){
          var selectors = response.plots[p_name].axis_domains[xy].selectors;
          if(!isArray(selectors)){
            selectors = [selectors];
          }
          update_scales(p_name, xy, selectors[0],
            response.selectors[selectors[0]].selected);
        }
      }
    }

    ////////////////////////////////////////////
    // Widgets at bottom of page
    ////////////////////////////////////////////
    element.append("br");
    if(response.hasOwnProperty("source")){
      element.append("a")
	.attr("id","a_source_href")
	.attr("href", response.source)
	.text("source");
    }
    // loading table.
    var show_hide_table = element.append("button")
      .text("Show download status table");
    show_hide_table
      .on("click", function(){
        if(this.textContent == "Show download status table"){
          loading.style("display", "");
          show_hide_table.text("Hide download status table");
        }else{
          loading.style("display", "none");
          show_hide_table.text("Show download status table");
        }
      });
    var loading = element.append("table")
      .style("display", "none");
    Widgets["loading"] = loading;
    var tr = loading.append("tr");
    tr.append("th").text("geom");
    tr.append("th").attr("class", "chunk").text("selected chunk");
    tr.append("th").attr("class", "downloaded").text("downloaded");
    tr.append("th").attr("class", "total").text("total");
    tr.append("th").attr("class", "status").text("status");
    
    // Add geoms and construct nest operators.
    for (var g_name in response.geoms) {
      add_geom(g_name, response.geoms[g_name]);
    }
    
    // Animation control widgets.
    var show_message = "Show animation controls";
    // add a button to view the animation widgets
    var show_hide_animation_controls = element.append("button")
      .text(show_message)
      .attr("id", viz_id + "_show_hide_animation_controls")
      .on("click", function(){
        if(this.textContent == show_message){
          time_table.style("display", "");
          show_hide_animation_controls.text("Hide animation controls");
        }else{
          time_table.style("display", "none");
          show_hide_animation_controls.text(show_message);
        }
      })
    ;
    // table of the animint widgets
    var time_table = element.append("table")
      .style("display", "none");
    var first_tr = time_table.append("tr");
    var first_th = first_tr.append("th");
    // if there's a time variable, add a button to pause the animint
    if(response.time){
      Animation.next = {};
      Animation.ms = response.time.ms;
      Animation.variable = response.time.variable;
      Animation.sequence = response.time.sequence;
      Widgets["play_pause"] = first_th.append("button")
	.text("Play")
        .attr("id", "play_pause")
	.on("click", function(){
          if(this.textContent == "Play"){
            Animation.play();
          }else{
            Animation.pause(false);
          }
        })
      ;
    }
    first_tr.append("th").text("milliseconds");
    if(response.time){
      var second_tr = time_table.append("tr");
      second_tr.append("td").text("updates");
      second_tr.append("td").append("input")
	.attr("id", "updates_ms")
	.attr("type", "text")
	.attr("value", Animation.ms)
	.on("change", function(){
          Animation.pause(false);
          Animation.ms = this.value;
          Animation.play();
        })
      ;
    }
    for(s_name in Selectors){
      var s_info = Selectors[s_name];
      if(!s_info.hasOwnProperty("duration")){
        s_info.duration = 0;
      }
    }
    var selector_array = d3.keys(Selectors);
    var duration_rows = time_table.selectAll("tr.duration")
      .data(selector_array)
      .enter()
      .append("tr");
    duration_rows
      .append("td")
      .text(function(s_name){return s_name;});
    var duration_tds = duration_rows.append("td");
    var duration_inputs = duration_tds
      .append("input")
      .attr("id", function(s_name){
        return viz_id + "_duration_ms_" + s_name;
      })
      .attr("type", "text")
      .on("change", function(s_name){
        Selectors[s_name].duration = this.value;
      })
      .attr("value", function(s_name){
        return Selectors[s_name].duration;
      });
    // selector widgets
    var toggle_message = "Show selection menus";
    var show_or_hide_fun = function(){
      if(this.textContent == toggle_message){
        selector_table.style("display", "");
        show_hide_selector_widgets.text("Hide selection menus");
        d3.select(".urltable").style("display","")
      }else{
        selector_table.style("display", "none");
        show_hide_selector_widgets.text(toggle_message);
        d3.select(".urltable").style("display","none")
      }
    }
    var show_hide_selector_widgets = element.append("button")
      .text(toggle_message)
      .attr("class", "show_hide_selector_widgets")
      .on("click", show_or_hide_fun)
    ;
    // adding a table for selector widgets
    var selector_table = element.append("table")
      .style("display", "none")
      .attr("class", "table_selector_widgets")
    ;
    var selector_first_tr = selector_table.append("tr");
    selector_first_tr
      .append("th")
      .text("Variable")
    ;
    selector_first_tr
      .append("th")
      .text("Selected value(s)")
    ;
      
     // looping through and adding a row for each selector
    for(s_name in Selectors) {
      var s_info = Selectors[s_name];
      // for .variable .value selectors, levels is undefined and we do
      // not want to make a selectize widget.

      // TODO: why does it take so long to initialize the selectize
      // widget when there are many (>1000) values?
      if(isArray(s_info.levels)){
	// If there were no geoms that specified clickSelects for this
	// selector, then there is no way to select it other than the
	// selectize widgets (and possibly legends). So in this case
	// we show the selectize widgets by default.
	var selector_widgets_hidden = 
	  show_hide_selector_widgets.text() == toggle_message;
	var has_no_clickSelects = 
	  !Selectors[s_name].hasOwnProperty("clickSelects")
	var has_no_legend = 
	  !Selectors[s_name].hasOwnProperty("legend")
	if(selector_widgets_hidden && has_no_clickSelects && has_no_legend){
	  var node = show_hide_selector_widgets.node();
	  show_or_hide_fun.apply(node);
	}
	// removing "." from name so it can be used in ids
	var s_name_id = legend_class_name(s_name);

	// adding a row for each selector
	var selector_widget_row = selector_table
          .append("tr")
          .attr("class", function() { return s_name_id + "_selector_widget"; })
	;
	selector_widget_row.append("td").text(s_name);
	// adding the selector
	var selector_widget_select = selector_widget_row
          .append("td")
          .append("select")
          .attr("class", function() { return s_name_id + "_input"; })
          .attr("placeholder", function() { return "Toggle " + s_name; });
	// adding an option for each level of the variable
	selector_widget_select.selectAll("option")
          .data(s_info.levels)
          .enter()
          .append("option")
          .attr("value", function(d) { return d; })
          .text(function(d) { return d; });
	// making sure that the first option is blank
	selector_widget_select
          .insert("option")
          .attr("value", "")
          .text(function() { return "Toggle " + s_name; });
	
	// calling selectize
	var selectize_selector = to_select + ' .' + s_name_id + "_input";
	if(s_info.type == "single") {
          // setting up array of selector and options
          var selector_values = [];
          for(i in s_info.levels) {
            selector_values[i] = {
              id: s_name.concat("___", s_info.levels[i]), 
              text: s_info.levels[i]
            };
          }
          // the id of the first selector
          var selected_id = s_name.concat("___", s_info.selected);

          // if single selection, only allow one item
          var $temp = $(selectize_selector)
            .selectize({
              create: false, 
              valueField: 'id',
              labelField: 'text',
              searchField: ['text'],
              options: selector_values, 
              items: [selected_id],
              maxItems: 1, 
              allowEmptyOption: true,
              onChange: function(value) {
		// extracting the name and the level to update
		var selector_name = value.split("___")[0];
		var selected_level = value.split("___")[1];
		// updating the selector
		update_selector(selector_name, selected_level);
              }
            })
          ;
	} else { // multiple selection:
          // setting up array of selector and options
          var selector_values = [];
          if(typeof s_info.levels == "object") {
            for(i in s_info.levels) {
              selector_values[i] = {
		id: s_name.concat("___", s_info.levels[i]), 
		text: s_info.levels[i]
              };
            }
          } else {
            selector_values[0] = {
              id: s_name.concat("___", s_info.levels), 
              text: s_info.levels
            };
          }
          // setting up an array to contain the initally selected elements
          var initial_selections = [];
          for(i in s_info.selected) {
            initial_selections[i] = s_name.concat("___", s_info.selected[i]);
          }
          
          // construct the selectize
          var $temp = $(selectize_selector)
            .selectize({
              create: false, 
              valueField: 'id',
              labelField: 'text',
              searchField: ['text'],
              options: selector_values, 
              items: initial_selections,
              maxItems: s_info.levels.length, 
              allowEmptyOption: true,
              onChange: function(value) { 
		// if nothing is selected, remove what is currently selected
		if(value == null) {
                  // extracting the selector ids from the options
                  var the_ids = Object.keys($(this)[0].options);
                  // the name of the appropriate selector
                  var selector_name = the_ids[0].split("___")[0];
                  // the previously selected elements
                  var old_selections = Selectors[selector_name].selected;
                  // updating the selector for each of the old selections
                  old_selections.forEach(function(element) {
                    update_selector(selector_name, element);
                  });
		} else { // value is not null:
                  // grabbing the name of the selector from the selected value
                  var selector_name = value[0].split("___")[0];
                  // identifying the levels that should be selected
                  var specified_levels = [];
                  for(i in value) {
                    specified_levels[i] = value[i].split("___")[1];
                  }
                  // the previously selected entries
                  old_selections = Selectors[selector_name].selected;
                  
                  // the levels that need to have selections turned on
                  specified_levels
                    .filter(function(n) {
                      return old_selections.indexOf(n) == -1;
                    })
                    .forEach(function(element) {
                      update_selector(selector_name, element);
                    })
                  ;
                  // the levels that need to be turned off
                  // - same approach
                  old_selections
                    .filter(function(n) {
                      return specified_levels.indexOf(n) == -1;
                    })
                    .forEach(function(element) {
                      update_selector(selector_name, element);
                    })
                  ;
		}//value==null
              }//onChange
            })//selectize
          ;
	}//single or multiple selection.
	selectized_array[s_name] = $temp[0].selectize;
      }//levels, is.variable.value
    } // close for loop through selector widgets
    // If this is an animation, then start downloading all the rest of
    // the data, and start the animation.
    if (response.time) {
      var i, prev, cur;
      for (var i = 0; i < Animation.sequence.length; i++) {
        if (i == 0) {
          prev = Animation.sequence[Animation.sequence.length-1];
        } else {
          prev = Animation.sequence[i - 1];
        }
        cur = Animation.sequence[i];
        Animation.next[prev] = cur;
      }
      Animation.timer = null;
      Animation.play = function(){
	if(Animation.timer == null){ // only play if not already playing.
    	  // as shown on http://bl.ocks.org/mbostock/3808234
    	  Animation.timer = setInterval(update_next_animation, Animation.ms);
    	  Widgets["play_pause"].text("Pause");
	}
      };
      Animation.play_after_visible = false;
      Animation.pause = function(play_after_visible){
        Animation.play_after_visible = play_after_visible;
        clearInterval(Animation.timer);
	Animation.timer = null;
        Widgets["play_pause"].text("Play");
      };
      var s_info = Selectors[Animation.variable];
      Animation.done_geoms = {};
      s_info.update.forEach(function(g_name){
        var g_info = Geoms[g_name];
        if(g_info.chunk_order.length == 1 &&
	   g_info.chunk_order[0] == Animation.variable){
	  g_info.seq_i = Animation.sequence.indexOf(s_info.selected);
	  g_info.seq_count = 0;
	  Animation.done_geoms[g_name] = 0;
	  download_next(g_name);
	}
      });
      Animation.play();
      all_geom_names = d3.keys(response.geoms);

      // This code starts/stops the animation timer when the page is
      // hidden, inspired by
      // http://stackoverflow.com/questions/1060008
      function onchange (evt) {
        if(document.visibilityState == "visible"){
          if(Animation.play_after_visible){
            Animation.play();
          }
        }else{
          if(Widgets["play_pause"].text() == "Pause"){
            Animation.pause(true);
          }
        }
      };
      document.addEventListener("visibilitychange", onchange);
    }
    // update_selector_url()
    var check_func=function(){
      var status_array = $('.status').map(function(){
        return $.trim($(this).text());
      }).get();
      status_array=status_array.slice(1)
      return status_array.every(function(elem){ return elem === "displayed"});           
    }
    if(window.location.hash) {
      var fragment=window.location.hash;
      fragment=fragment.slice(1);
      fragment=decodeURI(fragment)
      var frag_array=fragment.split(/(.*?})/);
      frag_array=frag_array.filter(function(x){ return x!=""})
      frag_array.forEach(function(selector_string){ 
        var selector_hash=selector_string.split("=");
        var selector_nam=selector_hash[0];
        var selector_values=selector_hash[1];
        var re = /\{(.*?)\}/;
        selector_values = re.exec(selector_values)[1];
        var array_values = selector_values.split(',');
	if(Selectors.hasOwnProperty(selector_nam)){
          var s_info = Selectors[selector_nam]
          if(s_info.type=="single"){//TODO fix
            array_values.forEach(function(element) {
              wait_until_then(100, check_func, update_selector,selector_nam,element)
              if(response.time)Animation.pause(true)
            });   
          }else{
            var old_selections = Selectors[selector_nam].selected;
            // the levels that need to have selections turned on
            array_values
              .filter(function(n) {
		return old_selections.indexOf(n) == -1;
              })
              .forEach(function(element) {
		wait_until_then(100, check_func, update_selector,selector_nam,element)
		if(response.time){
                  Animation.pause(true)
		}
              });
            old_selections
              .filter(function(n) {
		return array_values.indexOf(n) == -1;
              })
              .forEach(function(element) {
		wait_until_then(100, check_func, update_selector,selector_nam,element)
		if(response.time){
                  Animation.pause(true)
		}
              });     
          }//if(single) else multiple selection
	}//if(Selectors.hasOwnProperty(selector_nam))
      })//frag_array.forEach
    }//if(window.location.hash)
  });
};


</script>
<script>
/*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l="1.11.3",m=function(a,b){return new m.fn.init(a,b)},n=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,o=/^-ms-/,p=/-([\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:"jQuery"+(l+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===m.type(a)},isArray:Array.isArray||function(a){return"array"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,"ms-").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(n,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function r(a){var b="length"in a&&a.length,c=m.type(a);return"function"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);m.find=s,m.expr=s.selectors,m.expr[":"]=m.expr.pseudos,m.unique=s.uniqueSort,m.text=s.getText,m.isXMLDoc=s.isXML,m.contains=s.contains;var t=m.expr.match.needsContext,u=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,v=/^.[^:#\[\.,]*$/;function w(a,b,c){if(m.isFunction(b))return m.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return m.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(v.test(b))return m.filter(b,a,c);b=m.filter(b,a)}return m.grep(a,function(a){return m.inArray(a,b)>=0!==c})}m.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?m.find.matchesSelector(d,a)?[d]:[]:m.find.matches(a,m.grep(b,function(a){return 1===a.nodeType}))},m.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(m(a).filter(function(){for(b=0;e>b;b++)if(m.contains(d[b],this))return!0}));for(b=0;e>b;b++)m.find(a,d[b],c);return c=this.pushStack(e>1?m.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(w(this,a||[],!1))},not:function(a){return this.pushStack(w(this,a||[],!0))},is:function(a){return!!w(this,"string"==typeof a&&t.test(a)?m(a):a||[],!1).length}});var x,y=a.document,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=m.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||x).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof m?b[0]:b,m.merge(this,m.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:y,!0)),u.test(c[1])&&m.isPlainObject(b))for(c in b)m.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=y.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return x.find(a);this.length=1,this[0]=d}return this.context=y,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):m.isFunction(a)?"undefined"!=typeof x.ready?x.ready(a):a(m):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),m.makeArray(a,this))};A.prototype=m.fn,x=m(y);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};m.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!m(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),m.fn.extend({has:function(a){var b,c=m(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(m.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=t.test(a)||"string"!=typeof a?m(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&m.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?m.unique(f):f)},index:function(a){return a?"string"==typeof a?m.inArray(this[0],m(a)):m.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(m.unique(m.merge(this.get(),m(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}m.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return m.dir(a,"parentNode")},parentsUntil:function(a,b,c){return m.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return m.dir(a,"nextSibling")},prevAll:function(a){return m.dir(a,"previousSibling")},nextUntil:function(a,b,c){return m.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return m.dir(a,"previousSibling",c)},siblings:function(a){return m.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return m.sibling(a.firstChild)},contents:function(a){return m.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:m.merge([],a.childNodes)}},function(a,b){m.fn[a]=function(c,d){var e=m.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=m.filter(d,e)),this.length>1&&(C[a]||(e=m.unique(e)),B.test(a)&&(e=e.reverse())),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return m.each(a.match(E)||[],function(a,c){b[c]=!0}),b}m.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):m.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){m.each(b,function(b,c){var d=m.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&m.each(arguments,function(a,c){var d;while((d=m.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?m.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},m.extend({Deferred:function(a){var b=[["resolve","done",m.Callbacks("once memory"),"resolved"],["reject","fail",m.Callbacks("once memory"),"rejected"],["notify","progress",m.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return m.Deferred(function(c){m.each(b,function(b,f){var g=m.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&m.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?m.extend(a,d):d}},e={};return d.pipe=d.then,m.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&m.isFunction(a.promise)?e:0,g=1===f?a:m.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&m.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;m.fn.ready=function(a){return m.ready.promise().done(a),this},m.extend({isReady:!1,readyWait:1,holdReady:function(a){a?m.readyWait++:m.ready(!0)},ready:function(a){if(a===!0?!--m.readyWait:!m.isReady){if(!y.body)return setTimeout(m.ready);m.isReady=!0,a!==!0&&--m.readyWait>0||(H.resolveWith(y,[m]),m.fn.triggerHandler&&(m(y).triggerHandler("ready"),m(y).off("ready")))}}});function I(){y.addEventListener?(y.removeEventListener("DOMContentLoaded",J,!1),a.removeEventListener("load",J,!1)):(y.detachEvent("onreadystatechange",J),a.detachEvent("onload",J))}function J(){(y.addEventListener||"load"===event.type||"complete"===y.readyState)&&(I(),m.ready())}m.ready.promise=function(b){if(!H)if(H=m.Deferred(),"complete"===y.readyState)setTimeout(m.ready);else if(y.addEventListener)y.addEventListener("DOMContentLoaded",J,!1),a.addEventListener("load",J,!1);else{y.attachEvent("onreadystatechange",J),a.attachEvent("onload",J);var c=!1;try{c=null==a.frameElement&&y.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!m.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}I(),m.ready()}}()}return H.promise(b)};var K="undefined",L;for(L in m(k))break;k.ownLast="0"!==L,k.inlineBlockNeedsLayout=!1,m(function(){var a,b,c,d;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",k.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(d))}),function(){var a=y.createElement("div");if(null==k.deleteExpando){k.deleteExpando=!0;try{delete a.test}catch(b){k.deleteExpando=!1}}a=null}(),m.acceptData=function(a){var b=m.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var M=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,N=/([A-Z])/g;function O(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(N,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:M.test(c)?m.parseJSON(c):c}catch(e){}m.data(a,b,c)}else c=void 0}return c}function P(a){var b;for(b in a)if(("data"!==b||!m.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;

return!0}function Q(a,b,d,e){if(m.acceptData(a)){var f,g,h=m.expando,i=a.nodeType,j=i?m.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||m.guid++:h),j[k]||(j[k]=i?{}:{toJSON:m.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=m.extend(j[k],b):j[k].data=m.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[m.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[m.camelCase(b)])):f=g,f}}function R(a,b,c){if(m.acceptData(a)){var d,e,f=a.nodeType,g=f?m.cache:a,h=f?a[m.expando]:m.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){m.isArray(b)?b=b.concat(m.map(b,m.camelCase)):b in d?b=[b]:(b=m.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!P(d):!m.isEmptyObject(d))return}(c||(delete g[h].data,P(g[h])))&&(f?m.cleanData([a],!0):k.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}m.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?m.cache[a[m.expando]]:a[m.expando],!!a&&!P(a)},data:function(a,b,c){return Q(a,b,c)},removeData:function(a,b){return R(a,b)},_data:function(a,b,c){return Q(a,b,c,!0)},_removeData:function(a,b){return R(a,b,!0)}}),m.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=m.data(f),1===f.nodeType&&!m._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=m.camelCase(d.slice(5)),O(f,d,e[d])));m._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){m.data(this,a)}):arguments.length>1?this.each(function(){m.data(this,a,b)}):f?O(f,a,m.data(f,a)):void 0},removeData:function(a){return this.each(function(){m.removeData(this,a)})}}),m.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=m._data(a,b),c&&(!d||m.isArray(c)?d=m._data(a,b,m.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=m.queue(a,b),d=c.length,e=c.shift(),f=m._queueHooks(a,b),g=function(){m.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return m._data(a,c)||m._data(a,c,{empty:m.Callbacks("once memory").add(function(){m._removeData(a,b+"queue"),m._removeData(a,c)})})}}),m.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?m.queue(this[0],a):void 0===b?this:this.each(function(){var c=m.queue(this,a,b);m._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&m.dequeue(this,a)})},dequeue:function(a){return this.each(function(){m.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=m.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=m._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=["Top","Right","Bottom","Left"],U=function(a,b){return a=b||a,"none"===m.css(a,"display")||!m.contains(a.ownerDocument,a)},V=m.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===m.type(c)){e=!0;for(h in c)m.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,m.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(m(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},W=/^(?:checkbox|radio)$/i;!function(){var a=y.createElement("input"),b=y.createElement("div"),c=y.createDocumentFragment();if(b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",k.leadingWhitespace=3===b.firstChild.nodeType,k.tbody=!b.getElementsByTagName("tbody").length,k.htmlSerialize=!!b.getElementsByTagName("link").length,k.html5Clone="<:nav></:nav>"!==y.createElement("nav").cloneNode(!0).outerHTML,a.type="checkbox",a.checked=!0,c.appendChild(a),k.appendChecked=a.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,c.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,k.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){k.noCloneEvent=!1}),b.cloneNode(!0).click()),null==k.deleteExpando){k.deleteExpando=!0;try{delete b.test}catch(d){k.deleteExpando=!1}}}(),function(){var b,c,d=y.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(k[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),k[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var X=/^(?:input|select|textarea)$/i,Y=/^key/,Z=/^(?:mouse|pointer|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=/^([^.]*)(?:\.(.+)|)$/;function aa(){return!0}function ba(){return!1}function ca(){try{return y.activeElement}catch(a){}}m.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=m.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof m===K||a&&m.event.triggered===a.type?void 0:m.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(E)||[""],h=b.length;while(h--)f=_.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=m.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=m.event.special[o]||{},l=m.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&m.expr.match.needsContext.test(e),namespace:p.join(".")},i),(n=g[o])||(n=g[o]=[],n.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?n.splice(n.delegateCount++,0,l):n.push(l),m.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m.hasData(a)&&m._data(a);if(r&&(k=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=_.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=m.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,n=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=n.length;while(f--)g=n[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(n.splice(f,1),g.selector&&n.delegateCount--,l.remove&&l.remove.call(a,g));i&&!n.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||m.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)m.event.remove(a,o+b[j],c,d,!0);m.isEmptyObject(k)&&(delete r.handle,m._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,o=[d||y],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||y,3!==d.nodeType&&8!==d.nodeType&&!$.test(p+m.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[m.expando]?b:new m.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:m.makeArray(c,[b]),k=m.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!m.isWindow(d)){for(i=k.delegateType||p,$.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||y)&&o.push(l.defaultView||l.parentWindow||a)}n=0;while((h=o[n++])&&!b.isPropagationStopped())b.type=n>1?i:k.bindType||p,f=(m._data(h,"events")||{})[b.type]&&m._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&m.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&m.acceptData(d)&&g&&d[p]&&!m.isWindow(d)){l=d[g],l&&(d[g]=null),m.event.triggered=p;try{d[p]()}catch(r){}m.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=m.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(m._data(this,"events")||{})[a.type]||[],k=m.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=m.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((m.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?m(c,this).index(i)>=0:m.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[m.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=Z.test(e)?this.mouseHooks:Y.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new m.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||y),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||y,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ca()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ca()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return m.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return m.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=m.extend(new m.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?m.event.trigger(e,null,b):m.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},m.removeEvent=y.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===K&&(a[d]=null),a.detachEvent(d,c))},m.Event=function(a,b){return this instanceof m.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?aa:ba):this.type=a,b&&m.extend(this,b),this.timeStamp=a&&a.timeStamp||m.now(),void(this[m.expando]=!0)):new m.Event(a,b)},m.Event.prototype={isDefaultPrevented:ba,isPropagationStopped:ba,isImmediatePropagationStopped:ba,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=aa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=aa,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=aa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},m.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){m.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!m.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.submitBubbles||(m.event.special.submit={setup:function(){return m.nodeName(this,"form")?!1:void m.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=m.nodeName(b,"input")||m.nodeName(b,"button")?b.form:void 0;c&&!m._data(c,"submitBubbles")&&(m.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),m._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&m.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return m.nodeName(this,"form")?!1:void m.event.remove(this,"._submit")}}),k.changeBubbles||(m.event.special.change={setup:function(){return X.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(m.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),m.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),m.event.simulate("change",this,a,!0)})),!1):void m.event.add(this,"beforeactivate._change",function(a){var b=a.target;X.test(b.nodeName)&&!m._data(b,"changeBubbles")&&(m.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||m.event.simulate("change",this.parentNode,a,!0)}),m._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return m.event.remove(this,"._change"),!X.test(this.nodeName)}}),k.focusinBubbles||m.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){m.event.simulate(b,a.target,m.event.fix(a),!0)};m.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=m._data(d,b);e||d.addEventListener(a,c,!0),m._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=m._data(d,b)-1;e?m._data(d,b,e):(d.removeEventListener(a,c,!0),m._removeData(d,b))}}}),m.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=ba;else if(!d)return this;return 1===e&&(g=d,d=function(a){return m().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=m.guid++)),this.each(function(){m.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,m(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=ba),this.each(function(){m.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){m.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?m.event.trigger(a,b,c,!0):void 0}});function da(a){var b=ea.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var ea="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",fa=/ jQuery\d+="(?:null|\d+)"/g,ga=new RegExp("<(?:"+ea+")[\\s/>]","i"),ha=/^\s+/,ia=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ja=/<([\w:]+)/,ka=/<tbody/i,la=/<|&#?\w+;/,ma=/<(?:script|style|link)/i,na=/checked\s*(?:[^=]|=\s*.checked.)/i,oa=/^$|\/(?:java|ecma)script/i,pa=/^true\/(.*)/,qa=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ra={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:k.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},sa=da(y),ta=sa.appendChild(y.createElement("div"));ra.optgroup=ra.option,ra.tbody=ra.tfoot=ra.colgroup=ra.caption=ra.thead,ra.th=ra.td;function ua(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==K?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==K?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||m.nodeName(d,b)?f.push(d):m.merge(f,ua(d,b));return void 0===b||b&&m.nodeName(a,b)?m.merge([a],f):f}function va(a){W.test(a.type)&&(a.defaultChecked=a.checked)}function wa(a,b){return m.nodeName(a,"table")&&m.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function xa(a){return a.type=(null!==m.find.attr(a,"type"))+"/"+a.type,a}function ya(a){var b=pa.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function za(a,b){for(var c,d=0;null!=(c=a[d]);d++)m._data(c,"globalEval",!b||m._data(b[d],"globalEval"))}function Aa(a,b){if(1===b.nodeType&&m.hasData(a)){var c,d,e,f=m._data(a),g=m._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)m.event.add(b,c,h[c][d])}g.data&&(g.data=m.extend({},g.data))}}function Ba(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!k.noCloneEvent&&b[m.expando]){e=m._data(b);for(d in e.events)m.removeEvent(b,d,e.handle);b.removeAttribute(m.expando)}"script"===c&&b.text!==a.text?(xa(b).text=a.text,ya(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),k.html5Clone&&a.innerHTML&&!m.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&W.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}m.extend({clone:function(a,b,c){var d,e,f,g,h,i=m.contains(a.ownerDocument,a);if(k.html5Clone||m.isXMLDoc(a)||!ga.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(ta.innerHTML=a.outerHTML,ta.removeChild(f=ta.firstChild)),!(k.noCloneEvent&&k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||m.isXMLDoc(a)))for(d=ua(f),h=ua(a),g=0;null!=(e=h[g]);++g)d[g]&&Ba(e,d[g]);if(b)if(c)for(h=h||ua(a),d=d||ua(f),g=0;null!=(e=h[g]);g++)Aa(e,d[g]);else Aa(a,f);return d=ua(f,"script"),d.length>0&&za(d,!i&&ua(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,l,n=a.length,o=da(b),p=[],q=0;n>q;q++)if(f=a[q],f||0===f)if("object"===m.type(f))m.merge(p,f.nodeType?[f]:f);else if(la.test(f)){h=h||o.appendChild(b.createElement("div")),i=(ja.exec(f)||["",""])[1].toLowerCase(),l=ra[i]||ra._default,h.innerHTML=l[1]+f.replace(ia,"<$1></$2>")+l[2],e=l[0];while(e--)h=h.lastChild;if(!k.leadingWhitespace&&ha.test(f)&&p.push(b.createTextNode(ha.exec(f)[0])),!k.tbody){f="table"!==i||ka.test(f)?"<table>"!==l[1]||ka.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)m.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}m.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),k.appendChecked||m.grep(ua(p,"input"),va),q=0;while(f=p[q++])if((!d||-1===m.inArray(f,d))&&(g=m.contains(f.ownerDocument,f),h=ua(o.appendChild(f),"script"),g&&za(h),c)){e=0;while(f=h[e++])oa.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=m.expando,j=m.cache,l=k.deleteExpando,n=m.event.special;null!=(d=a[h]);h++)if((b||m.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)n[e]?m.event.remove(d,e):m.removeEvent(d,e,g.handle);j[f]&&(delete j[f],l?delete d[i]:typeof d.removeAttribute!==K?d.removeAttribute(i):d[i]=null,c.push(f))}}}),m.fn.extend({text:function(a){return V(this,function(a){return void 0===a?m.text(this):this.empty().append((this[0]&&this[0].ownerDocument||y).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?m.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||m.cleanData(ua(c)),c.parentNode&&(b&&m.contains(c.ownerDocument,c)&&za(ua(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&m.cleanData(ua(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&m.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return m.clone(this,a,b)})},html:function(a){return V(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(fa,""):void 0;if(!("string"!=typeof a||ma.test(a)||!k.htmlSerialize&&ga.test(a)||!k.leadingWhitespace&&ha.test(a)||ra[(ja.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(ia,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(m.cleanData(ua(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,m.cleanData(ua(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,n=this,o=l-1,p=a[0],q=m.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&na.test(p))return this.each(function(c){var d=n.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(i=m.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=m.map(ua(i,"script"),xa),f=g.length;l>j;j++)d=i,j!==o&&(d=m.clone(d,!0,!0),f&&m.merge(g,ua(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,m.map(g,ya),j=0;f>j;j++)d=g[j],oa.test(d.type||"")&&!m._data(d,"globalEval")&&m.contains(h,d)&&(d.src?m._evalUrl&&m._evalUrl(d.src):m.globalEval((d.text||d.textContent||d.innerHTML||"").replace(qa,"")));i=c=null}return this}}),m.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){m.fn[a]=function(a){for(var c,d=0,e=[],g=m(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),m(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Ca,Da={};function Ea(b,c){var d,e=m(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:m.css(e[0],"display");return e.detach(),f}function Fa(a){var b=y,c=Da[a];return c||(c=Ea(a,b),"none"!==c&&c||(Ca=(Ca||m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ca[0].contentWindow||Ca[0].contentDocument).document,b.write(),b.close(),c=Ea(a,b),Ca.detach()),Da[a]=c),c}!function(){var a;k.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,d;return c=y.getElementsByTagName("body")[0],c&&c.style?(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(y.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(d),a):void 0}}();var Ga=/^margin/,Ha=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ia,Ja,Ka=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ia=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||m.contains(a.ownerDocument,a)||(g=m.style(a,b)),Ha.test(g)&&Ga.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):y.documentElement.currentStyle&&(Ia=function(a){return a.currentStyle},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ha.test(g)&&!Ka.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function La(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h;if(b=y.createElement("div"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=d&&d.style){c.cssText="float:left;opacity:.5",k.opacity="0.5"===c.opacity,k.cssFloat=!!c.cssFloat,b.style.backgroundClip="content-box",b.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===b.style.backgroundClip,k.boxSizing=""===c.boxSizing||""===c.MozBoxSizing||""===c.WebkitBoxSizing,m.extend(k,{reliableHiddenOffsets:function(){return null==g&&i(),g},boxSizingReliable:function(){return null==f&&i(),f},pixelPosition:function(){return null==e&&i(),e},reliableMarginRight:function(){return null==h&&i(),h}});function i(){var b,c,d,i;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),b.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",e=f=!1,h=!0,a.getComputedStyle&&(e="1%"!==(a.getComputedStyle(b,null)||{}).top,f="4px"===(a.getComputedStyle(b,null)||{width:"4px"}).width,i=b.appendChild(y.createElement("div")),i.style.cssText=b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",i.style.marginRight=i.style.width="0",b.style.width="1px",h=!parseFloat((a.getComputedStyle(i,null)||{}).marginRight),b.removeChild(i)),b.innerHTML="<table><tr><td></td><td>t</td></tr></table>",i=b.getElementsByTagName("td"),i[0].style.cssText="margin:0;border:0;padding:0;display:none",g=0===i[0].offsetHeight,g&&(i[0].style.display="",i[1].style.display="none",g=0===i[0].offsetHeight),c.removeChild(d))}}}(),m.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Ma=/alpha\([^)]*\)/i,Na=/opacity\s*=\s*([^)]*)/,Oa=/^(none|table(?!-c[ea]).+)/,Pa=new RegExp("^("+S+")(.*)$","i"),Qa=new RegExp("^([+-])=("+S+")","i"),Ra={position:"absolute",visibility:"hidden",display:"block"},Sa={letterSpacing:"0",fontWeight:"400"},Ta=["Webkit","O","Moz","ms"];function Ua(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ta.length;while(e--)if(b=Ta[e]+c,b in a)return b;return d}function Va(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=m._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&U(d)&&(f[g]=m._data(d,"olddisplay",Fa(d.nodeName)))):(e=U(d),(c&&"none"!==c||!e)&&m._data(d,"olddisplay",e?c:m.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Wa(a,b,c){var d=Pa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Xa(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=m.css(a,c+T[f],!0,e)),d?("content"===c&&(g-=m.css(a,"padding"+T[f],!0,e)),"margin"!==c&&(g-=m.css(a,"border"+T[f]+"Width",!0,e))):(g+=m.css(a,"padding"+T[f],!0,e),"padding"!==c&&(g+=m.css(a,"border"+T[f]+"Width",!0,e)));return g}function Ya(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ia(a),g=k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Ja(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ha.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Xa(a,b,c||(g?"border":"content"),d,f)+"px"}m.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Ja(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":k.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=m.camelCase(b),i=a.style;if(b=m.cssProps[h]||(m.cssProps[h]=Ua(i,h)),g=m.cssHooks[b]||m.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Qa.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(m.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||m.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=m.camelCase(b);return b=m.cssProps[h]||(m.cssProps[h]=Ua(a.style,h)),g=m.cssHooks[b]||m.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Ja(a,b,d)),"normal"===f&&b in Sa&&(f=Sa[b]),""===c||c?(e=parseFloat(f),c===!0||m.isNumeric(e)?e||0:f):f}}),m.each(["height","width"],function(a,b){m.cssHooks[b]={get:function(a,c,d){return c?Oa.test(m.css(a,"display"))&&0===a.offsetWidth?m.swap(a,Ra,function(){return Ya(a,b,d)}):Ya(a,b,d):void 0},set:function(a,c,d){var e=d&&Ia(a);return Wa(a,c,d?Xa(a,b,d,k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,e),e):0)}}}),k.opacity||(m.cssHooks.opacity={get:function(a,b){return Na.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=m.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===m.trim(f.replace(Ma,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Ma.test(f)?f.replace(Ma,e):f+" "+e)}}),m.cssHooks.marginRight=La(k.reliableMarginRight,function(a,b){return b?m.swap(a,{display:"inline-block"},Ja,[a,"marginRight"]):void 0}),m.each({margin:"",padding:"",border:"Width"},function(a,b){m.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+T[d]+b]=f[d]||f[d-2]||f[0];return e}},Ga.test(a)||(m.cssHooks[a+b].set=Wa)}),m.fn.extend({css:function(a,b){return V(this,function(a,b,c){var d,e,f={},g=0;if(m.isArray(b)){for(d=Ia(a),e=b.length;e>g;g++)f[b[g]]=m.css(a,b[g],!1,d);return f}return void 0!==c?m.style(a,b,c):m.css(a,b)},a,b,arguments.length>1)},show:function(){return Va(this,!0)},hide:function(){return Va(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){U(this)?m(this).show():m(this).hide()})}});function Za(a,b,c,d,e){
return new Za.prototype.init(a,b,c,d,e)}m.Tween=Za,Za.prototype={constructor:Za,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(m.cssNumber[c]?"":"px")},cur:function(){var a=Za.propHooks[this.prop];return a&&a.get?a.get(this):Za.propHooks._default.get(this)},run:function(a){var b,c=Za.propHooks[this.prop];return this.options.duration?this.pos=b=m.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Za.propHooks._default.set(this),this}},Za.prototype.init.prototype=Za.prototype,Za.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=m.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){m.fx.step[a.prop]?m.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[m.cssProps[a.prop]]||m.cssHooks[a.prop])?m.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Za.propHooks.scrollTop=Za.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},m.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},m.fx=Za.prototype.init,m.fx.step={};var $a,_a,ab=/^(?:toggle|show|hide)$/,bb=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),cb=/queueHooks$/,db=[ib],eb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=bb.exec(b),f=e&&e[3]||(m.cssNumber[a]?"":"px"),g=(m.cssNumber[a]||"px"!==f&&+d)&&bb.exec(m.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,m.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function fb(){return setTimeout(function(){$a=void 0}),$a=m.now()}function gb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=T[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function hb(a,b,c){for(var d,e=(eb[b]||[]).concat(eb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,l,n=this,o={},p=a.style,q=a.nodeType&&U(a),r=m._data(a,"fxshow");c.queue||(h=m._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,n.always(function(){n.always(function(){h.unqueued--,m.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=m.css(a,"display"),l="none"===j?m._data(a,"olddisplay")||Fa(a.nodeName):j,"inline"===l&&"none"===m.css(a,"float")&&(k.inlineBlockNeedsLayout&&"inline"!==Fa(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",k.shrinkWrapBlocks()||n.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],ab.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||m.style(a,d)}else j=void 0;if(m.isEmptyObject(o))"inline"===("none"===j?Fa(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=m._data(a,"fxshow",{}),f&&(r.hidden=!q),q?m(a).show():n.done(function(){m(a).hide()}),n.done(function(){var b;m._removeData(a,"fxshow");for(b in o)m.style(a,b,o[b])});for(d in o)g=hb(q?r[d]:0,d,n),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=m.camelCase(c),e=b[d],f=a[c],m.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=m.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=db.length,h=m.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=$a||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:m.extend({},b),opts:m.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:$a||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=m.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);g>f;f++)if(d=db[f].call(j,a,k,j.opts))return d;return m.map(k,hb,j),m.isFunction(j.opts.start)&&j.opts.start.call(a,j),m.fx.timer(m.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}m.Animation=m.extend(kb,{tweener:function(a,b){m.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],eb[c]=eb[c]||[],eb[c].unshift(b)},prefilter:function(a,b){b?db.unshift(a):db.push(a)}}),m.speed=function(a,b,c){var d=a&&"object"==typeof a?m.extend({},a):{complete:c||!c&&b||m.isFunction(a)&&a,duration:a,easing:c&&b||b&&!m.isFunction(b)&&b};return d.duration=m.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in m.fx.speeds?m.fx.speeds[d.duration]:m.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){m.isFunction(d.old)&&d.old.call(this),d.queue&&m.dequeue(this,d.queue)},d},m.fn.extend({fadeTo:function(a,b,c,d){return this.filter(U).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=m.isEmptyObject(a),f=m.speed(b,c,d),g=function(){var b=kb(this,m.extend({},a),f);(e||m._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=m.timers,g=m._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&cb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&m.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=m._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=m.timers,g=d?d.length:0;for(c.finish=!0,m.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),m.each(["toggle","show","hide"],function(a,b){var c=m.fn[b];m.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),m.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){m.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),m.timers=[],m.fx.tick=function(){var a,b=m.timers,c=0;for($a=m.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||m.fx.stop(),$a=void 0},m.fx.timer=function(a){m.timers.push(a),a()?m.fx.start():m.timers.pop()},m.fx.interval=13,m.fx.start=function(){_a||(_a=setInterval(m.fx.tick,m.fx.interval))},m.fx.stop=function(){clearInterval(_a),_a=null},m.fx.speeds={slow:600,fast:200,_default:400},m.fn.delay=function(a,b){return a=m.fx?m.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e;b=y.createElement("div"),b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=y.createElement("select"),e=c.appendChild(y.createElement("option")),a=b.getElementsByTagName("input")[0],d.style.cssText="top:1px",k.getSetAttribute="t"!==b.className,k.style=/top/.test(d.getAttribute("style")),k.hrefNormalized="/a"===d.getAttribute("href"),k.checkOn=!!a.value,k.optSelected=e.selected,k.enctype=!!y.createElement("form").enctype,c.disabled=!0,k.optDisabled=!e.disabled,a=y.createElement("input"),a.setAttribute("value",""),k.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),k.radioValue="t"===a.value}();var lb=/\r/g;m.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=m.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,m(this).val()):a,null==e?e="":"number"==typeof e?e+="":m.isArray(e)&&(e=m.map(e,function(a){return null==a?"":a+""})),b=m.valHooks[this.type]||m.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=m.valHooks[e.type]||m.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(lb,""):null==c?"":c)}}}),m.extend({valHooks:{option:{get:function(a){var b=m.find.attr(a,"value");return null!=b?b:m.trim(m.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&m.nodeName(c.parentNode,"optgroup"))){if(b=m(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=m.makeArray(b),g=e.length;while(g--)if(d=e[g],m.inArray(m.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),m.each(["radio","checkbox"],function(){m.valHooks[this]={set:function(a,b){return m.isArray(b)?a.checked=m.inArray(m(a).val(),b)>=0:void 0}},k.checkOn||(m.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var mb,nb,ob=m.expr.attrHandle,pb=/^(?:checked|selected)$/i,qb=k.getSetAttribute,rb=k.input;m.fn.extend({attr:function(a,b){return V(this,m.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){m.removeAttr(this,a)})}}),m.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===K?m.prop(a,b,c):(1===f&&m.isXMLDoc(a)||(b=b.toLowerCase(),d=m.attrHooks[b]||(m.expr.match.bool.test(b)?nb:mb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=m.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void m.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=m.propFix[c]||c,m.expr.match.bool.test(c)?rb&&qb||!pb.test(c)?a[d]=!1:a[m.camelCase("default-"+c)]=a[d]=!1:m.attr(a,c,""),a.removeAttribute(qb?c:d)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&m.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),nb={set:function(a,b,c){return b===!1?m.removeAttr(a,c):rb&&qb||!pb.test(c)?a.setAttribute(!qb&&m.propFix[c]||c,c):a[m.camelCase("default-"+c)]=a[c]=!0,c}},m.each(m.expr.match.bool.source.match(/\w+/g),function(a,b){var c=ob[b]||m.find.attr;ob[b]=rb&&qb||!pb.test(b)?function(a,b,d){var e,f;return d||(f=ob[b],ob[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,ob[b]=f),e}:function(a,b,c){return c?void 0:a[m.camelCase("default-"+b)]?b.toLowerCase():null}}),rb&&qb||(m.attrHooks.value={set:function(a,b,c){return m.nodeName(a,"input")?void(a.defaultValue=b):mb&&mb.set(a,b,c)}}),qb||(mb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},ob.id=ob.name=ob.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},m.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:mb.set},m.attrHooks.contenteditable={set:function(a,b,c){mb.set(a,""===b?!1:b,c)}},m.each(["width","height"],function(a,b){m.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),k.style||(m.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var sb=/^(?:input|select|textarea|button|object)$/i,tb=/^(?:a|area)$/i;m.fn.extend({prop:function(a,b){return V(this,m.prop,a,b,arguments.length>1)},removeProp:function(a){return a=m.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),m.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!m.isXMLDoc(a),f&&(b=m.propFix[b]||b,e=m.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=m.find.attr(a,"tabindex");return b?parseInt(b,10):sb.test(a.nodeName)||tb.test(a.nodeName)&&a.href?0:-1}}}}),k.hrefNormalized||m.each(["href","src"],function(a,b){m.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),k.optSelected||(m.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),m.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){m.propFix[this.toLowerCase()]=this}),k.enctype||(m.propFix.enctype="encoding");var ub=/[\t\r\n\f]/g;m.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=m.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?m.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(m.isFunction(a)?function(c){m(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=m(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===K||"boolean"===c)&&(this.className&&m._data(this,"__className__",this.className),this.className=this.className||a===!1?"":m._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ub," ").indexOf(b)>=0)return!0;return!1}}),m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){m.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),m.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var vb=m.now(),wb=/\?/,xb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;m.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=m.trim(b+"");return e&&!m.trim(e.replace(xb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():m.error("Invalid JSON: "+b)},m.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||m.error("Invalid XML: "+b),c};var yb,zb,Ab=/#.*$/,Bb=/([?&])_=[^&]*/,Cb=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Db=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Eb=/^(?:GET|HEAD)$/,Fb=/^\/\//,Gb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Hb={},Ib={},Jb="*/".concat("*");try{zb=location.href}catch(Kb){zb=y.createElement("a"),zb.href="",zb=zb.href}yb=Gb.exec(zb.toLowerCase())||[];function Lb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(m.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Mb(a,b,c,d){var e={},f=a===Ib;function g(h){var i;return e[h]=!0,m.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Nb(a,b){var c,d,e=m.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&m.extend(!0,a,c),a}function Ob(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Pb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}m.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:zb,type:"GET",isLocal:Db.test(yb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Jb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":m.parseJSON,"text xml":m.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Nb(Nb(a,m.ajaxSettings),b):Nb(m.ajaxSettings,a)},ajaxPrefilter:Lb(Hb),ajaxTransport:Lb(Ib),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=m.ajaxSetup({},b),l=k.context||k,n=k.context&&(l.nodeType||l.jquery)?m(l):m.event,o=m.Deferred(),p=m.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Cb.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||zb)+"").replace(Ab,"").replace(Fb,yb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=m.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(c=Gb.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===yb[1]&&c[2]===yb[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(yb[3]||("http:"===yb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=m.param(k.data,k.traditional)),Mb(Hb,k,b,v),2===t)return v;h=m.event&&k.global,h&&0===m.active++&&m.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Eb.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(wb.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Bb.test(e)?e.replace(Bb,"$1_="+vb++):e+(wb.test(e)?"&":"?")+"_="+vb++)),k.ifModified&&(m.lastModified[e]&&v.setRequestHeader("If-Modified-Since",m.lastModified[e]),m.etag[e]&&v.setRequestHeader("If-None-Match",m.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Jb+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Mb(Ib,k,b,v)){v.readyState=1,h&&n.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Ob(k,v,c)),u=Pb(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(m.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(m.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&n.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(n.trigger("ajaxComplete",[v,k]),--m.active||m.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return m.get(a,b,c,"json")},getScript:function(a,b){return m.get(a,void 0,b,"script")}}),m.each(["get","post"],function(a,b){m[b]=function(a,c,d,e){return m.isFunction(c)&&(e=e||d,d=c,c=void 0),m.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),m._evalUrl=function(a){return m.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},m.fn.extend({wrapAll:function(a){if(m.isFunction(a))return this.each(function(b){m(this).wrapAll(a.call(this,b))});if(this[0]){var b=m(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(m.isFunction(a)?function(b){m(this).wrapInner(a.call(this,b))}:function(){var b=m(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=m.isFunction(a);return this.each(function(c){m(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){m.nodeName(this,"body")||m(this).replaceWith(this.childNodes)}).end()}}),m.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!k.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||m.css(a,"display"))},m.expr.filters.visible=function(a){return!m.expr.filters.hidden(a)};var Qb=/%20/g,Rb=/\[\]$/,Sb=/\r?\n/g,Tb=/^(?:submit|button|image|reset|file)$/i,Ub=/^(?:input|select|textarea|keygen)/i;function Vb(a,b,c,d){var e;if(m.isArray(b))m.each(b,function(b,e){c||Rb.test(a)?d(a,e):Vb(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==m.type(b))d(a,b);else for(e in b)Vb(a+"["+e+"]",b[e],c,d)}m.param=function(a,b){var c,d=[],e=function(a,b){b=m.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=m.ajaxSettings&&m.ajaxSettings.traditional),m.isArray(a)||a.jquery&&!m.isPlainObject(a))m.each(a,function(){e(this.name,this.value)});else for(c in a)Vb(c,a[c],b,e);return d.join("&").replace(Qb,"+")},m.fn.extend({serialize:function(){return m.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=m.prop(this,"elements");return a?m.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!m(this).is(":disabled")&&Ub.test(this.nodeName)&&!Tb.test(a)&&(this.checked||!W.test(a))}).map(function(a,b){var c=m(this).val();return null==c?null:m.isArray(c)?m.map(c,function(a){return{name:b.name,value:a.replace(Sb,"\r\n")}}):{name:b.name,value:c.replace(Sb,"\r\n")}}).get()}}),m.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&Zb()||$b()}:Zb;var Wb=0,Xb={},Yb=m.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Xb)Xb[a](void 0,!0)}),k.cors=!!Yb&&"withCredentials"in Yb,Yb=k.ajax=!!Yb,Yb&&m.ajaxTransport(function(a){if(!a.crossDomain||k.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Wb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Xb[g],b=void 0,f.onreadystatechange=m.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Xb[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function Zb(){try{return new a.XMLHttpRequest}catch(b){}}function $b(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}m.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return m.globalEval(a),a}}}),m.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),m.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=y.head||m("head")[0]||y.documentElement;return{send:function(d,e){b=y.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var _b=[],ac=/(=)\?(?=&|$)|\?\?/;m.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=_b.pop()||m.expando+"_"+vb++;return this[a]=!0,a}}),m.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(ac.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&ac.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=m.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(ac,"$1"+e):b.jsonp!==!1&&(b.url+=(wb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||m.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,_b.push(e)),g&&m.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),m.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||y;var d=u.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=m.buildFragment([a],b,e),e&&e.length&&m(e).remove(),m.merge([],d.childNodes))};var bc=m.fn.load;m.fn.load=function(a,b,c){if("string"!=typeof a&&bc)return bc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=m.trim(a.slice(h,a.length)),a=a.slice(0,h)),m.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&m.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?m("<div>").append(m.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},m.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){m.fn[b]=function(a){return this.on(b,a)}}),m.expr.filters.animated=function(a){return m.grep(m.timers,function(b){return a===b.elem}).length};var cc=a.document.documentElement;function dc(a){return m.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}m.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=m.css(a,"position"),l=m(a),n={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=m.css(a,"top"),i=m.css(a,"left"),j=("absolute"===k||"fixed"===k)&&m.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),m.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(n.top=b.top-h.top+g),null!=b.left&&(n.left=b.left-h.left+e),"using"in b?b.using.call(a,n):l.css(n)}},m.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){m.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,m.contains(b,e)?(typeof e.getBoundingClientRect!==K&&(d=e.getBoundingClientRect()),c=dc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===m.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),m.nodeName(a[0],"html")||(c=a.offset()),c.top+=m.css(a[0],"borderTopWidth",!0),c.left+=m.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-m.css(d,"marginTop",!0),left:b.left-c.left-m.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||cc;while(a&&!m.nodeName(a,"html")&&"static"===m.css(a,"position"))a=a.offsetParent;return a||cc})}}),m.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);m.fn[a]=function(d){return V(this,function(a,d,e){var f=dc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?m(f).scrollLeft():e,c?e:m(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),m.each(["top","left"],function(a,b){m.cssHooks[b]=La(k.pixelPosition,function(a,c){return c?(c=Ja(a,b),Ha.test(c)?m(a).position()[b]+"px":c):void 0})}),m.each({Height:"height",Width:"width"},function(a,b){m.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){m.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return V(this,function(b,c,d){var e;return m.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?m.css(b,c,g):m.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),m.fn.size=function(){return this.length},m.fn.andSelf=m.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return m});var ec=a.jQuery,fc=a.$;return m.noConflict=function(b){return a.$===m&&(a.$=fc),b&&a.jQuery===m&&(a.jQuery=ec),m},typeof b===K&&(a.jQuery=a.$=m),m});
</script>
<script>
/*! selectize.js - v0.12.1 | https://github.com/brianreavis/selectize.js | Apache License (v2) */
!function(a,b){"function"==typeof define&&define.amd?define("sifter",b):"object"==typeof exports?module.exports=b():a.Sifter=b()}(this,function(){var a=function(a,b){this.items=a,this.settings=b||{diacritics:!0}};a.prototype.tokenize=function(a){if(a=d(String(a||"").toLowerCase()),!a||!a.length)return[];var b,c,f,h,i=[],j=a.split(/ +/);for(b=0,c=j.length;c>b;b++){if(f=e(j[b]),this.settings.diacritics)for(h in g)g.hasOwnProperty(h)&&(f=f.replace(new RegExp(h,"g"),g[h]));i.push({string:j[b],regex:new RegExp(f,"i")})}return i},a.prototype.iterator=function(a,b){var c;c=f(a)?Array.prototype.forEach||function(a){for(var b=0,c=this.length;c>b;b++)a(this[b],b,this)}:function(a){for(var b in this)this.hasOwnProperty(b)&&a(this[b],b,this)},c.apply(a,[b])},a.prototype.getScoreFunction=function(a,b){var c,d,e,f;c=this,a=c.prepareSearch(a,b),e=a.tokens,d=a.options.fields,f=e.length;var g=function(a,b){var c,d;return a?(a=String(a||""),d=a.search(b.regex),-1===d?0:(c=b.string.length/a.length,0===d&&(c+=.5),c)):0},h=function(){var a=d.length;return a?1===a?function(a,b){return g(b[d[0]],a)}:function(b,c){for(var e=0,f=0;a>e;e++)f+=g(c[d[e]],b);return f/a}:function(){return 0}}();return f?1===f?function(a){return h(e[0],a)}:"and"===a.options.conjunction?function(a){for(var b,c=0,d=0;f>c;c++){if(b=h(e[c],a),0>=b)return 0;d+=b}return d/f}:function(a){for(var b=0,c=0;f>b;b++)c+=h(e[b],a);return c/f}:function(){return 0}},a.prototype.getSortFunction=function(a,c){var d,e,f,g,h,i,j,k,l,m,n;if(f=this,a=f.prepareSearch(a,c),n=!a.query&&c.sort_empty||c.sort,l=function(a,b){return"$score"===a?b.score:f.items[b.id][a]},h=[],n)for(d=0,e=n.length;e>d;d++)(a.query||"$score"!==n[d].field)&&h.push(n[d]);if(a.query){for(m=!0,d=0,e=h.length;e>d;d++)if("$score"===h[d].field){m=!1;break}m&&h.unshift({field:"$score",direction:"desc"})}else for(d=0,e=h.length;e>d;d++)if("$score"===h[d].field){h.splice(d,1);break}for(k=[],d=0,e=h.length;e>d;d++)k.push("desc"===h[d].direction?-1:1);return i=h.length,i?1===i?(g=h[0].field,j=k[0],function(a,c){return j*b(l(g,a),l(g,c))}):function(a,c){var d,e,f;for(d=0;i>d;d++)if(f=h[d].field,e=k[d]*b(l(f,a),l(f,c)))return e;return 0}:null},a.prototype.prepareSearch=function(a,b){if("object"==typeof a)return a;b=c({},b);var d=b.fields,e=b.sort,g=b.sort_empty;return d&&!f(d)&&(b.fields=[d]),e&&!f(e)&&(b.sort=[e]),g&&!f(g)&&(b.sort_empty=[g]),{options:b,query:String(a||"").toLowerCase(),tokens:this.tokenize(a),total:0,items:[]}},a.prototype.search=function(a,b){var c,d,e,f,g=this;return d=this.prepareSearch(a,b),b=d.options,a=d.query,f=b.score||g.getScoreFunction(d),a.length?g.iterator(g.items,function(a,e){c=f(a),(b.filter===!1||c>0)&&d.items.push({score:c,id:e})}):g.iterator(g.items,function(a,b){d.items.push({score:1,id:b})}),e=g.getSortFunction(d,b),e&&d.items.sort(e),d.total=d.items.length,"number"==typeof b.limit&&(d.items=d.items.slice(0,b.limit)),d};var b=function(a,b){return"number"==typeof a&&"number"==typeof b?a>b?1:b>a?-1:0:(a=h(String(a||"")),b=h(String(b||"")),a>b?1:b>a?-1:0)},c=function(a){var b,c,d,e;for(b=1,c=arguments.length;c>b;b++)if(e=arguments[b])for(d in e)e.hasOwnProperty(d)&&(a[d]=e[d]);return a},d=function(a){return(a+"").replace(/^\s+|\s+$|/g,"")},e=function(a){return(a+"").replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")},f=Array.isArray||$&&$.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)},g={a:"[aÀÁÂÃÄÅàáâãäåĀāąĄ]",c:"[cÇçćĆčČ]",d:"[dđĐďĎ]",e:"[eÈÉÊËèéêëěĚĒēęĘ]",i:"[iÌÍÎÏìíîïĪī]",l:"[lłŁ]",n:"[nÑñňŇńŃ]",o:"[oÒÓÔÕÕÖØòóôõöøŌō]",r:"[rřŘ]",s:"[sŠšśŚ]",t:"[tťŤ]",u:"[uÙÚÛÜùúûüůŮŪū]",y:"[yŸÿýÝ]",z:"[zŽžżŻźŹ]"},h=function(){var a,b,c,d,e="",f={};for(c in g)if(g.hasOwnProperty(c))for(d=g[c].substring(2,g[c].length-1),e+=d,a=0,b=d.length;b>a;a++)f[d.charAt(a)]=c;var h=new RegExp("["+e+"]","g");return function(a){return a.replace(h,function(a){return f[a]}).toLowerCase()}}();return a}),function(a,b){"function"==typeof define&&define.amd?define("microplugin",b):"object"==typeof exports?module.exports=b():a.MicroPlugin=b()}(this,function(){var a={};a.mixin=function(a){a.plugins={},a.prototype.initializePlugins=function(a){var c,d,e,f=this,g=[];if(f.plugins={names:[],settings:{},requested:{},loaded:{}},b.isArray(a))for(c=0,d=a.length;d>c;c++)"string"==typeof a[c]?g.push(a[c]):(f.plugins.settings[a[c].name]=a[c].options,g.push(a[c].name));else if(a)for(e in a)a.hasOwnProperty(e)&&(f.plugins.settings[e]=a[e],g.push(e));for(;g.length;)f.require(g.shift())},a.prototype.loadPlugin=function(b){var c=this,d=c.plugins,e=a.plugins[b];if(!a.plugins.hasOwnProperty(b))throw new Error('Unable to find "'+b+'" plugin');d.requested[b]=!0,d.loaded[b]=e.fn.apply(c,[c.plugins.settings[b]||{}]),d.names.push(b)},a.prototype.require=function(a){var b=this,c=b.plugins;if(!b.plugins.loaded.hasOwnProperty(a)){if(c.requested[a])throw new Error('Plugin has circular dependency ("'+a+'")');b.loadPlugin(a)}return c.loaded[a]},a.define=function(b,c){a.plugins[b]={name:b,fn:c}}};var b={isArray:Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)}};return a}),function(a,b){"function"==typeof define&&define.amd?define("selectize",["jquery","sifter","microplugin"],b):"object"==typeof exports?module.exports=b(require("jquery"),require("sifter"),require("microplugin")):a.Selectize=b(a.jQuery,a.Sifter,a.MicroPlugin)}(this,function(a,b,c){"use strict";var d=function(a,b){if("string"!=typeof b||b.length){var c="string"==typeof b?new RegExp(b,"i"):b,d=function(a){var b=0;if(3===a.nodeType){var e=a.data.search(c);if(e>=0&&a.data.length>0){var f=a.data.match(c),g=document.createElement("span");g.className="highlight";var h=a.splitText(e),i=(h.splitText(f[0].length),h.cloneNode(!0));g.appendChild(i),h.parentNode.replaceChild(g,h),b=1}}else if(1===a.nodeType&&a.childNodes&&!/(script|style)/i.test(a.tagName))for(var j=0;j<a.childNodes.length;++j)j+=d(a.childNodes[j]);return b};return a.each(function(){d(this)})}},e=function(){};e.prototype={on:function(a,b){this._events=this._events||{},this._events[a]=this._events[a]||[],this._events[a].push(b)},off:function(a,b){var c=arguments.length;return 0===c?delete this._events:1===c?delete this._events[a]:(this._events=this._events||{},void(a in this._events!=!1&&this._events[a].splice(this._events[a].indexOf(b),1)))},trigger:function(a){if(this._events=this._events||{},a in this._events!=!1)for(var b=0;b<this._events[a].length;b++)this._events[a][b].apply(this,Array.prototype.slice.call(arguments,1))}},e.mixin=function(a){for(var b=["on","off","trigger"],c=0;c<b.length;c++)a.prototype[b[c]]=e.prototype[b[c]]};var f=/Mac/.test(navigator.userAgent),g=65,h=13,i=27,j=37,k=38,l=80,m=39,n=40,o=78,p=8,q=46,r=16,s=f?91:17,t=f?18:17,u=9,v=1,w=2,x=!/android/i.test(window.navigator.userAgent)&&!!document.createElement("form").validity,y=function(a){return"undefined"!=typeof a},z=function(a){return"undefined"==typeof a||null===a?null:"boolean"==typeof a?a?"1":"0":a+""},A=function(a){return(a+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")},B=function(a){return(a+"").replace(/\$/g,"$$$$")},C={};C.before=function(a,b,c){var d=a[b];a[b]=function(){return c.apply(a,arguments),d.apply(a,arguments)}},C.after=function(a,b,c){var d=a[b];a[b]=function(){var b=d.apply(a,arguments);return c.apply(a,arguments),b}};var D=function(a){var b=!1;return function(){b||(b=!0,a.apply(this,arguments))}},E=function(a,b){var c;return function(){var d=this,e=arguments;window.clearTimeout(c),c=window.setTimeout(function(){a.apply(d,e)},b)}},F=function(a,b,c){var d,e=a.trigger,f={};a.trigger=function(){var c=arguments[0];return-1===b.indexOf(c)?e.apply(a,arguments):void(f[c]=arguments)},c.apply(a,[]),a.trigger=e;for(d in f)f.hasOwnProperty(d)&&e.apply(a,f[d])},G=function(a,b,c,d){a.on(b,c,function(b){for(var c=b.target;c&&c.parentNode!==a[0];)c=c.parentNode;return b.currentTarget=c,d.apply(this,[b])})},H=function(a){var b={};if("selectionStart"in a)b.start=a.selectionStart,b.length=a.selectionEnd-b.start;else if(document.selection){a.focus();var c=document.selection.createRange(),d=document.selection.createRange().text.length;c.moveStart("character",-a.value.length),b.start=c.text.length-d,b.length=d}return b},I=function(a,b,c){var d,e,f={};if(c)for(d=0,e=c.length;e>d;d++)f[c[d]]=a.css(c[d]);else f=a.css();b.css(f)},J=function(b,c){if(!b)return 0;var d=a("<test>").css({position:"absolute",top:-99999,left:-99999,width:"auto",padding:0,whiteSpace:"pre"}).text(b).appendTo("body");I(c,d,["letterSpacing","fontSize","fontFamily","fontWeight","textTransform"]);var e=d.width();return d.remove(),e},K=function(a){var b=null,c=function(c,d){var e,f,g,h,i,j,k,l;c=c||window.event||{},d=d||{},c.metaKey||c.altKey||(d.force||a.data("grow")!==!1)&&(e=a.val(),c.type&&"keydown"===c.type.toLowerCase()&&(f=c.keyCode,g=f>=97&&122>=f||f>=65&&90>=f||f>=48&&57>=f||32===f,f===q||f===p?(l=H(a[0]),l.length?e=e.substring(0,l.start)+e.substring(l.start+l.length):f===p&&l.start?e=e.substring(0,l.start-1)+e.substring(l.start+1):f===q&&"undefined"!=typeof l.start&&(e=e.substring(0,l.start)+e.substring(l.start+1))):g&&(j=c.shiftKey,k=String.fromCharCode(c.keyCode),k=j?k.toUpperCase():k.toLowerCase(),e+=k)),h=a.attr("placeholder"),!e&&h&&(e=h),i=J(e,a)+4,i!==b&&(b=i,a.width(i),a.triggerHandler("resize")))};a.on("keydown keyup update blur",c),c()},L=function(c,d){var e,f,g,h,i=this;h=c[0],h.selectize=i;var j=window.getComputedStyle&&window.getComputedStyle(h,null);if(g=j?j.getPropertyValue("direction"):h.currentStyle&&h.currentStyle.direction,g=g||c.parents("[dir]:first").attr("dir")||"",a.extend(i,{order:0,settings:d,$input:c,tabIndex:c.attr("tabindex")||"",tagType:"select"===h.tagName.toLowerCase()?v:w,rtl:/rtl/i.test(g),eventNS:".selectize"+ ++L.count,highlightedValue:null,isOpen:!1,isDisabled:!1,isRequired:c.is("[required]"),isInvalid:!1,isLocked:!1,isFocused:!1,isInputHidden:!1,isSetup:!1,isShiftDown:!1,isCmdDown:!1,isCtrlDown:!1,ignoreFocus:!1,ignoreBlur:!1,ignoreHover:!1,hasOptions:!1,currentResults:null,lastValue:"",caretPos:0,loading:0,loadedSearches:{},$activeOption:null,$activeItems:[],optgroups:{},options:{},userOptions:{},items:[],renderCache:{},onSearchChange:null===d.loadThrottle?i.onSearchChange:E(i.onSearchChange,d.loadThrottle)}),i.sifter=new b(this.options,{diacritics:d.diacritics}),i.settings.options){for(e=0,f=i.settings.options.length;f>e;e++)i.registerOption(i.settings.options[e]);delete i.settings.options}if(i.settings.optgroups){for(e=0,f=i.settings.optgroups.length;f>e;e++)i.registerOptionGroup(i.settings.optgroups[e]);delete i.settings.optgroups}i.settings.mode=i.settings.mode||(1===i.settings.maxItems?"single":"multi"),"boolean"!=typeof i.settings.hideSelected&&(i.settings.hideSelected="multi"===i.settings.mode),i.initializePlugins(i.settings.plugins),i.setupCallbacks(),i.setupTemplates(),i.setup()};return e.mixin(L),c.mixin(L),a.extend(L.prototype,{setup:function(){var b,c,d,e,g,h,i,j,k,l=this,m=l.settings,n=l.eventNS,o=a(window),p=a(document),q=l.$input;if(i=l.settings.mode,j=q.attr("class")||"",b=a("<div>").addClass(m.wrapperClass).addClass(j).addClass(i),c=a("<div>").addClass(m.inputClass).addClass("items").appendTo(b),d=a('<input type="text" autocomplete="off" />').appendTo(c).attr("tabindex",q.is(":disabled")?"-1":l.tabIndex),h=a(m.dropdownParent||b),e=a("<div>").addClass(m.dropdownClass).addClass(i).hide().appendTo(h),g=a("<div>").addClass(m.dropdownContentClass).appendTo(e),l.settings.copyClassesToDropdown&&e.addClass(j),b.css({width:q[0].style.width}),l.plugins.names.length&&(k="plugin-"+l.plugins.names.join(" plugin-"),b.addClass(k),e.addClass(k)),(null===m.maxItems||m.maxItems>1)&&l.tagType===v&&q.attr("multiple","multiple"),l.settings.placeholder&&d.attr("placeholder",m.placeholder),!l.settings.splitOn&&l.settings.delimiter){var u=l.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");l.settings.splitOn=new RegExp("\\s*"+u+"+\\s*")}q.attr("autocorrect")&&d.attr("autocorrect",q.attr("autocorrect")),q.attr("autocapitalize")&&d.attr("autocapitalize",q.attr("autocapitalize")),l.$wrapper=b,l.$control=c,l.$control_input=d,l.$dropdown=e,l.$dropdown_content=g,e.on("mouseenter","[data-selectable]",function(){return l.onOptionHover.apply(l,arguments)}),e.on("mousedown click","[data-selectable]",function(){return l.onOptionSelect.apply(l,arguments)}),G(c,"mousedown","*:not(input)",function(){return l.onItemSelect.apply(l,arguments)}),K(d),c.on({mousedown:function(){return l.onMouseDown.apply(l,arguments)},click:function(){return l.onClick.apply(l,arguments)}}),d.on({mousedown:function(a){a.stopPropagation()},keydown:function(){return l.onKeyDown.apply(l,arguments)},keyup:function(){return l.onKeyUp.apply(l,arguments)},keypress:function(){return l.onKeyPress.apply(l,arguments)},resize:function(){l.positionDropdown.apply(l,[])},blur:function(){return l.onBlur.apply(l,arguments)},focus:function(){return l.ignoreBlur=!1,l.onFocus.apply(l,arguments)},paste:function(){return l.onPaste.apply(l,arguments)}}),p.on("keydown"+n,function(a){l.isCmdDown=a[f?"metaKey":"ctrlKey"],l.isCtrlDown=a[f?"altKey":"ctrlKey"],l.isShiftDown=a.shiftKey}),p.on("keyup"+n,function(a){a.keyCode===t&&(l.isCtrlDown=!1),a.keyCode===r&&(l.isShiftDown=!1),a.keyCode===s&&(l.isCmdDown=!1)}),p.on("mousedown"+n,function(a){if(l.isFocused){if(a.target===l.$dropdown[0]||a.target.parentNode===l.$dropdown[0])return!1;l.$control.has(a.target).length||a.target===l.$control[0]||l.blur(a.target)}}),o.on(["scroll"+n,"resize"+n].join(" "),function(){l.isOpen&&l.positionDropdown.apply(l,arguments)}),o.on("mousemove"+n,function(){l.ignoreHover=!1}),this.revertSettings={$children:q.children().detach(),tabindex:q.attr("tabindex")},q.attr("tabindex",-1).hide().after(l.$wrapper),a.isArray(m.items)&&(l.setValue(m.items),delete m.items),x&&q.on("invalid"+n,function(a){a.preventDefault(),l.isInvalid=!0,l.refreshState()}),l.updateOriginalInput(),l.refreshItems(),l.refreshState(),l.updatePlaceholder(),l.isSetup=!0,q.is(":disabled")&&l.disable(),l.on("change",this.onChange),q.data("selectize",l),q.addClass("selectized"),l.trigger("initialize"),m.preload===!0&&l.onSearchChange("")},setupTemplates:function(){var b=this,c=b.settings.labelField,d=b.settings.optgroupLabelField,e={optgroup:function(a){return'<div class="optgroup">'+a.html+"</div>"},optgroup_header:function(a,b){return'<div class="optgroup-header">'+b(a[d])+"</div>"},option:function(a,b){return'<div class="option">'+b(a[c])+"</div>"},item:function(a,b){return'<div class="item">'+b(a[c])+"</div>"},option_create:function(a,b){return'<div class="create">Add <strong>'+b(a.input)+"</strong>&hellip;</div>"}};b.settings.render=a.extend({},e,b.settings.render)},setupCallbacks:function(){var a,b,c={initialize:"onInitialize",change:"onChange",item_add:"onItemAdd",item_remove:"onItemRemove",clear:"onClear",option_add:"onOptionAdd",option_remove:"onOptionRemove",option_clear:"onOptionClear",optgroup_add:"onOptionGroupAdd",optgroup_remove:"onOptionGroupRemove",optgroup_clear:"onOptionGroupClear",dropdown_open:"onDropdownOpen",dropdown_close:"onDropdownClose",type:"onType",load:"onLoad",focus:"onFocus",blur:"onBlur"};for(a in c)c.hasOwnProperty(a)&&(b=this.settings[c[a]],b&&this.on(a,b))},onClick:function(a){var b=this;b.isFocused||(b.focus(),a.preventDefault())},onMouseDown:function(b){{var c=this,d=b.isDefaultPrevented();a(b.target)}if(c.isFocused){if(b.target!==c.$control_input[0])return"single"===c.settings.mode?c.isOpen?c.close():c.open():d||c.setActiveItem(null),!1}else d||window.setTimeout(function(){c.focus()},0)},onChange:function(){this.$input.trigger("change")},onPaste:function(b){var c=this;c.isFull()||c.isInputHidden||c.isLocked?b.preventDefault():c.settings.splitOn&&setTimeout(function(){for(var b=a.trim(c.$control_input.val()||"").split(c.settings.splitOn),d=0,e=b.length;e>d;d++)c.createItem(b[d])},0)},onKeyPress:function(a){if(this.isLocked)return a&&a.preventDefault();var b=String.fromCharCode(a.keyCode||a.which);return this.settings.create&&"multi"===this.settings.mode&&b===this.settings.delimiter?(this.createItem(),a.preventDefault(),!1):void 0},onKeyDown:function(a){var b=(a.target===this.$control_input[0],this);if(b.isLocked)return void(a.keyCode!==u&&a.preventDefault());switch(a.keyCode){case g:if(b.isCmdDown)return void b.selectAll();break;case i:return void(b.isOpen&&(a.preventDefault(),a.stopPropagation(),b.close()));case o:if(!a.ctrlKey||a.altKey)break;case n:if(!b.isOpen&&b.hasOptions)b.open();else if(b.$activeOption){b.ignoreHover=!0;var c=b.getAdjacentOption(b.$activeOption,1);c.length&&b.setActiveOption(c,!0,!0)}return void a.preventDefault();case l:if(!a.ctrlKey||a.altKey)break;case k:if(b.$activeOption){b.ignoreHover=!0;var d=b.getAdjacentOption(b.$activeOption,-1);d.length&&b.setActiveOption(d,!0,!0)}return void a.preventDefault();case h:return void(b.isOpen&&b.$activeOption&&(b.onOptionSelect({currentTarget:b.$activeOption}),a.preventDefault()));case j:return void b.advanceSelection(-1,a);case m:return void b.advanceSelection(1,a);case u:return b.settings.selectOnTab&&b.isOpen&&b.$activeOption&&(b.onOptionSelect({currentTarget:b.$activeOption}),b.isFull()||a.preventDefault()),void(b.settings.create&&b.createItem()&&a.preventDefault());case p:case q:return void b.deleteSelection(a)}return!b.isFull()&&!b.isInputHidden||(f?a.metaKey:a.ctrlKey)?void 0:void a.preventDefault()},onKeyUp:function(a){var b=this;if(b.isLocked)return a&&a.preventDefault();var c=b.$control_input.val()||"";b.lastValue!==c&&(b.lastValue=c,b.onSearchChange(c),b.refreshOptions(),b.trigger("type",c))},onSearchChange:function(a){var b=this,c=b.settings.load;c&&(b.loadedSearches.hasOwnProperty(a)||(b.loadedSearches[a]=!0,b.load(function(d){c.apply(b,[a,d])})))},onFocus:function(a){var b=this,c=b.isFocused;return b.isDisabled?(b.blur(),a&&a.preventDefault(),!1):void(b.ignoreFocus||(b.isFocused=!0,"focus"===b.settings.preload&&b.onSearchChange(""),c||b.trigger("focus"),b.$activeItems.length||(b.showInput(),b.setActiveItem(null),b.refreshOptions(!!b.settings.openOnFocus)),b.refreshState()))},onBlur:function(a,b){var c=this;if(c.isFocused&&(c.isFocused=!1,!c.ignoreFocus)){if(!c.ignoreBlur&&document.activeElement===c.$dropdown_content[0])return c.ignoreBlur=!0,void c.onFocus(a);var d=function(){c.close(),c.setTextboxValue(""),c.setActiveItem(null),c.setActiveOption(null),c.setCaret(c.items.length),c.refreshState(),(b||document.body).focus(),c.ignoreFocus=!1,c.trigger("blur")};c.ignoreFocus=!0,c.settings.create&&c.settings.createOnBlur?c.createItem(null,!1,d):d()}},onOptionHover:function(a){this.ignoreHover||this.setActiveOption(a.currentTarget,!1)},onOptionSelect:function(b){var c,d,e=this;b.preventDefault&&(b.preventDefault(),b.stopPropagation()),d=a(b.currentTarget),d.hasClass("create")?e.createItem(null,function(){e.settings.closeAfterSelect&&e.close()}):(c=d.attr("data-value"),"undefined"!=typeof c&&(e.lastQuery=null,e.setTextboxValue(""),e.addItem(c),e.settings.closeAfterSelect?e.close():!e.settings.hideSelected&&b.type&&/mouse/.test(b.type)&&e.setActiveOption(e.getOption(c))))},onItemSelect:function(a){var b=this;b.isLocked||"multi"===b.settings.mode&&(a.preventDefault(),b.setActiveItem(a.currentTarget,a))},load:function(a){var b=this,c=b.$wrapper.addClass(b.settings.loadingClass);b.loading++,a.apply(b,[function(a){b.loading=Math.max(b.loading-1,0),a&&a.length&&(b.addOption(a),b.refreshOptions(b.isFocused&&!b.isInputHidden)),b.loading||c.removeClass(b.settings.loadingClass),b.trigger("load",a)}])},setTextboxValue:function(a){var b=this.$control_input,c=b.val()!==a;c&&(b.val(a).triggerHandler("update"),this.lastValue=a)},getValue:function(){return this.tagType===v&&this.$input.attr("multiple")?this.items:this.items.join(this.settings.delimiter)},setValue:function(a,b){var c=b?[]:["change"];F(this,c,function(){this.clear(b),this.addItems(a,b)})},setActiveItem:function(b,c){var d,e,f,g,h,i,j,k,l=this;if("single"!==l.settings.mode){if(b=a(b),!b.length)return a(l.$activeItems).removeClass("active"),l.$activeItems=[],void(l.isFocused&&l.showInput());if(d=c&&c.type.toLowerCase(),"mousedown"===d&&l.isShiftDown&&l.$activeItems.length){for(k=l.$control.children(".active:last"),g=Array.prototype.indexOf.apply(l.$control[0].childNodes,[k[0]]),h=Array.prototype.indexOf.apply(l.$control[0].childNodes,[b[0]]),g>h&&(j=g,g=h,h=j),e=g;h>=e;e++)i=l.$control[0].childNodes[e],-1===l.$activeItems.indexOf(i)&&(a(i).addClass("active"),l.$activeItems.push(i));c.preventDefault()}else"mousedown"===d&&l.isCtrlDown||"keydown"===d&&this.isShiftDown?b.hasClass("active")?(f=l.$activeItems.indexOf(b[0]),l.$activeItems.splice(f,1),b.removeClass("active")):l.$activeItems.push(b.addClass("active")[0]):(a(l.$activeItems).removeClass("active"),l.$activeItems=[b.addClass("active")[0]]);l.hideInput(),this.isFocused||l.focus()}},setActiveOption:function(b,c,d){var e,f,g,h,i,j=this;j.$activeOption&&j.$activeOption.removeClass("active"),j.$activeOption=null,b=a(b),b.length&&(j.$activeOption=b.addClass("active"),(c||!y(c))&&(e=j.$dropdown_content.height(),f=j.$activeOption.outerHeight(!0),c=j.$dropdown_content.scrollTop()||0,g=j.$activeOption.offset().top-j.$dropdown_content.offset().top+c,h=g,i=g-e+f,g+f>e+c?j.$dropdown_content.stop().animate({scrollTop:i},d?j.settings.scrollDuration:0):c>g&&j.$dropdown_content.stop().animate({scrollTop:h},d?j.settings.scrollDuration:0)))},selectAll:function(){var a=this;"single"!==a.settings.mode&&(a.$activeItems=Array.prototype.slice.apply(a.$control.children(":not(input)").addClass("active")),a.$activeItems.length&&(a.hideInput(),a.close()),a.focus())},hideInput:function(){var a=this;a.setTextboxValue(""),a.$control_input.css({opacity:0,position:"absolute",left:a.rtl?1e4:-1e4}),a.isInputHidden=!0},showInput:function(){this.$control_input.css({opacity:1,position:"relative",left:0}),this.isInputHidden=!1},focus:function(){var a=this;a.isDisabled||(a.ignoreFocus=!0,a.$control_input[0].focus(),window.setTimeout(function(){a.ignoreFocus=!1,a.onFocus()},0))},blur:function(a){this.$control_input[0].blur(),this.onBlur(null,a)},getScoreFunction:function(a){return this.sifter.getScoreFunction(a,this.getSearchOptions())},getSearchOptions:function(){var a=this.settings,b=a.sortField;return"string"==typeof b&&(b=[{field:b}]),{fields:a.searchField,conjunction:a.searchConjunction,sort:b}},search:function(b){var c,d,e,f=this,g=f.settings,h=this.getSearchOptions();if(g.score&&(e=f.settings.score.apply(this,[b]),"function"!=typeof e))throw new Error('Selectize "score" setting must be a function that returns a function');if(b!==f.lastQuery?(f.lastQuery=b,d=f.sifter.search(b,a.extend(h,{score:e})),f.currentResults=d):d=a.extend(!0,{},f.currentResults),g.hideSelected)for(c=d.items.length-1;c>=0;c--)-1!==f.items.indexOf(z(d.items[c].id))&&d.items.splice(c,1);return d},refreshOptions:function(b){var c,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s;"undefined"==typeof b&&(b=!0);var t=this,u=a.trim(t.$control_input.val()),v=t.search(u),w=t.$dropdown_content,x=t.$activeOption&&z(t.$activeOption.attr("data-value"));for(g=v.items.length,"number"==typeof t.settings.maxOptions&&(g=Math.min(g,t.settings.maxOptions)),h={},i=[],c=0;g>c;c++)for(j=t.options[v.items[c].id],k=t.render("option",j),l=j[t.settings.optgroupField]||"",m=a.isArray(l)?l:[l],e=0,f=m&&m.length;f>e;e++)l=m[e],t.optgroups.hasOwnProperty(l)||(l=""),h.hasOwnProperty(l)||(h[l]=[],i.push(l)),h[l].push(k);for(this.settings.lockOptgroupOrder&&i.sort(function(a,b){var c=t.optgroups[a].$order||0,d=t.optgroups[b].$order||0;return c-d}),n=[],c=0,g=i.length;g>c;c++)l=i[c],t.optgroups.hasOwnProperty(l)&&h[l].length?(o=t.render("optgroup_header",t.optgroups[l])||"",o+=h[l].join(""),n.push(t.render("optgroup",a.extend({},t.optgroups[l],{html:o})))):n.push(h[l].join(""));if(w.html(n.join("")),t.settings.highlight&&v.query.length&&v.tokens.length)for(c=0,g=v.tokens.length;g>c;c++)d(w,v.tokens[c].regex);if(!t.settings.hideSelected)for(c=0,g=t.items.length;g>c;c++)t.getOption(t.items[c]).addClass("selected");p=t.canCreate(u),p&&(w.prepend(t.render("option_create",{input:u})),s=a(w[0].childNodes[0])),t.hasOptions=v.items.length>0||p,t.hasOptions?(v.items.length>0?(r=x&&t.getOption(x),r&&r.length?q=r:"single"===t.settings.mode&&t.items.length&&(q=t.getOption(t.items[0])),q&&q.length||(q=s&&!t.settings.addPrecedence?t.getAdjacentOption(s,1):w.find("[data-selectable]:first"))):q=s,t.setActiveOption(q),b&&!t.isOpen&&t.open()):(t.setActiveOption(null),b&&t.isOpen&&t.close())},addOption:function(b){var c,d,e,f=this;if(a.isArray(b))for(c=0,d=b.length;d>c;c++)f.addOption(b[c]);else(e=f.registerOption(b))&&(f.userOptions[e]=!0,f.lastQuery=null,f.trigger("option_add",e,b))},registerOption:function(a){var b=z(a[this.settings.valueField]);return!b||this.options.hasOwnProperty(b)?!1:(a.$order=a.$order||++this.order,this.options[b]=a,b)},registerOptionGroup:function(a){var b=z(a[this.settings.optgroupValueField]);return b?(a.$order=a.$order||++this.order,this.optgroups[b]=a,b):!1},addOptionGroup:function(a,b){b[this.settings.optgroupValueField]=a,(a=this.registerOptionGroup(b))&&this.trigger("optgroup_add",a,b)},removeOptionGroup:function(a){this.optgroups.hasOwnProperty(a)&&(delete this.optgroups[a],this.renderCache={},this.trigger("optgroup_remove",a))},clearOptionGroups:function(){this.optgroups={},this.renderCache={},this.trigger("optgroup_clear")},updateOption:function(b,c){var d,e,f,g,h,i,j,k=this;if(b=z(b),f=z(c[k.settings.valueField]),null!==b&&k.options.hasOwnProperty(b)){if("string"!=typeof f)throw new Error("Value must be set in option data");j=k.options[b].$order,f!==b&&(delete k.options[b],g=k.items.indexOf(b),-1!==g&&k.items.splice(g,1,f)),c.$order=c.$order||j,k.options[f]=c,h=k.renderCache.item,i=k.renderCache.option,h&&(delete h[b],delete h[f]),i&&(delete i[b],delete i[f]),-1!==k.items.indexOf(f)&&(d=k.getItem(b),e=a(k.render("item",c)),d.hasClass("active")&&e.addClass("active"),d.replaceWith(e)),k.lastQuery=null,k.isOpen&&k.refreshOptions(!1)}},removeOption:function(a,b){var c=this;a=z(a);var d=c.renderCache.item,e=c.renderCache.option;d&&delete d[a],e&&delete e[a],delete c.userOptions[a],delete c.options[a],c.lastQuery=null,c.trigger("option_remove",a),c.removeItem(a,b)},clearOptions:function(){var a=this;a.loadedSearches={},a.userOptions={},a.renderCache={},a.options=a.sifter.items={},a.lastQuery=null,a.trigger("option_clear"),a.clear()},getOption:function(a){return this.getElementWithValue(a,this.$dropdown_content.find("[data-selectable]"))},getAdjacentOption:function(b,c){var d=this.$dropdown.find("[data-selectable]"),e=d.index(b)+c;return e>=0&&e<d.length?d.eq(e):a()},getElementWithValue:function(b,c){if(b=z(b),"undefined"!=typeof b&&null!==b)for(var d=0,e=c.length;e>d;d++)if(c[d].getAttribute("data-value")===b)return a(c[d]);return a()},getItem:function(a){return this.getElementWithValue(a,this.$control.children())},addItems:function(b,c){for(var d=a.isArray(b)?b:[b],e=0,f=d.length;f>e;e++)this.isPending=f-1>e,this.addItem(d[e],c)},addItem:function(b,c){var d=c?[]:["change"];F(this,d,function(){var d,e,f,g,h,i=this,j=i.settings.mode;return b=z(b),-1!==i.items.indexOf(b)?void("single"===j&&i.close()):void(i.options.hasOwnProperty(b)&&("single"===j&&i.clear(c),"multi"===j&&i.isFull()||(d=a(i.render("item",i.options[b])),h=i.isFull(),i.items.splice(i.caretPos,0,b),i.insertAtCaret(d),(!i.isPending||!h&&i.isFull())&&i.refreshState(),i.isSetup&&(f=i.$dropdown_content.find("[data-selectable]"),i.isPending||(e=i.getOption(b),g=i.getAdjacentOption(e,1).attr("data-value"),i.refreshOptions(i.isFocused&&"single"!==j),g&&i.setActiveOption(i.getOption(g))),!f.length||i.isFull()?i.close():i.positionDropdown(),i.updatePlaceholder(),i.trigger("item_add",b,d),i.updateOriginalInput({silent:c})))))})},removeItem:function(a,b){var c,d,e,f=this;c="object"==typeof a?a:f.getItem(a),a=z(c.attr("data-value")),d=f.items.indexOf(a),-1!==d&&(c.remove(),c.hasClass("active")&&(e=f.$activeItems.indexOf(c[0]),f.$activeItems.splice(e,1)),f.items.splice(d,1),f.lastQuery=null,!f.settings.persist&&f.userOptions.hasOwnProperty(a)&&f.removeOption(a,b),d<f.caretPos&&f.setCaret(f.caretPos-1),f.refreshState(),f.updatePlaceholder(),f.updateOriginalInput({silent:b}),f.positionDropdown(),f.trigger("item_remove",a,c))},createItem:function(b,c){var d=this,e=d.caretPos;b=b||a.trim(d.$control_input.val()||"");var f=arguments[arguments.length-1];if("function"!=typeof f&&(f=function(){}),"boolean"!=typeof c&&(c=!0),!d.canCreate(b))return f(),!1;d.lock();var g="function"==typeof d.settings.create?this.settings.create:function(a){var b={};return b[d.settings.labelField]=a,b[d.settings.valueField]=a,b},h=D(function(a){if(d.unlock(),!a||"object"!=typeof a)return f();var b=z(a[d.settings.valueField]);return"string"!=typeof b?f():(d.setTextboxValue(""),d.addOption(a),d.setCaret(e),d.addItem(b),d.refreshOptions(c&&"single"!==d.settings.mode),void f(a))}),i=g.apply(this,[b,h]);return"undefined"!=typeof i&&h(i),!0},refreshItems:function(){this.lastQuery=null,this.isSetup&&this.addItem(this.items),this.refreshState(),this.updateOriginalInput()},refreshState:function(){var a,b=this;b.isRequired&&(b.items.length&&(b.isInvalid=!1),b.$control_input.prop("required",a)),b.refreshClasses()},refreshClasses:function(){var b=this,c=b.isFull(),d=b.isLocked;b.$wrapper.toggleClass("rtl",b.rtl),b.$control.toggleClass("focus",b.isFocused).toggleClass("disabled",b.isDisabled).toggleClass("required",b.isRequired).toggleClass("invalid",b.isInvalid).toggleClass("locked",d).toggleClass("full",c).toggleClass("not-full",!c).toggleClass("input-active",b.isFocused&&!b.isInputHidden).toggleClass("dropdown-active",b.isOpen).toggleClass("has-options",!a.isEmptyObject(b.options)).toggleClass("has-items",b.items.length>0),b.$control_input.data("grow",!c&&!d)},isFull:function(){return null!==this.settings.maxItems&&this.items.length>=this.settings.maxItems},updateOriginalInput:function(a){var b,c,d,e,f=this;if(a=a||{},f.tagType===v){for(d=[],b=0,c=f.items.length;c>b;b++)e=f.options[f.items[b]][f.settings.labelField]||"",d.push('<option value="'+A(f.items[b])+'" selected="selected">'+A(e)+"</option>");d.length||this.$input.attr("multiple")||d.push('<option value="" selected="selected"></option>'),f.$input.html(d.join(""))}else f.$input.val(f.getValue()),f.$input.attr("value",f.$input.val());f.isSetup&&(a.silent||f.trigger("change",f.$input.val()))},updatePlaceholder:function(){if(this.settings.placeholder){var a=this.$control_input;this.items.length?a.removeAttr("placeholder"):a.attr("placeholder",this.settings.placeholder),a.triggerHandler("update",{force:!0})}},open:function(){var a=this;a.isLocked||a.isOpen||"multi"===a.settings.mode&&a.isFull()||(a.focus(),a.isOpen=!0,a.refreshState(),a.$dropdown.css({visibility:"hidden",display:"block"}),a.positionDropdown(),a.$dropdown.css({visibility:"visible"}),a.trigger("dropdown_open",a.$dropdown))},close:function(){var a=this,b=a.isOpen;"single"===a.settings.mode&&a.items.length&&a.hideInput(),a.isOpen=!1,a.$dropdown.hide(),a.setActiveOption(null),a.refreshState(),b&&a.trigger("dropdown_close",a.$dropdown)},positionDropdown:function(){var a=this.$control,b="body"===this.settings.dropdownParent?a.offset():a.position();b.top+=a.outerHeight(!0),this.$dropdown.css({width:a.outerWidth(),top:b.top,left:b.left})},clear:function(a){var b=this;b.items.length&&(b.$control.children(":not(input)").remove(),b.items=[],b.lastQuery=null,b.setCaret(0),b.setActiveItem(null),b.updatePlaceholder(),b.updateOriginalInput({silent:a}),b.refreshState(),b.showInput(),b.trigger("clear"))},insertAtCaret:function(b){var c=Math.min(this.caretPos,this.items.length);0===c?this.$control.prepend(b):a(this.$control[0].childNodes[c]).before(b),this.setCaret(c+1)},deleteSelection:function(b){var c,d,e,f,g,h,i,j,k,l=this;if(e=b&&b.keyCode===p?-1:1,f=H(l.$control_input[0]),l.$activeOption&&!l.settings.hideSelected&&(i=l.getAdjacentOption(l.$activeOption,-1).attr("data-value")),g=[],l.$activeItems.length){for(k=l.$control.children(".active:"+(e>0?"last":"first")),h=l.$control.children(":not(input)").index(k),e>0&&h++,c=0,d=l.$activeItems.length;d>c;c++)g.push(a(l.$activeItems[c]).attr("data-value"));
b&&(b.preventDefault(),b.stopPropagation())}else(l.isFocused||"single"===l.settings.mode)&&l.items.length&&(0>e&&0===f.start&&0===f.length?g.push(l.items[l.caretPos-1]):e>0&&f.start===l.$control_input.val().length&&g.push(l.items[l.caretPos]));if(!g.length||"function"==typeof l.settings.onDelete&&l.settings.onDelete.apply(l,[g])===!1)return!1;for("undefined"!=typeof h&&l.setCaret(h);g.length;)l.removeItem(g.pop());return l.showInput(),l.positionDropdown(),l.refreshOptions(!0),i&&(j=l.getOption(i),j.length&&l.setActiveOption(j)),!0},advanceSelection:function(a,b){var c,d,e,f,g,h,i=this;0!==a&&(i.rtl&&(a*=-1),c=a>0?"last":"first",d=H(i.$control_input[0]),i.isFocused&&!i.isInputHidden?(f=i.$control_input.val().length,g=0>a?0===d.start&&0===d.length:d.start===f,g&&!f&&i.advanceCaret(a,b)):(h=i.$control.children(".active:"+c),h.length&&(e=i.$control.children(":not(input)").index(h),i.setActiveItem(null),i.setCaret(a>0?e+1:e))))},advanceCaret:function(a,b){var c,d,e=this;0!==a&&(c=a>0?"next":"prev",e.isShiftDown?(d=e.$control_input[c](),d.length&&(e.hideInput(),e.setActiveItem(d),b&&b.preventDefault())):e.setCaret(e.caretPos+a))},setCaret:function(b){var c=this;if(b="single"===c.settings.mode?c.items.length:Math.max(0,Math.min(c.items.length,b)),!c.isPending){var d,e,f,g;for(f=c.$control.children(":not(input)"),d=0,e=f.length;e>d;d++)g=a(f[d]).detach(),b>d?c.$control_input.before(g):c.$control.append(g)}c.caretPos=b},lock:function(){this.close(),this.isLocked=!0,this.refreshState()},unlock:function(){this.isLocked=!1,this.refreshState()},disable:function(){var a=this;a.$input.prop("disabled",!0),a.$control_input.prop("disabled",!0).prop("tabindex",-1),a.isDisabled=!0,a.lock()},enable:function(){var a=this;a.$input.prop("disabled",!1),a.$control_input.prop("disabled",!1).prop("tabindex",a.tabIndex),a.isDisabled=!1,a.unlock()},destroy:function(){var b=this,c=b.eventNS,d=b.revertSettings;b.trigger("destroy"),b.off(),b.$wrapper.remove(),b.$dropdown.remove(),b.$input.html("").append(d.$children).removeAttr("tabindex").removeClass("selectized").attr({tabindex:d.tabindex}).show(),b.$control_input.removeData("grow"),b.$input.removeData("selectize"),a(window).off(c),a(document).off(c),a(document.body).off(c),delete b.$input[0].selectize},render:function(a,b){var c,d,e="",f=!1,g=this,h=/^[\t \r\n]*<([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?)/i;return("option"===a||"item"===a)&&(c=z(b[g.settings.valueField]),f=!!c),f&&(y(g.renderCache[a])||(g.renderCache[a]={}),g.renderCache[a].hasOwnProperty(c))?g.renderCache[a][c]:(e=g.settings.render[a].apply(this,[b,A]),("option"===a||"option_create"===a)&&(e=e.replace(h,"<$1 data-selectable")),"optgroup"===a&&(d=b[g.settings.optgroupValueField]||"",e=e.replace(h,'<$1 data-group="'+B(A(d))+'"')),("option"===a||"item"===a)&&(e=e.replace(h,'<$1 data-value="'+B(A(c||""))+'"')),f&&(g.renderCache[a][c]=e),e)},clearCache:function(a){var b=this;"undefined"==typeof a?b.renderCache={}:delete b.renderCache[a]},canCreate:function(a){var b=this;if(!b.settings.create)return!1;var c=b.settings.createFilter;return!(!a.length||"function"==typeof c&&!c.apply(b,[a])||"string"==typeof c&&!new RegExp(c).test(a)||c instanceof RegExp&&!c.test(a))}}),L.count=0,L.defaults={options:[],optgroups:[],plugins:[],delimiter:",",splitOn:null,persist:!0,diacritics:!0,create:!1,createOnBlur:!1,createFilter:null,highlight:!0,openOnFocus:!0,maxOptions:1e3,maxItems:null,hideSelected:null,addPrecedence:!1,selectOnTab:!1,preload:!1,allowEmptyOption:!1,closeAfterSelect:!1,scrollDuration:60,loadThrottle:300,loadingClass:"loading",dataAttr:"data-data",optgroupField:"optgroup",valueField:"value",labelField:"text",optgroupLabelField:"label",optgroupValueField:"value",lockOptgroupOrder:!1,sortField:"$order",searchField:["text"],searchConjunction:"and",mode:null,wrapperClass:"selectize-control",inputClass:"selectize-input",dropdownClass:"selectize-dropdown",dropdownContentClass:"selectize-dropdown-content",dropdownParent:null,copyClassesToDropdown:!0,render:{}},a.fn.selectize=function(b){var c=a.fn.selectize.defaults,d=a.extend({},c,b),e=d.dataAttr,f=d.labelField,g=d.valueField,h=d.optgroupField,i=d.optgroupLabelField,j=d.optgroupValueField,k=function(b,c){var h,i,j,k,l=b.attr(e);if(l)for(c.options=JSON.parse(l),h=0,i=c.options.length;i>h;h++)c.items.push(c.options[h][g]);else{var m=a.trim(b.val()||"");if(!d.allowEmptyOption&&!m.length)return;for(j=m.split(d.delimiter),h=0,i=j.length;i>h;h++)k={},k[f]=j[h],k[g]=j[h],c.options.push(k);c.items=j}},l=function(b,c){var k,l,m,n,o=c.options,p={},q=function(a){var b=e&&a.attr(e);return"string"==typeof b&&b.length?JSON.parse(b):null},r=function(b,e){b=a(b);var i=z(b.attr("value"));if(i||d.allowEmptyOption)if(p.hasOwnProperty(i)){if(e){var j=p[i][h];j?a.isArray(j)?j.push(e):p[i][h]=[j,e]:p[i][h]=e}}else{var k=q(b)||{};k[f]=k[f]||b.text(),k[g]=k[g]||i,k[h]=k[h]||e,p[i]=k,o.push(k),b.is(":selected")&&c.items.push(i)}},s=function(b){var d,e,f,g,h;for(b=a(b),f=b.attr("label"),f&&(g=q(b)||{},g[i]=f,g[j]=f,c.optgroups.push(g)),h=a("option",b),d=0,e=h.length;e>d;d++)r(h[d],f)};for(c.maxItems=b.attr("multiple")?null:1,n=b.children(),k=0,l=n.length;l>k;k++)m=n[k].tagName.toLowerCase(),"optgroup"===m?s(n[k]):"option"===m&&r(n[k])};return this.each(function(){if(!this.selectize){var e,f=a(this),g=this.tagName.toLowerCase(),h=f.attr("placeholder")||f.attr("data-placeholder");h||d.allowEmptyOption||(h=f.children('option[value=""]').text());var i={placeholder:h,options:[],optgroups:[],items:[]};"select"===g?l(f,i):k(f,i),e=new L(f,a.extend(!0,{},c,i,b))}})},a.fn.selectize.defaults=L.defaults,a.fn.selectize.support={validity:x},L.define("drag_drop",function(){if(!a.fn.sortable)throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');if("multi"===this.settings.mode){var b=this;b.lock=function(){var a=b.lock;return function(){var c=b.$control.data("sortable");return c&&c.disable(),a.apply(b,arguments)}}(),b.unlock=function(){var a=b.unlock;return function(){var c=b.$control.data("sortable");return c&&c.enable(),a.apply(b,arguments)}}(),b.setup=function(){var c=b.setup;return function(){c.apply(this,arguments);var d=b.$control.sortable({items:"[data-value]",forcePlaceholderSize:!0,disabled:b.isLocked,start:function(a,b){b.placeholder.css("width",b.helper.css("width")),d.css({overflow:"visible"})},stop:function(){d.css({overflow:"hidden"});var c=b.$activeItems?b.$activeItems.slice():null,e=[];d.children("[data-value]").each(function(){e.push(a(this).attr("data-value"))}),b.setValue(e),b.setActiveItem(c)}})}}()}}),L.define("dropdown_header",function(b){var c=this;b=a.extend({title:"Untitled",headerClass:"selectize-dropdown-header",titleRowClass:"selectize-dropdown-header-title",labelClass:"selectize-dropdown-header-label",closeClass:"selectize-dropdown-header-close",html:function(a){return'<div class="'+a.headerClass+'"><div class="'+a.titleRowClass+'"><span class="'+a.labelClass+'">'+a.title+'</span><a href="javascript:void(0)" class="'+a.closeClass+'">&times;</a></div></div>'}},b),c.setup=function(){var d=c.setup;return function(){d.apply(c,arguments),c.$dropdown_header=a(b.html(b)),c.$dropdown.prepend(c.$dropdown_header)}}()}),L.define("optgroup_columns",function(b){var c=this;b=a.extend({equalizeWidth:!0,equalizeHeight:!0},b),this.getAdjacentOption=function(b,c){var d=b.closest("[data-group]").find("[data-selectable]"),e=d.index(b)+c;return e>=0&&e<d.length?d.eq(e):a()},this.onKeyDown=function(){var a=c.onKeyDown;return function(b){var d,e,f,g;return!this.isOpen||b.keyCode!==j&&b.keyCode!==m?a.apply(this,arguments):(c.ignoreHover=!0,g=this.$activeOption.closest("[data-group]"),d=g.find("[data-selectable]").index(this.$activeOption),g=b.keyCode===j?g.prev("[data-group]"):g.next("[data-group]"),f=g.find("[data-selectable]"),e=f.eq(Math.min(f.length-1,d)),void(e.length&&this.setActiveOption(e)))}}();var d=function(){var a,b=d.width,c=document;return"undefined"==typeof b&&(a=c.createElement("div"),a.innerHTML='<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>',a=a.firstChild,c.body.appendChild(a),b=d.width=a.offsetWidth-a.clientWidth,c.body.removeChild(a)),b},e=function(){var e,f,g,h,i,j,k;if(k=a("[data-group]",c.$dropdown_content),f=k.length,f&&c.$dropdown_content.width()){if(b.equalizeHeight){for(g=0,e=0;f>e;e++)g=Math.max(g,k.eq(e).height());k.css({height:g})}b.equalizeWidth&&(j=c.$dropdown_content.innerWidth()-d(),h=Math.round(j/f),k.css({width:h}),f>1&&(i=j-h*(f-1),k.eq(f-1).css({width:i})))}};(b.equalizeHeight||b.equalizeWidth)&&(C.after(this,"positionDropdown",e),C.after(this,"refreshOptions",e))}),L.define("remove_button",function(b){if("single"!==this.settings.mode){b=a.extend({label:"&times;",title:"Remove",className:"remove",append:!0},b);var c=this,d='<a href="javascript:void(0)" class="'+b.className+'" tabindex="-1" title="'+A(b.title)+'">'+b.label+"</a>",e=function(a,b){var c=a.search(/(<\/[^>]+>\s*)$/);return a.substring(0,c)+b+a.substring(c)};this.setup=function(){var f=c.setup;return function(){if(b.append){var g=c.settings.render.item;c.settings.render.item=function(){return e(g.apply(this,arguments),d)}}f.apply(this,arguments),this.$control.on("click","."+b.className,function(b){if(b.preventDefault(),!c.isLocked){var d=a(b.currentTarget).parent();c.setActiveItem(d),c.deleteSelection()&&c.setCaret(c.items.length)}})}}()}}),L.define("restore_on_backspace",function(a){var b=this;a.text=a.text||function(a){return a[this.settings.labelField]},this.onKeyDown=function(){var c=b.onKeyDown;return function(b){var d,e;return b.keyCode===p&&""===this.$control_input.val()&&!this.$activeItems.length&&(d=this.caretPos-1,d>=0&&d<this.items.length)?(e=this.options[this.items[d]],this.deleteSelection(b)&&(this.setTextboxValue(a.text.apply(this,[e])),this.refreshOptions(!0)),void b.preventDefault()):c.apply(this,arguments)}}()}),L});
</script>
<link rel="stylesheet" type="text/css" href="SimulationsAnimintRegression/vendor/selectize.css" />
<p></p>
<div id='SimulationsAnimintRegression'></div>
<script>var SimulationsAnimintRegression = new animint("#SimulationsAnimintRegression", "SimulationsAnimintRegression/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-13-train-predict-subsets-regression&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-13-train-predict-subsets-regression/">https://tdhock.github.io/2023-12-13-train-predict-subsets-regression/</a></p>
<h2 id="simulated-classification-problems_1">Simulated classification problems</h2>
<p>The previous section investigated a simulated regression problem, whereas in this section we simulate a binary classification problem.
Assume there is a data set with some rows from one person, some rows
from another,</p>
<pre><code class="language-r">N &lt;- 200
library(data.table)
(full.dt &lt;- data.table(
  label=factor(rep(c(&quot;spam&quot;,&quot;not spam&quot;), l=N)),
  person=rep(1:2, each=0.5*N)
)[, signal := ifelse(label==&quot;not spam&quot;, 0, 3)][])
#&gt;         label person signal
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;
#&gt;   1:     spam      1      3
#&gt;   2: not spam      1      0
#&gt;   3:     spam      1      3
#&gt;   4: not spam      1      0
#&gt;   5:     spam      1      3
#&gt;  ---                       
#&gt; 196: not spam      2      0
#&gt; 197:     spam      2      3
#&gt; 198: not spam      2      0
#&gt; 199:     spam      2      3
#&gt; 200: not spam      2      0
</code></pre>
<p>Above each row has an person ID between 1 and 2.
We can imagine a spam filtering system, that has training data for multiple people (here just two).
Each row in the table above represents a message which has been labeled as spam or not, by one of the two people.
Can we train on one person, and accurately predict on the other person?
To do that we will need some features, which we generate/simulate below:</p>
<pre><code class="language-r">set.seed(1)
n.people &lt;- length(unique(full.dt$person))
for(person.i in 1:n.people){
  use.signal.vec &lt;- list(
    easy=rep(if(person.i==1)TRUE else FALSE, N),
    impossible=full.dt$person==person.i)
  for(task_id in names(use.signal.vec)){
    use.signal &lt;- use.signal.vec[[task_id]]
    full.dt[
    , paste0(&quot;x&quot;,person.i,&quot;_&quot;,task_id) := ifelse(
      use.signal, signal, 0
    )+rnorm(N)][]
  }
}
full.dt
#&gt;         label person signal    x1_easy x1_impossible    x2_easy x2_impossible
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;      &lt;num&gt;         &lt;num&gt;      &lt;num&gt;         &lt;num&gt;
#&gt;   1:     spam      1      3  2.3735462     3.4094018  1.0744410    -0.3410670
#&gt;   2: not spam      1      0  0.1836433     1.6888733  1.8956548     1.5024245
#&gt;   3:     spam      1      3  2.1643714     4.5865884 -0.6029973     0.5283077
#&gt;   4: not spam      1      0  1.5952808    -0.3309078 -0.3908678     0.5421914
#&gt;   5:     spam      1      3  3.3295078     0.7147645 -0.4162220    -0.1366734
#&gt;  ---                                                                         
#&gt; 196: not spam      2      0 -1.0479844    -0.9243128  0.7682782    -1.0293917
#&gt; 197:     spam      2      3  4.4411577     1.5929138 -0.8161606     2.9890743
#&gt; 198: not spam      2      0 -1.0158475     0.0450106 -0.4361069    -1.2249912
#&gt; 199:     spam      2      3  3.4119747    -0.7151284  0.9047050     0.4038886
#&gt; 200: not spam      2      0 -0.3810761     0.8652231 -0.7630863     1.1691226
</code></pre>
<p>In the table above, there are two sets of two features:</p>
<ul>
<li>For easy features, one is correlated with the label (<code>x1_easy</code>), and
one is random noise (<code>x2_easy</code>), so the algorithm just needs to
learn to ignore the noise feature, and concentrate on the signal
feature. That should be possible given data from either person (same
signal in each person).</li>
<li>Each impossible feature is correlated with the label (when feature
number same as person number), or is just noise (when person number
different from feature number). So if the algorithm has access to
the correct person (same as test, say person 2), then it needs to
learn to use the corresponding feature <code>x2_impossible</code>. But if
the algorithm does not have access to that person, then the best it
can do is same as featureless (predict most frequent class label in
train data).</li>
</ul>
<h3 id="static-visualization-of-simulated-data_2">Static visualization of simulated data</h3>
<p>Below we reshape the data to a table which is more suitable for visualization:</p>
<pre><code class="language-r">(scatter.dt &lt;- nc::capture_melt_multiple(
  full.dt,
  column=&quot;x[12]&quot;,
  &quot;_&quot;,
  task_id=&quot;easy|impossible&quot;))
#&gt;         label person signal    task_id         x1         x2
#&gt;        &lt;fctr&gt;  &lt;int&gt;  &lt;num&gt;     &lt;char&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;   1:     spam      1      3       easy  2.3735462  1.0744410
#&gt;   2: not spam      1      0       easy  0.1836433  1.8956548
#&gt;   3:     spam      1      3       easy  2.1643714 -0.6029973
#&gt;   4: not spam      1      0       easy  1.5952808 -0.3908678
#&gt;   5:     spam      1      3       easy  3.3295078 -0.4162220
#&gt;  ---                                                        
#&gt; 396: not spam      2      0 impossible -0.9243128 -1.0293917
#&gt; 397:     spam      2      3 impossible  1.5929138  2.9890743
#&gt; 398: not spam      2      0 impossible  0.0450106 -1.2249912
#&gt; 399:     spam      2      3 impossible -0.7151284  0.4038886
#&gt; 400: not spam      2      0 impossible  0.8652231  1.1691226
</code></pre>
<p>Below we visualize the pattern for each person and feature type:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x1, x2, color=label),
      shape=1,
      data=scatter.dt)+
    facet_grid(
      task_id ~ person,
      labeller=label_both)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-13" /></p>
<p>In the plot above, it is apparent that</p>
<ul>
<li>for easy features (left), the two label classes differ in x1 values
for both people. So it should be possible/easy to train on person 1, and
predict accurately on person 2.</li>
<li>for impossible features (right), the two people have different label
patterns. For person 1, the two label classes differ in x1 values,
whereas for person 2, the two label classes differ in x2 values. So
it should be impossible to train on person 1, and predict accurately
on person 2.</li>
</ul>
<h3 id="benchmark-computing-test-error_2">Benchmark: computing test error</h3>
<p>We use the code below to create a list of classification tasks, for
use in the mlr3 framework.</p>
<pre><code class="language-r">class.task.list &lt;- list()
for(task_id in c(&quot;easy&quot;,&quot;impossible&quot;)){
  feature.names &lt;- grep(task_id, names(full.dt), value=TRUE)
  task.col.names &lt;- c(feature.names, &quot;label&quot;, &quot;person&quot;)
  task.dt &lt;- full.dt[, task.col.names, with=FALSE]
  this.task &lt;- mlr3::TaskClassif$new(
    task_id, task.dt, target=&quot;label&quot;)
  this.task$col_roles$subset &lt;- &quot;person&quot;
  this.task$col_roles$stratum &lt;- c(&quot;person&quot;,&quot;label&quot;)
  this.task$col_roles$feature &lt;- setdiff(names(task.dt), this.task$col_roles$stratum)
  class.task.list[[task_id]] &lt;- this.task
}
class.task.list
#&gt; $easy
#&gt; &lt;TaskClassif:easy&gt; (200 x 3)
#&gt; * Target: label
#&gt; * Properties: twoclass, strata
#&gt; * Features (2):
#&gt;   - dbl (2): x1_easy, x2_easy
#&gt; * Strata: person, label
#&gt; 
#&gt; $impossible
#&gt; &lt;TaskClassif:impossible&gt; (200 x 3)
#&gt; * Target: label
#&gt; * Properties: twoclass, strata
#&gt; * Features (2):
#&gt;   - dbl (2): x1_impossible, x2_impossible
#&gt; * Strata: person, label
</code></pre>
<p>Note in the code above that person is assigned roles subset and
stratum, whereas label is assigned roles target and stratum.  When
adapting the code above to real data, the important part is the
<code>mlr3::TaskClassif</code> line which tells mlr3 what data set to use, and
what columns should be used for target/subset/stratum.</p>
<p>The code below is used to define a K-fold cross-validation experiment,</p>
<pre><code class="language-r">(class_same_other &lt;- mlr3resampling::ResamplingSameOtherCV$new())
#&gt; &lt;ResamplingSameOtherCV&gt; : Same versus Other Cross-Validation
#&gt; * Iterations:
#&gt; * Instantiated: FALSE
#&gt; * Parameters:
#&gt; List of 1
#&gt;  $ folds: int 3
</code></pre>
<p>The code below is used to define the learning algorithms to test,</p>
<pre><code class="language-r">(class.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerClassifRpart$new(),
  mlr3::LearnerClassifFeatureless$new()))
#&gt; [[1]]
#&gt; &lt;LearnerClassifRpart:classif.rpart&gt;: Classification Tree
#&gt; * Model: -
#&gt; * Parameters: xval=0
#&gt; * Packages: mlr3, rpart
#&gt; * Predict Types:  [response], prob
#&gt; * Feature Types: logical, integer, numeric, factor, ordered
#&gt; * Properties: importance, missings, multiclass, selected_features,
#&gt;   twoclass, weights
#&gt; 
#&gt; [[2]]
#&gt; &lt;LearnerClassifFeatureless:classif.featureless&gt;: Featureless Classification Learner
#&gt; * Model: -
#&gt; * Parameters: method=mode
#&gt; * Packages: mlr3
#&gt; * Predict Types:  [response], prob
#&gt; * Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt;   POSIXct
#&gt; * Properties: featureless, importance, missings, multiclass,
#&gt;   selected_features, twoclass
</code></pre>
<p>The code below defines the grid of tasks, learners, and resamplings.</p>
<pre><code class="language-r">(class.bench.grid &lt;- mlr3::benchmark_grid(
  class.task.list,
  class.learner.list,
  class_same_other))
#&gt;          task             learner    resampling
#&gt;        &lt;char&gt;              &lt;char&gt;        &lt;char&gt;
#&gt; 1:       easy       classif.rpart same_other_cv
#&gt; 2:       easy classif.featureless same_other_cv
#&gt; 3: impossible       classif.rpart same_other_cv
#&gt; 4: impossible classif.featureless same_other_cv
</code></pre>
<p>The code below runs the benchmark experiment grid. Note that each
iteration can be parallelized by declaring a future plan.</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(class.bench.result &lt;- mlr3::benchmark(
  class.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 72 rows with 4 resampling runs
#&gt;  nr    task_id          learner_id resampling_id iters warnings errors
#&gt;   1       easy       classif.rpart same_other_cv    18        0      0
#&gt;   2       easy classif.featureless same_other_cv    18        0      0
#&gt;   3 impossible       classif.rpart same_other_cv    18        0      0
#&gt;   4 impossible classif.featureless same_other_cv    18        0      0
</code></pre>
<p>Below we compute scores (test error) for each resampling iteration,
and show the first row of the result.</p>
<pre><code class="language-r">class.bench.score &lt;- mlr3resampling::score(class.bench.result)
class.bench.score[1]
#&gt;    train.subsets test.fold test.subset person iteration                  test
#&gt;           &lt;char&gt;     &lt;int&gt;       &lt;int&gt;  &lt;int&gt;     &lt;int&gt;                &lt;list&gt;
#&gt; 1:           all         1           1      1         1  1, 2, 8,11,12,18,...
#&gt;                    train                                uhash    nr
#&gt;                   &lt;list&gt;                               &lt;char&gt; &lt;int&gt;
#&gt; 1:  3, 4, 5, 6, 9,10,... c89df2a9-3bc9-477d-b981-dbfcafb0504d     1
#&gt;                  task task_id                             learner    learner_id
#&gt;                &lt;list&gt;  &lt;char&gt;                              &lt;list&gt;        &lt;char&gt;
#&gt; 1: &lt;TaskClassif:easy&gt;    easy &lt;LearnerClassifRpart:classif.rpart&gt; classif.rpart
#&gt;                 resampling resampling_id          prediction classif.ce
#&gt;                     &lt;list&gt;        &lt;char&gt;              &lt;list&gt;      &lt;num&gt;
#&gt; 1: &lt;ResamplingSameOtherCV&gt; same_other_cv &lt;PredictionClassif&gt; 0.08823529
#&gt;    algorithm
#&gt;       &lt;char&gt;
#&gt; 1:     rpart
</code></pre>
<p>Finally we plot the test error values below.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      classif.ce, train.subsets, color=algorithm),
      shape=1,
      data=class.bench.score)+
    facet_grid(
      person ~ task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAIAAABHLKd9AAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nOzdeXwTZf4H8O8zM0kmSdscbenF0UJpobRSoFDOchcsICgq4sGpa2FhWVxdxB8KiLqwi4uInOIiu6yugoIoUrkLonKUq1Qq5Sw96Emv3JmZ3x8ZYumdFJI2fN9/8Bqmz/PM95k0n8xM0gkRBAEQQggBUO4uACGEWgoMRIQQEmEgIoSQCAMRIYREjLsLqFdxcbG7S0AiPz+/Gmvw0WkhWJb18vJydxWeo+UGYmlpqbtLQKLagYiPTguhUqkwEO8jPGVGCCERBiJCCIkwEBFCSISBiBBCIgxEAACj0fif//ynKS1/+OGHDRs2NNDg1KlT7733XvU1n3/++VdffdWs+jyOW3Z47ZYPgm0r33777datW6uvP3PmzOLFix/01lEztdx3mV3JbDYfOHDghRdeaP5QMTExnTp1av44ns0tO9w1D41tK8ePH3/QG0IPAgYiAMCqVasKCws/+OCDefPmrV279vjx42azuX///q+88oper1+zZk1mZqZKpZo2bZq9y9atW2/cuLFo0SKapqsP9euvv6akpCxYsOCjjz76+eefNRpN27Ztu3TpAgDJycmTJk0aOnSovfH27dt37tzJMMzQoUOnT58uCELDWz9w4ECPHj1GjBjBcdxzzz23YcMGtVrtqp10P7llh9taPvbYY5s3b66oqKisrBw+fLjFYjlx4kRwcPC7776bkpJy5syZy5cvcxzXp0+fefPm0TS9devWffv2EUISExOnTJmi0+mql9ejR48aawRBSElJiYmJycnJmTt3blFRUc+ePefPn28vuMaD7ordjZoMAxEAYP78+XPnzv3zn/989erVnJycbdu2AcC0adNycnLOnj0rCMKnn356/vz5X375JTQ0FAC+/PLLy5cvv/322zWenHbff//9jRs3tm3bVlFRMXPmTNvzc+nSpd7e3vY2586dO3To0KZNm2iaXrx48ffffx8ZGdnw1ocOHbpr164RI0acOXMmIiKilaYhuGmH2125cuXf//43RVFPPvnkvHnz5syZ8/rrr586dQoA0tLSPv30U5VK9dprr+3ZsycgIODYsWOffPIJAMyePbtr1675+fnVy+vRo8fBgwerr+ndu7dtK6dOnfrX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" alt="plot of chunk unnamed-chunk-20" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>for the easy task, training on same is just as good as all or other
subsets.</li>
<li>for the impossible task, we must train on same subset for minimal
test error; training on all is almost as good, because the pattern
in person 1 is orthogonal to person 2; training on other is just as
bad as featureless, because patterns are different.</li>
<li>in a real data task, training on other will most likely not be quite as bad as in the impossible task above, but also not as good as in the easy task.</li>
</ul>
<h3 id="interactive-visualization-of-data-test-error-and-splits_2">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">inst &lt;- class.bench.score$resampling[[1]]$instance
rect.expand &lt;- 0.2
grid.value.dt &lt;- scatter.dt[
, lapply(.SD, function(x)do.call(seq, c(as.list(range(x)), l=21)))
, .SDcols=c(&quot;x1&quot;,&quot;x2&quot;)]
grid.class.dt &lt;- data.table(
  label=full.dt$label[1],
  do.call(
    CJ, grid.value.dt
  )
)
class.pred.dt.list &lt;- list()
class.point.dt.list &lt;- list()
for(score.i in 1:nrow(class.bench.score)){
  class.bench.row &lt;- class.bench.score[score.i]
  task.dt &lt;- data.table(
    class.bench.row$task[[1]]$data(),
    class.bench.row$resampling[[1]]$instance$id.dt)
  names(task.dt)[2:3] &lt;- c(&quot;x1&quot;,&quot;x2&quot;)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=class.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ][]
  class.point.dt.list[[score.i]] &lt;- data.table(
    class.bench.row[, .(task_id, iteration)],
    i.points)
  if(class.bench.row$algorithm!=&quot;featureless&quot;){
    i.learner &lt;- class.bench.row$learner[[1]]
    i.learner$predict_type &lt;- &quot;prob&quot;
    i.task &lt;- class.bench.row$task[[1]]
    setnames(grid.class.dt, names(i.task$data()))
    grid.class.task &lt;- mlr3::TaskClassif$new(
      &quot;grid&quot;, grid.class.dt, target=&quot;label&quot;)
    pred.grid &lt;- as.data.table(
      i.learner$predict(grid.class.task)
    )[, data.table(grid.class.dt, prob.spam)]
    names(pred.grid)[2:3] &lt;- c(&quot;x1&quot;,&quot;x2&quot;)
    pred.wide &lt;- dcast(pred.grid, x1 ~ x2, value.var=&quot;prob.spam&quot;)
    prob.mat &lt;- as.matrix(pred.wide[,-1])
    contour.list &lt;- contourLines(
      grid.value.dt$x1, grid.value.dt$x2, prob.mat, levels=0.5)
    class.pred.dt.list[[score.i]] &lt;- data.table(
      class.bench.row[, .(
        task_id, iteration, algorithm
      )],
      data.table(contour.i=seq_along(contour.list))[, {
        do.call(data.table, contour.list[[contour.i]])[, .(level, x1=x, x2=y)]
      }, by=contour.i]
    )
  }
}
(class.pred.dt &lt;- rbindlist(class.pred.dt.list))
#&gt;         task_id iteration algorithm contour.i level       x1        x2
#&gt;          &lt;char&gt;     &lt;int&gt;    &lt;char&gt;     &lt;int&gt; &lt;num&gt;    &lt;num&gt;     &lt;num&gt;
#&gt;   1:       easy         1     rpart         1   0.5 1.856156 -3.008049
#&gt;   2:       easy         1     rpart         1   0.5 1.856156 -2.606579
#&gt;   3:       easy         1     rpart         1   0.5 1.856156 -2.205109
#&gt;   4:       easy         1     rpart         1   0.5 1.856156 -1.803639
#&gt;   5:       easy         1     rpart         1   0.5 1.856156 -1.402169
#&gt;  ---                                                                  
#&gt; 766: impossible        18     rpart         1   0.5 3.743510  1.225096
#&gt; 767: impossible        18     rpart         1   0.5 4.158037  1.225096
#&gt; 768: impossible        18     rpart         1   0.5 4.572564  1.225096
#&gt; 769: impossible        18     rpart         1   0.5 4.987091  1.225096
#&gt; 770: impossible        18     rpart         1   0.5 5.401618  1.225096
</code></pre>
<pre><code class="language-r">(class.point.dt &lt;- rbindlist(class.point.dt.list))
#&gt;           task_id iteration set.name row_id    label         x1         x2
#&gt;            &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;   &lt;fctr&gt;      &lt;num&gt;      &lt;num&gt;
#&gt;     1:       easy         1     test      1     spam  2.3735462  1.0744410
#&gt;     2:       easy         1     test      2 not spam  0.1836433  1.8956548
#&gt;     3:       easy         1    train      3     spam  2.1643714 -0.6029973
#&gt;     4:       easy         1    train      4 not spam  1.5952808 -0.3908678
#&gt;     5:       easy         1    train      5     spam  3.3295078 -0.4162220
#&gt;    ---                                                                    
#&gt; 14396: impossible        18    train    196 not spam -0.9243128 -1.0293917
#&gt; 14397: impossible        18    train    197     spam  1.5929138  2.9890743
#&gt; 14398: impossible        18    train    198 not spam  0.0450106 -1.2249912
#&gt; 14399: impossible        18    train    199     spam -0.7151284  0.4038886
#&gt; 14400: impossible        18    train    200 not spam  0.8652231  1.1691226
#&gt;         fold person subset display_row
#&gt;        &lt;int&gt;  &lt;int&gt;  &lt;int&gt;       &lt;int&gt;
#&gt;     1:     1      1      1           1
#&gt;     2:     1      1      1           2
#&gt;     3:     2      1      1          35
#&gt;     4:     2      1      1          36
#&gt;     5:     2      1      1          37
#&gt;    ---                                
#&gt; 14396:     2      2      2         166
#&gt; 14397:     2      2      2         167
#&gt; 14398:     1      2      2         133
#&gt; 14399:     1      2      2         134
#&gt; 14400:     2      2      2         168
</code></pre>
<pre><code class="language-r">
set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
make_person_subset &lt;- function(DT){
  DT[, &quot;person/subset&quot; := person]
}
make_person_subset(class.point.dt)
make_person_subset(class.bench.score)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Train/predict on subsets, classification&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      scale_color_manual(values=c(spam=&quot;black&quot;,&quot;not spam&quot;=&quot;white&quot;))+
      geom_point(aes(
        x1, x2, color=label, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        stroke=2,
        shape=21,
        data=class.point.dt)+
      geom_path(aes(
        x1, x2, 
        subset=paste(algorithm, iteration, contour.i)),
        showSelected=c(&quot;iteration&quot;,&quot;algorithm&quot;),
        color=algo.colors[[&quot;rpart&quot;]],
        data=class.pred.dt)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;)+
      scale_y_continuous(
        breaks=seq(-100, 100, by=2)),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      scale_y_continuous(
        &quot;Classification error on test set&quot;,
        breaks=seq(0, 1, by=0.25))+
      scale_fill_manual(values=algo.colors)+
      scale_x_discrete(
        &quot;People/subsets in train set&quot;)+
      geom_hline(aes(
        yintercept=yint),
        data=data.table(yint=0.5),
        color=&quot;grey50&quot;)+
      geom_point(aes(
        train.subsets, classif.ce, fill=algorithm),
        shape=1,
        size=5,
        stroke=2,
        color=&quot;black&quot;,
        color_off=NA,
        clickSelects=&quot;iteration&quot;,
        data=class.bench.score)+
      facet_grid(
        task_id ~ `person/subset`,
        labeller=label_both),
    diagram=ggplot()+
      ggtitle(&quot;Select train/test split&quot;)+
      theme_bw()+
      theme_animint(height=300)+
      facet_grid(
        . ~ train.subsets,
        scales=&quot;free&quot;,
        space=&quot;free&quot;)+
      scale_size_manual(values=c(subset=3, fold=1))+
      scale_color_manual(values=c(subset=&quot;orange&quot;, fold=&quot;grey50&quot;))+
      geom_rect(aes(
        xmin=-Inf, xmax=Inf,
        color=rows,
        size=rows,
        ymin=display_row, ymax=display_end),
        fill=NA,
        data=inst$viz.rect.dt)+
      scale_fill_manual(values=set.colors)+
      geom_rect(aes(
        xmin=iteration-rect.expand, ymin=display_row,
        xmax=iteration+rect.expand, ymax=display_end,
        fill=set.name),
        clickSelects=&quot;iteration&quot;,
        data=inst$viz.set.dt)+
      geom_text(aes(
        ifelse(rows==&quot;subset&quot;, Inf, -Inf),
        (display_row+display_end)/2,
        hjust=ifelse(rows==&quot;subset&quot;, 1, 0),
        label=paste0(rows, &quot;=&quot;, ifelse(rows==&quot;subset&quot;, subset, fold))),
        data=data.table(train.name=&quot;same&quot;, inst$viz.rect.dt))+
      scale_x_continuous(
        &quot;Split number / cross-validation iteration&quot;)+
      scale_y_continuous(
        &quot;Row number&quot;),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/ResamplingSameOtherCV.Rmd&quot;)
  viz
}
</code></pre>
<p></p>
<div id='SimulationsAnimintClassification'></div>
<script>var SimulationsAnimintClassification = new animint("#SimulationsAnimintClassification", "SimulationsAnimintClassification/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-13-train-predict-subsets-classification&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-13-train-predict-subsets-classification/">https://tdhock.github.io/2023-12-13-train-predict-subsets-classification/</a></p>
<h2 id="conclusion_1">Conclusion</h2>
<p>In this section we have shown how to use mlr3resampling for comparing
test error of models trained on same/all/other subsets.</p>
<h1 id="variable-size-train-resampler">Variable size train resampler</h1>
<p>The goal of this section is to explain how to
<code>ResamplingVariableSizeTrainCV</code>, which can be used to determine how
many train data are necessary to provide accurate predictions on a
given test set.</p>
<h2 id="simulated-regression-problems_2">Simulated regression problems</h2>
<p>The code below creates data for simulated regression problems. First
we define a vector of input values,</p>
<pre><code class="language-r">N &lt;- 300
abs.x &lt;- 10
set.seed(1)
x.vec &lt;- runif(N, -abs.x, abs.x)
str(x.vec)
#&gt;  num [1:300] -4.69 -2.56 1.46 8.16 -5.97 ...
</code></pre>
<p>Below we define a list of two true regression functions (tasks in mlr3
terminology) for our simulated data,</p>
<pre><code class="language-r">reg.pattern.list &lt;- list(
  sin=sin,
  constant=function(x)0)
</code></pre>
<p>The constant function represents a regression problem which can be
solved by always predicting the mean value of outputs (featureless is
the best possible learning algorithm). The sin function will be used
to generate data with a non-linear pattern that will need to be
learned. Below we use a for loop over these two functions/tasks, to
simulate the data which will be used as input to the learning
algorithms:</p>
<pre><code class="language-r">library(data.table)
reg.task.list &lt;- list()
reg.data.list &lt;- list()
for(task_id in names(reg.pattern.list)){
  f &lt;- reg.pattern.list[[task_id]]
  task.dt &lt;- data.table(
    x=x.vec,
    y = f(x.vec)+rnorm(N,sd=0.5))
  reg.data.list[[task_id]] &lt;- data.table(task_id, task.dt)
  reg.task.list[[task_id]] &lt;- mlr3::TaskRegr$new(
    task_id, task.dt, target=&quot;y&quot;
  )
}
(reg.data &lt;- rbindlist(reg.data.list))
#&gt;       task_id         x          y
#&gt;        &lt;char&gt;     &lt;num&gt;      &lt;num&gt;
#&gt;   1:      sin -4.689827  1.2248390
#&gt;   2:      sin -2.557522 -0.5607042
#&gt;   3:      sin  1.457067  0.8345056
#&gt;   4:      sin  8.164156  0.4875994
#&gt;   5:      sin -5.966361 -0.4321800
#&gt;  ---                              
#&gt; 596: constant  3.628850 -0.6728968
#&gt; 597: constant -8.016618  0.5168327
#&gt; 598: constant -7.621949 -0.4058882
#&gt; 599: constant -8.991207  0.9008627
#&gt; 600: constant  8.585078  0.8857710
</code></pre>
<p>In the table above, the input is x, and the output is y. Below we
visualize these data, with one task in each facet/panel:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x, y),
      data=reg.data)+
    facet_grid(task_id ~ ., labeller=label_both)
}
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-24" /></p>
<p>In the plot above we can see two different simulated data sets
(constant and sin).  Note that the code above used the <code>animint2</code>
package, which provides interactive extensions to the static graphics
of the <code>ggplot2</code> package (see below section Interactive data viz).</p>
<h3 id="visualizing-instance-table">Visualizing instance table</h3>
<p>In the code below, we define a K-fold cross-validation experiment,
with K=3 folds.</p>
<pre><code class="language-r">reg_size_cv &lt;- mlr3resampling::ResamplingVariableSizeTrainCV$new()
reg_size_cv$param_set$values$train_sizes &lt;- 6
reg_size_cv
#&gt; &lt;ResamplingVariableSizeTrainCV&gt; : Cross-Validation with variable size train sets
#&gt; * Iterations:
#&gt; * Instantiated: FALSE
#&gt; * Parameters:
#&gt; List of 4
#&gt;  $ folds         : int 3
#&gt;  $ min_train_data: int 10
#&gt;  $ random_seeds  : int 3
#&gt;  $ train_sizes   : int 6
</code></pre>
<p>In the output above we can see the parameters of the resampling
object, all of which should be integer scalars:</p>
<ul>
<li><code>folds</code> is the number of cross-validation folds.</li>
<li><code>min_train_data</code> is the minimum number of train data to consider.</li>
<li><code>random_seeds</code> is the number of random seeds, each of which
determines a different random ordering of the train data. The random
ordering determines which data are included in small train set
sizes.</li>
<li><code>train_sizes</code> is the number of train set sizes, evenly spaced on a
log scale, from <code>min_train_data</code> to the max number of train data
(determined by <code>folds</code>).</li>
</ul>
<p>Below we instantiate the resampling on one of the tasks:</p>
<pre><code class="language-r">reg_size_cv$instantiate(reg.task.list[[&quot;sin&quot;]])
reg_size_cv$instance
#&gt; $iteration.dt
#&gt;     test.fold  seed small_stratum_size train_size_i train_size
#&gt;         &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt;  1:         1     1                 10            1         10
#&gt;  2:         1     1                 18            2         18
#&gt;  3:         1     1                 33            3         33
#&gt;  4:         1     1                 60            4         60
#&gt;  5:         1     1                110            5        110
#&gt;  6:         1     1                200            6        200
#&gt;  7:         1     2                 10            1         10
#&gt;  8:         1     2                 18            2         18
#&gt;  9:         1     2                 33            3         33
#&gt; 10:         1     2                 60            4         60
#&gt; 11:         1     2                110            5        110
#&gt; 12:         1     2                200            6        200
#&gt; 13:         1     3                 10            1         10
#&gt; 14:         1     3                 18            2         18
#&gt; 15:         1     3                 33            3         33
#&gt; 16:         1     3                 60            4         60
#&gt; 17:         1     3                110            5        110
#&gt; 18:         1     3                200            6        200
#&gt; 19:         2     1                 10            1         10
#&gt; 20:         2     1                 18            2         18
#&gt; 21:         2     1                 33            3         33
#&gt; 22:         2     1                 60            4         60
#&gt; 23:         2     1                110            5        110
#&gt; 24:         2     1                200            6        200
#&gt; 25:         2     2                 10            1         10
#&gt; 26:         2     2                 18            2         18
#&gt; 27:         2     2                 33            3         33
#&gt; 28:         2     2                 60            4         60
#&gt; 29:         2     2                110            5        110
#&gt; 30:         2     2                200            6        200
#&gt; 31:         2     3                 10            1         10
#&gt; 32:         2     3                 18            2         18
#&gt; 33:         2     3                 33            3         33
#&gt; 34:         2     3                 60            4         60
#&gt; 35:         2     3                110            5        110
#&gt; 36:         2     3                200            6        200
#&gt; 37:         3     1                 10            1         10
#&gt; 38:         3     1                 18            2         18
#&gt; 39:         3     1                 33            3         33
#&gt; 40:         3     1                 60            4         60
#&gt; 41:         3     1                110            5        110
#&gt; 42:         3     1                200            6        200
#&gt; 43:         3     2                 10            1         10
#&gt; 44:         3     2                 18            2         18
#&gt; 45:         3     2                 33            3         33
#&gt; 46:         3     2                 60            4         60
#&gt; 47:         3     2                110            5        110
#&gt; 48:         3     2                200            6        200
#&gt; 49:         3     3                 10            1         10
#&gt; 50:         3     3                 18            2         18
#&gt; 51:         3     3                 33            3         33
#&gt; 52:         3     3                 60            4         60
#&gt; 53:         3     3                110            5        110
#&gt; 54:         3     3                200            6        200
#&gt;     test.fold  seed small_stratum_size train_size_i train_size
#&gt;                           train                  test iteration train_min_size
#&gt;                          &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt;  1: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         1             10
#&gt;  2: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         2             18
#&gt;  3: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         3             33
#&gt;  4: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         4             60
#&gt;  5: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         5            110
#&gt;  6: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         6            200
#&gt;  7: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         7             10
#&gt;  8: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         8             18
#&gt;  9: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...         9             33
#&gt; 10: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        10             60
#&gt; 11: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        11            110
#&gt; 12: 260,291, 16,164,109, 45,...  1, 7,11,13,15,19,...        12            200
#&gt; 13:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        13             10
#&gt; 14:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        14             18
#&gt; 15:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        15             33
#&gt; 16:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        16             60
#&gt; 17:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        17            110
#&gt; 18:  14,253,115,102,293, 18,...  1, 7,11,13,15,19,...        18            200
#&gt; 19: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        19             10
#&gt; 20: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        20             18
#&gt; 21: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        21             33
#&gt; 22: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        22             60
#&gt; 23: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        23            110
#&gt; 24: 203,197, 81,171,130, 43,...  4, 6, 9,12,14,16,...        24            200
#&gt; 25: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        25             10
#&gt; 26: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        26             18
#&gt; 27: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        27             33
#&gt; 28: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        28             60
#&gt; 29: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        29            110
#&gt; 30: 251,291, 19,164,109, 55,...  4, 6, 9,12,14,16,...        30            200
#&gt; 31:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        31             10
#&gt; 32:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        32             18
#&gt; 33:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        33             33
#&gt; 34:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        34             60
#&gt; 35:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        35            110
#&gt; 36:  15,253,115,110,293, 18,...  4, 6, 9,12,14,16,...        36            200
#&gt; 37: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        37             10
#&gt; 38: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        38             18
#&gt; 39: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        39             33
#&gt; 40: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        40             60
#&gt; 41: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        41            110
#&gt; 42: 203,211, 82,194,130, 43,...  2, 3, 5, 8,10,17,...        42            200
#&gt; 43: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        43             10
#&gt; 44: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        44             18
#&gt; 45: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        45             33
#&gt; 46: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        46             60
#&gt; 47: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        47            110
#&gt; 48: 251,295, 19,189,102, 55,...  2, 3, 5, 8,10,17,...        48            200
#&gt; 49:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        49             10
#&gt; 50:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        50             18
#&gt; 51:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        51             33
#&gt; 52:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        52             60
#&gt; 53:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        53            110
#&gt; 54:  15,263,135,110,296, 25,...  2, 3, 5, 8,10,17,...        54            200
#&gt;                           train                  test iteration train_min_size
#&gt; 
#&gt; $id.dt
#&gt;      row_id  fold
#&gt;       &lt;int&gt; &lt;int&gt;
#&gt;   1:      1     1
#&gt;   2:      2     3
#&gt;   3:      3     3
#&gt;   4:      4     2
#&gt;   5:      5     3
#&gt;  ---             
#&gt; 296:    296     2
#&gt; 297:    297     1
#&gt; 298:    298     1
#&gt; 299:    299     3
#&gt; 300:    300     2
</code></pre>
<p>Above we see the instance, which need not be examined by the user, but
for informational purposes, it contains the following data:</p>
<ul>
<li><code>iteration.dt</code> has one row for each train/test split,</li>
<li><code>id.dt</code> has one row for each data point.</li>
</ul>
<h3 id="benchmark-computing-test-error_3">Benchmark: computing test error</h3>
<p>In the code below, we define two learners to compare,</p>
<pre><code class="language-r">(reg.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerRegrRpart$new(),
  mlr3::LearnerRegrFeatureless$new()))
#&gt; [[1]]
#&gt; &lt;LearnerRegrRpart:regr.rpart&gt;: Regression Tree
#&gt; * Model: -
#&gt; * Parameters: xval=0
#&gt; * Packages: mlr3, rpart
#&gt; * Predict Types:  [response]
#&gt; * Feature Types: logical, integer, numeric, factor, ordered
#&gt; * Properties: importance, missings, selected_features, weights
#&gt; 
#&gt; [[2]]
#&gt; &lt;LearnerRegrFeatureless:regr.featureless&gt;: Featureless Regression Learner
#&gt; * Model: -
#&gt; * Parameters: robust=FALSE
#&gt; * Packages: mlr3, stats
#&gt; * Predict Types:  [response], se
#&gt; * Feature Types: logical, integer, numeric, character, factor, ordered,
#&gt;   POSIXct
#&gt; * Properties: featureless, importance, missings, selected_features
</code></pre>
<p>The code above defines</p>
<ul>
<li><code>regr.rpart</code>: Regression Tree learning algorithm, which should be
able to learn the non-linear pattern in the sin data (if there are
enough data in the train set).</li>
<li><code>regr.featureless</code>: Featureless Regression learning algorithm, which
should be optimal for the constant data, and can be used as a
baseline in the sin data. When the rpart learner gets smaller
prediction error rates than featureless, then we know that it has
learned some non-trivial relationship between inputs and outputs.</li>
</ul>
<p>In the code below, we define the benchmark grid, which is all
combinations of tasks (constant and sin), learners (rpart and
featureless), and the one resampling method.</p>
<pre><code class="language-r">(reg.bench.grid &lt;- mlr3::benchmark_grid(
  reg.task.list,
  reg.learner.list,
  reg_size_cv))
#&gt;        task          learner             resampling
#&gt;      &lt;char&gt;           &lt;char&gt;                 &lt;char&gt;
#&gt; 1:      sin       regr.rpart variable_size_train_cv
#&gt; 2:      sin regr.featureless variable_size_train_cv
#&gt; 3: constant       regr.rpart variable_size_train_cv
#&gt; 4: constant regr.featureless variable_size_train_cv
</code></pre>
<p>In the code below, we execute the benchmark experiment (optionally in parallel
using the multisession future plan).</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(reg.bench.result &lt;- mlr3::benchmark(
  reg.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 216 rows with 4 resampling runs
#&gt;  nr  task_id       learner_id          resampling_id iters warnings errors
#&gt;   1      sin       regr.rpart variable_size_train_cv    54        0      0
#&gt;   2      sin regr.featureless variable_size_train_cv    54        0      0
#&gt;   3 constant       regr.rpart variable_size_train_cv    54        0      0
#&gt;   4 constant regr.featureless variable_size_train_cv    54        0      0
</code></pre>
<p>The code below computes the test error for each split, and visualizes
the information stored in the first row of the result:</p>
<pre><code class="language-r">reg.bench.score &lt;- mlr3resampling::score(reg.bench.result)
reg.bench.score[1]
#&gt;    test.fold  seed small_stratum_size train_size_i train_size
#&gt;        &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt; 1:         1     1                 10            1         10
#&gt;                          train                  test iteration train_min_size
#&gt;                         &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt; 1: 216,197, 81,171,143, 36,...  1, 7,11,13,15,19,...         1             10
#&gt;                                   uhash    nr           task task_id
#&gt;                                  &lt;char&gt; &lt;int&gt;         &lt;list&gt;  &lt;char&gt;
#&gt; 1: e3dabfcd-49c7-428b-bb5d-ec6df8f744fa     1 &lt;TaskRegr:sin&gt;     sin
#&gt;                          learner learner_id                      resampling
#&gt;                           &lt;list&gt;     &lt;char&gt;                          &lt;list&gt;
#&gt; 1: &lt;LearnerRegrRpart:regr.rpart&gt; regr.rpart &lt;ResamplingVariableSizeTrainCV&gt;
#&gt;             resampling_id       prediction  regr.mse algorithm
#&gt;                    &lt;char&gt;           &lt;list&gt;     &lt;num&gt;    &lt;char&gt;
#&gt; 1: variable_size_train_cv &lt;PredictionRegr&gt; 0.8008255     rpart
</code></pre>
<p>The output above contains all of the results related to a particular
train/test split. In particular for our purposes, the interesting
columns are:</p>
<ul>
<li><code>test.fold</code> is the cross-validation fold ID.</li>
<li><code>seed</code> is the random seed used to determine the train set order.</li>
<li><code>train_size</code> is the number of data in the train set.</li>
<li><code>train</code> and <code>test</code> are vectors of row numbers assigned to each set.</li>
<li><code>iteration</code> is an ID for the train/test split, for a particular
learning algorithm and task. It is the row number of <code>iteration.dt</code>
(see instance above), which has one row for each unique combination
of <code>test.fold</code>, <code>seed</code>, and <code>train_size</code>.</li>
<li><code>learner</code> is the mlr3 learner object, which can be used to compute
predictions on new data (including a grid of inputs, to show
predictions in the visualization below).</li>
<li><code>regr.mse</code> is the mean squared error on the test set.</li>
<li><code>algorithm</code> is the name of the learning algorithm (same as
<code>learner_id</code> but without <code>regr.</code> prefix).</li>
</ul>
<p>The code below visualizes the resulting test accuracy numbers.</p>
<pre><code class="language-r">train_size_vec &lt;- unique(reg.bench.score$train_size)
if(require(animint2)){
  ggplot()+
    scale_x_log10(
      breaks=train_size_vec)+
    scale_y_log10()+
    geom_line(aes(
      train_size, regr.mse,
      group=paste(algorithm, seed),
      color=algorithm),
      shape=1,
      data=reg.bench.score)+
    geom_point(aes(
      train_size, regr.mse, color=algorithm),
      shape=1,
      data=reg.bench.score)+
    facet_grid(
      test.fold~task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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qp4pnq+/oCIQCNT9rjZ6VEMiuRaSJGtXqrTQFMdxoY8lGeDTtKSJJwoUWb416g/1oeIBNnTtdNvR4wN//W1JcsJtBcX/LS6ZaLPWM8XzfCQXWH/pXmOQJMmybCTOK80u3YMm+r3eT5dBCzHGEA0uQC7m2M8yUp4rr1xaVVPvLTNJvpuaNM1unZRbONVue6y4vEINc396fqFpmqcOTz31lMfjCXuLahDCEESDC5NuHLsiLfmZssoVNZ56b4WGFN9OSXy7qjqBpuYVlbaLh23EnDlz5syZc98ptm3bdt99961YsaK17K9fv37y5Mmne9TatWtvueUWv9+/aNEiAPj555/PwMhZwBhRNrhg6c5zH6UlTc0rIgAm2es/Fw8zC+sz027JL97o939a45nSoMF5SmZm5qOPPlr78uWXX37ggQfa0R8AUBRl0KBB3bt3F0Xxo48+evzxx9vXn2Yw7hANLmT6CPwnacmPlpR/7m4kU0MyQ6/JSu0nCHMLS7f5gw0bnI88+uijR48eXbZs2Xvvvbdv374WqiHG+IEHHsjIyEhISLjzzjvrDiUvWLCgQ4cOgwYNGjdu3Nq1awHgqaee6tChQ8eOHf/2t78BwKZNm2bOnDlp0qRXXnll27ZtjzzyyJw5c/Lz8++55x4AqKmpufHGG7t27TplyhRd13/++edhw4Z17949OTn54Ycfvv/++zt16jRq1Kiw48utS3hBfPfdd++44w6/379z586z4JCBQevSV+A+Skt6pLjsW4+v4bssQp+lJ/cUuEm5BV831uC847PPPnv++ecJgvj+++///e9/r1y5siXW9u/fn52dnZ2dnZ+fv2nTpqNHj4b2r127dsOGDYcPH/7www83bdoEAN9+++3nn3++f//+ffv2rVy5MiSRq1evfumll/7yl7+EjnrjjTdSU1Nff/11ANiwYcOzzz578ODBgoKCH374AQB27969du3aPXv2vPLKK926dTty5AhBEN99911L/D9dwgjiE088sWLFih9//BEhNG/evIULF54dtwwMWpH+Av9OSsI9RSVrvY1L3qdpyRaSmFtU8nRZpY5Bw1jWz9cUEJ9//vmrr756ww03JCQkvPjii6tWrWqJtR49erz++usff/zx448/XlxcXDs58/3330+YMIGiqPT09CuuuAIANmzYMHnyZEEQBEGYMGHChg0bAKBv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167NtNmzZ8+yZcsafatd0kCEGUOMioo6x7NTGBi0Ipkss08Un4uLOSBKz5RVrstMs5LEvNjop8sq1mSm1Y0l6c5zX3fpMP5QNgZ0R7S9SYtnnXqpE6qqqnbu3Nm7d++6My2nC8rNqb0fRDVVqKRI6z8IAMgtmxBvgtq10jSNU9Jqj3r//fd37949ZsyY5557ThTFxMTEt99+u7Kycvr06TzPx8XFvfXWW//5z3+ys7MLCwtHjx49bty4p556auTIkQcOHPjll19UVX3llVemT59ee2zIrNvtrrszOzv78ccfVxRlypQpvXr1qt2+6aabzuBKwwii0+ns0qXL4MGDa2fxP//88zM4jYHBeQGN0KtJ8e+6quJpykKgT2rcD8dGz3TY33VVf+3xXf3HIMTuAr86M3XiiQIN8OxoR3v5XI96wcJ///vfH3nkkSeffLIlNqnN6/GpbClIkkBVyR/WAgDyeamfNuBT6RfBYlWn/B7cc+uttyYnJ69fv37atGlTpkx5/vnnP/jgg759+z799NP9+/efPHlyXl7erFmzdu7c2TBGkiTJd95555lnnql7bOit1157re7O4uLiG264YdKkSatXr165cmXt9hleafNvh0pkGRj8eUii6edSkiiK+q2q+spjuRdx7Hir+bG4mKdKy0eZTQzxh5DjTizzeUbKxNyCgK7PizlXEhxs37593759GOOePXs+8sgjANBCQVSm31G7jSSJWvGhNnAo0jRy+0/KlOnQbA7aY8eO7d279/vvvweAiy++2GKxPPvss4IgHD16VFXrZ1erjXkcNGhQw2NDeX3q7Rw9evTChQvffPPNO+64Y9asWbXbZ3alYQRx4MCBtduaptXL2QUAmzdv/uSTTzDGkydPHjFiRN237rzzztpURYsWLerSpcuZuWhg0C6k0NSSlITbCko6MCnX2Sxvu6qXVtfc3uBOsCPLfJGeMiG3QMPwcGz7a+IHH3zw008/DR48GADeeuutw4cPT58+vRXtY5ZVrruB3L8HCEKdeGPzaggAnTt3TklJuemmmz788MNOnTotXrx4zpw5gwcPnjBhwkmDGFMUFUq7vXPnzquuugpOZcyud2xIEOvt/OmnnxYtWuRwOPr370+SZO32maWcOI304rm5uR06dKibF8/tdi9duvTFF18kCGLevHk9e/aMioqqvUhZlltY4MbA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" alt="plot of chunk unnamed-chunk-31" /></p>
<p>Above we plot the test error for each fold and train set size.
There is a different panel for each task and test fold.
Each line represents a random seed (ordering of data in train set),
and each dot represents a specific train set size.
So the plot above shows that some variation in test error, for a given test fold,
is due to the random ordering of the train data.</p>
<p>Below we summarize each train set size, by taking the mean and standard deviation over each random seed.</p>
<pre><code class="language-r">reg.mean.dt &lt;- dcast(
  reg.bench.score,
  task_id + train_size + test.fold + algorithm ~ .,
  list(mean, sd),
  value.var=&quot;regr.mse&quot;)
if(require(animint2)){
  ggplot()+
    scale_x_log10(
      breaks=train_size_vec)+
    scale_y_log10()+
    geom_ribbon(aes(
      train_size,
      ymin=regr.mse_mean-regr.mse_sd,
      ymax=regr.mse_mean+regr.mse_sd,
      fill=algorithm),
      alpha=0.5,
      data=reg.mean.dt)+
    geom_line(aes(
      train_size, regr.mse_mean, color=algorithm),
      shape=1,
      data=reg.mean.dt)+
    facet_grid(
      test.fold~task_id,
      labeller=label_both,
      scales=&quot;free&quot;)
}
</code></pre>
<p><img src="data:image/png;base64,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9dZ6Wzt27FhRUVFRUREhpFevXidPnlT2b968+Ztvvjlx4sS5c+d69er1xz/+8Ysvvti4ceOxY8cAAL/73e8GDhzI8/ymTZsOHjzYoUOHbdu2AQDefPPNY8eO/e1vf9u9e/c333xTVFTUoUOHwYMHf/3114IgHDp06MSJEwzD5OTkrFy58rXXXhs/fvyWLVtuvvnmuNwZLai0ED0ej9Pp7Ny5c3Z29vHjxz/44IPGcYtCiS8R24kcgpMs5p+83gL3b2MOyd5I3Lhx4xtvvHHbbbdlZ2evWLHi008/jcVa7969//a3v3300UeLFi26cOFCYHBm69atEydOZBimQ4cO119/PQDgm2++mTx5sl6v1+v1EydO/OabbwAA/fv3r21qynXXXdexY0cIYV5enjItadiwYdnZ2RkZGVlZWVOnToUQ9urVS3V6WXxREcQJEya8+eabx4NoHLcolLgTURONGN1qMe91un7w/PZq9sKFS43oV5wRRTGwKkGZ7x2LtW+//famm27yer233357v36/5RHz+/2BOeGVlZXKRmAPxliZAGsymWqz3KpVq5A9GAcltuY4kAhUBPHUqVNffPHF/wTROG5RKA3B/Exr+LqUdAb/3mL+yuE87RMDO5edS9Zl+2PGjHnyySc9Hk9JScnixYvz8/NjsbZ9+/bx48fff//9giAcOXIksN5hxIgR//rXvyRJOn36dEFBAQAgPz9//fr1Ho/H5XKtX79++PDhEQ1Gn3yecFQEccyYMW+//XZVVZX3Co3jFoXScIQ3FduwzI0m4yZbVUnQhO0kfXe+5557Zs+eDQC45pprhg0bds8998Ribfr06ceOHevTp8/TTz89ffr0uXPnKvtvvvnmQYMG9ejRY86cOcOGDbNYLOPHj58wYULv3r1zc3NvvfXWcePGhVtLSUkxm8133313LC41KCpL95588snXXnstKysrsOfs2bNxOTFduldvU3TpXkSCl+5pMRWud0fcnj0u950plnRehxBSvIoyEadpLt0rLi7+/PPP77777l9//fX7778fOXJkxJXUMS7d279//759+x599FGPx5Obm7tr16709PR6W2s6qLQQP/roo/Pnz58NonHcolAamnCl6yPwVysTtuUkXsSydOlSQojNZluwYEFhYeEbb7zREGfp1avXsWPH8vPzR4wY8fTTTzcPNQSq027S0tKa+Ds/hVJvwqfjDDPqnVXy+vKKOzJ+k8vkmrBdUlIyc+bMrVu3jhgx4sEHH5w5c2ZDnEWv17/zzjsNYTmxqAii1Wrt0aPH0KFDAwNANMkUpTkRroljjMZP7VX/KbeNNQq1HdWUycnJKSsr++677yZMmHD06FGLxZJoj5IJFUFUFh6GcOTIkT59+jSMPxRKYxOiiRiCP6Sl/KOk/HuMrhGqIycmUSPx5ptvnjlzZq9evXJzc//+9783UAuxuaIiiIMHDw7f+c9//pMKIqU5EaKJPEJ/sKauuVyaxTKZTPW7UbJo4rBhw/Ly8iCEVVVVd9xxxyuvvNK5c2eO4+oXiECWZe+X/67TIfy4CckbtjamSZsUSrMhRBNbc+xgg36TrWpGqoVDyRT9Yfbs2U6nM9DHVVJS8uijj44aNWr69On1Mxh9IkozgwoihVJNiCb2E/jzPnGzw3Gz+bflFk1fE5tgtJskQmXaDYXSoggRu7Fm40VROuapMU2yiU/EmTNnTnCbjqphnaCCSKHUYH6mdWHr6mW2OggnWIzfOJwl/hqTz5qyJo4bN+7ixQhptihaoIJIoUSjFcMM0QubbHafXKMrrclq4oYNG4KXliUQu90+dOjQH374IUqZ8vLy06dPazT497//fcOGDfFwrVbUBfG99967//77nU6nsoQbAPDQQw81qE8USsIJTvGcpxcyGOZLR+jawYj5ThOOXq8XRdFzheXLlycqocr3338/fPjwq6++OkqZw4cPf/zxxxE/SsiSEJVBlWeeeWb//v2nTp1SkkwNHz58yZIlnTp1ahznKJQEEjzGMtZsXF1uO+r29BZqTF5pgmMsIaETysvLCwoK8vLygkda6gqsrAAaxpoJxsD82zzwVatWHTp0aNy4cX/5y188Hk/r1q3feeed0tLSGTNmCIKQlZX19ttv/+Mf/ygqKjp37tzYsWNvvPHGJUuWjBo16vjx4wcOHPD7/a+99tqMGTMCxypmbTZb8M6ioqJFixaJojhlypS+ffsGtu+88856XClNMkWhqKOD8GaLcbvTFdKZCJreu/PamowcOXLdunVutzsWm+j0r/DXX1T/obM1Xn5nzpw5YcKEbdu23XHHHZs3b+7evfsHH3xQUlKydOnSzz77rKKi4vTp0/fcc8+kSZO6dOkSckaM8apVq1auXBl8rPJRyM7169ffdtttn376qSAIwdv1u9JYk0zt3Llz7dq1hJDJkyePHDky+KNZs2YFInMsW7asR48e9XORQkkUwY3EVgxzvV6/yWafkZoSmJmo0NTaifv27Tt69CghJDc3d/78+QCAZ599NhaDUu++9T72559/PnLkyNatWwEAPXv2NJlML7zwgl6vP3nypD8sO3YgONOQIUPCj1Xi+oTsHDt27OLFi996663777//nnvuCWzXz1sVQVSSTJWXl7/88surVq0KSTJls9lWr169YsUKhNDcuXNzc3PT0tKUjwghPp9v/fr19XOLQmmC9NXzZ0XxS4dzgtkY8lHT0cQPPvhg165dQ4cOBQC8/fbbJ06cmDFjRgL96d69e9u2be+88841a9Z069bt9ddfnz179tChQydOnKgUIIQwDKOE3S4oKBg9ejS4EjE75FhFEEN27tq1a9myZampqQMHDsQYB7bvuOOOenir8so8b968F1988Y477hBF8f333w8RxIMHD+bm5ipBHwcMGLB///7AR6Wlpc0mIhClJRM+M7FY9B9xRximaCLvzlu3bl25cuX06dOnT5++cuVKJR9eAnnwwQfXr18/adKkvXv3du/e/Q9/+MPy5ctvvfVWJV5OmzZtNm7c2KNHj3fffXfw4MEhgSNDjo24s127dnfdddfMmTP/8Ic/BG/Xz1uVALFff/31l19++dJLL9144427du169913b7vttsCnn3zyiSzLU6ZMAQB8+umnHo8noMrHjx9/9dVXs7Ozz5w5M2jQoPvvvx8hBAB4++23//vf/yKEFi9eHHwihBDGOPB6XhsMw4Q3s0NgWVaSpOiBUTWawhhDCFWLNbIpCCHLsqoRcJW8FtHrFyHEMEy4KZ1OF/xnSADX2o4KQWNlybKsOp6o8Q4jhOLyCIVXVnBGgWKf+OHlsmkZaa15PvwxCx6eBgBACDmOU42Aq6Wyaqv3kGkr06dPf/fdd5Ua9Hg8991335o1a8KtaQwQK8uy54tNqsWCEcbf0mzXMi9evHjp0qXbtm3T6/U//PDD9OnTgwVRluXgKw9+OEwm08SJE8eNG+dwOJYtW7Z582YlpHiPHj2sVmv4g8swjJanWeMTL0mS6kOvxZTGYlrKQAghhHExhRBiWVaL836/P/p3DGMc/jsUnOtHIbyAll8vLdeCMfb7/fGqrHBX620q5AKDJduK0fUmw4ay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hORqBaNMfmkHDhzYv3//DTfcYPw4ffr0m2++OXFB883DjZWBztpYyDx8UgUhhFp1oUNmhBDqXBiICCHUCgMRIYRaYSD2WH6/f+XKlWlne++99+bOnZtB/YwXRKjLwosqPZbb7Z48efLBgwejUyKRSGKX936/3+v1lpSUdLR+xgsi1GXhHmKPtWTJktra2jvuuGPHjh3z58+/7rrrnn76ac75nXfeOXTo0JKSksWLF3POP/roo4qKig8++ODHP/7x1KlThw8fPnv27KRPPni93nnz5l1wwQVTpkzZunWrseC6detKS0tLS0uHDRtmPEv3u9/9zni9YsWKs77SCGUFA7HHWrt27aBBg5599lkA2LBhw5NPPnn33Xfv37+/pqampqamtrZ2x44dhw4dis7/7rvv/vd///eXX3558uTJrVu3JhZ86aWXOOeff/75b37zm40bNxoTb7zxxk8++aSqqmrIkCGPPPLItm3bXnnllerq6qqqqt27d7/44otnZ2URygkMxF6hrKxsyJAhAPAv//Ivzz777Lp16+6///66ujpFUaLzTJw4cejQoZTS0tLS6GNhsX7wgx9s3br1nnvu0TTtsccei32roqJi7NixM2bM2LZtW2Nj48yZM6+99tqvv/56165dZ3jNEMolDMReITp25f/93/9dc801oVBo9uzZ48ePj50n7dMOo0eP/uSTTy666KK1a9deffXV0emvvvpqdXX1qlWrAMBmsy1ZsmTTpk2bNm36+OOPn3766VyvCkJnEAZiT5Y4aO/27dt/+MMfLlq0SJblffv2me8xEABWrFjxzDPP3HTTTU8//fTf//5343LcZ5999uCDD7766qvGYMeXX375n/70J4/HoyjKVVddFXtJB6GuDwOxxzJ6D50/f37sxLlz5+7fv3/MmDEPPPDA3Llz77rrLvMFFy5cuHnz5sGDB8+ZM+cPf/iD0f3UypUrW1parrnmmrKysrKystLS0kWLFo0fP37EiBHl5eVxO6EIdXF42w1CCLXqQr3doK7jyJEjzz33XNzEm266CccFRj0b7iEihFArPIeIEEKtMBARQqgVBiJCCLXCQEQIoVYYiAgh1Or/A92TudFaU0v0AAAAAElFTkSuQmCC" alt="plot of chunk unnamed-chunk-32" /></p>
<p>The plot above shows a line for the mean,
and a ribbon for the standard deviation,
over the three random seeds.
It is clear from the plot above that</p>
<ul>
<li>in constant task, the featureless always has smaller or equal
prediction error rates than rpart, which indicates that rpart
sometimes overfits for large sample sizes.</li>
<li>in sin task, more than 30 samples are required for rpart to be more
accurate than featureless, which indicates it has learned a
non-trivial relationship between input and output.</li>
</ul>
<h3 id="interactive-data-viz">Interactive data viz</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">grid.dt &lt;- data.table(x=seq(-abs.x, abs.x, l=101), y=0)
grid.task &lt;- mlr3::TaskRegr$new(&quot;grid&quot;, grid.dt, target=&quot;y&quot;)
pred.dt.list &lt;- list()
point.dt.list &lt;- list()
for(score.i in 1:nrow(reg.bench.score)){
  reg.bench.row &lt;- reg.bench.score[score.i]
  task.dt &lt;- data.table(
    reg.bench.row$task[[1]]$data(),
    reg.bench.row$resampling[[1]]$instance$id.dt)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=reg.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ]
  point.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(task_id, iteration)],
    i.points)
  i.learner &lt;- reg.bench.row$learner[[1]]
  pred.dt.list[[score.i]] &lt;- data.table(
    reg.bench.row[, .(
      task_id, iteration, algorithm
    )],
    as.data.table(
      i.learner$predict(grid.task)
    )[, .(x=grid.dt$x, y=response)]
  )
}
(pred.dt &lt;- rbindlist(pred.dt.list))
#&gt;         task_id iteration   algorithm     x           y
#&gt;          &lt;char&gt;     &lt;int&gt;      &lt;char&gt; &lt;num&gt;       &lt;num&gt;
#&gt;     1:      sin         1       rpart -10.0  0.25011658
#&gt;     2:      sin         1       rpart  -9.8  0.25011658
#&gt;     3:      sin         1       rpart  -9.6  0.25011658
#&gt;     4:      sin         1       rpart  -9.4  0.25011658
#&gt;     5:      sin         1       rpart  -9.2  0.25011658
#&gt;    ---                                                 
#&gt; 21812: constant        54 featureless   9.2 -0.03385654
#&gt; 21813: constant        54 featureless   9.4 -0.03385654
#&gt; 21814: constant        54 featureless   9.6 -0.03385654
#&gt; 21815: constant        54 featureless   9.8 -0.03385654
#&gt; 21816: constant        54 featureless  10.0 -0.03385654
</code></pre>
<pre><code class="language-r">(point.dt &lt;- rbindlist(point.dt.list))
#&gt;         task_id iteration set.name row_id          y         x  fold
#&gt;          &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt;      &lt;num&gt;     &lt;num&gt; &lt;int&gt;
#&gt;     1:      sin         1     test      1  1.2248390 -4.689827     1
#&gt;     2:      sin         1   unused      2 -0.5607042 -2.557522     3
#&gt;     3:      sin         1   unused      3  0.8345056  1.457067     3
#&gt;     4:      sin         1   unused      4  0.4875994  8.164156     2
#&gt;     5:      sin         1   unused      5 -0.4321800 -5.966361     3
#&gt;    ---                                                              
#&gt; 64796: constant        54    train    296 -0.6728968  3.628850     2
#&gt; 64797: constant        54    train    297  0.5168327 -8.016618     1
#&gt; 64798: constant        54    train    298 -0.4058882 -7.621949     1
#&gt; 64799: constant        54     test    299  0.9008627 -8.991207     3
#&gt; 64800: constant        54    train    300  0.8857710  8.585078     2
</code></pre>
<pre><code class="language-r">set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Variable size train set, regression&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme_animint(height=400)+
      scale_fill_manual(values=set.colors)+
      geom_point(aes(
        x, y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        shape=21,
        data=point.dt)+
      scale_size_manual(values=c(
        featureless=3,
        rpart=2))+
      scale_color_manual(values=algo.colors)+
      geom_line(aes(
        x, y,
        color=algorithm,
        size=algorithm,
        group=paste(algorithm, iteration)),
        showSelected=&quot;iteration&quot;,
        data=pred.dt)+
      facet_grid(
        task_id ~ .,
        labeller=label_both),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(width=500)+
      theme(
        panel.margin=grid::unit(1, &quot;lines&quot;),
        legend.position=&quot;none&quot;)+
      scale_y_log10(
        &quot;Mean squared error on test set&quot;)+
      scale_color_manual(values=algo.colors)+
      scale_x_log10(
        &quot;Train set size&quot;,
        breaks=train_size_vec)+
      geom_line(aes(
        train_size, regr.mse,
        group=paste(algorithm, seed),
        color=algorithm),
        clickSelects=&quot;seed&quot;,
        alpha_off=0.2,
        showSelected=&quot;algorithm&quot;,
        size=4,
        data=reg.bench.score)+
      facet_grid(
        test.fold~task_id,
        labeller=label_both,
        scales=&quot;free&quot;)+
      geom_point(aes(
        train_size, regr.mse,
        color=algorithm),
        size=5,
        stroke=3,
        fill=&quot;black&quot;,
        fill_off=NA,
        showSelected=c(&quot;algorithm&quot;,&quot;seed&quot;),
        clickSelects=&quot;iteration&quot;,
        data=reg.bench.score),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/Simulations.Rmd&quot;)
  viz
}
</code></pre>
<p></p>
<div id='ResamplingVariableSizeTrainCVAnimintRegression'></div>
<script>var ResamplingVariableSizeTrainCVAnimintRegression = new animint("#ResamplingVariableSizeTrainCVAnimintRegression", "ResamplingVariableSizeTrainCVAnimintRegression/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-26-train-sizes-regression&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-26-train-sizes-regression/">https://tdhock.github.io/2023-12-26-train-sizes-regression/</a></p>
<p>The interactive data viz consists of two plots:</p>
<ul>
<li>The first plot shows the data, with each point colored according to
the set it was assigned, in the currently selected
split/iteration. The red/blue lines additionally show the learned
prediction functions for the currently selected split/iteration.</li>
<li>The second plot shows the test error rates, as a function of train
set size. Clicking a line selects the corresponding random seed,
which makes the corresponding points on that line appear. Clicking a
point selects the corresponding iteration (seed, test fold, and train
set size).</li>
</ul>
<h2 id="simulated-classification-problems_2">Simulated classification problems</h2>
<p>Whereas in the section above, we focused on regression (output is a real number),
in this section we simulate a binary classification problem (output if a factor with two levels).</p>
<pre><code class="language-r">class.N &lt;- 300
class.abs.x &lt;- 1
rclass &lt;- function(){
  runif(class.N, -class.abs.x, class.abs.x)
}
library(data.table)
set.seed(1)
class.x.dt &lt;- data.table(x1=rclass(), x2=rclass())
class.fun.list &lt;- list(
  constant=function(...)0.5,
  xor=function(x1, x2)xor(x1&gt;0, x2&gt;0))
class.data.list &lt;- list()
class.task.list &lt;- list()
for(task_id in names(class.fun.list)){
  class.fun &lt;- class.fun.list[[task_id]]
  y &lt;- factor(ifelse(
    class.x.dt[, class.fun(x1, x2)+rnorm(class.N, sd=0.5)]&gt;0.5,
    &quot;spam&quot;, &quot;not&quot;))
  task.dt &lt;- data.table(class.x.dt, y)
  this.task &lt;- mlr3::TaskClassif$new(
    task_id, task.dt, target=&quot;y&quot;)
  this.task$col_roles$stratum &lt;- &quot;y&quot;
  class.task.list[[task_id]] &lt;- this.task
  class.data.list[[task_id]] &lt;- data.table(task_id, task.dt)
}
(class.data &lt;- rbindlist(class.data.list))
#&gt;       task_id         x1           x2      y
#&gt;        &lt;char&gt;      &lt;num&gt;        &lt;num&gt; &lt;fctr&gt;
#&gt;   1: constant -0.4689827  0.347424466   spam
#&gt;   2: constant -0.2557522 -0.810284289    not
#&gt;   3: constant  0.1457067 -0.014807758   spam
#&gt;   4: constant  0.8164156 -0.076896319    not
#&gt;   5: constant -0.5966361 -0.249566938   spam
#&gt;  ---                                        
#&gt; 596:      xor  0.3628850  0.297101895    not
#&gt; 597:      xor -0.8016618 -0.040328411    not
#&gt; 598:      xor -0.7621949 -0.009871789   spam
#&gt; 599:      xor -0.8991207 -0.240254817    not
#&gt; 600:      xor  0.8585078 -0.099029126   spam
</code></pre>
<p>The simulated data table above consists of two input features (<code>x1</code>
and <code>x2</code>) along with an output/label to predict (<code>y</code>). Below we count
the number of times each label appears in each task:</p>
<pre><code class="language-r">class.data[, .(count=.N), by=.(task_id, y)]
#&gt;     task_id      y count
#&gt;      &lt;char&gt; &lt;fctr&gt; &lt;int&gt;
#&gt; 1: constant   spam   143
#&gt; 2: constant    not   157
#&gt; 3:      xor   spam   145
#&gt; 4:      xor    not   155
</code></pre>
<p>The table above shows that the <code>spam</code> label is the minority class
(<code>not</code> is majority, so that will be the prediction of the featureless
baseline). Below we visualize the data in the feature space:</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_point(aes(
      x1, x2, color=y),
      shape=1,
      data=class.data)+
    facet_grid(. ~ task_id, labeller=label_both)+
    coord_equal()
}
</code></pre>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbAAAAGwCAIAAABHLKd9AAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nOzdd3xUVdo48OfcNvdOn8mk9wQSgnRpAiJNFEUpgtjW1dW1rbqWfXddX3fffbfY/em+uru6rrtYEFBUREVREQSRGhJ6DYT0TElmJjNz+z2/P2aIIY0EIgKe74c/hsmd286dZ+495TkIYwwEQRAEAPVD7wBBEMTZggREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoEERIIgiAQSEAmCIBJIQCQIgkggAZEgCCKBBESCIIgEEhAJgiASSEAkCIJIIAGRIAgigQREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoEERIIgiAQSEAmCIBJIQCQIgkggAZEgCCKBBESCIIgEEhAJgiASSEAkCIJIIAGRIAgigQREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoEERIIgiAQSEAmCIBJIQCQIgkggAZEgCCKBBESCIIgEEhAJgiASSEAkCIJIIAGRIAgigQREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoEERIIgiAQSEAmCIBJIQCQIgkggAZEgCCKBBESCIIgEEhAJgiASSEAkCIJIIAGRIAgigQREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoEERIIgiAQSEAmCIBJIQCQIgkggAZEgCCKBBESCIIgEEhAJgiASSEAkCIJIIAGRIAgigQREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoEERIIgiAQSEAmCIBJIQCQIgkggAZEgCCKBBESCIIgEEhAJgiASSEAkCIJIIAGRIAgigQREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoEERIIgiAQSEAmCIBJIQCQIgkggAZEgCCKBBESCIIgEEhAJgiASSEAkCIJIIAGRIAgigQREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoEERIIgiAQSEAmCIBJIQCQIgkggAZEgCCKBBESCIIgEEhAJgiASSEAkCIJIIAGRIAgigQREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoEERIIgiAQSEAmCIBJIQCQIgkggAZEgCCKBBESCIIgEEhAJgiASSEAkCIJIIAGRIAgigQREgiCIBBIQCYIgEkhAJAiCSCABkSAIIoH5oXcAAODgwYM/9C4Qfcntdns8nrbvHDp0CGP8Q+0P0edcLldycvIPvRd9j9whEgRBJJCASBAEkUACIkEQRAIJiARBEAk/0oAoSdKbb77ZkyVXrVr18ssvd7PA1q1bH3/88bbvLF68+L333jut/etaz/e8twv/OJ27VwLxffiRBkRFUb788ss+WdXgwYPvuuuuPllVT/Rqz/vwMM9XZ/mVoOt6366Q6N5Z0e3mzHv++ee9Xu8LL7zwy1/+8m9/+9uGDRsURRk3btxDDz0Ui8VefPHF/fv3OxyOW265pfUjr7/+emVl5WOPPUbTdNtV7d2797PPPvvNb37z0ksvbdy40eVyZWVlDRgwAADuuuuuBQsWTJ48uXXh1157bc2aNQBwyy23TJs2Lb7azz//HCE0ffr0m2++effu3YsXL45Go36/v6io6LHHHhNFse3+rFixoqs937NnT7vPth7mAw88cGZO7DnnB7kSPv300+3bt//3f//3vn37XnzxxRdffPGtt95qexmUl5evWrUqFosNHDhwwYIFZ/B8/Nj9SAPigw8+eN999z3wwAMVFRU1NTVvvfUWANxyyy01NTVlZWUY44ULF+7YsWPTpk15eXkA8M477xw8ePCPf/xju+9Aq5UrV1ZWVr711lvhcPi2226Lfw3+93//12aztS6zbt268vLyhQsXBoPBO++8c+LEiWVlZevXr3/ttdcA4J577ikpKREEYfPmzW+++WZqaurDDz9cVlZWW1vbdn+62XMAaPfZ1oW/9xN6zvpBroQZM2asWbPm22+/feONN37zm99s27at3WXAsuyGDRv++c9/pqWlnYGTQLT6kT4ytyosLHzggQdWr179r3/9KxAIKIoyePDgsrKyl19+Wdf1O+64AwC++eab119/fcyYMV19BwCgvLx8+vTpDMO43e6RI0fG30xNTTWbza3LlJaWXnLJJQzDeDyet956i2GY8vLySZMm8TzP8/zFF19cVlYGAAMHDkxPT6coql+/fuFwuOP+dLXnHT/7PZ2089KZvBIA4OGHH37iiScmTJiQn5/f6WUwYMAAEg3PvB97QNy5c+ejjz6qKMqUKVOKiooAID8//9VXXy0oKPjwww9/+9vfAkBycvLf//73119/PRQKdbUeiqIQQvHXFoul02V0XWdZNv46FAqpqtr2rzRNx8dyOByOtu933J+u9rzjZ4meO5NXAgDEYjGapv1+f7v3Wy8DQRBO/6CI3vrxBsR4dfWOHTvGjBkzc+ZMk8lUUVGhqup//vOf9957b9q0affee++uXbswxsXFxbm5uVdcccWrr77a1dqGDh36+eef67oeiUQ2bNgQf9Pn84mi2LrMsGHD1qxZo+t6U1PTnXfeKcvysGHD1q1bpyiKJElr164dNmxYxzV33J+u9rybwyS6ceavBF3Xn3766aeeemr//v07d+7syWVAnBk/0oBosVgsFstTTz116aWXVlRU3H777a+99tr06dP//ve/X3HFFdu3b7/uuusef/zxX/3qV62/9jfeeOO2bdv27t3b6QpnzJiRnZ198803//rXv540aVL8zd/97nebNm1qXWbq1KklJSW33HLLPffcc/fdd9vt9jFjxowbN+622277+c9/PmnSpDFjxnRcc7v9sVqtXe15N4d5mqfrPPaDXAmLFi0aNmxYcXHxQw899Pzzzw8fPvyklwFxZqCzYcg9Se5wniHJHc5752tyhx9pK/OpqaurW7FiRbs3p02b1q9fvx9kf4gfCrkSzlfkDpHoe+QO8bx3vt4h/kjrEAmCIDoiAZEgCCLhrKhD5Hm+9TVFURRFaZrW25XQNN3bLiYURdE03VWHlb7dFkKIYZgzti2WZeNdtb/vbQEAx3HttsUw7a8rk8nU+vo8LuIf9rR/r9tSVbVtpUfHIj4/nBVH1bYTv8lkMplMvR1lgRASBCEWi/XqUxzHmc3mYDDYq08BgMViiUajvfoIwzB2u72pqekMbIuiKJfLFQgEzsC2AMDj8QQCgbbfltb+563aFTHP8930be6K2WzubRGzLGuxWM5MEdM07XA4zkwRI4SSkpI69uv+PrYFAB6Pp6mpyTCM1nc4juvtSs4J5JGZIAgioY8DoiRJv/vd7zq+v27durvvvvuuu+5avXp1326RIAiir/TlI/MXX3zxxRdfdKzXCIVCb7zxxrPPPktR1EMPPTR8+HC3292H2yUIgugTfXmH6HA4xo0b1/H90tLS4cOHO51Ou90+evToLVu29OFG4yifFx3chySpz9fcUxjTtdV0VSW0qWch+tABSf6kORT8QYdmb4uJ6yJRlXSoPH/15R3i6NGja2tr165d2+79QCDQ2k03Xjsbf+3z+RRFibeHtC4cTxbSTXoliF+OxweWAgC7+Rsq2Iwysswb1slXzMJOVw93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" alt="plot of chunk unnamed-chunk-35" /></p>
<p>The plot above shows how the output <code>y</code> is related to the two inputs <code>x1</code> and
<code>x2</code>, for the two tasks.</p>
<ul>
<li>For the constant task, the two inputs are not related to the output.</li>
<li>For the xor task, the spam label is associated with either <code>x1</code> or
<code>x2</code> being negative (but not both).</li>
</ul>
<p>In the mlr3 code below, we define a list of learners, our resampling
method, and a benchmark grid:</p>
<pre><code class="language-r">class.learner.list &lt;- list(
  if(requireNamespace(&quot;rpart&quot;))mlr3::LearnerClassifRpart$new(),
  mlr3::LearnerClassifFeatureless$new())
size_cv &lt;- mlr3resampling::ResamplingVariableSizeTrainCV$new()
(class.bench.grid &lt;- mlr3::benchmark_grid(
  class.task.list,
  class.learner.list,
  size_cv))
#&gt;        task             learner             resampling
#&gt;      &lt;char&gt;              &lt;char&gt;                 &lt;char&gt;
#&gt; 1: constant       classif.rpart variable_size_train_cv
#&gt; 2: constant classif.featureless variable_size_train_cv
#&gt; 3:      xor       classif.rpart variable_size_train_cv
#&gt; 4:      xor classif.featureless variable_size_train_cv
</code></pre>
<p>Below we run the learning algorithm for each of the train/test splits
defined by our benchmark grid:</p>
<pre><code class="language-r">if(FALSE){
  if(require(future))plan(&quot;multisession&quot;)
}
if(require(lgr))get_logger(&quot;mlr3&quot;)$set_threshold(&quot;warn&quot;)
(class.bench.result &lt;- mlr3::benchmark(
  class.bench.grid, store_models = TRUE))
#&gt; &lt;BenchmarkResult&gt; of 180 rows with 4 resampling runs
#&gt;  nr  task_id          learner_id          resampling_id iters warnings errors
#&gt;   1 constant       classif.rpart variable_size_train_cv    45        0      0
#&gt;   2 constant classif.featureless variable_size_train_cv    45        0      0
#&gt;   3      xor       classif.rpart variable_size_train_cv    45        0      0
#&gt;   4      xor classif.featureless variable_size_train_cv    45        0      0
</code></pre>
<p>Below we compute scores (test error) for each resampling iteration,
and show the first row of the result.</p>
<pre><code class="language-r">class.bench.score &lt;- mlr3resampling::score(class.bench.result)
class.bench.score[1]
#&gt;    test.fold  seed small_stratum_size train_size_i train_size
#&gt;        &lt;int&gt; &lt;int&gt;              &lt;int&gt;        &lt;int&gt;      &lt;int&gt;
#&gt; 1:         1     1                 10            1         21
#&gt;                          train                  test iteration train_min_size
#&gt;                         &lt;list&gt;                &lt;list&gt;     &lt;int&gt;          &lt;int&gt;
#&gt; 1: 132,239, 10,216,245,276,...  5, 6, 8,21,23,28,...         1             21
#&gt;                                   uhash    nr                   task  task_id
#&gt;                                  &lt;char&gt; &lt;int&gt;                 &lt;list&gt;   &lt;char&gt;
#&gt; 1: 6e475cca-b056-41c6-b61e-00299178f921     1 &lt;TaskClassif:constant&gt; constant
#&gt;                                learner    learner_id
#&gt;                                 &lt;list&gt;        &lt;char&gt;
#&gt; 1: &lt;LearnerClassifRpart:classif.rpart&gt; classif.rpart
#&gt;                         resampling          resampling_id          prediction
#&gt;                             &lt;list&gt;                 &lt;char&gt;              &lt;list&gt;
#&gt; 1: &lt;ResamplingVariableSizeTrainCV&gt; variable_size_train_cv &lt;PredictionClassif&gt;
#&gt;    classif.ce algorithm
#&gt;         &lt;num&gt;    &lt;char&gt;
#&gt; 1:  0.4257426     rpart
</code></pre>
<p>The output above has columns which are very similar to the regression
example in the previous section. The main difference is the
<code>classif.ce</code> column, which is the classification error on the test
set.</p>
<p>Finally we plot the test error values below.</p>
<pre><code class="language-r">if(require(animint2)){
  ggplot()+
    geom_line(aes(
      train_size, classif.ce,
      group=paste(algorithm, seed),
      color=algorithm),
      shape=1,
      data=class.bench.score)+
    geom_point(aes(
      train_size, classif.ce, color=algorithm),
      shape=1,
      data=class.bench.score)+
    facet_grid(
      task_id ~ test.fold,
      labeller=label_both,
      scales=&quot;free&quot;)+
    scale_x_log10()
}
</code></pre>
<p><img src="data:image/png;base64,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5fnKxsbGFhUViZ9ra2tTU1Pdu/bv36/VarOysoYOHVpcXLx///5p06alp6dDEKRWqwcMGFBSUiKWdE91+Z00FARBInAp0GvUtFphlRHvQ6AyEgZI2xZieZfLJXHtvoY9mxD37MUqmyBkEsTTcbG+FQVBCMWw0MuE+1zEXdIxD16EdQqxgda0hxKp2xLokYlhzIF2SR88rDvWNPzmNohWwghJa9++vVdTpU+fPgcOHLDZbHa7fd++fX379hUEobKy0uVy1dbWfvXVVyzLWq3Wo0ePpqam/vTTTy+//DLP81arde/evZ06dYr0tcgEJBXHVqQlf90+Y1laMi5LO8jIBCBgC3Hy5Mlr167917/+9cknn4hbfHMqabXaGTNmLF68WBCEgoICvV7PMMz8+fNXrlx5ww03nDt37t577xUEYciQIYMGDeJ53mAwLFiwwOl0jhgxIj8//4pemIyMjEy4BHSISqUyLS3NYDCIi7TdFBcXe/6Zn5/v6dpIkly3bp34+Z577ml0JhSdO3dui41Ql5GRkQnYZf7ss89Onz49ffr04425msbJyMi0UFwuEGxs0WQyDRky5OTJkxJl6urqSktLQzzn8uXLv/vuu1AtbBIBW4gzZ85ctmyZw+G4++67PbevWrXqihokIyPTwkG2bYIulAGXIHTM4fsNDFTs2LFjw4YN69y5s8ShDh06tH///scee8x3F8/z0rnRrwQBHeKMGTPUavWcOXPcWwRBaL2z6TIyMk0GKjnnbg9CDXXQxQt8/0EAAOSvrRClAO6pBQwT0jLctT777LODBw+OGTPmpZdeYhgmOTl5xYoVBoNh1qxZFEUlJCR8+OGHn3zySVFRUXl5+ejRo8eOHfvss8+OHDny+PHj+/btczqdb7755qxZs9x1xcMajUbPjUVFRU899ZTD4SgoKOjVq5f78+23396UK5Wett+0adP69ev/+9//jh07dseOHR999NHUqVObcBoZGZnWiMvlslqt2MoVwuXQXYhlgdMpKBQAAMhiBgQpYNil0iq1s2CmUqkUW047d+78888/URTNysoqKCh4+eWX4+Li+vbta7fb+/fvP2XKlFdfffXMmTP79+8nSTIrK8vTIR48eHD58uUvvviiZ12n06nX60+dOuW5saKiIjs7e9KkSevWrTtx4oT7sxg9HS5B4hCXLl36/PPPb9y4kabp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" alt="plot of chunk unnamed-chunk-39" /></p>
<p>It is clear from the plot above that</p>
<ul>
<li>in constant task, rpart does not have significantly lower error
rates than featureless, which is expected, because the best
prediction function is constant (predict the most frequent class, no
relationship between inputs and output).</li>
<li>in xor task, more than 30 samples are required for rpart to be more
accurate than featureless, which indicates it has learned a
non-trivial relationship between inputs and output.</li>
</ul>
<p>Exercise for the reader: compute and plot mean and SD for these
classification tasks, similar to the plot for the regression tasks in
the previous section.</p>
<h3 id="interactive-visualization-of-data-test-error-and-splits_3">Interactive visualization of data, test error, and splits</h3>
<p>The code below can be used to create an interactive data visualization
which allows exploring how different functions are learned during
different splits.</p>
<pre><code class="language-r">class.grid.vec &lt;- seq(-class.abs.x, class.abs.x, l=21)
class.grid.dt &lt;- CJ(x1=class.grid.vec, x2=class.grid.vec)
class.pred.dt.list &lt;- list()
class.point.dt.list &lt;- list()
for(score.i in 1:nrow(class.bench.score)){
  class.bench.row &lt;- class.bench.score[score.i]
  task.dt &lt;- data.table(
    class.bench.row$task[[1]]$data(),
    class.bench.row$resampling[[1]]$instance$id.dt)
  set.ids &lt;- data.table(
    set.name=c(&quot;test&quot;,&quot;train&quot;)
  )[
  , data.table(row_id=class.bench.row[[set.name]][[1]])
  , by=set.name]
  i.points &lt;- set.ids[
    task.dt, on=&quot;row_id&quot;
  ][
    is.na(set.name), set.name := &quot;unused&quot;
  ][]
  class.point.dt.list[[score.i]] &lt;- data.table(
    class.bench.row[, .(task_id, iteration)],
    i.points)
  if(class.bench.row$algorithm!=&quot;featureless&quot;){
    i.learner &lt;- class.bench.row$learner[[1]]
    i.learner$predict_type &lt;- &quot;prob&quot;
    i.task &lt;- class.bench.row$task[[1]]
    grid.class.task &lt;- mlr3::TaskClassif$new(
      &quot;grid&quot;, class.grid.dt[, label:=factor(NA,levels(task.dt$y))], target=&quot;label&quot;)
    pred.grid &lt;- as.data.table(
      i.learner$predict(grid.class.task)
    )[, data.table(class.grid.dt, prob.spam)]
    pred.wide &lt;- dcast(pred.grid, x1 ~ x2, value.var=&quot;prob.spam&quot;)
    prob.mat &lt;- as.matrix(pred.wide[,-1])
    if(length(table(prob.mat))&gt;1){
      contour.list &lt;- contourLines(
        class.grid.vec, class.grid.vec, prob.mat, levels=0.5)
      class.pred.dt.list[[score.i]] &lt;- data.table(
        class.bench.row[, .(
          task_id, iteration, algorithm
        )],
        data.table(contour.i=seq_along(contour.list))[, {
          do.call(data.table, contour.list[[contour.i]])[, .(level, x1=x, x2=y)]
        }, by=contour.i]
      )
    }
  }
}
(class.pred.dt &lt;- rbindlist(class.pred.dt.list))
#&gt;        task_id iteration algorithm contour.i level     x1          x2
#&gt;         &lt;char&gt;     &lt;int&gt;    &lt;char&gt;     &lt;int&gt; &lt;num&gt;  &lt;num&gt;       &lt;num&gt;
#&gt;    1: constant         1     rpart         1   0.5 0.0375 -1.00000000
#&gt;    2: constant         1     rpart         1   0.5 0.0375 -0.90000000
#&gt;    3: constant         1     rpart         1   0.5 0.0375 -0.80000000
#&gt;    4: constant         1     rpart         1   0.5 0.0375 -0.70000000
#&gt;    5: constant         1     rpart         1   0.5 0.0375 -0.60000000
#&gt;   ---                                                                
#&gt; 5190:      xor        45     rpart         2   0.5 0.6000  0.04888889
#&gt; 5191:      xor        45     rpart         2   0.5 0.7000  0.04888889
#&gt; 5192:      xor        45     rpart         2   0.5 0.8000  0.04888889
#&gt; 5193:      xor        45     rpart         2   0.5 0.9000  0.04888889
#&gt; 5194:      xor        45     rpart         2   0.5 1.0000  0.04888889
</code></pre>
<pre><code class="language-r">(class.point.dt &lt;- rbindlist(class.point.dt.list))
#&gt;         task_id iteration set.name row_id      y         x1           x2  fold
#&gt;          &lt;char&gt;     &lt;int&gt;   &lt;char&gt;  &lt;int&gt; &lt;fctr&gt;      &lt;num&gt;        &lt;num&gt; &lt;int&gt;
#&gt;     1: constant         1   unused      1   spam -0.4689827  0.347424466     3
#&gt;     2: constant         1   unused      2    not -0.2557522 -0.810284289     2
#&gt;     3: constant         1   unused      3   spam  0.1457067 -0.014807758     3
#&gt;     4: constant         1    train      4    not  0.8164156 -0.076896319     3
#&gt;     5: constant         1     test      5   spam -0.5966361 -0.249566938     1
#&gt;    ---                                                                        
#&gt; 53996:      xor        45    train    296    not  0.3628850  0.297101895     2
#&gt; 53997:      xor        45    train    297    not -0.8016618 -0.040328411     2
#&gt; 53998:      xor        45     test    298   spam -0.7621949 -0.009871789     3
#&gt; 53999:      xor        45     test    299    not -0.8991207 -0.240254817     3
#&gt; 54000:      xor        45    train    300   spam  0.8585078 -0.099029126     2
</code></pre>
<pre><code class="language-r">
set.colors &lt;- c(
  train=&quot;#1B9E77&quot;,
  test=&quot;#D95F02&quot;,
  unused=&quot;white&quot;)
algo.colors &lt;- c(
  featureless=&quot;blue&quot;,
  rpart=&quot;red&quot;)
if(require(animint2)){
  viz &lt;- animint(
    title=&quot;Variable size train sets, classification&quot;,
    pred=ggplot()+
      ggtitle(&quot;Predictions for selected train/test split&quot;)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      theme_animint(width=600)+
      coord_equal()+
      scale_fill_manual(values=set.colors)+
      scale_color_manual(values=c(spam=&quot;black&quot;,&quot;not spam&quot;=&quot;white&quot;))+
      geom_point(aes(
        x1, x2, color=y, fill=set.name),
        showSelected=&quot;iteration&quot;,
        size=3,
        stroke=2,
        shape=21,
        data=class.point.dt)+
      geom_path(aes(
        x1, x2, 
        group=paste(algorithm, iteration, contour.i)),
        showSelected=c(&quot;iteration&quot;,&quot;algorithm&quot;),
        color=algo.colors[[&quot;rpart&quot;]],
        data=class.pred.dt)+
      facet_grid(
        . ~ task_id,
        labeller=label_both,
        space=&quot;free&quot;,
        scales=&quot;free&quot;),
    err=ggplot()+
      ggtitle(&quot;Test error for each split&quot;)+
      theme_animint(height=400)+
      theme(panel.margin=grid::unit(1, &quot;lines&quot;))+
      scale_y_continuous(
        &quot;Classification error on test set&quot;)+
      scale_color_manual(values=algo.colors)+
      scale_x_log10(
        &quot;Train set size&quot;)+
      geom_line(aes(
        train_size, classif.ce,
        group=paste(algorithm, seed),
        color=algorithm),
        clickSelects=&quot;seed&quot;,
        alpha_off=0.2,
        showSelected=&quot;algorithm&quot;,
        size=4,
        data=class.bench.score)+
      facet_grid(
        test.fold~task_id,
        labeller=label_both,
        scales=&quot;free&quot;)+
      geom_point(aes(
        train_size, classif.ce,
        color=algorithm),
        size=5,
        stroke=3,
        fill=&quot;black&quot;,
        fill_off=NA,
        showSelected=c(&quot;algorithm&quot;,&quot;seed&quot;),
        clickSelects=&quot;iteration&quot;,
        data=class.bench.score),
    source=&quot;https://github.com/tdhock/mlr3resampling/blob/main/vignettes/ResamplingVariableSizeTrainCV.Rmd&quot;)
  viz
}
</code></pre>
<p></p>
<div id='ResamplingVariableSizeTrainCVAnimintClassification'></div>
<script>var ResamplingVariableSizeTrainCVAnimintClassification = new animint("#ResamplingVariableSizeTrainCVAnimintClassification", "ResamplingVariableSizeTrainCVAnimintClassification/plot.json");</script>
<pre><code class="language-r">if(FALSE){
  animint2pages(viz, &quot;2023-12-27-train-sizes-classification&quot;)
}
</code></pre>
<p>If you are viewing this in an installed package or on CRAN,
then there will be no data viz on this page,
but you can view it on:
<a href="https://tdhock.github.io/2023-12-27-train-sizes-classification/">https://tdhock.github.io/2023-12-27-train-sizes-classification/</a></p>
<p>The interactive data viz consists of two plots</p>
<ul>
<li>The first plot shows the data, with each point colored according to
its label/y value (black outline for spam, white outline for not),
and the set it was assigned (fill color) in the currently selected
split/iteration. The red lines additionally show the learned
decision boundary for rpart, given the currently selected
split/iteration.  For constant, the ideal decision boundary is none
(always predict the most frequent class), and for xor, the ideal
decision boundary looks like a plus sign.</li>
<li>The second plot shows the test error rates, as a function of train
set size. Clicking a line selects the corresponding random seed,
which makes the corresponding points on that line appear. Clicking a
point selects the corresponding iteration (seed, test fold, and train
set size).</li>
</ul>
<h2 id="conclusion_2">Conclusion</h2>
<p>In this section we have shown how to use mlr3resampling for comparing
test error of models trained on different sized train sets.</p>
<h1 id="session-info">Session info</h1>
<pre><code class="language-r">sessionInfo()
#&gt; R version 4.4.1 (2024-06-14)
#&gt; Platform: x86_64-pc-linux-gnu
#&gt; Running under: Ubuntu 22.04.4 LTS
#&gt; 
#&gt; Matrix products: default
#&gt; BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 
#&gt; LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0
#&gt; 
#&gt; locale:
#&gt;  [1] LC_CTYPE=fr_FR.UTF-8       LC_NUMERIC=C              
#&gt;  [3] LC_TIME=fr_FR.UTF-8        LC_COLLATE=C              
#&gt;  [5] LC_MONETARY=fr_FR.UTF-8    LC_MESSAGES=fr_FR.UTF-8   
#&gt;  [7] LC_PAPER=fr_FR.UTF-8       LC_NAME=C                 
#&gt;  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
#&gt; [11] LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C       
#&gt; 
#&gt; time zone: America/New_York
#&gt; tzcode source: system (glibc)
#&gt; 
#&gt; attached base packages:
#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     
#&gt; 
#&gt; other attached packages:
#&gt; [1] lgr_0.4.4              animint2_2024.6.6      directlabels_2024.1.21
#&gt; [4] mlr3_0.20.0            ggplot2_3.5.1          data.table_1.15.99    
#&gt; 
#&gt; loaded via a namespace (and not attached):
#&gt;  [1] utf8_1.2.4              future_1.33.1           generics_0.1.3         
#&gt;  [4] stringi_1.8.3           listenv_0.9.1           digest_0.6.34          
#&gt;  [7] magrittr_2.0.3          evaluate_0.23           grid_4.4.1             
#&gt; [10] plyr_1.8.9              backports_1.4.1         fansi_1.0.6            
#&gt; [13] mlr3resampling_2024.7.3 scales_1.3.0            RhpcBLASctl_0.23-42    
#&gt; [16] mlr3tuning_1.0.0        codetools_0.2-20        mlr3measures_0.5.0     
#&gt; [19] palmerpenguins_0.1.1    cli_3.6.2               rlang_1.1.3            
#&gt; [22] crayon_1.5.2            parallelly_1.36.0       future.apply_1.11.1    
#&gt; [25] munsell_0.5.0           commonmark_1.9.1        withr_3.0.0            
#&gt; [28] nc_2024.2.21            tools_4.4.1             parallel_4.4.1         
#&gt; [31] reshape2_1.4.4          RJSONIO_1.3-1.9         uuid_1.2-0             
#&gt; [34] checkmate_2.3.1         dplyr_1.1.4             colorspace_2.1-0       
#&gt; [37] globals_0.16.2          bbotk_1.0.0             vctrs_0.6.5            
#&gt; [40] R6_2.5.1                mime_0.12               rpart_4.1.23           
#&gt; [43] lifecycle_1.0.4         stringr_1.5.1           mlr3misc_0.15.1        
#&gt; [46] pkgconfig_2.0.3         pillar_1.9.0            gtable_0.3.4           
#&gt; [49] Rcpp_1.0.12             glue_1.7.0              paradox_1.0.0          
#&gt; [52] xfun_0.45               tibble_3.2.1            tidyselect_1.2.0       
#&gt; [55] highr_0.11              knitr_1.47              farver_2.1.1           
#&gt; [58] labeling_0.4.3          compiler_4.4.1          quadprog_1.5-8         
#&gt; [61] markdown_1.13
</code></pre>
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</body>
</html>
